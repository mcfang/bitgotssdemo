"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const utils_1 = __importDefault(require("./utils"));
const nacl = __importStar(require("tweetnacl"));
class KeyPair extends sdk_core_1.Ed25519KeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    constructor(source) {
        super(source);
    }
    /** @inheritdoc */
    getKeys() {
        const result = { pub: this.keyPair.pub };
        if (this.keyPair.prv) {
            result.prv = this.keyPair.prv;
        }
        return result;
    }
    /** @inheritdoc */
    recordKeysFromPrivateKeyInProtocolFormat(prv) {
        throw new Error('Method not implemented.');
    }
    /** @inheritdoc */
    recordKeysFromPublicKeyInProtocolFormat(pub) {
        if (!utils_1.default.isValidPublicKey(pub)) {
            throw new Error(`Invalid Public Key ${pub}`);
        }
        return { pub };
    }
    /** @inheritdoc */
    getAddress() {
        throw new Error('Method not implemented.');
        // this is the async way to get the address using tonweb library
        // but we cannot use it as it is aysnc, there is a getAddressfromPublicKey in utlis.ts
        /*
        const tonweb = new TonWeb(new TonWeb.HttpProvider(''));
    
        const WalletClass = tonweb.wallet.all['v4R2'];
        const wallet = new WalletClass(tonweb.provider, {
          publicKey: Buffer.from(this.keyPair.pub),
          wc: 0
        });
        const address = await wallet.getAddress();
        return address.toString(true, true, true);
        */
    }
    /**
     *  Sign the message in Uint8Array
     *
     * @param {Uint8Array} message to be signed
     * @returns {Uint8Array} signed message
     */
    signMessageinUint8Array(message) {
        const { prv } = this.keyPair;
        if (!prv) {
            throw new Error('Missing private key');
        }
        return nacl.sign.detached(message, nacl.sign.keyPair.fromSeed(sdk_core_1.toUint8Array(prv)).secretKey);
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOENBQTRGO0FBQzVGLG9EQUE0QjtBQUM1QixnREFBa0M7QUFFbEMsTUFBYSxPQUFRLFNBQVEseUJBQWM7SUFDekM7Ozs7T0FJRztJQUNILFlBQVksTUFBdUI7UUFDakMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hCLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsT0FBTztRQUNMLE1BQU0sTUFBTSxHQUFnQixFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQ3RELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUU7WUFDcEIsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztTQUMvQjtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsd0NBQXdDLENBQUMsR0FBVztRQUNsRCxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELGtCQUFrQjtJQUNsQix1Q0FBdUMsQ0FBQyxHQUFXO1FBQ2pELElBQUksQ0FBQyxlQUFLLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsR0FBRyxFQUFFLENBQUMsQ0FBQztTQUM5QztRQUVELE9BQU8sRUFBRSxHQUFHLEVBQUUsQ0FBQztJQUNqQixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFVBQVU7UUFDUixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7UUFFM0MsZ0VBQWdFO1FBQ2hFLHNGQUFzRjtRQUN0Rjs7Ozs7Ozs7OztVQVVFO0lBQ0osQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsdUJBQXVCLENBQUMsT0FBbUI7UUFDekMsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7UUFDN0IsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUN4QztRQUNELE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyx1QkFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDOUYsQ0FBQztDQUNGO0FBakVELDBCQWlFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlZmF1bHRLZXlzLCBFZDI1NTE5S2V5UGFpciwgS2V5UGFpck9wdGlvbnMsIHRvVWludDhBcnJheSB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgKiBhcyBuYWNsIGZyb20gJ3R3ZWV0bmFjbCc7XG5cbmV4cG9ydCBjbGFzcyBLZXlQYWlyIGV4dGVuZHMgRWQyNTUxOUtleVBhaXIge1xuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLiBCeSBkZWZhdWx0LCBjcmVhdGVzIGEga2V5IHBhaXIgd2l0aCBhIHJhbmRvbSBtYXN0ZXIgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHsgS2V5UGFpck9wdGlvbnMgfSBzb3VyY2UgRWl0aGVyIGEgbWFzdGVyIHNlZWQsIGEgcHJpdmF0ZSBrZXksIG9yIGEgcHVibGljIGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGdldEtleXMoKTogRGVmYXVsdEtleXMge1xuICAgIGNvbnN0IHJlc3VsdDogRGVmYXVsdEtleXMgPSB7IHB1YjogdGhpcy5rZXlQYWlyLnB1YiB9O1xuICAgIGlmICh0aGlzLmtleVBhaXIucHJ2KSB7XG4gICAgICByZXN1bHQucHJ2ID0gdGhpcy5rZXlQYWlyLnBydjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZWNvcmRLZXlzRnJvbVByaXZhdGVLZXlJblByb3RvY29sRm9ybWF0KHBydjogc3RyaW5nKTogRGVmYXVsdEtleXMge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZWNvcmRLZXlzRnJvbVB1YmxpY0tleUluUHJvdG9jb2xGb3JtYXQocHViOiBzdHJpbmcpOiBEZWZhdWx0S2V5cyB7XG4gICAgaWYgKCF1dGlscy5pc1ZhbGlkUHVibGljS2V5KHB1YikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBQdWJsaWMgS2V5ICR7cHVifWApO1xuICAgIH1cblxuICAgIHJldHVybiB7IHB1YiB9O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGdldEFkZHJlc3MoKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG5cbiAgICAvLyB0aGlzIGlzIHRoZSBhc3luYyB3YXkgdG8gZ2V0IHRoZSBhZGRyZXNzIHVzaW5nIHRvbndlYiBsaWJyYXJ5XG4gICAgLy8gYnV0IHdlIGNhbm5vdCB1c2UgaXQgYXMgaXQgaXMgYXlzbmMsIHRoZXJlIGlzIGEgZ2V0QWRkcmVzc2Zyb21QdWJsaWNLZXkgaW4gdXRsaXMudHNcbiAgICAvKlxuICAgIGNvbnN0IHRvbndlYiA9IG5ldyBUb25XZWIobmV3IFRvbldlYi5IdHRwUHJvdmlkZXIoJycpKTtcblxuICAgIGNvbnN0IFdhbGxldENsYXNzID0gdG9ud2ViLndhbGxldC5hbGxbJ3Y0UjInXTtcbiAgICBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0Q2xhc3ModG9ud2ViLnByb3ZpZGVyLCB7XG4gICAgICBwdWJsaWNLZXk6IEJ1ZmZlci5mcm9tKHRoaXMua2V5UGFpci5wdWIpLFxuICAgICAgd2M6IDBcbiAgICB9KTtcbiAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgd2FsbGV0LmdldEFkZHJlc3MoKTtcbiAgICByZXR1cm4gYWRkcmVzcy50b1N0cmluZyh0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAqL1xuICB9XG5cbiAgLyoqXG4gICAqICBTaWduIHRoZSBtZXNzYWdlIGluIFVpbnQ4QXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBtZXNzYWdlIHRvIGJlIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gc2lnbmVkIG1lc3NhZ2VcbiAgICovXG4gIHNpZ25NZXNzYWdlaW5VaW50OEFycmF5KG1lc3NhZ2U6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCB7IHBydiB9ID0gdGhpcy5rZXlQYWlyO1xuICAgIGlmICghcHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hY2wuc2lnbi5kZXRhY2hlZChtZXNzYWdlLCBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZCh0b1VpbnQ4QXJyYXkocHJ2KSkuc2VjcmV0S2V5KTtcbiAgfVxufVxuIl19