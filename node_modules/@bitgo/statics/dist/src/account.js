"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tadaToken = exports.adaToken = exports.tsolToken = exports.solToken = exports.teosToken = exports.eosToken = exports.talgoToken = exports.algoToken = exports.hederaToken = exports.hederaCoin = exports.ttronToken = exports.tronToken = exports.tstellarToken = exports.stellarToken = exports.tbscToken = exports.bscToken = exports.tceloToken = exports.celoToken = exports.erc20CompatibleAccountCoin = exports.terc1155 = exports.erc1155 = exports.nonstandardToken = exports.terc721 = exports.erc721 = exports.terc20 = exports.erc20 = exports.account = exports.FiatCoin = exports.XrpCoin = exports.ArbethERC20Token = exports.PolygonERC20Token = exports.AvaxERC20Token = exports.AdaCoin = exports.SolCoin = exports.EosCoin = exports.AlgoCoin = exports.HederaToken = exports.HederaCoin = exports.StellarCoin = exports.BscCoin = exports.CeloCoin = exports.Erc20CompatibleAccountCoin = exports.TronErc20Coin = exports.Erc1155Coin = exports.Erc721Coin = exports.Erc20Coin = exports.Base58ContractAddressDefinedToken = exports.ContractAddressDefinedToken = exports.AccountCoinToken = exports.AccountCoin = void 0;
exports.fiat = exports.txrpToken = exports.xrpToken = exports.tarbethErc20 = exports.arbethErc20 = exports.tpolygonErc20 = exports.polygonErc20 = exports.tavaxErc20 = exports.avaxErc20 = void 0;
const base_1 = require("./base");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const networks_1 = require("./networks");
/**
 * Account based coins, such as Ethereum, Stellar, or XRP.
 *
 * These types of coins maintain an "account balance" for each address on the network,
 * as opposed to the unspent transaction output model which maintains a record of all
 * "pieces" of coin which belong to an address.
 */
class AccountCoin extends base_1.BaseCoin {
    constructor(options) {
        super({
            ...options,
            kind: base_1.CoinKind.CRYPTO,
        });
        this.network = options.network;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL]);
    }
    disallowedFeatures() {
        return new Set([base_1.CoinFeature.UNSPENT_MODEL]);
    }
}
exports.AccountCoin = AccountCoin;
AccountCoin.DEFAULT_FEATURES = [
    base_1.CoinFeature.ACCOUNT_MODEL,
    base_1.CoinFeature.REQUIRES_BIG_NUMBER,
    base_1.CoinFeature.VALUELESS_TRANSFER,
    base_1.CoinFeature.TRANSACTION_DATA,
    base_1.CoinFeature.CUSTODY,
    base_1.CoinFeature.CUSTODY_BITGO_TRUST,
];
class AccountCoinToken extends AccountCoin {
    constructor(options) {
        super({
            ...options,
        });
    }
}
exports.AccountCoinToken = AccountCoinToken;
/**
 * Some blockchains support tokens which are defined by an address at which they have a smart contract deployed.
 * Examples are ERC20 tokens, and the equivalent on other chains.
 */
class ContractAddressDefinedToken extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        // valid ERC 20 contract addresses are "0x" followed by 40 lowercase hex characters
        // do not use a valid address format for generic tokens because they not have onchain addresses
        if (!options.contractAddress.match(/^0x[a-f0-9]{40}$/) && !options.features.includes(base_1.CoinFeature.GENERIC_TOKEN)) {
            throw new errors_1.InvalidContractAddressError(options.name, options.contractAddress);
        }
        this.contractAddress = options.contractAddress;
    }
}
exports.ContractAddressDefinedToken = ContractAddressDefinedToken;
/**
 * ERC20 token addresses are Base58 formatted on some blockchains.
 */
class Base58ContractAddressDefinedToken extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (!/^[1-9A-HJ-NP-Za-km-z]{34}$/.test(options.contractAddress)) {
            throw new errors_1.InvalidContractAddressError(options.name, options.contractAddress);
        }
        this.contractAddress = options.contractAddress;
    }
}
exports.Base58ContractAddressDefinedToken = Base58ContractAddressDefinedToken;
/**
 * ERC 20 is a token standard for the Ethereum blockchain. They are similar to other account coins, but have a
 * contract address property which identifies the smart contract which defines the token.
 */
class Erc20Coin extends ContractAddressDefinedToken {
}
exports.Erc20Coin = Erc20Coin;
/**
 * ERC 721 is the non fungible token standard for the Ethereum blockchain.
 *
 * {@link https://eips.ethereum.org/EIPS/eip-721 EIP721}
 */
class Erc721Coin extends ContractAddressDefinedToken {
}
exports.Erc721Coin = Erc721Coin;
/**
 * ERC 1155 is the multi token standard for the Ethereum blockchain.
 *
 * {@link https://eips.ethereum.org/EIPS/eip-1155 EIP1155}
 */
class Erc1155Coin extends ContractAddressDefinedToken {
}
exports.Erc1155Coin = Erc1155Coin;
/**
 * The TRON blockchain supports tokens of the ERC20 standard similar to ETH ERC20 tokens.
 */
class TronErc20Coin extends Base58ContractAddressDefinedToken {
}
exports.TronErc20Coin = TronErc20Coin;
/**
 * Some blockchains have native coins which also support the ERC20 interface such as CELO.
 */
class Erc20CompatibleAccountCoin extends ContractAddressDefinedToken {
    constructor(options) {
        super({
            ...options,
            // These coins should not be classified as tokens as they are not children of other coins
            isToken: false,
        });
    }
}
exports.Erc20CompatibleAccountCoin = Erc20CompatibleAccountCoin;
/**
 * The CELO blockchain supports tokens of the ERC20 standard similar to ETH ERC20 tokens.
 */
class CeloCoin extends ContractAddressDefinedToken {
}
exports.CeloCoin = CeloCoin;
/**
 * The BSC blockchain supports tokens of the ERC20 standard similar to ETH ERC20 tokens.
 */
class BscCoin extends ContractAddressDefinedToken {
}
exports.BscCoin = BscCoin;
/**
 * The Stellar network supports tokens (non-native assets)
 * XLM is also known as the native asset.
 * Stellar tokens work similar to XLM, but the token name is determined by the chain,
 * the token code and the issuer account in the form: (t)xlm:<token>-<issuer>
 */
class StellarCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (options.domain !== '' && !options.domain.match(constants_1.DOMAIN_PATTERN)) {
            throw new errors_1.InvalidDomainError(options.name, options.domain);
        }
        this.domain = options.domain;
    }
}
exports.StellarCoin = StellarCoin;
/**
 * The Hedera coin needs a client set with the node account Id.
 * It's an account based coin that needs the node account ID
 * where the transaction will be sent.
 *
 */
class HederaCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.nodeAccountId = options.nodeAccountId;
    }
}
exports.HederaCoin = HederaCoin;
/**
 * The Hedera network supports tokens.
 * Hedera tokens work similar to native Hedera coin,
 * but the token is determined by the tokenId on the node
 *
 */
class HederaToken extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.nodeAccountId = options.nodeAccountId;
        this.tokenId = options.tokenId;
    }
}
exports.HederaToken = HederaToken;
/**
 * The Algo network supports tokens (assets)
 * Algo tokens work similar to native ALGO coin, but the token name is determined by
 * unique asset id on the chain. Internally, BitGo uses token identifiers of the format: (t)algo:<assetId>
 *
 */
class AlgoCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (options.tokenURL) {
            try {
                new URL(options.tokenURL);
            }
            catch (ex) {
                throw new errors_1.InvalidDomainError(options.name, options.tokenURL);
            }
        }
        this.tokenURL = options.tokenURL;
    }
}
exports.AlgoCoin = AlgoCoin;
/**
 * The Eos network supports tokens
 * Eos tokens work similar to native Eos coin, but the token name is determined by
 * the contractName on the chain.
 *
 */
class EosCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.contractName = options.contractName;
    }
}
exports.EosCoin = EosCoin;
/**
 * The Sol network supports tokens
 * Sol tokens work similar to native SOL coin, but the token name is determined by
 * the tokenAddress on the chain.
 *
 */
class SolCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.tokenAddress = options.tokenAddress;
    }
}
exports.SolCoin = SolCoin;
/**
 * The Ada network supports tokens
 * Ada tokens are identified by their policy ID and asset name
 *
 */
class AdaCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        this.policyId = options.policyId;
        this.assetName = options.assetName;
    }
}
exports.AdaCoin = AdaCoin;
/**
 * The AVAX C Chain network support tokens
 * AVAX C Chain Tokens are ERC20 coins
 */
class AvaxERC20Token extends ContractAddressDefinedToken {
    constructor(options) {
        super(options);
    }
}
exports.AvaxERC20Token = AvaxERC20Token;
/**
 * The Polygon Chain network support tokens
 * Polygon Chain Tokens are ERC20 coins
 */
class PolygonERC20Token extends ContractAddressDefinedToken {
    constructor(options) {
        super(options);
    }
}
exports.PolygonERC20Token = PolygonERC20Token;
/**
 * The Arbitrum Chain network support tokens
 * Arbitrum Chain Tokens are ERC20 tokens
 */
class ArbethERC20Token extends ContractAddressDefinedToken {
    constructor(options) {
        super(options);
    }
}
exports.ArbethERC20Token = ArbethERC20Token;
/**
 * The Xrp network supports tokens
 * Xrp tokens are identified by their issuer address
 * Naming format is similar to XLM
 * <network>:<token>-<issuer>
 */
class XrpCoin extends AccountCoinToken {
    constructor(options) {
        super({
            ...options,
        });
        if (options.domain !== '' && !options.domain.match(constants_1.DOMAIN_PATTERN)) {
            throw new errors_1.InvalidDomainError(options.name, options.domain);
        }
        this.domain = options.domain;
        this.currencyCode = options.currencyCode;
        this.issuerAddress = options.issuerAddress;
    }
}
exports.XrpCoin = XrpCoin;
/**
 * Fiat currencies, such as USD, EUR, or YEN.
 */
class FiatCoin extends base_1.BaseCoin {
    constructor(options) {
        super({ ...options, kind: base_1.CoinKind.FIAT });
        this.network = options.network;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL]);
    }
    disallowedFeatures() {
        return new Set([base_1.CoinFeature.UNSPENT_MODEL]);
    }
}
exports.FiatCoin = FiatCoin;
FiatCoin.DEFAULT_FEATURES = [...AccountCoin.DEFAULT_FEATURES];
/**
 * Factory function for account coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve? The elliptic curve for this chain/token
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 */
function account(id, name, fullName, network, decimalPlaces, asset, baseUnit, features = AccountCoin.DEFAULT_FEATURES, primaryKeyCurve = base_1.KeyCurve.Secp256k1, prefix = '', suffix = name.toUpperCase(), isToken = false) {
    return Object.freeze(new AccountCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        baseUnit,
        features,
        decimalPlaces,
        isToken,
        asset,
        primaryKeyCurve,
    }));
}
exports.account = account;
/**
 * Factory function for erc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc20Coin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.erc20 = erc20;
/**
 * Factory function for testnet erc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Kovan test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function terc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.kovan) {
    return erc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.terc20 = terc20;
/**
 * Factory function for erc721 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc721(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc721Coin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces: 0,
        asset: base_1.UnderlyingAsset.ERC721,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.erc721 = erc721;
/**
 * Factory function for testnet erc721 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Goerli test network.
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function terc721(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.goerli, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return erc721(id, name, fullName, contractAddress, features, prefix, suffix, network, primaryKeyCurve);
}
exports.terc721 = terc721;
/**
 * Factory function for nonstandard token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function nonstandardToken(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new ContractAddressDefinedToken({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces: 0,
        asset: base_1.UnderlyingAsset.NONSTANDARD,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.nonstandardToken = nonstandardToken;
/**
 * Factory function for erc1155 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Ethereum main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc1155(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ethereum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc1155Coin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces: 0,
        asset: base_1.UnderlyingAsset.ERC1155,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.erc1155 = erc1155;
/**
 * Factory function for testnet erc1155 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param contractAddress Contract address of this token
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Goerli test network.
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function terc1155(id, name, fullName, contractAddress, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.goerli, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return erc1155(id, name, fullName, contractAddress, features, prefix, suffix, network, primaryKeyCurve);
}
exports.terc1155 = terc1155;
/**
 * Factory function for ERC20-compatible account coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function erc20CompatibleAccountCoin(id, name, fullName, network, decimalPlaces, contractAddress, asset, baseUnit, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new Erc20CompatibleAccountCoin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: false,
        primaryKeyCurve,
        baseUnit,
    }));
}
exports.erc20CompatibleAccountCoin = erc20CompatibleAccountCoin;
/**
 * Factory function for celo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to CELO main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function celoToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.celo, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new CeloCoin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.celoToken = celoToken;
/**
 * Factory function for testnet celo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet CELO network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tceloToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.celo) {
    return celoToken(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.tceloToken = tceloToken;
/**
 * Factory function for celo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to BSC main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function bscToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.bsc, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new BscCoin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.BSC,
    }));
}
exports.bscToken = bscToken;
/**
 * Factory function for testnet bsc token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet BSC network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tbscToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.bsc) {
    return bscToken(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network);
}
exports.tbscToken = tbscToken;
/**
 * Factory function for Stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function stellarToken(id, name, fullName, decimalPlaces, asset, domain = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.stellar, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new StellarCoin({
        id,
        name,
        fullName,
        decimalPlaces,
        asset,
        domain,
        features,
        prefix,
        suffix,
        network,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XLM,
    }));
}
exports.stellarToken = stellarToken;
/**
 * Factory function for testnet Stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param domain Domain of the token issuer (used to access token information from the issuer's stellar.toml file)
 * See https://www.stellar.org/developers/guides/concepts/stellar-toml.html
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Stellar testnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function tstellarToken(id, name, fullName, decimalPlaces, asset, domain = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.stellar) {
    return stellarToken(id, name, fullName, decimalPlaces, asset, domain, features, prefix, suffix, network);
}
exports.tstellarToken = tstellarToken;
/**
 * Factory function for tron token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to TRON main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tronToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.trx, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new TronErc20Coin({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.TRX,
    }));
}
exports.tronToken = tronToken;
/**
 * Factory function for testnet tron token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet TRON network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ttronToken(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.trx, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return tronToken(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.ttronToken = ttronToken;
/**
 * Factory function for Hedera coin instances
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param nodeAccountId node account Id from which the transaction will be sent
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Hedera mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function hederaCoin(id, name, fullName, network, decimalPlaces, asset, nodeAccountId = '0.0.3', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new HederaCoin({
        id,
        name,
        fullName,
        decimalPlaces,
        asset,
        nodeAccountId,
        features,
        prefix,
        suffix,
        network,
        isToken: false,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.hederaCoin = hederaCoin;
/**
 * Factory function for Hedera token instances
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param nodeAccountId node account Id from which the transaction will be sent
 * @param tokenId The unique identifier of this token
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Hedera mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function hederaToken(id, name, fullName, network, decimalPlaces, asset, nodeAccountId = '0.0.3', tokenId, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new HederaToken({
        id,
        name,
        fullName,
        decimalPlaces,
        asset,
        nodeAccountId,
        tokenId,
        features,
        prefix,
        suffix,
        network,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.hederaToken = hederaToken;
/**
 * Factory function for ALGO token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token

 * @param alias (optional) alternative identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param tokenURL Optional asset Url for more informationa about the asset
 * See https://developer.algorand.org/docs/reference/transactions/#url
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to ALGO mainnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function algoToken(id, name, alias, fullName, decimalPlaces, asset, tokenURL = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.algorand, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new AlgoCoin({
        id,
        name,
        alias,
        fullName,
        decimalPlaces,
        asset,
        tokenURL: tokenURL,
        features,
        prefix,
        suffix,
        network,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ALGO,
    }));
}
exports.algoToken = algoToken;
/**
 * Factory function for testnet ALGO token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param alias (optional) alternative identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param tokenURL Optional asset Url for more informationa about the asset
 * See https://developer.algorand.org/docs/reference/transactions/#url
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Algo testnet.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function talgoToken(id, name, alias, fullName, decimalPlaces, asset, tokenURL = '', features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.algorand) {
    return algoToken(id, name, alias, fullName, decimalPlaces, asset, tokenURL, features, prefix, suffix, network);
}
exports.talgoToken = talgoToken;
/**
 * Factory function for eos token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractName Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to EOS main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function eosToken(id, name, fullName, decimalPlaces, contractName, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.eos, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new EosCoin({
        id,
        name,
        fullName,
        network,
        contractName,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.EOS,
    }));
}
exports.eosToken = eosToken;
/**
 * Factory function for testnet eos token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet EOS network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function teosToken(id, name, fullName, decimalPlaces, contractName, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.eos) {
    return eosToken(id, name, fullName, decimalPlaces, contractName, asset, features, prefix, suffix, network);
}
exports.teosToken = teosToken;
/**
 * Factory function for sol token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenAddress Token address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to SOL main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function solToken(id, name, fullName, decimalPlaces, tokenAddress, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.sol, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new SolCoin({
        id,
        name,
        fullName,
        network,
        tokenAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.SOL,
    }));
}
exports.solToken = solToken;
/**
 * Factory function for testnet solana token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenAddress Token address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet Solana network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 */
function tsolToken(id, name, fullName, decimalPlaces, tokenAddress, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.sol) {
    return solToken(id, name, fullName, decimalPlaces, tokenAddress, asset, features, prefix, suffix, network);
}
exports.tsolToken = tsolToken;
/**
 * Factory function for ada token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenSymbol Token symbol of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Cardano main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function adaToken(id, name, fullName, decimalPlaces, policyId, assetName, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ada, primaryKeyCurve = base_1.KeyCurve.Ed25519) {
    return Object.freeze(new AdaCoin({
        id,
        name,
        fullName,
        network,
        policyId,
        assetName,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ADA,
    }));
}
exports.adaToken = adaToken;
/**
 * Factory function for testnet cardano token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param tokenSymbol Token symbol of this token i.e: AUSD
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet Cardano network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES and REQUIRES_RESERVE defined in `AccountCoin`
 */
function tadaToken(id, name, fullName, decimalPlaces, policyId, assetName, asset, features = [...AccountCoin.DEFAULT_FEATURES, base_1.CoinFeature.REQUIRES_RESERVE], prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ada) {
    return adaToken(id, name, fullName, decimalPlaces, policyId, assetName, asset, features, prefix, suffix, network);
}
exports.tadaToken = tadaToken;
/**
 * Factory function for avaxErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to AvalancheC main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function avaxErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.avalancheC, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new AvaxERC20Token({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.avaxErc20 = avaxErc20;
/**
 * Factory function for testnet avaxErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the AvalancheC test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tavaxErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.avalancheC, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return avaxErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.tavaxErc20 = tavaxErc20;
/**
 * Factory function for polygonErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Polygon main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function polygonErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.polygon, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new PolygonERC20Token({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.polygonErc20 = polygonErc20;
/**
 * Factory function for Mumbai testnet polygonErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Polygon test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tpolygonErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.polygon, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return polygonErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.tpolygonErc20 = tpolygonErc20;
/**
 * Factory function for arbethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Polygon main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function arbethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.arbitrum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new ArbethERC20Token({
        id,
        name,
        fullName,
        network,
        contractAddress,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.arbethErc20 = arbethErc20;
/**
 * Factory function for Arbitrum Sepolia testnet arbethErc20 token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param contractAddress Contract address of this token
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the Polygon test network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tarbethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.arbitrum, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return arbethErc20(id, name, fullName, decimalPlaces, contractAddress, asset, features, prefix, suffix, network, primaryKeyCurve);
}
exports.tarbethErc20 = tarbethErc20;
/**
 * Factory function for xrp token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param issuerAddress: The address of the issuer of the token,
 * @param currencyCode The token symbol. Example: USD, BTC, ETH, etc.
 * @param domain? the domain of the issuer of the token,
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to Cardano main network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function xrpToken(id, name, fullName, decimalPlaces, issuerAddress, currencyCode, domain = '', asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.xrp, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new XrpCoin({
        id,
        name,
        fullName,
        network,
        issuerAddress,
        currencyCode,
        domain,
        prefix,
        suffix,
        features,
        decimalPlaces,
        asset,
        isToken: true,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XRP,
    }));
}
exports.xrpToken = xrpToken;
/**
 * Factory function for testnet cardano token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the token
 * @param fullName Complete human-readable name of the token
 * @param decimalPlaces Number of decimal places this token supports (divisibility exponent)
 * @param issuerAddress: The address of the issuer of the token,
 * @param currencyCode The token symbol. Example: USD, BTC, ETH, etc.
 * @param domain? the domain of the issuer of the token,
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param prefix? Optional token prefix. Defaults to empty string
 * @param suffix? Optional token suffix. Defaults to token name.
 * @param network? Optional token network. Defaults to the testnet Cardano network.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `AccountCoin`
 */
function txrpToken(id, name, fullName, decimalPlaces, issuerAddress, currencyCode, domain = '', asset, features = AccountCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.xrp) {
    return xrpToken(id, name, fullName, decimalPlaces, issuerAddress, currencyCode, domain, asset, features, prefix, suffix, network);
}
exports.txrpToken = txrpToken;
/**
 * Factory function for fiat coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin, should start with 'fiat' or 'tfiat' followed by the 3-char ISO-4217 alphabetical code
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `FiatCoin`
 * @param primaryKeyCurve? The elliptic curve for this chain/token
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this coin is a token of another coin
 */
function fiat(id, name, fullName, network, decimalPlaces, asset, features = FiatCoin.DEFAULT_FEATURES, primaryKeyCurve = base_1.KeyCurve.Secp256k1, prefix = '', suffix = name.toUpperCase(), isToken = false) {
    return Object.freeze(new FiatCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.FIAT,
    }));
}
exports.fiat = fiat;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hY2NvdW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpQ0FBOEY7QUFDOUYsMkNBQTZDO0FBQzdDLHFDQUEyRTtBQUMzRSx5Q0FBaUc7QUFrQmpHOzs7Ozs7R0FNRztBQUNILE1BQWEsV0FBWSxTQUFRLGVBQVE7SUFZdkMsWUFBWSxPQUFrQztRQUM1QyxLQUFLLENBQUM7WUFDSixHQUFHLE9BQU87WUFDVixJQUFJLEVBQUUsZUFBUSxDQUFDLE1BQU07U0FDdEIsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2pDLENBQUM7SUFFUyxnQkFBZ0I7UUFDeEIsT0FBTyxJQUFJLEdBQUcsQ0FBYyxDQUFDLGtCQUFXLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRVMsa0JBQWtCO1FBQzFCLE9BQU8sSUFBSSxHQUFHLENBQWMsQ0FBQyxrQkFBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQzs7QUEzQkgsa0NBNEJDO0FBM0J3Qiw0QkFBZ0IsR0FBRztJQUN4QyxrQkFBVyxDQUFDLGFBQWE7SUFDekIsa0JBQVcsQ0FBQyxtQkFBbUI7SUFDL0Isa0JBQVcsQ0FBQyxrQkFBa0I7SUFDOUIsa0JBQVcsQ0FBQyxnQkFBZ0I7SUFDNUIsa0JBQVcsQ0FBQyxPQUFPO0lBQ25CLGtCQUFXLENBQUMsbUJBQW1CO0NBQ2hDLENBQUM7QUF1RUosTUFBYSxnQkFBaUIsU0FBUSxXQUFXO0lBQy9DLFlBQVksT0FBa0M7UUFDNUMsS0FBSyxDQUFDO1lBQ0osR0FBRyxPQUFPO1NBQ1gsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBTkQsNENBTUM7QUFFRDs7O0dBR0c7QUFDSCxNQUFhLDJCQUE0QixTQUFRLGdCQUFnQjtJQUcvRCxZQUFZLE9BQWdDO1FBQzFDLEtBQUssQ0FBQztZ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Q0gsQ0FBQztBQUNKLENBQUM7QUE3QkQsb0JBNkJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4sIEJhc2VVbml0LCBDb2luRmVhdHVyZSwgQ29pbktpbmQsIEtleUN1cnZlLCBVbmRlcmx5aW5nQXNzZXQgfSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IHsgRE9NQUlOX1BBVFRFUk4gfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IsIEludmFsaWREb21haW5FcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IEFjY291bnROZXR3b3JrLCBCYXNlTmV0d29yaywgRXRoZXJldW1OZXR3b3JrLCBOZXR3b3JrcywgVHJvbk5ldHdvcmsgfSBmcm9tICcuL25ldHdvcmtzJztcblxuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgaWQ6IHN0cmluZztcbiAgZnVsbE5hbWU6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBhbGlhcz86IHN0cmluZztcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcms7XG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQ7XG4gIGJhc2VVbml0OiBCYXNlVW5pdDtcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW107XG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcjtcbiAgaXNUb2tlbjogYm9vbGVhbjtcbiAgcHJlZml4Pzogc3RyaW5nO1xuICBzdWZmaXg/OiBzdHJpbmc7XG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmU7XG59XG5cbi8qKlxuICogQWNjb3VudCBiYXNlZCBjb2lucywgc3VjaCBhcyBFdGhlcmV1bSwgU3RlbGxhciwgb3IgWFJQLlxuICpcbiAqIFRoZXNlIHR5cGVzIG9mIGNvaW5zIG1haW50YWluIGFuIFwiYWNjb3VudCBiYWxhbmNlXCIgZm9yIGVhY2ggYWRkcmVzcyBvbiB0aGUgbmV0d29yayxcbiAqIGFzIG9wcG9zZWQgdG8gdGhlIHVuc3BlbnQgdHJhbnNhY3Rpb24gb3V0cHV0IG1vZGVsIHdoaWNoIG1haW50YWlucyBhIHJlY29yZCBvZiBhbGxcbiAqIFwicGllY2VzXCIgb2YgY29pbiB3aGljaCBiZWxvbmcgdG8gYW4gYWRkcmVzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFjY291bnRDb2luIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfRkVBVFVSRVMgPSBbXG4gICAgQ29pbkZlYXR1cmUuQUNDT1VOVF9NT0RFTCxcbiAgICBDb2luRmVhdHVyZS5SRVFVSVJFU19CSUdfTlVNQkVSLFxuICAgIENvaW5GZWF0dXJlLlZBTFVFTEVTU19UUkFOU0ZFUixcbiAgICBDb2luRmVhdHVyZS5UUkFOU0FDVElPTl9EQVRBLFxuICAgIENvaW5GZWF0dXJlLkNVU1RPRFksXG4gICAgQ29pbkZlYXR1cmUuQ1VTVE9EWV9CSVRHT19UUlVTVCxcbiAgXTtcblxuICBwdWJsaWMgcmVhZG9ubHkgbmV0d29yazogQWNjb3VudE5ldHdvcms7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBraW5kOiBDb2luS2luZC5DUllQVE8sXG4gICAgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmsgPSBvcHRpb25zLm5ldHdvcms7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVxdWlyZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUxdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXNhbGxvd2VkRmVhdHVyZXMoKTogU2V0PENvaW5GZWF0dXJlPiB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8Q29pbkZlYXR1cmU+KFtDb2luRmVhdHVyZS5VTlNQRU5UX01PREVMXSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcmMyMENvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGVsbGFyQ29pbkNvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBkb21haW46IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWRlcmFDb2luQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIG5vZGVBY2NvdW50SWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWRlcmFUb2tlbkNvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICBub2RlQWNjb3VudElkOiBzdHJpbmc7XG4gIHRva2VuSWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbGdvQ29pbkNvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICB0b2tlblVSTDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVvc0NvaW5Db25zdHJ1Y3Rvck9wdGlvbnMgZXh0ZW5kcyBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgY29udHJhY3ROYW1lOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU29sQ29pbkNvbnN0cnVjdG9yT3B0aW9ucyBleHRlbmRzIEFjY291bnRDb25zdHJ1Y3Rvck9wdGlvbnMge1xuICB0b2tlbkFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBZGFDb2luQ29uc3RydWN0b3JPcHRpb25zIGV4dGVuZHMgQWNjb3VudENvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIHBvbGljeUlkOiBzdHJpbmc7XG4gIGFzc2V0TmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFhycENvaW5Db25zdHJ1Y3Rvck9wdGlvbnMgZXh0ZW5kcyBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgaXNzdWVyQWRkcmVzczogc3RyaW5nO1xuICBjdXJyZW5jeUNvZGU6IHN0cmluZztcbiAgZG9tYWluOiBzdHJpbmc7XG59XG5cbnR5cGUgRmlhdENvaW5OYW1lID0gYGZpYXQke3N0cmluZ31gIHwgYHRmaWF0JHtzdHJpbmd9YDtcbmV4cG9ydCBpbnRlcmZhY2UgRmlhdENvaW5Db25zdHJ1Y3Rvck9wdGlvbnMgZXh0ZW5kcyBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zIHtcbiAgbmFtZTogRmlhdENvaW5OYW1lO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnRyYWN0QWRkcmVzcyBleHRlbmRzIFN0cmluZyB7XG4gIF9fY29udHJhY3RhZGRyZXNzX3BoYW50b21fXzogbmV2ZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBBY2NvdW50Q29pblRva2VuIGV4dGVuZHMgQWNjb3VudENvaW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBY2NvdW50Q29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgYmxvY2tjaGFpbnMgc3VwcG9ydCB0b2tlbnMgd2hpY2ggYXJlIGRlZmluZWQgYnkgYW4gYWRkcmVzcyBhdCB3aGljaCB0aGV5IGhhdmUgYSBzbWFydCBjb250cmFjdCBkZXBsb3llZC5cbiAqIEV4YW1wbGVzIGFyZSBFUkMyMCB0b2tlbnMsIGFuZCB0aGUgZXF1aXZhbGVudCBvbiBvdGhlciBjaGFpbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGNvbnRyYWN0QWRkcmVzczogQ29udHJhY3RBZGRyZXNzO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEVyYzIwQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIC8vIHZhbGlkIEVSQyAyMCBjb250cmFjdCBhZGRyZXNzZXMgYXJlIFwiMHhcIiBmb2xsb3dlZCBieSA0MCBsb3dlcmNhc2UgaGV4IGNoYXJhY3RlcnNcbiAgICAvLyBkbyBub3QgdXNlIGEgdmFsaWQgYWRkcmVzcyBmb3JtYXQgZm9yIGdlbmVyaWMgdG9rZW5zIGJlY2F1c2UgdGhleSBub3QgaGF2ZSBvbmNoYWluIGFkZHJlc3Nlc1xuICAgIGlmICghb3B0aW9ucy5jb250cmFjdEFkZHJlc3MubWF0Y2goL14weFthLWYwLTldezQwfSQvKSAmJiAhb3B0aW9ucy5mZWF0dXJlcy5pbmNsdWRlcyhDb2luRmVhdHVyZS5HRU5FUklDX1RPS0VOKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvcihvcHRpb25zLm5hbWUsIG9wdGlvbnMuY29udHJhY3RBZGRyZXNzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyYWN0QWRkcmVzcyA9IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzIGFzIHVua25vd24gYXMgQ29udHJhY3RBZGRyZXNzO1xuICB9XG59XG5cbi8qKlxuICogRVJDMjAgdG9rZW4gYWRkcmVzc2VzIGFyZSBCYXNlNTggZm9ybWF0dGVkIG9uIHNvbWUgYmxvY2tjaGFpbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlNThDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGNvbnRyYWN0QWRkcmVzczogQ29udHJhY3RBZGRyZXNzO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEVyYzIwQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGlmICghL15bMS05QS1ISi1OUC1aYS1rbS16XXszNH0kLy50ZXN0KG9wdGlvbnMuY29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvcihvcHRpb25zLm5hbWUsIG9wdGlvbnMuY29udHJhY3RBZGRyZXNzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyYWN0QWRkcmVzcyA9IG9wdGlvbnMuY29udHJhY3RBZGRyZXNzIGFzIHVua25vd24gYXMgQ29udHJhY3RBZGRyZXNzO1xuICB9XG59XG5cbi8qKlxuICogRVJDIDIwIGlzIGEgdG9rZW4gc3RhbmRhcmQgZm9yIHRoZSBFdGhlcmV1bSBibG9ja2NoYWluLiBUaGV5IGFyZSBzaW1pbGFyIHRvIG90aGVyIGFjY291bnQgY29pbnMsIGJ1dCBoYXZlIGFcbiAqIGNvbnRyYWN0IGFkZHJlc3MgcHJvcGVydHkgd2hpY2ggaWRlbnRpZmllcyB0aGUgc21hcnQgY29udHJhY3Qgd2hpY2ggZGVmaW5lcyB0aGUgdG9rZW4uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcmMyMENvaW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge31cblxuLyoqXG4gKiBFUkMgNzIxIGlzIHRoZSBub24gZnVuZ2libGUgdG9rZW4gc3RhbmRhcmQgZm9yIHRoZSBFdGhlcmV1bSBibG9ja2NoYWluLlxuICpcbiAqIHtAbGluayBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcyMSBFSVA3MjF9XG4gKi9cbmV4cG9ydCBjbGFzcyBFcmM3MjFDb2luIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHt9XG5cbi8qKlxuICogRVJDIDExNTUgaXMgdGhlIG11bHRpIHRva2VuIHN0YW5kYXJkIGZvciB0aGUgRXRoZXJldW0gYmxvY2tjaGFpbi5cbiAqXG4gKiB7QGxpbmsgaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTU1IEVJUDExNTV9XG4gKi9cbmV4cG9ydCBjbGFzcyBFcmMxMTU1Q29pbiBleHRlbmRzIENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbiB7fVxuXG4vKipcbiAqIFRoZSBUUk9OIGJsb2NrY2hhaW4gc3VwcG9ydHMgdG9rZW5zIG9mIHRoZSBFUkMyMCBzdGFuZGFyZCBzaW1pbGFyIHRvIEVUSCBFUkMyMCB0b2tlbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcm9uRXJjMjBDb2luIGV4dGVuZHMgQmFzZTU4Q29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHt9XG5cbi8qKlxuICogU29tZSBibG9ja2NoYWlucyBoYXZlIG5hdGl2ZSBjb2lucyB3aGljaCBhbHNvIHN1cHBvcnQgdGhlIEVSQzIwIGludGVyZmFjZSBzdWNoIGFzIENFTE8uXG4gKi9cbmV4cG9ydCBjbGFzcyBFcmMyMENvbXBhdGlibGVBY2NvdW50Q29pbiBleHRlbmRzIENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEVyYzIwQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC8vIFRoZXNlIGNvaW5zIHNob3VsZCBub3QgYmUgY2xhc3NpZmllZCBhcyB0b2tlbnMgYXMgdGhleSBhcmUgbm90IGNoaWxkcmVuIG9mIG90aGVyIGNvaW5zXG4gICAgICBpc1Rva2VuOiBmYWxzZSxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBDRUxPIGJsb2NrY2hhaW4gc3VwcG9ydHMgdG9rZW5zIG9mIHRoZSBFUkMyMCBzdGFuZGFyZCBzaW1pbGFyIHRvIEVUSCBFUkMyMCB0b2tlbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDZWxvQ29pbiBleHRlbmRzIENvbnRyYWN0QWRkcmVzc0RlZmluZWRUb2tlbiB7fVxuXG4vKipcbiAqIFRoZSBCU0MgYmxvY2tjaGFpbiBzdXBwb3J0cyB0b2tlbnMgb2YgdGhlIEVSQzIwIHN0YW5kYXJkIHNpbWlsYXIgdG8gRVRIIEVSQzIwIHRva2Vucy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJzY0NvaW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge31cblxuLyoqXG4gKiBUaGUgU3RlbGxhciBuZXR3b3JrIHN1cHBvcnRzIHRva2VucyAobm9uLW5hdGl2ZSBhc3NldHMpXG4gKiBYTE0gaXMgYWxzbyBrbm93biBhcyB0aGUgbmF0aXZlIGFzc2V0LlxuICogU3RlbGxhciB0b2tlbnMgd29yayBzaW1pbGFyIHRvIFhMTSwgYnV0IHRoZSB0b2tlbiBuYW1lIGlzIGRldGVybWluZWQgYnkgdGhlIGNoYWluLFxuICogdGhlIHRva2VuIGNvZGUgYW5kIHRoZSBpc3N1ZXIgYWNjb3VudCBpbiB0aGUgZm9ybTogKHQpeGxtOjx0b2tlbj4tPGlzc3Vlcj5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0ZWxsYXJDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBkb21haW46IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBTdGVsbGFyQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5kb21haW4gIT09ICcnICYmICFvcHRpb25zLmRvbWFpbi5tYXRjaChET01BSU5fUEFUVEVSTikpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRG9tYWluRXJyb3Iob3B0aW9ucy5uYW1lLCBvcHRpb25zLmRvbWFpbik7XG4gICAgfVxuXG4gICAgdGhpcy5kb21haW4gPSBvcHRpb25zLmRvbWFpbiBhcyBzdHJpbmc7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgSGVkZXJhIGNvaW4gbmVlZHMgYSBjbGllbnQgc2V0IHdpdGggdGhlIG5vZGUgYWNjb3VudCBJZC5cbiAqIEl0J3MgYW4gYWNjb3VudCBiYXNlZCBjb2luIHRoYXQgbmVlZHMgdGhlIG5vZGUgYWNjb3VudCBJRFxuICogd2hlcmUgdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgc2VudC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBIZWRlcmFDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBub2RlQWNjb3VudElkOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogSGVkZXJhQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICB0aGlzLm5vZGVBY2NvdW50SWQgPSBvcHRpb25zLm5vZGVBY2NvdW50SWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgSGVkZXJhIG5ldHdvcmsgc3VwcG9ydHMgdG9rZW5zLlxuICogSGVkZXJhIHRva2VucyB3b3JrIHNpbWlsYXIgdG8gbmF0aXZlIEhlZGVyYSBjb2luLFxuICogYnV0IHRoZSB0b2tlbiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSB0b2tlbklkIG9uIHRoZSBub2RlXG4gKlxuICovXG5leHBvcnQgY2xhc3MgSGVkZXJhVG9rZW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIG5vZGVBY2NvdW50SWQ6IHN0cmluZztcbiAgcHVibGljIHRva2VuSWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBIZWRlcmFUb2tlbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICB0aGlzLm5vZGVBY2NvdW50SWQgPSBvcHRpb25zLm5vZGVBY2NvdW50SWQ7XG4gICAgdGhpcy50b2tlbklkID0gb3B0aW9ucy50b2tlbklkO1xuICB9XG59XG5cbi8qKlxuICogVGhlIEFsZ28gbmV0d29yayBzdXBwb3J0cyB0b2tlbnMgKGFzc2V0cylcbiAqIEFsZ28gdG9rZW5zIHdvcmsgc2ltaWxhciB0byBuYXRpdmUgQUxHTyBjb2luLCBidXQgdGhlIHRva2VuIG5hbWUgaXMgZGV0ZXJtaW5lZCBieVxuICogdW5pcXVlIGFzc2V0IGlkIG9uIHRoZSBjaGFpbi4gSW50ZXJuYWxseSwgQml0R28gdXNlcyB0b2tlbiBpZGVudGlmaWVycyBvZiB0aGUgZm9ybWF0OiAodClhbGdvOjxhc3NldElkPlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEFsZ29Db2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyB0b2tlblVSTDogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBBbGdvQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy50b2tlblVSTCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IFVSTChvcHRpb25zLnRva2VuVVJMKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkRG9tYWluRXJyb3Iob3B0aW9ucy5uYW1lLCBvcHRpb25zLnRva2VuVVJMKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRva2VuVVJMID0gb3B0aW9ucy50b2tlblVSTDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBFb3MgbmV0d29yayBzdXBwb3J0cyB0b2tlbnNcbiAqIEVvcyB0b2tlbnMgd29yayBzaW1pbGFyIHRvIG5hdGl2ZSBFb3MgY29pbiwgYnV0IHRoZSB0b2tlbiBuYW1lIGlzIGRldGVybWluZWQgYnlcbiAqIHRoZSBjb250cmFjdE5hbWUgb24gdGhlIGNoYWluLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEVvc0NvaW4gZXh0ZW5kcyBBY2NvdW50Q29pblRva2VuIHtcbiAgcHVibGljIGNvbnRyYWN0TmFtZTogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFb3NDb2luQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIHRoaXMuY29udHJhY3ROYW1lID0gb3B0aW9ucy5jb250cmFjdE5hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgU29sIG5ldHdvcmsgc3VwcG9ydHMgdG9rZW5zXG4gKiBTb2wgdG9rZW5zIHdvcmsgc2ltaWxhciB0byBuYXRpdmUgU09MIGNvaW4sIGJ1dCB0aGUgdG9rZW4gbmFtZSBpcyBkZXRlcm1pbmVkIGJ5XG4gKiB0aGUgdG9rZW5BZGRyZXNzIG9uIHRoZSBjaGFpbi5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2xDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyB0b2tlbkFkZHJlc3M6IHN0cmluZztcbiAgY29uc3RydWN0b3Iob3B0aW9uczogU29sQ29pbkNvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRva2VuQWRkcmVzcyA9IG9wdGlvbnMudG9rZW5BZGRyZXNzO1xuICB9XG59XG5cbi8qKlxuICogVGhlIEFkYSBuZXR3b3JrIHN1cHBvcnRzIHRva2Vuc1xuICogQWRhIHRva2VucyBhcmUgaWRlbnRpZmllZCBieSB0aGVpciBwb2xpY3kgSUQgYW5kIGFzc2V0IG5hbWVcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBBZGFDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBwb2xpY3lJZDogc3RyaW5nO1xuICBwdWJsaWMgYXNzZXROYW1lOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEFkYUNvaW5Db25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wb2xpY3lJZCA9IG9wdGlvbnMucG9saWN5SWQ7XG4gICAgdGhpcy5hc3NldE5hbWUgPSBvcHRpb25zLmFzc2V0TmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBBVkFYIEMgQ2hhaW4gbmV0d29yayBzdXBwb3J0IHRva2Vuc1xuICogQVZBWCBDIENoYWluIFRva2VucyBhcmUgRVJDMjAgY29pbnNcbiAqL1xuZXhwb3J0IGNsYXNzIEF2YXhFUkMyMFRva2VuIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogRXJjMjBDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBQb2x5Z29uIENoYWluIG5ldHdvcmsgc3VwcG9ydCB0b2tlbnNcbiAqIFBvbHlnb24gQ2hhaW4gVG9rZW5zIGFyZSBFUkMyMCBjb2luc1xuICovXG5leHBvcnQgY2xhc3MgUG9seWdvbkVSQzIwVG9rZW4gZXh0ZW5kcyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFcmMyMENvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIEFyYml0cnVtIENoYWluIG5ldHdvcmsgc3VwcG9ydCB0b2tlbnNcbiAqIEFyYml0cnVtIENoYWluIFRva2VucyBhcmUgRVJDMjAgdG9rZW5zXG4gKi9cbmV4cG9ydCBjbGFzcyBBcmJldGhFUkMyMFRva2VuIGV4dGVuZHMgQ29udHJhY3RBZGRyZXNzRGVmaW5lZFRva2VuIHtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogRXJjMjBDb25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBYcnAgbmV0d29yayBzdXBwb3J0cyB0b2tlbnNcbiAqIFhycCB0b2tlbnMgYXJlIGlkZW50aWZpZWQgYnkgdGhlaXIgaXNzdWVyIGFkZHJlc3NcbiAqIE5hbWluZyBmb3JtYXQgaXMgc2ltaWxhciB0byBYTE1cbiAqIDxuZXR3b3JrPjo8dG9rZW4+LTxpc3N1ZXI+XG4gKi9cbmV4cG9ydCBjbGFzcyBYcnBDb2luIGV4dGVuZHMgQWNjb3VudENvaW5Ub2tlbiB7XG4gIHB1YmxpYyBpc3N1ZXJBZGRyZXNzOiBzdHJpbmc7XG4gIHB1YmxpYyBjdXJyZW5jeUNvZGU6IHN0cmluZztcbiAgcHVibGljIGRvbWFpbjogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBYcnBDb2luQ29uc3RydWN0b3JPcHRpb25zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGlmIChvcHRpb25zLmRvbWFpbiAhPT0gJycgJiYgIW9wdGlvbnMuZG9tYWluLm1hdGNoKERPTUFJTl9QQVRURVJOKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREb21haW5FcnJvcihvcHRpb25zLm5hbWUsIG9wdGlvbnMuZG9tYWluKTtcbiAgICB9XG5cbiAgICB0aGlzLmRvbWFpbiA9IG9wdGlvbnMuZG9tYWluIGFzIHN0cmluZztcbiAgICB0aGlzLmN1cnJlbmN5Q29kZSA9IG9wdGlvbnMuY3VycmVuY3lDb2RlO1xuICAgIHRoaXMuaXNzdWVyQWRkcmVzcyA9IG9wdGlvbnMuaXNzdWVyQWRkcmVzcztcbiAgfVxufVxuXG4vKipcbiAqIEZpYXQgY3VycmVuY2llcywgc3VjaCBhcyBVU0QsIEVVUiwgb3IgWUVOLlxuICovXG5leHBvcnQgY2xhc3MgRmlhdENvaW4gZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9GRUFUVVJFUyA9IFsuLi5BY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTXTtcblxuICBwdWJsaWMgcmVhZG9ubHkgbmV0d29yazogQmFzZU5ldHdvcms7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogRmlhdENvaW5Db25zdHJ1Y3Rvck9wdGlvbnMpIHtcbiAgICBzdXBlcih7IC4uLm9wdGlvbnMsIGtpbmQ6IENvaW5LaW5kLkZJQVQgfSk7XG5cbiAgICB0aGlzLm5ldHdvcmsgPSBvcHRpb25zLm5ldHdvcms7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVxdWlyZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUxdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXNhbGxvd2VkRmVhdHVyZXMoKTogU2V0PENvaW5GZWF0dXJlPiB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8Q29pbkZlYXR1cmU+KFtDb2luRmVhdHVyZS5VTlNQRU5UX01PREVMXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBhY2NvdW50IGNvaW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmU/IFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICovXG5leHBvcnQgZnVuY3Rpb24gYWNjb3VudChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBiYXNlVW5pdDogQmFzZVVuaXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMSxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBpc1Rva2VuID0gZmFsc2Vcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgQWNjb3VudENvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgYmFzZVVuaXQsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBlcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gRXRoZXJldW0gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBFdGhlcmV1bU5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmV0aGVyZXVtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzIwQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBlcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIEtvdmFuIHRlc3QgbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MudGVzdC5rb3ZhblxuKSB7XG4gIHJldHVybiBlcmMyMChpZCwgbmFtZSwgZnVsbE5hbWUsIGRlY2ltYWxQbGFjZXMsIGNvbnRyYWN0QWRkcmVzcywgYXNzZXQsIGZlYXR1cmVzLCBwcmVmaXgsIHN1ZmZpeCwgbmV0d29yayk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgZXJjNzIxIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEV0aGVyZXVtIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcmM3MjEoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBFdGhlcmV1bU5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmV0aGVyZXVtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzcyMUNvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzOiAwLFxuICAgICAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldC5FUkM3MjEsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgZXJjNzIxIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEdvZXJsaSB0ZXN0IG5ldHdvcmsuXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVyYzcyMShcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLnRlc3QuZ29lcmxpLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIGVyYzcyMShpZCwgbmFtZSwgZnVsbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrLCBwcmltYXJ5S2V5Q3VydmUpO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbnN0YW5kYXJkIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEV0aGVyZXVtIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub25zdGFuZGFyZFRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MubWFpbi5ldGhlcmV1bSxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzOiAwLFxuICAgICAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldC5OT05TVEFOREFSRCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgZXJjMTE1NSB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBFdGhlcmV1bSBtYWluIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJjMTE1NShcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLm1haW4uZXRoZXJldW0sXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgRXJjMTE1NUNvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzOiAwLFxuICAgICAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldC5FUkMxMTU1LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGVyYzExNTUgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gR29lcmxpIHRlc3QgbmV0d29yay5cbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXJjMTE1NShcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLnRlc3QuZ29lcmxpLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIGVyYzExNTUoaWQsIG5hbWUsIGZ1bGxOYW1lLCBjb250cmFjdEFkZHJlc3MsIGZlYXR1cmVzLCBwcmVmaXgsIHN1ZmZpeCwgbmV0d29yaywgcHJpbWFyeUtleUN1cnZlKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBFUkMyMC1jb21wYXRpYmxlIGFjY291bnQgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gZXJjMjBDb21wYXRpYmxlQWNjb3VudENvaW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBiYXNlVW5pdDogQmFzZVVuaXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEVyYzIwQ29tcGF0aWJsZUFjY291bnRDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogZmFsc2UsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGNlbG8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIENFTE8gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNlbG9Ub2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MubWFpbi5jZWxvLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IENlbG9Db2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FVEgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGNlbG8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIHRoZSB0ZXN0bmV0IENFTE8gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRjZWxvVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLnRlc3QuY2Vsb1xuKSB7XG4gIHJldHVybiBjZWxvVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBjb250cmFjdEFkZHJlc3MsIGFzc2V0LCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGNlbG8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEJTQyBtYWluIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnNjVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEV0aGVyZXVtTmV0d29yayA9IE5ldHdvcmtzLm1haW4uYnNjLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEJzY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkJTQyxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgYnNjIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgdGVzdG5ldCBCU0MgbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRic2NUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogRXRoZXJldW1OZXR3b3JrID0gTmV0d29ya3MudGVzdC5ic2Ncbikge1xuICByZXR1cm4gYnNjVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBjb250cmFjdEFkZHJlc3MsIGFzc2V0LCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIFN0ZWxsYXIgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBkb21haW4gRG9tYWluIG9mIHRoZSB0b2tlbiBpc3N1ZXIgKHVzZWQgdG8gYWNjZXNzIHRva2VuIGluZm9ybWF0aW9uIGZyb20gdGhlIGlzc3VlcidzIHN0ZWxsYXIudG9tbCBmaWxlKVxuICogU2VlIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL3N0ZWxsYXItdG9tbC5odG1sXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIFN0ZWxsYXIgbWFpbm5ldC5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGVsbGFyVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBkb21haW4gPSAnJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MubWFpbi5zdGVsbGFyLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBTdGVsbGFyQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGRvbWFpbixcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgbmV0d29yayxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuWExNLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBTdGVsbGFyIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gZG9tYWluIERvbWFpbiBvZiB0aGUgdG9rZW4gaXNzdWVyICh1c2VkIHRvIGFjY2VzcyB0b2tlbiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBpc3N1ZXIncyBzdGVsbGFyLnRvbWwgZmlsZSlcbiAqIFNlZSBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy9zdGVsbGFyLXRvbWwuaHRtbFxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBTdGVsbGFyIHRlc3RuZXQuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c3RlbGxhclRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZG9tYWluID0gJycsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLnRlc3Quc3RlbGxhclxuKSB7XG4gIHJldHVybiBzdGVsbGFyVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBhc3NldCwgZG9tYWluLCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRyb24gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIFRST04gbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyb25Ub2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogVHJvbk5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLnRyeCxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBUcm9uRXJjMjBDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5UUlgsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IHRyb24gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIHRoZSB0ZXN0bmV0IFRST04gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0dHJvblRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBUcm9uTmV0d29yayA9IE5ldHdvcmtzLnRlc3QudHJ4LFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIHRyb25Ub2tlbihcbiAgICBpZCxcbiAgICBuYW1lLFxuICAgIGZ1bGxOYW1lLFxuICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgY29udHJhY3RBZGRyZXNzLFxuICAgIGFzc2V0LFxuICAgIGZlYXR1cmVzLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgbmV0d29yayxcbiAgICBwcmltYXJ5S2V5Q3VydmVcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBIZWRlcmEgY29pbiBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBub2RlQWNjb3VudElkIG5vZGUgYWNjb3VudCBJZCBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHNlbnRcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gSGVkZXJhIG1haW5uZXQuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaGVkZXJhQ29pbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBub2RlQWNjb3VudElkID0gJzAuMC4zJyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5FZDI1NTE5XG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEhlZGVyYUNvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBub2RlQWNjb3VudElkLFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBuZXR3b3JrLFxuICAgICAgaXNUb2tlbjogZmFsc2UsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuSEJBUixcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIEhlZGVyYSB0b2tlbiBpbnN0YW5jZXNcbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBub2RlQWNjb3VudElkIG5vZGUgYWNjb3VudCBJZCBmcm9tIHdoaWNoIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHNlbnRcbiAqIEBwYXJhbSB0b2tlbklkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEhlZGVyYSBtYWlubmV0LlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhlZGVyYVRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIG5vZGVBY2NvdW50SWQgPSAnMC4wLjMnLFxuICB0b2tlbklkOiBzdHJpbmcsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBIZWRlcmFUb2tlbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIG5vZGVBY2NvdW50SWQsXG4gICAgICB0b2tlbklkLFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBuZXR3b3JrLFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5IQkFSLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgQUxHTyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuXG4gKiBAcGFyYW0gYWxpYXMgKG9wdGlvbmFsKSBhbHRlcm5hdGl2ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHRva2VuVVJMIE9wdGlvbmFsIGFzc2V0IFVybCBmb3IgbW9yZSBpbmZvcm1hdGlvbmEgYWJvdXQgdGhlIGFzc2V0XG4gKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYWxnb3JhbmQub3JnL2RvY3MvcmVmZXJlbmNlL3RyYW5zYWN0aW9ucy8jdXJsXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEFMR08gbWFpbm5ldC5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbGdvVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgYWxpYXM6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICB0b2tlblVSTCA9ICcnLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmFsZ29yYW5kLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKTogUmVhZG9ubHk8QWxnb0NvaW4+IHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEFsZ29Db2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGFsaWFzLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICB0b2tlblVSTDogdG9rZW5VUkwsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIG5ldHdvcmssXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkFMR08sXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IEFMR08gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBhbGlhcyAob3B0aW9uYWwpIGFsdGVybmF0aXZlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gdG9rZW5VUkwgT3B0aW9uYWwgYXNzZXQgVXJsIGZvciBtb3JlIGluZm9ybWF0aW9uYSBhYm91dCB0aGUgYXNzZXRcbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5hbGdvcmFuZC5vcmcvZG9jcy9yZWZlcmVuY2UvdHJhbnNhY3Rpb25zLyN1cmxcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gQWxnbyB0ZXN0bmV0LlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFsZ29Ub2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBhbGlhczogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIHRva2VuVVJMID0gJycsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLnRlc3QuYWxnb3JhbmRcbik6IFJlYWRvbmx5PEFsZ29Db2luPiB7XG4gIHJldHVybiBhbGdvVG9rZW4oaWQsIG5hbWUsIGFsaWFzLCBmdWxsTmFtZSwgZGVjaW1hbFBsYWNlcywgYXNzZXQsIHRva2VuVVJMLCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGVvcyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0TmFtZSBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gRU9TIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlb3NUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0TmFtZTogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmVvcyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBFb3NDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5FT1MsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGVvcyB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgRU9TIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW9zVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBjb250cmFjdE5hbWU6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBBY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5lb3Ncbikge1xuICByZXR1cm4gZW9zVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBjb250cmFjdE5hbWUsIGFzc2V0LCBmZWF0dXJlcywgcHJlZml4LCBzdWZmaXgsIG5ldHdvcmspO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHNvbCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIHRva2VuQWRkcmVzcyBUb2tlbiBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gU09MIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBhbmQgUkVRVUlSRVNfUkVTRVJWRSBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb2xUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIHRva2VuQWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IFsuLi5BY2NvdW50Q29pbi5ERUZBVUxUX0ZFQVRVUkVTLCBDb2luRmVhdHVyZS5SRVFVSVJFU19SRVNFUlZFXSxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4uc29sLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuRWQyNTUxOVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBTb2xDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHRva2VuQWRkcmVzcyxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5TT0wsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IHNvbGFuYSB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIHRva2VuQWRkcmVzcyBUb2tlbiBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgU29sYW5hIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgYW5kIFJFUVVJUkVTX1JFU0VSVkUgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c29sVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICB0b2tlbkFkZHJlc3M6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBbLi4uQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUywgQ29pbkZlYXR1cmUuUkVRVUlSRVNfUkVTRVJWRV0sXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LnNvbFxuKSB7XG4gIHJldHVybiBzb2xUb2tlbihpZCwgbmFtZSwgZnVsbE5hbWUsIGRlY2ltYWxQbGFjZXMsIHRva2VuQWRkcmVzcywgYXNzZXQsIGZlYXR1cmVzLCBwcmVmaXgsIHN1ZmZpeCwgbmV0d29yayk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgYWRhIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gdG9rZW5TeW1ib2wgVG9rZW4gc3ltYm9sIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gQ2FyZGFubyBtYWluIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgYW5kIFJFUVVJUkVTX1JFU0VSVkUgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRhVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBwb2xpY3lJZDogc3RyaW5nLFxuICBhc3NldE5hbWU6IHN0cmluZyxcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBbLi4uQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUywgQ29pbkZlYXR1cmUuUkVRVUlSRVNfUkVTRVJWRV0sXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmFkYSxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLkVkMjU1MTlcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgQWRhQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwb2xpY3lJZCxcbiAgICAgIGFzc2V0TmFtZSxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGFzc2V0LFxuICAgICAgaXNUb2tlbjogdHJ1ZSxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5BREEsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IGNhcmRhbm8gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSB0b2tlblN5bWJvbCBUb2tlbiBzeW1ib2wgb2YgdGhpcyB0b2tlbiBpLmU6IEFVU0RcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIHRlc3RuZXQgQ2FyZGFubyBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGFuZCBSRVFVSVJFU19SRVNFUlZFIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFkYVRva2VuKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgcG9saWN5SWQ6IHN0cmluZyxcbiAgYXNzZXROYW1lOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gWy4uLkFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsIENvaW5GZWF0dXJlLlJFUVVJUkVTX1JFU0VSVkVdLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IEFjY291bnROZXR3b3JrID0gTmV0d29ya3MudGVzdC5hZGFcbikge1xuICByZXR1cm4gYWRhVG9rZW4oaWQsIG5hbWUsIGZ1bGxOYW1lLCBkZWNpbWFsUGxhY2VzLCBwb2xpY3lJZCwgYXNzZXROYW1lLCBhc3NldCwgZmVhdHVyZXMsIHByZWZpeCwgc3VmZml4LCBuZXR3b3JrKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBhdmF4RXJjMjAgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgdG9rZW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgQ29udHJhY3QgYWRkcmVzcyBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIEF2YWxhbmNoZUMgbWFpbiBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF2YXhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmF2YWxhbmNoZUMsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgQXZheEVSQzIwVG9rZW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgYXZheEVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgQXZhbGFuY2hlQyB0ZXN0IG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdGF2YXhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LmF2YWxhbmNoZUMsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gYXZheEVyYzIwKFxuICAgIGlkLFxuICAgIG5hbWUsXG4gICAgZnVsbE5hbWUsXG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgYXNzZXQsXG4gICAgZmVhdHVyZXMsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeCxcbiAgICBuZXR3b3JrLFxuICAgIHByaW1hcnlLZXlDdXJ2ZVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHBvbHlnb25FcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gUG9seWdvbiBtYWluIG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9seWdvbkVyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgY29udHJhY3RBZGRyZXNzOiBzdHJpbmcsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gQWNjb3VudENvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBBY2NvdW50TmV0d29yayA9IE5ldHdvcmtzLm1haW4ucG9seWdvbixcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBQb2x5Z29uRVJDMjBUb2tlbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgTXVtYmFpIHRlc3RuZXQgcG9seWdvbkVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byB0aGUgUG9seWdvbiB0ZXN0IG5ldHdvcmsuXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgQWNjb3VudENvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdHBvbHlnb25FcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LnBvbHlnb24sXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gcG9seWdvbkVyYzIwKFxuICAgIGlkLFxuICAgIG5hbWUsXG4gICAgZnVsbE5hbWUsXG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgYXNzZXQsXG4gICAgZmVhdHVyZXMsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeCxcbiAgICBuZXR3b3JrLFxuICAgIHByaW1hcnlLZXlDdXJ2ZVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGFyYmV0aEVyYzIwIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIENvbnRyYWN0IGFkZHJlc3Mgb2YgdGhpcyB0b2tlblxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBQb2x5Z29uIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcmJldGhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLmFyYml0cnVtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEFyYmV0aEVSQzIwVG9rZW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgYXNzZXQsXG4gICAgICBpc1Rva2VuOiB0cnVlLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIEFyYml0cnVtIFNlcG9saWEgdGVzdG5ldCBhcmJldGhFcmMyMCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBDb250cmFjdCBhZGRyZXNzIG9mIHRoaXMgdG9rZW5cbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIHRva2VuIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCB0b2tlbiBzdWZmaXguIERlZmF1bHRzIHRvIHRva2VuIG5hbWUuXG4gKiBAcGFyYW0gbmV0d29yaz8gT3B0aW9uYWwgdG9rZW4gbmV0d29yay4gRGVmYXVsdHMgdG8gdGhlIFBvbHlnb24gdGVzdCBuZXR3b3JrLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEFjY291bnRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRhcmJldGhFcmMyMChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LmFyYml0cnVtLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIGFyYmV0aEVyYzIwKFxuICAgIGlkLFxuICAgIG5hbWUsXG4gICAgZnVsbE5hbWUsXG4gICAgZGVjaW1hbFBsYWNlcyxcbiAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgYXNzZXQsXG4gICAgZmVhdHVyZXMsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeCxcbiAgICBuZXR3b3JrLFxuICAgIHByaW1hcnlLZXlDdXJ2ZVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHhycCB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0b2tlblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyB0b2tlbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGlzc3VlckFkZHJlc3M6IFRoZSBhZGRyZXNzIG9mIHRoZSBpc3N1ZXIgb2YgdGhlIHRva2VuLFxuICogQHBhcmFtIGN1cnJlbmN5Q29kZSBUaGUgdG9rZW4gc3ltYm9sLiBFeGFtcGxlOiBVU0QsIEJUQywgRVRILCBldGMuXG4gKiBAcGFyYW0gZG9tYWluPyB0aGUgZG9tYWluIG9mIHRoZSBpc3N1ZXIgb2YgdGhlIHRva2VuLFxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgdG9rZW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIHRva2VuIHN1ZmZpeC4gRGVmYXVsdHMgdG8gdG9rZW4gbmFtZS5cbiAqIEBwYXJhbSBuZXR3b3JrPyBPcHRpb25hbCB0b2tlbiBuZXR3b3JrLiBEZWZhdWx0cyB0byBDYXJkYW5vIG1haW4gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4cnBUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGlzc3VlckFkZHJlc3M6IHN0cmluZyxcbiAgY3VycmVuY3lDb2RlOiBzdHJpbmcsXG4gIGRvbWFpbiA9ICcnLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy5tYWluLnhycCxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBYcnBDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIGlzc3VlckFkZHJlc3MsXG4gICAgICBjdXJyZW5jeUNvZGUsXG4gICAgICBkb21haW4sXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBhc3NldCxcbiAgICAgIGlzVG9rZW46IHRydWUsXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuWFJQLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBjYXJkYW5vIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHRva2VuXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgdG9rZW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIHRva2VuIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gaXNzdWVyQWRkcmVzczogVGhlIGFkZHJlc3Mgb2YgdGhlIGlzc3VlciBvZiB0aGUgdG9rZW4sXG4gKiBAcGFyYW0gY3VycmVuY3lDb2RlIFRoZSB0b2tlbiBzeW1ib2wuIEV4YW1wbGU6IFVTRCwgQlRDLCBFVEgsIGV0Yy5cbiAqIEBwYXJhbSBkb21haW4/IHRoZSBkb21haW4gb2YgdGhlIGlzc3VlciBvZiB0aGUgdG9rZW4sXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCB0b2tlbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgdG9rZW4gc3VmZml4LiBEZWZhdWx0cyB0byB0b2tlbiBuYW1lLlxuICogQHBhcmFtIG5ldHdvcms/IE9wdGlvbmFsIHRva2VuIG5ldHdvcmsuIERlZmF1bHRzIHRvIHRoZSB0ZXN0bmV0IENhcmRhbm8gbmV0d29yay5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBBY2NvdW50Q29pbmBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR4cnBUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGlzc3VlckFkZHJlc3M6IHN0cmluZyxcbiAgY3VycmVuY3lDb2RlOiBzdHJpbmcsXG4gIGRvbWFpbiA9ICcnLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEFjY291bnRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogQWNjb3VudE5ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0LnhycFxuKSB7XG4gIHJldHVybiB4cnBUb2tlbihcbiAgICBpZCxcbiAgICBuYW1lLFxuICAgIGZ1bGxOYW1lLFxuICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgaXNzdWVyQWRkcmVzcyxcbiAgICBjdXJyZW5jeUNvZGUsXG4gICAgZG9tYWluLFxuICAgIGFzc2V0LFxuICAgIGZlYXR1cmVzLFxuICAgIHByZWZpeCxcbiAgICBzdWZmaXgsXG4gICAgbmV0d29ya1xuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIGZpYXQgY29pbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luLCBzaG91bGQgc3RhcnQgd2l0aCAnZmlhdCcgb3IgJ3RmaWF0JyBmb2xsb3dlZCBieSB0aGUgMy1jaGFyIElTTy00MjE3IGFscGhhYmV0aWNhbCBjb2RlXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYEZpYXRDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZT8gVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlhdChcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogRmlhdENvaW5OYW1lLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBuZXR3b3JrOiBCYXNlTmV0d29yayxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IEZpYXRDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azEsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgaXNUb2tlbiA9IGZhbHNlXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IEZpYXRDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5GSUFULFxuICAgIH0pXG4gICk7XG59XG4iXX0=