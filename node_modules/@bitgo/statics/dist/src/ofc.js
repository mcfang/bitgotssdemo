"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tofcHederaToken = exports.ofcHederaToken = exports.tofcAlgoToken = exports.ofcAlgoToken = exports.tofcStellarToken = exports.ofcStellarToken = exports.tofcerc20 = exports.ofcerc20 = exports.tofc = exports.ofc = exports.OfcCoin = void 0;
const base_1 = require("./base");
const networks_1 = require("./networks");
/**
 * OFC (off chain) coins. These are virtual coins used to represent off chain assets on the BitGo platform.
 */
class OfcCoin extends base_1.BaseCoin {
    constructor(options) {
        const { addressCoin, ...baseOptions } = options;
        super(baseOptions);
        this.addressCoin = addressCoin;
    }
    requiredFeatures() {
        return new Set([base_1.CoinFeature.ACCOUNT_MODEL, base_1.CoinFeature.REQUIRES_BIG_NUMBER]);
    }
    disallowedFeatures() {
        return new Set([
            base_1.CoinFeature.UNSPENT_MODEL,
            base_1.CoinFeature.CHILD_PAYS_FOR_PARENT,
            base_1.CoinFeature.PAYGO,
            base_1.CoinFeature.SUPPORTS_TOKENS,
        ]);
    }
}
exports.OfcCoin = OfcCoin;
OfcCoin.DEFAULT_FEATURES = [
    base_1.CoinFeature.ACCOUNT_MODEL,
    base_1.CoinFeature.REQUIRES_BIG_NUMBER,
    base_1.CoinFeature.CUSTODY,
    base_1.CoinFeature.CUSTODY_BITGO_TRUST,
];
/**
 * Factory function for ofc coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofc(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, 
/** OFC tokens use SECP256K1 under the hood even if the chain doesn't **/
primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.OFC,
    }));
}
exports.ofc = ofc;
/**
 * Factory function for testnet ofc coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofc(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.OFC,
    }));
}
exports.tofc = tofc;
/**
 * Factory function for ofc erc20 coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcerc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'eth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.ofcerc20 = ofcerc20;
/**
 * Factory function for testnet ofc erc20 coin instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcerc20(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.replace(/^ofc/, '').toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'teth', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ETH,
    }));
}
exports.tofcerc20 = tofcerc20;
/**
 * Factory function for ofc stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcStellarToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'xlm', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XLM,
    }));
}
exports.ofcStellarToken = ofcStellarToken;
/**
 * Factory function for testnet ofc stellar token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcStellarToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'txlm', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.XLM,
    }));
}
exports.tofcStellarToken = tofcStellarToken;
/**
 * Factory function for ofc algo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcAlgoToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'algo', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ALGO,
    }));
}
exports.ofcAlgoToken = ofcAlgoToken;
/**
 * Factory function for testnet ofc algo token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcAlgoToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'talgo', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.ALGO,
    }));
}
exports.tofcAlgoToken = tofcAlgoToken;
/**
 * Factory function for ofc hedera token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function ofcHederaToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.main.ofc, isToken = true, addressCoin = 'hbar', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.ofcHederaToken = ofcHederaToken;
/**
 * Factory function for testnet ofc hedera token instances.
 *
 * @param id uuid v4
 * @param name unique identifier of the coin
 * @param fullName Complete human-readable name of the coin
 * @param network Network object for this coin
 * @param decimalPlaces Number of decimal places this coin supports (divisibility exponent)
 * @param asset Asset which this coin represents. This is the same for both mainnet and testnet variants of a coin.
 * @param kind Differentiates coins which represent fiat assets from those which represent crypto assets
 * @param prefix? Optional coin prefix. Defaults to empty string
 * @param suffix? Optional coin suffix. Defaults to coin name.
 * @param isToken? Whether or not this account coin is a token of another coin
 * @param features? Features of this coin. Defaults to the DEFAULT_FEATURES defined in `OfcCoin`
 * @param primaryKeyCurve The elliptic curve for this chain/token
 */
function tofcHederaToken(id, name, fullName, decimalPlaces, asset, kind = base_1.CoinKind.CRYPTO, features = OfcCoin.DEFAULT_FEATURES, prefix = '', suffix = name.toUpperCase(), network = networks_1.Networks.test.ofc, isToken = true, addressCoin = 'thbar', primaryKeyCurve = base_1.KeyCurve.Secp256k1) {
    return Object.freeze(new OfcCoin({
        id,
        name,
        fullName,
        network,
        prefix,
        suffix,
        features,
        decimalPlaces,
        isToken,
        asset,
        kind,
        addressCoin,
        primaryKeyCurve,
        baseUnit: base_1.BaseUnit.HBAR,
    }));
}
exports.tofcHederaToken = tofcHederaToken;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2ZjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL29mYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxpQ0FBOEY7QUFDOUYseUNBQStEO0FBbUIvRDs7R0FFRztBQUNILE1BQWEsT0FBUSxTQUFRLGVBQVE7SUFXbkMsWUFBWSxPQUE4QjtRQUN4QyxNQUFNLEVBQUUsV0FBVyxFQUFFLEdBQUcsV0FBVyxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQ2hELEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNqQyxDQUFDO0lBRVMsZ0JBQWdCO1FBQ3hCLE9BQU8sSUFBSSxHQUFHLENBQWMsQ0FBQyxrQkFBVyxDQUFDLGFBQWEsRUFBRSxrQkFBVyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztJQUM1RixDQUFDO0lBRVMsa0JBQWtCO1FBQzFCLE9BQU8sSUFBSSxHQUFHLENBQWM7WUFDMUIsa0JBQVcsQ0FBQyxhQUFhO1lBQ3pCLGtCQUFXLENBQUMscUJBQXFCO1lBQ2pDLGtCQUFXLENBQUMsS0FBSztZQUNqQixrQkFBVyxDQUFDLGVBQWU7U0FDNUIsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7QUE1QkgsMEJBNkJDO0FBNUJ3Qix3QkFBZ0IsR0FBRztJQUN4QyxrQkFBVyxDQUFDLGFBQWE7SUFDekIsa0JBQVcsQ0FBQyxtQkFBbUI7SUFDL0Isa0JBQVcsQ0FBQyxPQUFPO0lBQ25CLGtCQUFXLENBQUMsbUJBQW1CO0NBQ2hDLENBQUM7QUF5Qko7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsU0FBZ0IsR0FBRyxDQUNqQixFQUFVLEVBQ1YsSUFBWSxFQUNaLFFBQWdCLEVBQ2hCLGFBQXFCLEVBQ3JCLEtBQXNCLEVBQ3RCLE9BQWlCLGVBQVEsQ0FBQyxNQUFNLEVBQ2hDLFdBQTBCLE9BQU8sQ0FBQyxnQkFBZ0IsRUFDbEQsTUFBTSxHQUFHLEVBQUUsRUFDWCxTQUFpQixJ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QUFhO1FBQ2IsT0FBTztRQUNQLEtBQUs7UUFDTCxJQUFJO1FBQ0osV0FBVztRQUNYLGVBQWU7UUFDZixRQUFRLEVBQUUsZUFBUSxDQUFDLElBQUk7S0FDeEIsQ0FBQyxDQUNILENBQUM7QUFDSixDQUFDO0FBakNELDBDQWlDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luLCBCYXNlVW5pdCwgQ29pbkZlYXR1cmUsIENvaW5LaW5kLCBLZXlDdXJ2ZSwgVW5kZXJseWluZ0Fzc2V0IH0gZnJvbSAnLi9iYXNlJztcbmltcG9ydCB7IEJhc2VOZXR3b3JrLCBOZXR3b3JrcywgT2ZjTmV0d29yayB9IGZyb20gJy4vbmV0d29ya3MnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9mY0NvbnN0cnVjdG9yT3B0aW9ucyB7XG4gIGlkOiBzdHJpbmc7XG4gIGZ1bGxOYW1lOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgbmV0d29yazogQmFzZU5ldHdvcms7XG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQ7XG4gIGJhc2VVbml0OiBCYXNlVW5pdDtcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW107XG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcjtcbiAgaXNUb2tlbjogYm9vbGVhbjtcbiAga2luZDogQ29pbktpbmQ7XG4gIHByZWZpeD86IHN0cmluZztcbiAgc3VmZml4Pzogc3RyaW5nO1xuICBhZGRyZXNzQ29pbj86IHN0cmluZztcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZTtcbn1cblxuLyoqXG4gKiBPRkMgKG9mZiBjaGFpbikgY29pbnMuIFRoZXNlIGFyZSB2aXJ0dWFsIGNvaW5zIHVzZWQgdG8gcmVwcmVzZW50IG9mZiBjaGFpbiBhc3NldHMgb24gdGhlIEJpdEdvIHBsYXRmb3JtLlxuICovXG5leHBvcnQgY2xhc3MgT2ZjQ29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBERUZBVUxUX0ZFQVRVUkVTID0gW1xuICAgIENvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUwsXG4gICAgQ29pbkZlYXR1cmUuUkVRVUlSRVNfQklHX05VTUJFUixcbiAgICBDb2luRmVhdHVyZS5DVVNUT0RZLFxuICAgIENvaW5GZWF0dXJlLkNVU1RPRFlfQklUR09fVFJVU1QsXG4gIF07XG5cbiAgLy8gSWYgc2V0LCB0aGlzIGNvaW4gaXMgdGhlIG5hdGl2ZSBhZGRyZXNzIGZvcm1hdCBmb3IgdGhpcyB0b2tlbi5cbiAgcHVibGljIHJlYWRvbmx5IGFkZHJlc3NDb2luPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IE9mY0NvbnN0cnVjdG9yT3B0aW9ucykge1xuICAgIGNvbnN0IHsgYWRkcmVzc0NvaW4sIC4uLmJhc2VPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgIHN1cGVyKGJhc2VPcHRpb25zKTtcbiAgICB0aGlzLmFkZHJlc3NDb2luID0gYWRkcmVzc0NvaW47XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVxdWlyZWRGZWF0dXJlcygpOiBTZXQ8Q29pbkZlYXR1cmU+IHtcbiAgICByZXR1cm4gbmV3IFNldDxDb2luRmVhdHVyZT4oW0NvaW5GZWF0dXJlLkFDQ09VTlRfTU9ERUwsIENvaW5GZWF0dXJlLlJFUVVJUkVTX0JJR19OVU1CRVJdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBkaXNhbGxvd2VkRmVhdHVyZXMoKTogU2V0PENvaW5GZWF0dXJlPiB7XG4gICAgcmV0dXJuIG5ldyBTZXQ8Q29pbkZlYXR1cmU+KFtcbiAgICAgIENvaW5GZWF0dXJlLlVOU1BFTlRfTU9ERUwsXG4gICAgICBDb2luRmVhdHVyZS5DSElMRF9QQVlTX0ZPUl9QQVJFTlQsXG4gICAgICBDb2luRmVhdHVyZS5QQVlHTyxcbiAgICAgIENvaW5GZWF0dXJlLlNVUFBPUlRTX1RPS0VOUyxcbiAgICBdKTtcbiAgfVxufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9mYyBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZjKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgLyoqIE9GQyB0b2tlbnMgdXNlIFNFQ1AyNTZLMSB1bmRlciB0aGUgaG9vZCBldmVuIGlmIHRoZSBjaGFpbiBkb2Vzbid0ICoqL1xuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5PRkMsXG4gICAgfSlcbiAgKTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9mYyhcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS5yZXBsYWNlKC9eb2ZjLywgJycpLnRvVXBwZXJDYXNlKCksXG4gIG5ldHdvcms6IE9mY05ldHdvcmsgPSBOZXR3b3Jrcy50ZXN0Lm9mYyxcbiAgaXNUb2tlbiA9IHRydWUsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0Lk9GQyxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9mYyBlcmMyMCBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gb2ZjZXJjMjAoXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUucmVwbGFjZSgvXm9mYy8sICcnKS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICdldGgnLFxuICBwcmltYXJ5S2V5Q3VydmU6IEtleUN1cnZlID0gS2V5Q3VydmUuU2VjcDI1NmsxXG4pIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoXG4gICAgbmV3IE9mY0NvaW4oe1xuICAgICAgaWQsXG4gICAgICBuYW1lLFxuICAgICAgZnVsbE5hbWUsXG4gICAgICBuZXR3b3JrLFxuICAgICAgcHJlZml4LFxuICAgICAgc3VmZml4LFxuICAgICAgZmVhdHVyZXMsXG4gICAgICBkZWNpbWFsUGxhY2VzLFxuICAgICAgaXNUb2tlbixcbiAgICAgIGFzc2V0LFxuICAgICAga2luZCxcbiAgICAgIGFkZHJlc3NDb2luLFxuICAgICAgcHJpbWFyeUtleUN1cnZlLFxuICAgICAgYmFzZVVuaXQ6IEJhc2VVbml0LkVUSCxcbiAgICB9KVxuICApO1xufVxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBlcmMyMCBjb2luIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9mY2VyYzIwKFxuICBpZDogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGZ1bGxOYW1lOiBzdHJpbmcsXG4gIGRlY2ltYWxQbGFjZXM6IG51bWJlcixcbiAgYXNzZXQ6IFVuZGVybHlpbmdBc3NldCxcbiAga2luZDogQ29pbktpbmQgPSBDb2luS2luZC5DUllQVE8sXG4gIGZlYXR1cmVzOiBDb2luRmVhdHVyZVtdID0gT2ZjQ29pbi5ERUZBVUxUX0ZFQVRVUkVTLFxuICBwcmVmaXggPSAnJyxcbiAgc3VmZml4OiBzdHJpbmcgPSBuYW1lLnJlcGxhY2UoL15vZmMvLCAnJykudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAndGV0aCcsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuRVRILFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3Igb2ZjIHN0ZWxsYXIgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmNTdGVsbGFyVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAneGxtJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5YTE0sXG4gICAgfSlcbiAgKTtcbn1cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGVzdG5ldCBvZmMgc3RlbGxhciB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZmNTdGVsbGFyVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLnRlc3Qub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAndHhsbScsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuWExNLFxuICAgIH0pXG4gICk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiBmb3Igb2ZjIGFsZ28gdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmNBbGdvVG9rZW4oXG4gIGlkOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgZnVsbE5hbWU6IHN0cmluZyxcbiAgZGVjaW1hbFBsYWNlczogbnVtYmVyLFxuICBhc3NldDogVW5kZXJseWluZ0Fzc2V0LFxuICBraW5kOiBDb2luS2luZCA9IENvaW5LaW5kLkNSWVBUTyxcbiAgZmVhdHVyZXM6IENvaW5GZWF0dXJlW10gPSBPZmNDb2luLkRFRkFVTFRfRkVBVFVSRVMsXG4gIHByZWZpeCA9ICcnLFxuICBzdWZmaXg6IHN0cmluZyA9IG5hbWUudG9VcHBlckNhc2UoKSxcbiAgbmV0d29yazogT2ZjTmV0d29yayA9IE5ldHdvcmtzLm1haW4ub2ZjLFxuICBpc1Rva2VuID0gdHJ1ZSxcbiAgYWRkcmVzc0NvaW4gPSAnYWxnbycsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuQUxHTyxcbiAgICB9KVxuICApO1xufVxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0ZXN0bmV0IG9mYyBhbGdvIHRva2VuIGluc3RhbmNlcy5cbiAqXG4gKiBAcGFyYW0gaWQgdXVpZCB2NFxuICogQHBhcmFtIG5hbWUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBmdWxsTmFtZSBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gbmV0d29yayBOZXR3b3JrIG9iamVjdCBmb3IgdGhpcyBjb2luXG4gKiBAcGFyYW0gZGVjaW1hbFBsYWNlcyBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhpcyBjb2luIHN1cHBvcnRzIChkaXZpc2liaWxpdHkgZXhwb25lbnQpXG4gKiBAcGFyYW0gYXNzZXQgQXNzZXQgd2hpY2ggdGhpcyBjb2luIHJlcHJlc2VudHMuIFRoaXMgaXMgdGhlIHNhbWUgZm9yIGJvdGggbWFpbm5ldCBhbmQgdGVzdG5ldCB2YXJpYW50cyBvZiBhIGNvaW4uXG4gKiBAcGFyYW0ga2luZCBEaWZmZXJlbnRpYXRlcyBjb2lucyB3aGljaCByZXByZXNlbnQgZmlhdCBhc3NldHMgZnJvbSB0aG9zZSB3aGljaCByZXByZXNlbnQgY3J5cHRvIGFzc2V0c1xuICogQHBhcmFtIHByZWZpeD8gT3B0aW9uYWwgY29pbiBwcmVmaXguIERlZmF1bHRzIHRvIGVtcHR5IHN0cmluZ1xuICogQHBhcmFtIHN1ZmZpeD8gT3B0aW9uYWwgY29pbiBzdWZmaXguIERlZmF1bHRzIHRvIGNvaW4gbmFtZS5cbiAqIEBwYXJhbSBpc1Rva2VuPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGFjY291bnQgY29pbiBpcyBhIHRva2VuIG9mIGFub3RoZXIgY29pblxuICogQHBhcmFtIGZlYXR1cmVzPyBGZWF0dXJlcyBvZiB0aGlzIGNvaW4uIERlZmF1bHRzIHRvIHRoZSBERUZBVUxUX0ZFQVRVUkVTIGRlZmluZWQgaW4gYE9mY0NvaW5gXG4gKiBAcGFyYW0gcHJpbWFyeUtleUN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZSBmb3IgdGhpcyBjaGFpbi90b2tlblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9mY0FsZ29Ub2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MudGVzdC5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICd0YWxnbycsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuQUxHTyxcbiAgICB9KVxuICApO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIG9mYyBoZWRlcmEgdG9rZW4gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSBpZCB1dWlkIHY0XG4gKiBAcGFyYW0gbmFtZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgY29pblxuICogQHBhcmFtIGZ1bGxOYW1lIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhlIGNvaW5cbiAqIEBwYXJhbSBuZXR3b3JrIE5ldHdvcmsgb2JqZWN0IGZvciB0aGlzIGNvaW5cbiAqIEBwYXJhbSBkZWNpbWFsUGxhY2VzIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGlzIGNvaW4gc3VwcG9ydHMgKGRpdmlzaWJpbGl0eSBleHBvbmVudClcbiAqIEBwYXJhbSBhc3NldCBBc3NldCB3aGljaCB0aGlzIGNvaW4gcmVwcmVzZW50cy4gVGhpcyBpcyB0aGUgc2FtZSBmb3IgYm90aCBtYWlubmV0IGFuZCB0ZXN0bmV0IHZhcmlhbnRzIG9mIGEgY29pbi5cbiAqIEBwYXJhbSBraW5kIERpZmZlcmVudGlhdGVzIGNvaW5zIHdoaWNoIHJlcHJlc2VudCBmaWF0IGFzc2V0cyBmcm9tIHRob3NlIHdoaWNoIHJlcHJlc2VudCBjcnlwdG8gYXNzZXRzXG4gKiBAcGFyYW0gcHJlZml4PyBPcHRpb25hbCBjb2luIHByZWZpeC4gRGVmYXVsdHMgdG8gZW1wdHkgc3RyaW5nXG4gKiBAcGFyYW0gc3VmZml4PyBPcHRpb25hbCBjb2luIHN1ZmZpeC4gRGVmYXVsdHMgdG8gY29pbiBuYW1lLlxuICogQHBhcmFtIGlzVG9rZW4/IFdoZXRoZXIgb3Igbm90IHRoaXMgYWNjb3VudCBjb2luIGlzIGEgdG9rZW4gb2YgYW5vdGhlciBjb2luXG4gKiBAcGFyYW0gZmVhdHVyZXM/IEZlYXR1cmVzIG9mIHRoaXMgY29pbi4gRGVmYXVsdHMgdG8gdGhlIERFRkFVTFRfRkVBVFVSRVMgZGVmaW5lZCBpbiBgT2ZjQ29pbmBcbiAqIEBwYXJhbSBwcmltYXJ5S2V5Q3VydmUgVGhlIGVsbGlwdGljIGN1cnZlIGZvciB0aGlzIGNoYWluL3Rva2VuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvZmNIZWRlcmFUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MubWFpbi5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICdoYmFyJyxcbiAgcHJpbWFyeUtleUN1cnZlOiBLZXlDdXJ2ZSA9IEtleUN1cnZlLlNlY3AyNTZrMVxuKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKFxuICAgIG5ldyBPZmNDb2luKHtcbiAgICAgIGlkLFxuICAgICAgbmFtZSxcbiAgICAgIGZ1bGxOYW1lLFxuICAgICAgbmV0d29yayxcbiAgICAgIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIGZlYXR1cmVzLFxuICAgICAgZGVjaW1hbFBsYWNlcyxcbiAgICAgIGlzVG9rZW4sXG4gICAgICBhc3NldCxcbiAgICAgIGtpbmQsXG4gICAgICBhZGRyZXNzQ29pbixcbiAgICAgIHByaW1hcnlLZXlDdXJ2ZSxcbiAgICAgIGJhc2VVbml0OiBCYXNlVW5pdC5IQkFSLFxuICAgIH0pXG4gICk7XG59XG4vKipcbiAqIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRlc3RuZXQgb2ZjIGhlZGVyYSB0b2tlbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIGlkIHV1aWQgdjRcbiAqIEBwYXJhbSBuYW1lIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBjb2luXG4gKiBAcGFyYW0gZnVsbE5hbWUgQ29tcGxldGUgaHVtYW4tcmVhZGFibGUgbmFtZSBvZiB0aGUgY29pblxuICogQHBhcmFtIG5ldHdvcmsgTmV0d29yayBvYmplY3QgZm9yIHRoaXMgY29pblxuICogQHBhcmFtIGRlY2ltYWxQbGFjZXMgTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoaXMgY29pbiBzdXBwb3J0cyAoZGl2aXNpYmlsaXR5IGV4cG9uZW50KVxuICogQHBhcmFtIGFzc2V0IEFzc2V0IHdoaWNoIHRoaXMgY29pbiByZXByZXNlbnRzLiBUaGlzIGlzIHRoZSBzYW1lIGZvciBib3RoIG1haW5uZXQgYW5kIHRlc3RuZXQgdmFyaWFudHMgb2YgYSBjb2luLlxuICogQHBhcmFtIGtpbmQgRGlmZmVyZW50aWF0ZXMgY29pbnMgd2hpY2ggcmVwcmVzZW50IGZpYXQgYXNzZXRzIGZyb20gdGhvc2Ugd2hpY2ggcmVwcmVzZW50IGNyeXB0byBhc3NldHNcbiAqIEBwYXJhbSBwcmVmaXg/IE9wdGlvbmFsIGNvaW4gcHJlZml4LiBEZWZhdWx0cyB0byBlbXB0eSBzdHJpbmdcbiAqIEBwYXJhbSBzdWZmaXg/IE9wdGlvbmFsIGNvaW4gc3VmZml4LiBEZWZhdWx0cyB0byBjb2luIG5hbWUuXG4gKiBAcGFyYW0gaXNUb2tlbj8gV2hldGhlciBvciBub3QgdGhpcyBhY2NvdW50IGNvaW4gaXMgYSB0b2tlbiBvZiBhbm90aGVyIGNvaW5cbiAqIEBwYXJhbSBmZWF0dXJlcz8gRmVhdHVyZXMgb2YgdGhpcyBjb2luLiBEZWZhdWx0cyB0byB0aGUgREVGQVVMVF9GRUFUVVJFUyBkZWZpbmVkIGluIGBPZmNDb2luYFxuICogQHBhcmFtIHByaW1hcnlLZXlDdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUgZm9yIHRoaXMgY2hhaW4vdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvZmNIZWRlcmFUb2tlbihcbiAgaWQ6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBmdWxsTmFtZTogc3RyaW5nLFxuICBkZWNpbWFsUGxhY2VzOiBudW1iZXIsXG4gIGFzc2V0OiBVbmRlcmx5aW5nQXNzZXQsXG4gIGtpbmQ6IENvaW5LaW5kID0gQ29pbktpbmQuQ1JZUFRPLFxuICBmZWF0dXJlczogQ29pbkZlYXR1cmVbXSA9IE9mY0NvaW4uREVGQVVMVF9GRUFUVVJFUyxcbiAgcHJlZml4ID0gJycsXG4gIHN1ZmZpeDogc3RyaW5nID0gbmFtZS50b1VwcGVyQ2FzZSgpLFxuICBuZXR3b3JrOiBPZmNOZXR3b3JrID0gTmV0d29ya3MudGVzdC5vZmMsXG4gIGlzVG9rZW4gPSB0cnVlLFxuICBhZGRyZXNzQ29pbiA9ICd0aGJhcicsXG4gIHByaW1hcnlLZXlDdXJ2ZTogS2V5Q3VydmUgPSBLZXlDdXJ2ZS5TZWNwMjU2azFcbikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShcbiAgICBuZXcgT2ZjQ29pbih7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBmdWxsTmFtZSxcbiAgICAgIG5ldHdvcmssXG4gICAgICBwcmVmaXgsXG4gICAgICBzdWZmaXgsXG4gICAgICBmZWF0dXJlcyxcbiAgICAgIGRlY2ltYWxQbGFjZXMsXG4gICAgICBpc1Rva2VuLFxuICAgICAgYXNzZXQsXG4gICAgICBraW5kLFxuICAgICAgYWRkcmVzc0NvaW4sXG4gICAgICBwcmltYXJ5S2V5Q3VydmUsXG4gICAgICBiYXNlVW5pdDogQmFzZVVuaXQuSEJBUixcbiAgICB9KVxuICApO1xufVxuIl19