/// <reference types="node" />
import { ExplainTransactionOptions } from '@bitgo/abstract-eth';
import { Eth, Recipient, GetSendMethodArgsOptions, SendMethodArgs, BuildTransactionParams, SignFinalOptions, SignTransactionOptions, SignedTransaction, RecoverOptions, RecoveryInfo, OfflineVaultTxInfo } from '@bitgo/sdk-coin-eth';
import { BaseCoin, BitGoBase, TransactionExplanation, FullySignedTransaction, MPCAlgorithm } from '@bitgo/sdk-core';
import { BaseCoin as StaticsBaseCoin } from '@bitgo/statics';
import { TransactionBuilder } from './lib';
import type * as EthTxLib from '@ethereumjs/tx';
export declare class Polygon extends Eth {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    protected readonly sendMethodName: 'sendMultiSig' | 'sendMultiSigToken';
    protected constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    static getCustomChainName(chainId?: number): string;
    static buildTransaction(params: BuildTransactionParams): EthTxLib.FeeMarketEIP1559Transaction | EthTxLib.Transaction;
    getChain(): string;
    getFamily(): string;
    getFullName(): string;
    /**
     * Get the base chain that the coin exists on.
     */
    getBaseChain(): string;
    isValidPub(pub: string): boolean;
    /** @inheritDoc */
    explainTransaction(options: ExplainTransactionOptions): Promise<TransactionExplanation>;
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    getTransactionBuilder(): TransactionBuilder;
    /**
     * Get transfer operation for coin
     * @param recipient recipient info
     * @param expireTime expiry time
     * @param contractSequenceId sequence id
     * @returns {Array} operation array
     */
    getOperation(recipient: Recipient, expireTime: number, contractSequenceId: number): (string | Buffer)[][];
    /**
     * Build arguments to call the send method on the wallet contract
     * @param txInfo
     */
    getSendMethodArgs(txInfo: GetSendMethodArgsOptions): SendMethodArgs[];
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.prv
     * @returns {{txHex: string}}
     */
    signFinalPolygon(params: SignFinalOptions): Promise<FullySignedTransaction>;
    /**
     * Assemble half-sign prebuilt transaction
     * @param params
     */
    signTransaction(params: SignTransactionOptions): Promise<SignedTransaction>;
    /**
     * Make a query to Polygonscan for information such as balance, token balance, solidity calls
     * @param {Object} query key-value pairs of parameters to append after /api
     * @returns {Promise<Object>} response from Polygonscan
     */
    recoveryBlockchainExplorerQuery(query: Record<string, string>): Promise<any>;
    /**
     * Builds a funds recovery transaction without BitGo for non-TSS transaction
     * @param params
     * @param {String} params.userKey [encrypted] xprv or xpub
     * @param {String} params.backupKey [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param {String} params.walletPassphrase used to decrypt userKey and backupKey
     * @param {String} params.walletContractAddress the Polygon address of the wallet contract
     * @param {String} params.krsProvider necessary if backup key is held by KRS
     * @param {String} params.recoveryDestination target address to send recovered funds to
     * @param {String} params.bitgoFeeAddress wrong chain wallet fee address for evm based cross chain recovery txn
     * @param {String} params.bitgoDestinationAddress target bitgo address where fee will be sent for evm based cross chain recovery txn
     * @returns {Promise<RecoveryInfo | OfflineVaultTxInfo>}
     */
    recoverEthLike(params: RecoverOptions): Promise<RecoveryInfo | OfflineVaultTxInfo>;
    /** @inheritDoc */
    supportsTss(): boolean;
    /** @inheritDoc */
    supportsMessageSigning(): boolean;
    /** @inheritDoc */
    getMPCAlgorithm(): MPCAlgorithm;
}
//# sourceMappingURL=polygon.d.ts.map