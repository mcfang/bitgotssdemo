"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenTransferBuilder = void 0;
const Long = __importStar(require("long"));
const sdk_core_1 = require("@bitgo/sdk-core");
const transferBuilder_1 = require("./transferBuilder");
const utils_1 = require("./utils");
const bignumber_js_1 = require("bignumber.js");
class TokenTransferBuilder extends transferBuilder_1.TransferBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    /** @inheritdoc */
    async buildImplementation() {
        this._txBodyData.tokenTransfers = this.buildTokenTransferData(); // set to list by the contract
        return await super.buildImplementation();
    }
    buildTokenTransferData() {
        let tokenTransferAmount = new bignumber_js_1.BigNumber(0); // total send amount for each token
        const tokenId = utils_1.getHederaTokenIdFromName(this._tokenName);
        const tokenTransferData = [
            {
                accountID: utils_1.buildHederaAccountID(this._source.address),
                amount: Long.fromInt(0),
            },
        ];
        this._recipients.forEach((recipient) => {
            tokenTransferAmount = tokenTransferAmount.plus(recipient.amount);
            tokenTransferData.push({ accountID: utils_1.buildHederaAccountID(recipient.address), amount: Long.fromString(recipient.amount) } // recipient
            );
        });
        tokenTransferData[0].amount = Long.fromString(tokenTransferAmount.toString()).negate(); // update sender send amount
        return [
            {
                token: utils_1.buildHederaTokenID(tokenId),
                transfers: tokenTransferData,
            },
        ];
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        const transferData = tx.txBody.cryptoTransfer;
        if (utils_1.isTokenTransfer(transferData)) {
            this.initTokenTransfers(transferData.tokenTransfers);
        }
    }
    /**
     * Initialize the transfer specific data, getting the recipient account
     * represented by the element with a positive amount on the transfer element.
     * The negative amount represents the source account so it's ignored.
     *
     * @param {proto.IAccountAmount[]} transfers array of objects which contains accountID and transferred amount
     */
    initTokenTransfers(tokenTransfers) {
        tokenTransfers.forEach((tokenTransfer) => {
            if (!tokenTransfer.token) {
                throw new sdk_core_1.BuildTransactionError('Invalid transaction: missing token id');
            }
            if (!tokenTransfer.transfers) {
                throw new sdk_core_1.BuildTransactionError('Invalid transaction: missing transfer data');
            }
            const token = utils_1.getHederaTokenNameFromId(utils_1.stringifyTokenId(tokenTransfer.token));
            if (!token) {
                throw new sdk_core_1.BuildTransactionError('Invalid transaction: invalid token id');
            }
            tokenTransfer.transfers.forEach((transferData) => {
                const amount = Long.fromValue(transferData.amount);
                if (amount.isPositive()) {
                    this.send({
                        address: utils_1.stringifyAccountId(transferData.accountID),
                        amount: amount.toString(),
                        tokenName: token.name,
                    });
                }
            });
        });
    }
    // region Transfer fields
    /** @inheritdoc */
    send(recipient) {
        if (!recipient.tokenName) {
            throw new sdk_core_1.InvalidParameterValueError('Invalid missing token name');
        }
        const tokenId = utils_1.getHederaTokenIdFromName(recipient.tokenName);
        if (!tokenId) {
            throw new sdk_core_1.InvalidParameterValueError(`Invalid token name: ${recipient.tokenName}`);
        }
        if (this._tokenName && this._tokenName !== recipient.tokenName) {
            throw new sdk_core_1.InvalidParameterValueError(`Invalid token: received ${recipient.tokenName} for ${this._tokenName} tx`);
        }
        this._tokenName = recipient.tokenName;
        return super.send(recipient);
    }
}
exports.TokenTransferBuilder = TokenTransferBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5UcmFuc2ZlckJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3Rva2VuVHJhbnNmZXJCdWlsZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSwyQ0FBNkI7QUFFN0IsOENBQW9GO0FBRXBGLHVEQUFvRDtBQUVwRCxtQ0FRaUI7QUFDakIsK0NBQXlDO0FBRXpDLE1BQWEsb0JBQXFCLFNBQVEsaUNBQWU7SUFHdkQsWUFBWSxXQUFpQztRQUMzQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDckIsQ0FBQztJQUVELGtCQUFrQjtJQUNSLEtBQUssQ0FBQyxtQkFBbUI7UUFDakMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixFQUFFLENBQUMsQ0FBQyw4QkFBOEI7UUFDL0YsT0FBTyxNQUFNLEtBQUssQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQzNDLENBQUM7SUFFTyxzQkFBc0I7UUFDNUIsSUFBSSxtQkFBbUIsR0FBRyxJQUFJLHdCQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQ0FBbUM7UUFDL0UsTUFBTSxPQUFPLEdBQUcsZ0NBQXdCLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzFELE1BQU0saUJBQWlCLEdBQTJCO1lBQ2hEO2dCQUNFLFNBQVMsRUFBRSw0QkFBb0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztnQkFDckQsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO2FBQ3hCO1NBQ0YsQ0FBQztRQUVGLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7WUFDckMsbUJBQW1CLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNqRSxpQkFBaUIsQ0FB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LENBQUMsU0FBUyxRQUFRLElBQUksQ0FBQyxVQUFVLEtBQUssQ0FBQyxDQUFDO1NBQ2xIO1FBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDO1FBQ3RDLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMvQixDQUFDO0NBRUY7QUFsR0Qsb0RBa0dDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCAqIGFzIExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgeyBwcm90byB9IGZyb20gJ0BoYXNoZ3JhcGgvcHJvdG8nO1xuaW1wb3J0IHsgQnVpbGRUcmFuc2FjdGlvbkVycm9yLCBJbnZhbGlkUGFyYW1ldGVyVmFsdWVFcnJvciB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBSZWNpcGllbnQgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IFRyYW5zZmVyQnVpbGRlciB9IGZyb20gJy4vdHJhbnNmZXJCdWlsZGVyJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQge1xuICBidWlsZEhlZGVyYUFjY291bnRJRCxcbiAgYnVpbGRIZWRlcmFUb2tlbklELFxuICBnZXRIZWRlcmFUb2tlbklkRnJvbU5hbWUsXG4gIGdldEhlZGVyYVRva2VuTmFtZUZyb21JZCxcbiAgaXNUb2tlblRyYW5zZmVyLFxuICBzdHJpbmdpZnlBY2NvdW50SWQsXG4gIHN0cmluZ2lmeVRva2VuSWQsXG59IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcblxuZXhwb3J0IGNsYXNzIFRva2VuVHJhbnNmZXJCdWlsZGVyIGV4dGVuZHMgVHJhbnNmZXJCdWlsZGVyIHtcbiAgcHJpdmF0ZSBfdG9rZW5OYW1lOyAvLyBjdXJyZW50bHkgb25seSBzdXBwb3J0IDEgdG9rZW4vdHJhbnNmZXJcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIHRoaXMuX3R4Qm9keURhdGEudG9rZW5UcmFuc2ZlcnMgPSB0aGlzLmJ1aWxkVG9rZW5UcmFuc2ZlckRhdGEoKTsgLy8gc2V0IHRvIGxpc3QgYnkgdGhlIGNvbnRyYWN0XG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxuXG4gIHByaXZhdGUgYnVpbGRUb2tlblRyYW5zZmVyRGF0YSgpOiBwcm90by5JVG9rZW5UcmFuc2Zlckxpc3RbXSB7XG4gICAgbGV0IHRva2VuVHJhbnNmZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApOyAvLyB0b3RhbCBzZW5kIGFtb3VudCBmb3IgZWFjaCB0b2tlblxuICAgIGNvbnN0IHRva2VuSWQgPSBnZXRIZWRlcmFUb2tlbklkRnJvbU5hbWUodGhpcy5fdG9rZW5OYW1lKTtcbiAgICBjb25zdCB0b2tlblRyYW5zZmVyRGF0YTogcHJvdG8uSUFjY291bnRBbW91bnRbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgYWNjb3VudElEOiBidWlsZEhlZGVyYUFjY291bnRJRCh0aGlzLl9zb3VyY2UuYWRkcmVzcyksXG4gICAgICAgIGFtb3VudDogTG9uZy5mcm9tSW50KDApLFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgdGhpcy5fcmVjaXBpZW50cy5mb3JFYWNoKChyZWNpcGllbnQpID0+IHtcbiAgICAgIHRva2VuVHJhbnNmZXJBbW91bnQgPSB0b2tlblRyYW5zZmVyQW1vdW50LnBsdXMocmVjaXBpZW50LmFtb3VudCk7XG4gICAgICB0b2tlblRyYW5zZmVyRGF0YS5wdXNoKFxuICAgICAgICB7IGFjY291bnRJRDogYnVpbGRIZWRlcmFBY2NvdW50SUQocmVjaXBpZW50LmFkZHJlc3MpLCBhbW91bnQ6IExvbmcuZnJvbVN0cmluZyhyZWNpcGllbnQuYW1vdW50KSB9IC8vIHJlY2lwaWVudFxuICAgICAgKTtcbiAgICB9KTtcbiAgICB0b2tlblRyYW5zZmVyRGF0YVswXS5hbW91bnQgPSBMb25nLmZyb21TdHJpbmcodG9rZW5UcmFuc2ZlckFtb3VudC50b1N0cmluZygpKS5uZWdhdGUoKTsgLy8gdXBkYXRlIHNlbmRlciBzZW5kIGFtb3VudFxuXG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgdG9rZW46IGJ1aWxkSGVkZXJhVG9rZW5JRCh0b2tlbklkISksXG4gICAgICAgIHRyYW5zZmVyczogdG9rZW5UcmFuc2ZlckRhdGEsXG4gICAgICB9LFxuICAgIF07XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaW5pdEJ1aWxkZXIodHg6IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgc3VwZXIuaW5pdEJ1aWxkZXIodHgpO1xuICAgIGNvbnN0IHRyYW5zZmVyRGF0YSA9IHR4LnR4Qm9keS5jcnlwdG9UcmFuc2ZlciE7XG4gICAgaWYgKGlzVG9rZW5UcmFuc2Zlcih0cmFuc2ZlckRhdGEpKSB7XG4gICAgICB0aGlzLmluaXRUb2tlblRyYW5zZmVycyh0cmFuc2ZlckRhdGEudG9rZW5UcmFuc2ZlcnMhKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgdHJhbnNmZXIgc3BlY2lmaWMgZGF0YSwgZ2V0dGluZyB0aGUgcmVjaXBpZW50IGFjY291bnRcbiAgICogcmVwcmVzZW50ZWQgYnkgdGhlIGVsZW1lbnQgd2l0aCBhIHBvc2l0aXZlIGFtb3VudCBvbiB0aGUgdHJhbnNmZXIgZWxlbWVudC5cbiAgICogVGhlIG5lZ2F0aXZlIGFtb3VudCByZXByZXNlbnRzIHRoZSBzb3VyY2UgYWNjb3VudCBzbyBpdCdzIGlnbm9yZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7cHJvdG8uSUFjY291bnRBbW91bnRbXX0gdHJhbnNmZXJzIGFycmF5IG9mIG9iamVjdHMgd2hpY2ggY29udGFpbnMgYWNjb3VudElEIGFuZCB0cmFuc2ZlcnJlZCBhbW91bnRcbiAgICovXG4gIHByb3RlY3RlZCBpbml0VG9rZW5UcmFuc2ZlcnModG9rZW5UcmFuc2ZlcnM6IHByb3RvLklUb2tlblRyYW5zZmVyTGlzdFtdKTogdm9pZCB7XG4gICAgdG9rZW5UcmFuc2ZlcnMuZm9yRWFjaCgodG9rZW5UcmFuc2ZlcjogcHJvdG8uSVRva2VuVHJhbnNmZXJMaXN0KSA9PiB7XG4gICAgICBpZiAoIXRva2VuVHJhbnNmZXIudG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogbWlzc2luZyB0b2tlbiBpZCcpO1xuICAgICAgfVxuICAgICAgaWYgKCF0b2tlblRyYW5zZmVyLnRyYW5zZmVycykge1xuICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIHRyYW5zZmVyIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdG9rZW4gPSBnZXRIZWRlcmFUb2tlbk5hbWVGcm9tSWQoc3RyaW5naWZ5VG9rZW5JZCh0b2tlblRyYW5zZmVyLnRva2VuISkpO1xuICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBpbnZhbGlkIHRva2VuIGlkJyk7XG4gICAgICB9XG4gICAgICB0b2tlblRyYW5zZmVyLnRyYW5zZmVycy5mb3JFYWNoKCh0cmFuc2ZlckRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gTG9uZy5mcm9tVmFsdWUodHJhbnNmZXJEYXRhLmFtb3VudCEpO1xuICAgICAgICBpZiAoYW1vdW50LmlzUG9zaXRpdmUoKSkge1xuICAgICAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBzdHJpbmdpZnlBY2NvdW50SWQodHJhbnNmZXJEYXRhLmFjY291bnRJRCEpLFxuICAgICAgICAgICAgYW1vdW50OiBhbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHRva2VuTmFtZTogdG9rZW4ubmFtZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyByZWdpb24gVHJhbnNmZXIgZmllbGRzXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBzZW5kKHJlY2lwaWVudDogUmVjaXBpZW50KTogdGhpcyB7XG4gICAgaWYgKCFyZWNpcGllbnQudG9rZW5OYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtZXRlclZhbHVlRXJyb3IoJ0ludmFsaWQgbWlzc2luZyB0b2tlbiBuYW1lJyk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuSWQgPSBnZXRIZWRlcmFUb2tlbklkRnJvbU5hbWUocmVjaXBpZW50LnRva2VuTmFtZSk7XG4gICAgaWYgKCF0b2tlbklkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtZXRlclZhbHVlRXJyb3IoYEludmFsaWQgdG9rZW4gbmFtZTogJHtyZWNpcGllbnQudG9rZW5OYW1lfWApO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdG9rZW5OYW1lICYmIHRoaXMuX3Rva2VuTmFtZSAhPT0gcmVjaXBpZW50LnRva2VuTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbWV0ZXJWYWx1ZUVycm9yKGBJbnZhbGlkIHRva2VuOiByZWNlaXZlZCAke3JlY2lwaWVudC50b2tlbk5hbWV9IGZvciAke3RoaXMuX3Rva2VuTmFtZX0gdHhgKTtcbiAgICB9XG4gICAgdGhpcy5fdG9rZW5OYW1lID0gcmVjaXBpZW50LnRva2VuTmFtZTtcbiAgICByZXR1cm4gc3VwZXIuc2VuZChyZWNpcGllbnQpO1xuICB9XG4gIC8vIGVuZHJlZ2lvblxufVxuIl19