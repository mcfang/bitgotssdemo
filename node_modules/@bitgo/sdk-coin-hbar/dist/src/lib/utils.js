"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTokenTransfer = exports.getHederaTokenNameFromId = exports.getHederaTokenIdFromName = exports.isValidHederaTokenID = exports.buildHederaAccountID = exports.buildHederaTokenID = exports.isValidAddressWithPaymentId = exports.normalizeAddress = exports.getAddressDetails = exports.getBaseAddress = exports.isSameBaseAddress = exports.convertFromStellarPub = exports.createRawKey = exports.isValidMemo = exports.removePrefix = exports.stringifyTxTime = exports.stringifyTokenId = exports.stringifyAccountId = exports.isValidRawTransactionFormat = exports.isValidAmount = exports.isValidTimeString = exports.getCurrentTime = exports.isNodeEnvironment = exports.isValidPublicKey = exports.isValidTransactionId = exports.isValidAddress = exports.toUint8Array = exports.toHex = void 0;
const _ = __importStar(require("lodash"));
const sdk_1 = require("@hashgraph/sdk");
const proto_1 = require("@hashgraph/proto");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const stellar = __importStar(require("stellar-sdk"));
const url_1 = __importDefault(require("url"));
const sdk_core_1 = require("@bitgo/sdk-core");
Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return sdk_core_1.toHex; } });
Object.defineProperty(exports, "toUint8Array", { enumerable: true, get: function () { return sdk_core_1.toUint8Array; } });
const statics_1 = require("@bitgo/statics");
const MAX_TINYBARS_AMOUNT = new bignumber_js_1.default(2).pow(63).minus(1);
/**
 * Returns whether the string is a valid Hedera account address
 *
 * In any form, `shard` and `realm` are assumed to be 0 if not provided.
 *
 * @param {string} address - The address to be validated
 * @returns {boolean} - The validation result
 */
function isValidAddress(address) {
    if (_.isEmpty(address) || !address.match(/^\d+(?:(?=\.)(\.\d+){2}|(?!\.))$/)) {
        return false;
    }
    try {
        const acc = sdk_1.AccountId.fromString(address);
        return !_.isNaN(acc.num);
    }
    catch (e) {
        return false;
    }
}
exports.isValidAddress = isValidAddress;
/**
 * Returns whether the string is a valid Hedera transaction id
 *
 * @param {string} txId - The transaction id to be validated
 * @returns {boolean} - The validation result
 */
function isValidTransactionId(txId) {
    if (_.isEmpty(txId)) {
        return false;
    }
    try {
        const tx = sdk_1.TransactionId.fromString(txId);
        if (_.isNil(tx.accountId)) {
            return false;
        }
        return !_.isNaN(tx.accountId.num);
    }
    catch (e) {
        return false;
    }
}
exports.isValidTransactionId = isValidTransactionId;
/**
 Returns whether the string is a valid Hedera public key
 *
 * @param {string} key - The public key to be validated
 * @returns {boolean} - The validation result
 */
function isValidPublicKey(key) {
    if (_.isEmpty(key)) {
        return false;
    }
    try {
        const pubKey = sdk_1.PublicKey.fromString(key.toLowerCase());
        return !_.isNaN(pubKey.toString());
    }
    catch (e) {
        return false;
    }
}
exports.isValidPublicKey = isValidPublicKey;
/**
 * Checks whether nodeJS.process exist and if a node version is defined to determine if this is an nodeJS environment
 *
 * @returns {boolean} - The validation result
 */
function isNodeEnvironment() {
    return typeof process !== 'undefined' && typeof process.versions.node !== 'undefined';
}
exports.isNodeEnvironment = isNodeEnvironment;
/**
 * Calculate the current time with nanoseconds precision
 *
 * @returns {string} - The current time in seconds
 */
function getCurrentTime() {
    if (isNodeEnvironment()) {
        const nanos = process.hrtime()[1];
        const seconds = (Date.now() * 1000000 + nanos) / 1000000000;
        return seconds.toFixed(9);
    }
    else {
        return (performance.timeOrigin + performance.now()).toFixed(9);
    }
}
exports.getCurrentTime = getCurrentTime;
/**
 * Returns whether the string is a valid timestamp
 *
 * Nanoseconds are optional and can be passed after a dot, for example: 1595374723.356981689
 *
 * @param {string} time - The timestamp to be validated
 * @returns {boolean} - The validation result
 */
function isValidTimeString(time) {
    return /^\d+(\.\d+)?$/.test(time);
}
exports.isValidTimeString = isValidTimeString;
/**
 * Returns whether the string is a valid amount number
 *
 * @param {string} amount - The string to validate
 * @returns {boolean} - The validation result
 */
function isValidAmount(amount) {
    const bigNumberAmount = new bignumber_js_1.default(amount);
    return (bigNumberAmount.isInteger() &&
        bigNumberAmount.isGreaterThanOrEqualTo(0) &&
        bigNumberAmount.isLessThanOrEqualTo(MAX_TINYBARS_AMOUNT));
}
exports.isValidAmount = isValidAmount;
/**
 * Returns whether the provided raw transaction accommodates to bitgo's preferred format
 *
 * @param {any} rawTransaction - The raw transaction to be checked
 * @returns {boolean} - The validation result
 */
function isValidRawTransactionFormat(rawTransaction) {
    const isAlphaNumeric = typeof rawTransaction === 'string' && /^[\da-fA-F]+$/.test(rawTransaction);
    const isValidBuffer = Buffer.isBuffer(rawTransaction) && !!Uint8Array.from(rawTransaction);
    return isAlphaNumeric || isValidBuffer;
}
exports.isValidRawTransactionFormat = isValidRawTransactionFormat;
/**
 * Returns a string representation of an {proto.IAccountID} object
 *
 * @param {proto.IAccountID} accountId - Account id to be cast to string
 * @returns {string} - The string representation of the {proto.IAccountID}
 */
function stringifyAccountId({ shardNum, realmNum, accountNum }) {
    return `${shardNum || 0}.${realmNum || 0}.${accountNum}`;
}
exports.stringifyAccountId = stringifyAccountId;
/**
 * Returns a string representation of an {proto.ITokenID} object
 *
 * @param {proto.ITokenID} - token id to be cast to string
 * @returns {string} - the string representation of the {proto.ITokenID}
 */
function stringifyTokenId({ shardNum, realmNum, tokenNum }) {
    return `${shardNum || 0}.${realmNum || 0}.${tokenNum}`;
}
exports.stringifyTokenId = stringifyTokenId;
/**
 * Returns a string representation of an {proto.ITimestamp} object
 *
 * @param {proto.ITimestamp} timestamp - Timestamp to be cast to string
 * @returns {string} - The string representation of the {proto.ITimestamp}
 */
function stringifyTxTime({ seconds, nanos }) {
    return `${seconds}.${nanos}`;
}
exports.stringifyTxTime = stringifyTxTime;
/**
 * Remove the specified prefix from a string only if it starts with that prefix
 *
 * @param {string} prefix - The prefix to be removed
 * @param {string} key - The original string, usually a private or public key
 * @returns {string} - The string without prefix
 */
function removePrefix(prefix, key) {
    if (key.startsWith(prefix)) {
        return key.slice(prefix.length);
    }
    return key;
}
exports.removePrefix = removePrefix;
/**
 * Check if this is a valid memo
 *
 * @param {string} memo
 * @returns {boolean}
 */
function isValidMemo(memo) {
    return !(_.isEmpty(memo) || Buffer.from(memo).length > 100);
}
exports.isValidMemo = isValidMemo;
/**
 * Uses the native hashgraph SDK function to get a raw key.
 *
 * @param {string} prv - Private key
 * @returns {PrivateKey}
 */
function createRawKey(prv) {
    return sdk_1.PrivateKey.fromString(prv);
}
exports.createRawKey = createRawKey;
/**
 * Converts a stellar public key to ed25519 hex format
 *
 * @param {string} stellarPub
 * @returns {string}
 */
function convertFromStellarPub(stellarPub) {
    if (!stellar.StrKey.isValidEd25519PublicKey(stellarPub)) {
        throw new Error('Not a valid stellar pub.');
    }
    const rawKey = stellar.StrKey.decodeEd25519PublicKey(stellarPub);
    return rawKey.toString('hex');
}
exports.convertFromStellarPub = convertFromStellarPub;
/**
 * Checks if two addresses have the same base address
 *
 * @param {String} address
 * @param {String} baseAddress
 * @returns {boolean}
 */
function isSameBaseAddress(address, baseAddress) {
    if (!isValidAddressWithPaymentId(address)) {
        throw new sdk_core_1.UtilsError(`invalid address: ${address}`);
    }
    return getBaseAddress(address) === getBaseAddress(baseAddress);
}
exports.isSameBaseAddress = isSameBaseAddress;
/**
 * Returns the base address portion of an address
 *
 * @param {String} address
 * @returns {String} - the base address
 */
function getBaseAddress(address) {
    const addressDetails = getAddressDetails(address);
    return addressDetails.address;
}
exports.getBaseAddress = getBaseAddress;
/**
 * Process address into address and memo id
 *
 * @param {string} rawAddress
 * @returns {AddressDetails} - object containing address and memo id
 */
function getAddressDetails(rawAddress) {
    const addressDetails = url_1.default.parse(rawAddress);
    const queryDetails = addressDetails.query ? new URLSearchParams(addressDetails.query) : undefined;
    const baseAddress = addressDetails.pathname;
    if (!isValidAddress(baseAddress)) {
        throw new sdk_core_1.UtilsError(`invalid address: ${rawAddress}`);
    }
    // address doesn't have a memo id or memoId is empty
    if (baseAddress === rawAddress) {
        return {
            address: rawAddress,
            memoId: undefined,
        };
    }
    if (!queryDetails || _.isNil(queryDetails.get('memoId'))) {
        // if there are more properties, the query details need to contain the memo id property
        throw new sdk_core_1.UtilsError(`invalid address with memo id: ${rawAddress}`);
    }
    const memoId = queryDetails.get('memoId');
    if (!isValidMemo(memoId)) {
        throw new sdk_core_1.UtilsError(`invalid address: '${rawAddress}', memoId is not valid`);
    }
    return {
        address: baseAddress,
        memoId,
    };
}
exports.getAddressDetails = getAddressDetails;
/**
 * Validate and return address with appended memo id
 *
 * @param {AddressDetails} addressDetails - Address which to append memo id
 * @returns {string} - Address with appended memo id
 */
function normalizeAddress({ address, memoId }) {
    if (memoId && isValidMemo(memoId)) {
        return `${address}?memoId=${memoId}`;
    }
    return address;
}
exports.normalizeAddress = normalizeAddress;
/**
 * Return boolean indicating whether input is a valid address with memo id
 *
 * @param {string} address - Address in the form <address>?memoId=<memoId>
 * @returns {boolean} - True if input is a valid address
 */
function isValidAddressWithPaymentId(address) {
    try {
        const addressDetails = getAddressDetails(address);
        return address === normalizeAddress(addressDetails);
    }
    catch (e) {
        return false;
    }
}
exports.isValidAddressWithPaymentId = isValidAddressWithPaymentId;
/**
 * Build hedera {proto.TokenID} object from token ID string
 *
 * @param {string} tokenID - The token ID to build
 * @returns {proto.TokenID} - The resulting proto TokenID object
 */
function buildHederaTokenID(tokenID) {
    const tokenData = sdk_1.TokenId.fromString(tokenID);
    return new proto_1.proto.TokenID({
        tokenNum: tokenData.num,
        realmNum: tokenData.realm,
        shardNum: tokenData.shard,
    });
}
exports.buildHederaTokenID = buildHederaTokenID;
/**
 * Build hedera {proto.AccountID} object from account ID string
 *
 * @param {string} accountID - The account ID to build
 * @returns {proto} - The resulting proto AccountID object
 */
function buildHederaAccountID(accountID) {
    const accountId = sdk_1.AccountId.fromString(accountID);
    return new proto_1.proto.AccountID({
        shardNum: accountId.shard,
        realmNum: accountId.realm,
        accountNum: accountId.num,
    });
}
exports.buildHederaAccountID = buildHederaAccountID;
/**
 * Check if Hedera token ID is valid and supported
 *
 * @param {string} tokenId - The token ID to validate
 * @returns {boolean} - True if tokenId is valid and supported
 */
function isValidHederaTokenID(tokenId) {
    const isFormatValid = !_.isEmpty(tokenId) && !!tokenId.match(/^\d+(?:(?=\.)(\.\d+){2}|(?!\.))$/);
    const isTokenSupported = getHederaTokenNameFromId(tokenId) !== undefined;
    return isFormatValid && isTokenSupported;
}
exports.isValidHederaTokenID = isValidHederaTokenID;
/**
 * Get the associated hedera token ID from token name, if supported
 *
 * @param {string} tokenName - The hedera token name
 * @returns {boolean} - The associated token ID or undefined if not supported
 */
function getHederaTokenIdFromName(tokenName) {
    if (statics_1.coins.has(tokenName)) {
        const token = statics_1.coins.get(tokenName);
        if (token.isToken && token instanceof statics_1.HederaToken) {
            return token.tokenId;
        }
    }
    return undefined;
}
exports.getHederaTokenIdFromName = getHederaTokenIdFromName;
/**
 * Get the associated hedera token from token ID, if supported
 *
 * @param tokenId - The token address
 * @returns {BaseCoin} - BaseCoin object for the matching token
 */
function getHederaTokenNameFromId(tokenId) {
    const tokensArray = statics_1.coins
        .filter((coin) => {
        return coin instanceof statics_1.HederaToken && coin.tokenId === tokenId;
    })
        .map((token) => token); // flatten coin map to array
    return tokensArray.length > 0 ? tokensArray[0] : undefined;
}
exports.getHederaTokenNameFromId = getHederaTokenNameFromId;
/**
 * Return boolean indicating whether input is a valid token transfer transaction
 *
 * @param {proto.ICryptoTransferTransactionBody | null} transferTxBody is a transfer transaction body
 * @returns {boolean} true is input is a valid token transfer transaction
 */
function isTokenTransfer(transferTxBody) {
    return !!transferTxBody && !!transferTxBody.tokenTransfers && transferTxBody.tokenTransfers.length > 0;
}
exports.isTokenTransfer = isTokenTransfer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwQ0FBNEI7QUFDNUIsd0NBQTBGO0FBQzFGLDRDQUF5QztBQUN6QyxnRUFBcUM7QUFDckMscURBQXVDO0FBRXZDLDhDQUFzQjtBQUN0Qiw4Q0FBa0U7QUFFekQsc0ZBRkEsZ0JBQUssT0FFQTtBQUFFLDZGQUZBLHVCQUFZLE9BRUE7QUFENUIsNENBQThEO0FBRzlELE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxzQkFBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFOUQ7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLGNBQWMsQ0FBQyxPQUFlO0lBQzVDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsa0NBQWtDLENBQUMsRUFBRTtRQUM1RSxPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSTtRQUNGLE1BQU0sR0FBRyxHQUFHLGVBQVMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDMUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQzFCO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0gsQ0FBQztBQVZELHdDQVVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixvQkFBb0IsQ0FBQyxJQUFZO0lBQy9DLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUNuQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSTtRQUNGLE1BQU0sRUFBRSxHQUFHLG1CQUFhLENBQUMsVUFB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RDs7Ozs7R0FLRztBQUNILFNBQWdCLHdCQUF3QixDQUFDLFNBQWlCO0lBQ3hELElBQUksZUFBSyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUN4QixNQUFNLEtBQUssR0FBRyxlQUFLLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ25DLElBQUksS0FBSyxDQUFDLE9BQU8sSUFBSSxLQUFLLFlBQVkscUJBQVcsRUFBRTtZQUNqRCxPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUM7U0FDdEI7S0FDRjtJQUVELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFURCw0REFTQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0Isd0JBQXdCLENBQUMsT0FBZTtJQUN0RCxNQUFNLFdBQVcsR0FBRyxlQUFLO1NBQ3RCLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ2YsT0FBTyxJQUFJLFlBQVkscUJBQVcsSUFBSSxJQUFJLENBQUMsT0FBTyxLQUFLLE9BQU8sQ0FBQztJQUNqRSxDQUFDLENBQUM7U0FDRCxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsNEJBQTRCO0lBRXRELE9BQU8sV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0FBQzdELENBQUM7QUFSRCw0REFRQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsZUFBZSxDQUFDLGNBQTJEO0lBQ3pGLE9BQU8sQ0FBQyxDQUFDLGNBQWMsSUFBSSxDQUFDLENBQUMsY0FBYyxDQUFDLGNBQWMsSUFBSSxjQUFjLENBQUMsY0FBYyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDekcsQ0FBQztBQUZELDBDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgQWNjb3VudElkLCBQcml2YXRlS2V5LCBQdWJsaWNLZXksIFRva2VuSWQsIFRyYW5zYWN0aW9uSWQgfSBmcm9tICdAaGFzaGdyYXBoL3Nkayc7XG5pbXBvcnQgeyBwcm90byB9IGZyb20gJ0BoYXNoZ3JhcGgvcHJvdG8nO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0ICogYXMgc3RlbGxhciBmcm9tICdzdGVsbGFyLXNkayc7XG5pbXBvcnQgeyBBZGRyZXNzRGV0YWlscyB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IHsgdG9IZXgsIHRvVWludDhBcnJheSwgVXRpbHNFcnJvciB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBCYXNlQ29pbiwgY29pbnMsIEhlZGVyYVRva2VuIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuZXhwb3J0IHsgdG9IZXgsIHRvVWludDhBcnJheSB9O1xuXG5jb25zdCBNQVhfVElOWUJBUlNfQU1PVU5UID0gbmV3IEJpZ051bWJlcigyKS5wb3coNjMpLm1pbnVzKDEpO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgSGVkZXJhIGFjY291bnQgYWRkcmVzc1xuICpcbiAqIEluIGFueSBmb3JtLCBgc2hhcmRgIGFuZCBgcmVhbG1gIGFyZSBhc3N1bWVkIHRvIGJlIDAgaWYgbm90IHByb3ZpZGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUaGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoXy5pc0VtcHR5KGFkZHJlc3MpIHx8ICFhZGRyZXNzLm1hdGNoKC9eXFxkKyg/Oig/PVxcLikoXFwuXFxkKyl7Mn18KD8hXFwuKSkkLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBhY2MgPSBBY2NvdW50SWQuZnJvbVN0cmluZyhhZGRyZXNzKTtcbiAgICByZXR1cm4gIV8uaXNOYU4oYWNjLm51bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHN0cmluZyBpcyBhIHZhbGlkIEhlZGVyYSB0cmFuc2FjdGlvbiBpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eElkIC0gVGhlIHRyYW5zYWN0aW9uIGlkIHRvIGJlIHZhbGlkYXRlZFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVHJhbnNhY3Rpb25JZCh0eElkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKF8uaXNFbXB0eSh0eElkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHR4ID0gVHJhbnNhY3Rpb25JZC5mcm9tU3RyaW5nKHR4SWQpO1xuICAgIGlmIChfLmlzTmlsKHR4LmFjY291bnRJZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICFfLmlzTmFOKHR4LmFjY291bnRJZC5udW0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuIFJldHVybnMgd2hldGhlciB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgSGVkZXJhIHB1YmxpYyBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIHB1YmxpYyBrZXkgdG8gYmUgdmFsaWRhdGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUaGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKF8uaXNFbXB0eShrZXkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcHViS2V5ID0gUHVibGljS2V5LmZyb21TdHJpbmcoa2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgIHJldHVybiAhXy5pc05hTihwdWJLZXkudG9TdHJpbmcoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBub2RlSlMucHJvY2VzcyBleGlzdCBhbmQgaWYgYSBub2RlIHZlcnNpb24gaXMgZGVmaW5lZCB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhbiBub2RlSlMgZW52aXJvbm1lbnRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUaGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZUVudmlyb25tZW50KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgY3VycmVudCB0aW1lIHdpdGggbmFub3NlY29uZHMgcHJlY2lzaW9uXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgY3VycmVudCB0aW1lIGluIHNlY29uZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRUaW1lKCk6IHN0cmluZyB7XG4gIGlmIChpc05vZGVFbnZpcm9ubWVudCgpKSB7XG4gICAgY29uc3QgbmFub3MgPSBwcm9jZXNzLmhydGltZSgpWzFdO1xuICAgIGNvbnN0IHNlY29uZHMgPSAoRGF0ZS5ub3coKSAqIDEwMDAwMDAgKyBuYW5vcykgLyAxMDAwMDAwMDAwO1xuICAgIHJldHVybiBzZWNvbmRzLnRvRml4ZWQoOSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgcGVyZm9ybWFuY2Uubm93KCkpLnRvRml4ZWQoOSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHN0cmluZyBpcyBhIHZhbGlkIHRpbWVzdGFtcFxuICpcbiAqIE5hbm9zZWNvbmRzIGFyZSBvcHRpb25hbCBhbmQgY2FuIGJlIHBhc3NlZCBhZnRlciBhIGRvdCwgZm9yIGV4YW1wbGU6IDE1OTUzNzQ3MjMuMzU2OTgxNjg5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbWUgLSBUaGUgdGltZXN0YW1wIHRvIGJlIHZhbGlkYXRlZFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVGltZVN0cmluZyh0aW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9eXFxkKyhcXC5cXGQrKT8kLy50ZXN0KHRpbWUpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgYW1vdW50IG51bWJlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnQgLSBUaGUgc3RyaW5nIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUaGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBbW91bnQoYW1vdW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgYmlnTnVtYmVyQW1vdW50ID0gbmV3IEJpZ051bWJlcihhbW91bnQpO1xuICByZXR1cm4gKFxuICAgIGJpZ051bWJlckFtb3VudC5pc0ludGVnZXIoKSAmJlxuICAgIGJpZ051bWJlckFtb3VudC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvKDApICYmXG4gICAgYmlnTnVtYmVyQW1vdW50LmlzTGVzc1RoYW5PckVxdWFsVG8oTUFYX1RJTllCQVJTX0FNT1VOVClcbiAgKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHJhdyB0cmFuc2FjdGlvbiBhY2NvbW1vZGF0ZXMgdG8gYml0Z28ncyBwcmVmZXJyZWQgZm9ybWF0XG4gKlxuICogQHBhcmFtIHthbnl9IHJhd1RyYW5zYWN0aW9uIC0gVGhlIHJhdyB0cmFuc2FjdGlvbiB0byBiZSBjaGVja2VkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUaGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRSYXdUcmFuc2FjdGlvbkZvcm1hdChyYXdUcmFuc2FjdGlvbjogYW55KTogYm9vbGVhbiB7XG4gIGNvbnN0IGlzQWxwaGFOdW1lcmljID0gdHlwZW9mIHJhd1RyYW5zYWN0aW9uID09PSAnc3RyaW5nJyAmJiAvXltcXGRhLWZBLUZdKyQvLnRlc3QocmF3VHJhbnNhY3Rpb24pO1xuICBjb25zdCBpc1ZhbGlkQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKHJhd1RyYW5zYWN0aW9uKSAmJiAhIVVpbnQ4QXJyYXkuZnJvbShyYXdUcmFuc2FjdGlvbik7XG5cbiAgcmV0dXJuIGlzQWxwaGFOdW1lcmljIHx8IGlzVmFsaWRCdWZmZXI7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiB7cHJvdG8uSUFjY291bnRJRH0gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtwcm90by5JQWNjb3VudElEfSBhY2NvdW50SWQgLSBBY2NvdW50IGlkIHRvIGJlIGNhc3QgdG8gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtwcm90by5JQWNjb3VudElEfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5QWNjb3VudElkKHsgc2hhcmROdW0sIHJlYWxtTnVtLCBhY2NvdW50TnVtIH06IHByb3RvLklBY2NvdW50SUQpOiBzdHJpbmcge1xuICByZXR1cm4gYCR7c2hhcmROdW0gfHwgMH0uJHtyZWFsbU51bSB8fCAwfS4ke2FjY291bnROdW19YDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHtwcm90by5JVG9rZW5JRH0gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtwcm90by5JVG9rZW5JRH0gLSB0b2tlbiBpZCB0byBiZSBjYXN0IHRvIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7cHJvdG8uSVRva2VuSUR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlUb2tlbklkKHsgc2hhcmROdW0sIHJlYWxtTnVtLCB0b2tlbk51bSB9OiBwcm90by5JVG9rZW5JRCk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtzaGFyZE51bSB8fCAwfS4ke3JlYWxtTnVtIHx8IDB9LiR7dG9rZW5OdW19YDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIHtwcm90by5JVGltZXN0YW1wfSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge3Byb3RvLklUaW1lc3RhbXB9IHRpbWVzdGFtcCAtIFRpbWVzdGFtcCB0byBiZSBjYXN0IHRvIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB7cHJvdG8uSVRpbWVzdGFtcH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeVR4VGltZSh7IHNlY29uZHMsIG5hbm9zIH06IHByb3RvLklUaW1lc3RhbXApOiBzdHJpbmcge1xuICByZXR1cm4gYCR7c2Vjb25kc30uJHtuYW5vc31gO1xufVxuXG4vKipcbiAqIFJlbW92ZSB0aGUgc3BlY2lmaWVkIHByZWZpeCBmcm9tIGEgc3RyaW5nIG9ubHkgaWYgaXQgc3RhcnRzIHdpdGggdGhhdCBwcmVmaXhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IC0gVGhlIHByZWZpeCB0byBiZSByZW1vdmVkXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIG9yaWdpbmFsIHN0cmluZywgdXN1YWxseSBhIHByaXZhdGUgb3IgcHVibGljIGtleVxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgc3RyaW5nIHdpdGhvdXQgcHJlZml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVQcmVmaXgocHJlZml4OiBzdHJpbmcsIGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKGtleS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICByZXR1cm4ga2V5LnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBpcyBhIHZhbGlkIG1lbW9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVtb1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTWVtbyhtZW1vOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuICEoXy5pc0VtcHR5KG1lbW8pIHx8IEJ1ZmZlci5mcm9tKG1lbW8pLmxlbmd0aCA+IDEwMCk7XG59XG5cbi8qKlxuICogVXNlcyB0aGUgbmF0aXZlIGhhc2hncmFwaCBTREsgZnVuY3Rpb24gdG8gZ2V0IGEgcmF3IGtleS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJ2IC0gUHJpdmF0ZSBrZXlcbiAqIEByZXR1cm5zIHtQcml2YXRlS2V5fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmF3S2V5KHBydjogc3RyaW5nKTogUHJpdmF0ZUtleSB7XG4gIHJldHVybiBQcml2YXRlS2V5LmZyb21TdHJpbmcocHJ2KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0ZWxsYXIgcHVibGljIGtleSB0byBlZDI1NTE5IGhleCBmb3JtYXRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RlbGxhclB1YlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRGcm9tU3RlbGxhclB1YihzdGVsbGFyUHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIXN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KHN0ZWxsYXJQdWIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBzdGVsbGFyIHB1Yi4nKTtcbiAgfVxuXG4gIGNvbnN0IHJhd0tleTogQnVmZmVyID0gc3RlbGxhci5TdHJLZXkuZGVjb2RlRWQyNTUxOVB1YmxpY0tleShzdGVsbGFyUHViKTtcbiAgcmV0dXJuIHJhd0tleS50b1N0cmluZygnaGV4Jyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBhZGRyZXNzZXMgaGF2ZSB0aGUgc2FtZSBiYXNlIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGJhc2VBZGRyZXNzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2FtZUJhc2VBZGRyZXNzKGFkZHJlc3M6IHN0cmluZywgYmFzZUFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoIWlzVmFsaWRBZGRyZXNzV2l0aFBheW1lbnRJZChhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgfVxuICByZXR1cm4gZ2V0QmFzZUFkZHJlc3MoYWRkcmVzcykgPT09IGdldEJhc2VBZGRyZXNzKGJhc2VBZGRyZXNzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIGFkZHJlc3MgcG9ydGlvbiBvZiBhbiBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdGhlIGJhc2UgYWRkcmVzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZUFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgcmV0dXJuIGFkZHJlc3NEZXRhaWxzLmFkZHJlc3M7XG59XG5cbi8qKlxuICogUHJvY2VzcyBhZGRyZXNzIGludG8gYWRkcmVzcyBhbmQgbWVtbyBpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByYXdBZGRyZXNzXG4gKiBAcmV0dXJucyB7QWRkcmVzc0RldGFpbHN9IC0gb2JqZWN0IGNvbnRhaW5pbmcgYWRkcmVzcyBhbmQgbWVtbyBpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzc0RldGFpbHMocmF3QWRkcmVzczogc3RyaW5nKTogQWRkcmVzc0RldGFpbHMge1xuICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IHVybC5wYXJzZShyYXdBZGRyZXNzKTtcbiAgY29uc3QgcXVlcnlEZXRhaWxzID0gYWRkcmVzc0RldGFpbHMucXVlcnkgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKGFkZHJlc3NEZXRhaWxzLnF1ZXJ5KSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgYmFzZUFkZHJlc3MgPSBhZGRyZXNzRGV0YWlscy5wYXRobmFtZSBhcyBzdHJpbmc7XG4gIGlmICghaXNWYWxpZEFkZHJlc3MoYmFzZUFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHtyYXdBZGRyZXNzfWApO1xuICB9XG5cbiAgLy8gYWRkcmVzcyBkb2Vzbid0IGhhdmUgYSBtZW1vIGlkIG9yIG1lbW9JZCBpcyBlbXB0eVxuICBpZiAoYmFzZUFkZHJlc3MgPT09IHJhd0FkZHJlc3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogcmF3QWRkcmVzcyxcbiAgICAgIG1lbW9JZDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICBpZiAoIXF1ZXJ5RGV0YWlscyB8fCBfLmlzTmlsKHF1ZXJ5RGV0YWlscy5nZXQoJ21lbW9JZCcpKSkge1xuICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIHByb3BlcnRpZXMsIHRoZSBxdWVyeSBkZXRhaWxzIG5lZWQgdG8gY29udGFpbiB0aGUgbWVtbyBpZCBwcm9wZXJ0eVxuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3Mgd2l0aCBtZW1vIGlkOiAke3Jhd0FkZHJlc3N9YCk7XG4gIH1cbiAgY29uc3QgbWVtb0lkID0gcXVlcnlEZXRhaWxzLmdldCgnbWVtb0lkJykgYXMgc3RyaW5nO1xuICBpZiAoIWlzVmFsaWRNZW1vKG1lbW9JZCkpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAnJHtyYXdBZGRyZXNzfScsIG1lbW9JZCBpcyBub3QgdmFsaWRgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRkcmVzczogYmFzZUFkZHJlc3MsXG4gICAgbWVtb0lkLFxuICB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGFuZCByZXR1cm4gYWRkcmVzcyB3aXRoIGFwcGVuZGVkIG1lbW8gaWRcbiAqXG4gKiBAcGFyYW0ge0FkZHJlc3NEZXRhaWxzfSBhZGRyZXNzRGV0YWlscyAtIEFkZHJlc3Mgd2hpY2ggdG8gYXBwZW5kIG1lbW8gaWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gQWRkcmVzcyB3aXRoIGFwcGVuZGVkIG1lbW8gaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUFkZHJlc3MoeyBhZGRyZXNzLCBtZW1vSWQgfTogQWRkcmVzc0RldGFpbHMpOiBzdHJpbmcge1xuICBpZiAobWVtb0lkICYmIGlzVmFsaWRNZW1vKG1lbW9JZCkpIHtcbiAgICByZXR1cm4gYCR7YWRkcmVzc30/bWVtb0lkPSR7bWVtb0lkfWA7XG4gIH1cbiAgcmV0dXJuIGFkZHJlc3M7XG59XG5cbi8qKlxuICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIGEgdmFsaWQgYWRkcmVzcyB3aXRoIG1lbW8gaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEFkZHJlc3MgaW4gdGhlIGZvcm0gPGFkZHJlc3M+P21lbW9JZD08bWVtb0lkPlxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiBpbnB1dCBpcyBhIHZhbGlkIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzV2l0aFBheW1lbnRJZChhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IGdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgIHJldHVybiBhZGRyZXNzID09PSBub3JtYWxpemVBZGRyZXNzKGFkZHJlc3NEZXRhaWxzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGhlZGVyYSB7cHJvdG8uVG9rZW5JRH0gb2JqZWN0IGZyb20gdG9rZW4gSUQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuSUQgLSBUaGUgdG9rZW4gSUQgdG8gYnVpbGRcbiAqIEByZXR1cm5zIHtwcm90by5Ub2tlbklEfSAtIFRoZSByZXN1bHRpbmcgcHJvdG8gVG9rZW5JRCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkSGVkZXJhVG9rZW5JRCh0b2tlbklEOiBzdHJpbmcpOiBwcm90by5Ub2tlbklEIHtcbiAgY29uc3QgdG9rZW5EYXRhID0gVG9rZW5JZC5mcm9tU3RyaW5nKHRva2VuSUQpO1xuICByZXR1cm4gbmV3IHByb3RvLlRva2VuSUQoe1xuICAgIHRva2VuTnVtOiB0b2tlbkRhdGEubnVtLFxuICAgIHJlYWxtTnVtOiB0b2tlbkRhdGEucmVhbG0sXG4gICAgc2hhcmROdW06IHRva2VuRGF0YS5zaGFyZCxcbiAgfSk7XG59XG5cbi8qKlxuICogQnVpbGQgaGVkZXJhIHtwcm90by5BY2NvdW50SUR9IG9iamVjdCBmcm9tIGFjY291bnQgSUQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJRCAtIFRoZSBhY2NvdW50IElEIHRvIGJ1aWxkXG4gKiBAcmV0dXJucyB7cHJvdG99IC0gVGhlIHJlc3VsdGluZyBwcm90byBBY2NvdW50SUQgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEhlZGVyYUFjY291bnRJRChhY2NvdW50SUQ6IHN0cmluZyk6IHByb3RvLkFjY291bnRJRCB7XG4gIGNvbnN0IGFjY291bnRJZCA9IEFjY291bnRJZC5mcm9tU3RyaW5nKGFjY291bnRJRCk7XG4gIHJldHVybiBuZXcgcHJvdG8uQWNjb3VudElEKHtcbiAgICBzaGFyZE51bTogYWNjb3VudElkLnNoYXJkLFxuICAgIHJlYWxtTnVtOiBhY2NvdW50SWQucmVhbG0sXG4gICAgYWNjb3VudE51bTogYWNjb3VudElkLm51bSxcbiAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgSGVkZXJhIHRva2VuIElEIGlzIHZhbGlkIGFuZCBzdXBwb3J0ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5JZCAtIFRoZSB0b2tlbiBJRCB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0b2tlbklkIGlzIHZhbGlkIGFuZCBzdXBwb3J0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRIZWRlcmFUb2tlbklEKHRva2VuSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBpc0Zvcm1hdFZhbGlkID0gIV8uaXNFbXB0eSh0b2tlbklkKSAmJiAhIXRva2VuSWQubWF0Y2goL15cXGQrKD86KD89XFwuKShcXC5cXGQrKXsyfXwoPyFcXC4pKSQvKTtcbiAgY29uc3QgaXNUb2tlblN1cHBvcnRlZCA9IGdldEhlZGVyYVRva2VuTmFtZUZyb21JZCh0b2tlbklkKSAhPT0gdW5kZWZpbmVkO1xuXG4gIHJldHVybiBpc0Zvcm1hdFZhbGlkICYmIGlzVG9rZW5TdXBwb3J0ZWQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhc3NvY2lhdGVkIGhlZGVyYSB0b2tlbiBJRCBmcm9tIHRva2VuIG5hbWUsIGlmIHN1cHBvcnRlZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbk5hbWUgLSBUaGUgaGVkZXJhIHRva2VuIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRoZSBhc3NvY2lhdGVkIHRva2VuIElEIG9yIHVuZGVmaW5lZCBpZiBub3Qgc3VwcG9ydGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWRlcmFUb2tlbklkRnJvbU5hbWUodG9rZW5OYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoY29pbnMuaGFzKHRva2VuTmFtZSkpIHtcbiAgICBjb25zdCB0b2tlbiA9IGNvaW5zLmdldCh0b2tlbk5hbWUpO1xuICAgIGlmICh0b2tlbi5pc1Rva2VuICYmIHRva2VuIGluc3RhbmNlb2YgSGVkZXJhVG9rZW4pIHtcbiAgICAgIHJldHVybiB0b2tlbi50b2tlbklkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhc3NvY2lhdGVkIGhlZGVyYSB0b2tlbiBmcm9tIHRva2VuIElELCBpZiBzdXBwb3J0ZWRcbiAqXG4gKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSB0b2tlbiBhZGRyZXNzXG4gKiBAcmV0dXJucyB7QmFzZUNvaW59IC0gQmFzZUNvaW4gb2JqZWN0IGZvciB0aGUgbWF0Y2hpbmcgdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhlZGVyYVRva2VuTmFtZUZyb21JZCh0b2tlbklkOiBzdHJpbmcpOiBSZWFkb25seTxCYXNlQ29pbj4gfCB1bmRlZmluZWQge1xuICBjb25zdCB0b2tlbnNBcnJheSA9IGNvaW5zXG4gICAgLmZpbHRlcigoY29pbikgPT4ge1xuICAgICAgcmV0dXJuIGNvaW4gaW5zdGFuY2VvZiBIZWRlcmFUb2tlbiAmJiBjb2luLnRva2VuSWQgPT09IHRva2VuSWQ7XG4gICAgfSlcbiAgICAubWFwKCh0b2tlbikgPT4gdG9rZW4pOyAvLyBmbGF0dGVuIGNvaW4gbWFwIHRvIGFycmF5XG5cbiAgcmV0dXJuIHRva2Vuc0FycmF5Lmxlbmd0aCA+IDAgPyB0b2tlbnNBcnJheVswXSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgYSB2YWxpZCB0b2tlbiB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICpcbiAqIEBwYXJhbSB7cHJvdG8uSUNyeXB0b1RyYW5zZmVyVHJhbnNhY3Rpb25Cb2R5IHwgbnVsbH0gdHJhbnNmZXJUeEJvZHkgaXMgYSB0cmFuc2ZlciB0cmFuc2FjdGlvbiBib2R5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBpbnB1dCBpcyBhIHZhbGlkIHRva2VuIHRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Rva2VuVHJhbnNmZXIodHJhbnNmZXJUeEJvZHk6IHByb3RvLklDcnlwdG9UcmFuc2ZlclRyYW5zYWN0aW9uQm9keSB8IG51bGwpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhdHJhbnNmZXJUeEJvZHkgJiYgISF0cmFuc2ZlclR4Qm9keS50b2tlblRyYW5zZmVycyAmJiB0cmFuc2ZlclR4Qm9keS50b2tlblRyYW5zZmVycy5sZW5ndGggPiAwO1xufVxuIl19