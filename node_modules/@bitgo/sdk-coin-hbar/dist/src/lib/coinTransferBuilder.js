"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinTransferBuilder = void 0;
const Long = __importStar(require("long"));
const sdk_core_1 = require("@bitgo/sdk-core");
const transferBuilder_1 = require("./transferBuilder");
const utils_1 = require("./utils");
const bignumber_js_1 = require("bignumber.js");
class CoinTransferBuilder extends transferBuilder_1.TransferBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    /** @inheritdoc */
    async buildImplementation() {
        this._txBodyData.transfers = this.buildTransferData();
        return await super.buildImplementation();
    }
    buildTransferData() {
        let totalSend = new bignumber_js_1.BigNumber(0);
        const accountAmounts = [
            {
                accountID: utils_1.buildHederaAccountID(this._source.address),
                amount: Long.fromInt(0),
            }, // sender
        ];
        // add recipients and update send amount
        this._recipients.forEach((recipient) => {
            accountAmounts.push({ accountID: utils_1.buildHederaAccountID(recipient.address), amount: Long.fromString(recipient.amount) } // recipient
            );
            totalSend = totalSend.plus(recipient.amount);
        });
        accountAmounts[0].amount = Long.fromString(totalSend.toString()).negate(); // update sender send amount
        return {
            accountAmounts: accountAmounts,
        };
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        const transferData = tx.txBody.cryptoTransfer;
        if (transferData && transferData.transfers && transferData.transfers.accountAmounts) {
            this.initTransfers(transferData.transfers.accountAmounts);
        }
    }
    /**
     * Initialize the transfer specific data, getting the recipient account
     * represented by the element with a positive amount on the transfer element.
     * The negative amount represents the source account, so it's ignored.
     *
     * @param {proto} transfers - Array of objects which contains accountID and transferred amount
     */
    initTransfers(transfers) {
        transfers.forEach((transferData) => {
            const amount = Long.fromValue(transferData.amount);
            if (amount.isPositive()) {
                this.send({
                    address: utils_1.stringifyAccountId(transferData.accountID),
                    amount: amount.toString(),
                });
            }
        });
    }
    // region Transfer fields
    // Currently works for one recipient by using exatcly one of to + amount or send function
    /**
     * @deprecated - Use the send method instead
     *
     * Set the destination address where the funds will be sent,
     * it may take the format `'<shard>.<realm>.<account>'` or `'<account>'`
     *
     * @param {string} address - The address to transfer funds to
     * @returns {TransferBuilder} - The builder with the new parameter set
     */
    to(address) {
        if (this._recipients.length > 0) {
            throw new sdk_core_1.DuplicateMethodError('Invalid method: send already used');
        }
        if (!utils_1.isValidAddress(address)) {
            throw new sdk_core_1.InvalidParameterValueError('Invalid address');
        }
        this._toAddress = address;
        return this;
    }
    /**
     * @deprecated - Use the send method instead
     *
     * Set the amount to be transferred
     *
     * @param {string} amount - Amount to transfer in tinyBars (there are 100,000,000 tinyBars in one Hbar)
     * @returns {TransferBuilder} - The builder with the new parameter set
     */
    amount(amount) {
        if (this._recipients.length > 0) {
            throw new sdk_core_1.DuplicateMethodError('Invalid method: send already used');
        }
        if (!utils_1.isValidAmount(amount)) {
            throw new sdk_core_1.InvalidParameterValueError('Invalid amount');
        }
        this._amount = amount;
        return this;
    }
    /** @inheritdoc */
    send(recipient) {
        if (this._amount || this._toAddress) {
            throw new sdk_core_1.DuplicateMethodError('Invalid method: to or amount already used');
        }
        if (recipient.tokenName) {
            throw new sdk_core_1.InvalidParameterValueError('Invalid token name must be empty');
        }
        return super.send(recipient);
    }
    // endregion
    // region Validators
    /** @inheritdoc */
    validateMandatoryFields() {
        if (this._toAddress && this._amount) {
            this._recipients.push({
                address: this._toAddress,
                amount: this._amount,
            });
        }
        super.validateMandatoryFields();
    }
}
exports.CoinTransferBuilder = CoinTransferBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29pblRyYW5zZmVyQnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvY29pblRyYW5zZmVyQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsMkNBQTZCO0FBRTdCLDhDQUFtRjtBQUVuRix1REFBb0Q7QUFFcEQsbUNBQWtHO0FBQ2xHLCtDQUF5QztBQUV6QyxNQUFhLG1CQUFvQixTQUFRLGlDQUFlO0lBTXRELFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxrQkFBa0I7SUFDUixLQUFLLENBQUMsbUJBQW1CO1FBQ2pDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3RELE9BQU8sTUFBTSxLQUFLLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztJQUMzQyxDQUFDO0lBRU8saUJBQWlCO1FBQ3ZCLElBQUksU0FBUyxHQUFHLElBQUksd0JBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQyxNQUFNLGNBQWMsR0FBMkI7WUFDN0M7Z0JBQ0UsU0FBUyxFQUFFLDRCQUFvQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO2dCQUNyRCxNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7YUFDeEIsRUFBRSxTQUFTO1NBQ2IsQ0FBQztRQUNGLHdDQUF3QztRQUN4QyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFO1lBQ3JDLGNBQWMsQ0FBQyxJQUFJLENBQ2pCLEVBQUUsU0FBUyxFQUFFLDRCQUFvQixDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxZQUFZO2FB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a0JBQWtCO0lBQ2xCLHVCQUF1QjtRQUNyQixJQUFJLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNuQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztnQkFDcEIsT0FBTyxFQUFFLElBQUksQ0FBQyxVQUFVO2dCQUN4QixNQUFNLEVBQUUsSUFBSSxDQUFDLE9BQU87YUFDckIsQ0FBQyxDQUFDO1NBQ0o7UUFDRCxLQUFLLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0NBRUY7QUFwSUQsa0RBb0lDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCAqIGFzIExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgeyBwcm90byB9IGZyb20gJ0BoYXNoZ3JhcGgvcHJvdG8nO1xuaW1wb3J0IHsgRHVwbGljYXRlTWV0aG9kRXJyb3IsIEludmFsaWRQYXJhbWV0ZXJWYWx1ZUVycm9yIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IFJlY2lwaWVudCB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgVHJhbnNmZXJCdWlsZGVyIH0gZnJvbSAnLi90cmFuc2ZlckJ1aWxkZXInO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGlzVmFsaWRBZGRyZXNzLCBpc1ZhbGlkQW1vdW50LCBzdHJpbmdpZnlBY2NvdW50SWQsIGJ1aWxkSGVkZXJhQWNjb3VudElEIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5leHBvcnQgY2xhc3MgQ29pblRyYW5zZmVyQnVpbGRlciBleHRlbmRzIFRyYW5zZmVyQnVpbGRlciB7XG4gIC8vIEBkZXByZWNhdGVkIFVzZSBfcmVjaXBpZW50cyBmaWVsZCBpbnN0ZWFkXG4gIHByaXZhdGUgX3RvQWRkcmVzczogc3RyaW5nO1xuICAvLyBAZGVwcmVjYXRlZCBVc2UgX3JlY2lwaWVudHMgZmllbGQgaW5zdGVhZFxuICBwcml2YXRlIF9hbW91bnQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIHRoaXMuX3R4Qm9keURhdGEudHJhbnNmZXJzID0gdGhpcy5idWlsZFRyYW5zZmVyRGF0YSgpO1xuICAgIHJldHVybiBhd2FpdCBzdXBlci5idWlsZEltcGxlbWVudGF0aW9uKCk7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkVHJhbnNmZXJEYXRhKCk6IHByb3RvLklUcmFuc2Zlckxpc3Qge1xuICAgIGxldCB0b3RhbFNlbmQgPSBuZXcgQmlnTnVtYmVyKDApO1xuICAgIGNvbnN0IGFjY291bnRBbW91bnRzOiBwcm90by5JQWNjb3VudEFtb3VudFtdID0gW1xuICAgICAge1xuICAgICAgICBhY2NvdW50SUQ6IGJ1aWxkSGVkZXJhQWNjb3VudElEKHRoaXMuX3NvdXJjZS5hZGRyZXNzKSxcbiAgICAgICAgYW1vdW50OiBMb25nLmZyb21JbnQoMCksXG4gICAgICB9LCAvLyBzZW5kZXJcbiAgICBdO1xuICAgIC8vIGFkZCByZWNpcGllbnRzIGFuZCB1cGRhdGUgc2VuZCBhbW91bnRcbiAgICB0aGlzLl9yZWNpcGllbnRzLmZvckVhY2goKHJlY2lwaWVudCkgPT4ge1xuICAgICAgYWNjb3VudEFtb3VudHMucHVzaChcbiAgICAgICAgeyBhY2NvdW50SUQ6IGJ1aWxkSGVkZXJhQWNjb3VudElEKHJlY2lwaWVudC5hZGRyZXNzKSwgYW1vdW50OiBMb25nLmZyb21TdHJpbmcocmVjaXBpZW50LmFtb3VudCkgfSAvLyByZWNpcGllbnRcbiAgICAgICk7XG4gICAgICB0b3RhbFNlbmQgPSB0b3RhbFNlbmQucGx1cyhyZWNpcGllbnQuYW1vdW50KTtcbiAgICB9KTtcbiAgICBhY2NvdW50QW1vdW50c1swXS5hbW91bnQgPSBMb25nLmZyb21TdHJpbmcodG90YWxTZW5kLnRvU3RyaW5nKCkpLm5lZ2F0ZSgpOyAvLyB1cGRhdGUgc2VuZGVyIHNlbmQgYW1vdW50XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudEFtb3VudHM6IGFjY291bnRBbW91bnRzLFxuICAgIH07XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaW5pdEJ1aWxkZXIodHg6IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgc3VwZXIuaW5pdEJ1aWxkZXIodHgpO1xuICAgIGNvbnN0IHRyYW5zZmVyRGF0YSA9IHR4LnR4Qm9keS5jcnlwdG9UcmFuc2ZlcjtcbiAgICBpZiAodHJhbnNmZXJEYXRhICYmIHRyYW5zZmVyRGF0YS50cmFuc2ZlcnMgJiYgdHJhbnNmZXJEYXRhLnRyYW5zZmVycy5hY2NvdW50QW1vdW50cykge1xuICAgICAgdGhpcy5pbml0VHJhbnNmZXJzKHRyYW5zZmVyRGF0YS50cmFuc2ZlcnMuYWNjb3VudEFtb3VudHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSB0cmFuc2ZlciBzcGVjaWZpYyBkYXRhLCBnZXR0aW5nIHRoZSByZWNpcGllbnQgYWNjb3VudFxuICAgKiByZXByZXNlbnRlZCBieSB0aGUgZWxlbWVudCB3aXRoIGEgcG9zaXRpdmUgYW1vdW50IG9uIHRoZSB0cmFuc2ZlciBlbGVtZW50LlxuICAgKiBUaGUgbmVnYXRpdmUgYW1vdW50IHJlcHJlc2VudHMgdGhlIHNvdXJjZSBhY2NvdW50LCBzbyBpdCdzIGlnbm9yZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7cHJvdG99IHRyYW5zZmVycyAtIEFycmF5IG9mIG9iamVjdHMgd2hpY2ggY29udGFpbnMgYWNjb3VudElEIGFuZCB0cmFuc2ZlcnJlZCBhbW91bnRcbiAgICovXG4gIHByb3RlY3RlZCBpbml0VHJhbnNmZXJzKHRyYW5zZmVyczogcHJvdG8uSUFjY291bnRBbW91bnRbXSk6IHZvaWQge1xuICAgIHRyYW5zZmVycy5mb3JFYWNoKCh0cmFuc2ZlckRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGFtb3VudCA9IExvbmcuZnJvbVZhbHVlKHRyYW5zZmVyRGF0YS5hbW91bnQhKTtcbiAgICAgIGlmIChhbW91bnQuaXNQb3NpdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgICAgYWRkcmVzczogc3RyaW5naWZ5QWNjb3VudElkKHRyYW5zZmVyRGF0YS5hY2NvdW50SUQhKSxcbiAgICAgICAgICBhbW91bnQ6IGFtb3VudC50b1N0cmluZygpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIHJlZ2lvbiBUcmFuc2ZlciBmaWVsZHNcblxuICAvLyBDdXJyZW50bHkgd29ya3MgZm9yIG9uZSByZWNpcGllbnQgYnkgdXNpbmcgZXhhdGNseSBvbmUgb2YgdG8gKyBhbW91bnQgb3Igc2VuZCBmdW5jdGlvblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgLSBVc2UgdGhlIHNlbmQgbWV0aG9kIGluc3RlYWRcbiAgICpcbiAgICogU2V0IHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzIHdoZXJlIHRoZSBmdW5kcyB3aWxsIGJlIHNlbnQsXG4gICAqIGl0IG1heSB0YWtlIHRoZSBmb3JtYXQgYCc8c2hhcmQ+LjxyZWFsbT4uPGFjY291bnQ+J2Agb3IgYCc8YWNjb3VudD4nYFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIHRyYW5zZmVyIGZ1bmRzIHRvXG4gICAqIEByZXR1cm5zIHtUcmFuc2ZlckJ1aWxkZXJ9IC0gVGhlIGJ1aWxkZXIgd2l0aCB0aGUgbmV3IHBhcmFtZXRlciBzZXRcbiAgICovXG4gIHRvKGFkZHJlc3M6IHN0cmluZyk6IHRoaXMge1xuICAgIGlmICh0aGlzLl9yZWNpcGllbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBEdXBsaWNhdGVNZXRob2RFcnJvcignSW52YWxpZCBtZXRob2Q6IHNlbmQgYWxyZWFkeSB1c2VkJyk7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1ldGVyVmFsdWVFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHRoaXMuX3RvQWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgLSBVc2UgdGhlIHNlbmQgbWV0aG9kIGluc3RlYWRcbiAgICpcbiAgICogU2V0IHRoZSBhbW91bnQgdG8gYmUgdHJhbnNmZXJyZWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIEFtb3VudCB0byB0cmFuc2ZlciBpbiB0aW55QmFycyAodGhlcmUgYXJlIDEwMCwwMDAsMDAwIHRpbnlCYXJzIGluIG9uZSBIYmFyKVxuICAgKiBAcmV0dXJucyB7VHJhbnNmZXJCdWlsZGVyfSAtIFRoZSBidWlsZGVyIHdpdGggdGhlIG5ldyBwYXJhbWV0ZXIgc2V0XG4gICAqL1xuICBhbW91bnQoYW1vdW50OiBzdHJpbmcpOiB0aGlzIHtcbiAgICBpZiAodGhpcy5fcmVjaXBpZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRHVwbGljYXRlTWV0aG9kRXJyb3IoJ0ludmFsaWQgbWV0aG9kOiBzZW5kIGFscmVhZHkgdXNlZCcpO1xuICAgIH1cbiAgICBpZiAoIWlzVmFsaWRBbW91bnQoYW1vdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbWV0ZXJWYWx1ZUVycm9yKCdJbnZhbGlkIGFtb3VudCcpO1xuICAgIH1cbiAgICB0aGlzLl9hbW91bnQgPSBhbW91bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgc2VuZChyZWNpcGllbnQ6IFJlY2lwaWVudCk6IHRoaXMge1xuICAgIGlmICh0aGlzLl9hbW91bnQgfHwgdGhpcy5fdG9BZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRHVwbGljYXRlTWV0aG9kRXJyb3IoJ0ludmFsaWQgbWV0aG9kOiB0byBvciBhbW91bnQgYWxyZWFkeSB1c2VkJyk7XG4gICAgfVxuICAgIGlmIChyZWNpcGllbnQudG9rZW5OYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtZXRlclZhbHVlRXJyb3IoJ0ludmFsaWQgdG9rZW4gbmFtZSBtdXN0IGJlIGVtcHR5Jyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zZW5kKHJlY2lwaWVudCk7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG5cbiAgLy8gcmVnaW9uIFZhbGlkYXRvcnNcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlTWFuZGF0b3J5RmllbGRzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl90b0FkZHJlc3MgJiYgdGhpcy5fYW1vdW50KSB7XG4gICAgICB0aGlzLl9yZWNpcGllbnRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzOiB0aGlzLl90b0FkZHJlc3MsXG4gICAgICAgIGFtb3VudDogdGhpcy5fYW1vdW50LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyLnZhbGlkYXRlTWFuZGF0b3J5RmllbGRzKCk7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG59XG4iXX0=