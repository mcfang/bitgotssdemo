"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stx = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const statics_1 = require("@bitgo/statics");
const _1 = require(".");
class Stx extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Stx(bitgo, staticsCoin);
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    async verifyTransaction(params) {
        // TODO: Implement when available on the SDK.
        return true;
    }
    /**
     * Check if address is valid, then make sure it matches the base address.
     *
     * @param {VerifyAddressOptions} params
     * @param {String} params.address - the address to verify
     * @param {String} params.baseAddress - the base address from the wallet
     */
    async isWalletAddress(params) {
        const { address, keychains } = params;
        if (!keychains || keychains.length !== 3) {
            throw new Error('Invalid keychains');
        }
        const pubs = keychains.map((keychain) => _1.StxLib.Utils.xpubToSTXPubkey(keychain.pub));
        const addressVersion = _1.StxLib.Utils.getAddressVersion(address);
        const baseAddress = _1.StxLib.Utils.getSTXAddressFromPubKeys(pubs, addressVersion).address;
        return _1.StxLib.Utils.isSameBaseAddress(address, baseAddress);
    }
    /**
     * Generate Stacks key pair
     *
     * @param {Buffer} seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? new _1.StxLib.KeyPair({ seed }) : new _1.StxLib.KeyPair();
        const keys = keyPair.getExtendedKeys();
        if (!keys.xprv) {
            throw new Error('Missing xprv in key generation.');
        }
        return {
            pub: keys.xpub,
            prv: keys.xprv,
        };
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {string} pub the prv to be checked
     * @returns is it valid?
     */
    isValidPub(pub) {
        try {
            return _1.StxLib.Utils.isValidPublicKey(pub);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {string} prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        try {
            return _1.StxLib.Utils.isValidPrivateKey(prv);
        }
        catch (e) {
            return false;
        }
    }
    isValidAddress(address) {
        try {
            return _1.StxLib.Utils.isValidAddressWithPaymentId(address);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Signs stacks transaction
     * @param params
     */
    async signTransaction(params) {
        const factory = new _1.StxLib.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
        const txBuilder = factory.from(params.txPrebuild.txHex);
        const prvKeys = params.prv instanceof Array ? params.prv : [params.prv];
        prvKeys.forEach((prv) => txBuilder.sign({ key: prv }));
        if (params.pubKeys)
            txBuilder.fromPubKey(params.pubKeys);
        // if (params.numberSignature) txBuilder.numberSignatures(params.numberSignature);
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid message passed to signMessage');
        }
        return {
            txHex: transaction.toBroadcastFormat(),
        };
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Explain a Stacks transaction from txHex
     * @param params
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const factory = new _1.StxLib.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
        const txBuilder = factory.from(txHex);
        if (params.publicKeys !== undefined) {
            txBuilder.fromPubKey(params.publicKeys);
            if (params.publicKeys.length === 1) {
                // definitely a single sig tx
                txBuilder.numberSignatures(1);
            }
        }
        const tx = await txBuilder.build();
        const txJson = tx.toJson();
        if (tx.type === sdk_core_1.TransactionType.Send) {
            const outputs = [
                {
                    address: txJson.payload.to,
                    amount: txJson.payload.amount,
                    memo: txJson.payload.memo,
                },
            ];
            const displayOrder = ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee', 'memo', 'type'];
            return {
                displayOrder,
                id: txJson.id,
                outputAmount: txJson.payload.amount.toString(),
                changeAmount: '0',
                outputs,
                changeOutputs: [],
                fee: txJson.fee,
                memo: txJson.payload.memo,
                type: tx.type,
            };
        }
        if (tx.type === sdk_core_1.TransactionType.ContractCall) {
            const displayOrder = [
                'id',
                'fee',
                'type',
                'contractAddress',
                'contractName',
                'contractFunction',
                'contractFunctionArgs',
            ];
            return {
                displayOrder,
                id: txJson.id,
                changeAmount: '0',
                outputAmount: '',
                outputs: [],
                changeOutputs: [],
                fee: txJson.fee,
                type: tx.type,
                contractAddress: txJson.payload.contractAddress,
                contractName: txJson.payload.contractName,
                contractFunction: txJson.payload.functionName,
                contractFunctionArgs: txJson.payload.functionArgs,
            };
        }
    }
}
exports.Stx = Stx;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3R4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3N0eC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw4Q0FTeUI7QUFDekIsNENBQWdGO0FBRWhGLHdCQUEyQjtBQUUzQixNQUFhLEdBQUksU0FBUSxtQkFBUTtJQUcvQixZQUFZLEtBQWdCLEVBQUUsV0FBdUM7UUFDbkUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWIsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFnQixFQUFFLFdBQXVDO1FBQzdFLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQUVELFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDO0lBQ3BDLENBQUM7SUFFRCxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxLQUFLLENBQUMsaUJBQWlCLENBQUMsTUFBZ0M7UUFDdEQsNkNBQTZDO1FBQzdDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxlQUFlLENBQUMsTUFBNEI7UUFDaEQsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxNQUFNLENBQUM7UUFDdEMsSUFBSSxDQUFDLFNBQVMsSUFBSSxTQUFTLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN4QyxNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDdEM7UUFDRCxNQUFNLElBQUksR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxTQUFNLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNyRixNQUFNLGNBQWMsR0FBRyxTQUFNLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9ELE1BQU0sV0FBVyxHQUFHLFNBQU0sQ0FBQyxLQUFLLENBQUMsd0JBQXdCLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztRQUN4RixPQUFPLFNBQU0sQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsT0FBTyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGVBQWUsQ0FBQyxJQUFhO1FBQzNCLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFNLENBQUMsT0FBTyxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDM0UsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRXZDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1NBQ3BEO1FBRUQsT0FBTztZQUNMLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNkLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSTtTQUNmLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxVQUFVLENBQUMsR0FBVztRQUNwQixJQUFJO1lBQ0YsT0FBTyxTQUFNLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNDO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPLEtBQUssQ0FBQztTQUNkO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsVUFBVSxDQUFDLEdBQVc7UUFDcEIsSUFBSTtZQUNGLE9BQU8sU0FBTSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM1QztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxLQUFLLENBQUM7U0FDZDtJQUNILENBQUM7SUFFRCxjQUFjLENBQUMsT0FBZTtRQUM1QixJQUFJO1lBQ0YsT0FBTyxTQUFNLENBQUMsS0FBSyxDQUFDLDJCQUEyQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzFEO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPLEtBQUssQ0FBQztTQUNkO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxlQUFlLENBQUMsTUFBaUM7UUFDckQsTUFBTSxPQUFPLEdBQUcsSUFBSSxTQUFNLENBQUMseUJBQXlCLENBQUMsZUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pGLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4RCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsR0FBRyxZQUFZLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdkQsSUFBSSxNQUFNLENBQUMsT0FBTztZQUFFLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3pELGtGQUFrRjtRQUNsRixNQUFNLFdBQVcsR0FBRyxNQUFNLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUU1QyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQztTQUMxRDtRQUVELE9BQU87WUFDTCxLQUFLLEVBQUUsV0FBVyxDQUFDLGlCQUFpQixFQUFFO1NBQ3ZDLENBQUM7SUFDSixDQUFDO0lBRUQsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQVc7UUFDaEMsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsS0FBSyxDQUFDLGtCQUFrQixDQUFDLE1BQWlDO1FBQ3hELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0UsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxTQUFNLENBQUMseUJBQXlCLENBQUMsZUFBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ2pGLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdEMsSUFBSSxNQUFNLENBQUMsVUFBVSxLQUFLLFNBQVMsRUFBRTtZQUNuQyxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUN4QyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDbEMsNkJBQTZCO2dCQUM3QixTQUFTLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDL0I7U0FDRjtRQUVELE1BQU0sRUFBRSxHQUFHLE1BQU0sU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ25DLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUUzQixJQUFJLEVBQUUsQ0FBQyxJQUFJLEtBQUssMEJBQWUsQ0FBQyxJQUFJLEVBQUU7WUFDcEMsTUFBTSxPQUFPLEdBQTJCO2dCQUN0QztvQkFDRSxPQUFPLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUMxQixNQUFNLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNO29CQUM3QixJQUFJLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJO2lCQUMxQjthQUNGLENBQUM7WUFFRixNQUFNLFlBQVksR0FBRyxDQUFDLElBQUksRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxlQUFlLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztZQUMvRyxPQUFPO2dCQUNMLFlBQVk7Z0JBQ1osRUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFO2dCQUNiLFlBQVksRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7Z0JBQzlDLFlBQVksRUFBRSxHQUFHO2dCQUNqQixPQUFPO2dCQUNQLGFBQWEsRUFBRSxFQUFFO2dCQUNqQixHQUFHLEVBQUUsTUFBTSxDQUFDLEdBQUc7Z0JBQ2YsSUFBSSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSTtnQkFDekIsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJO2FBQ2QsQ0FBQztTQUNIO1FBRUQsSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLDBCQUFlLENBQUMsWUFBWSxFQUFFO1lBQzVDLE1BQU0sWUFBWSxHQUFHO2dCQUNuQixJQUFJO2dCQUNKLEtBQUs7Z0JBQ0wsTUFBTTtnQkFDTixpQkFBaUI7Z0JBQ2pCLGNBQWM7Z0JBQ2Qsa0JBQWtCO2dCQUNsQixzQkFBc0I7YUFDdkIsQ0FBQztZQUNGLE9BQU87Z0JBQ0wsWUFBWTtnQkFDWixFQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUU7Z0JBQ2IsWUFBWSxFQUFFLEdBQUc7Z0JBQ2pCLFlBQVksRUFBRSxFQUFFO2dCQUNoQixPQUFPLEVBQUUsRUFBRTtnQkFDWCxhQUFhLEVBQUUsRUFBRTtnQkFDakIsR0FBRyxFQUFFLE1BQU0sQ0FBQyxHQUFHO2dCQUNmLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSTtnQkFDYixlQUFlLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxlQUFlO2dCQUMvQyxZQUFZLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxZQUFZO2dCQUN6QyxnQkFBZ0IsRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLFlBQVk7Z0JBQzdDLG9CQUFvQixFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsWUFBWTthQUNsRCxDQUFDO1NBQ0g7SUFDSCxDQUFDO0NBQ0Y7QUFuTkQsa0JBbU5DIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgS2V5UGFpcixcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uUmVjaXBpZW50LFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBCYXNlQ29pbiBhcyBTdGF0aWNzQmFzZUNvaW4sIENvaW5GYW1pbHksIGNvaW5zIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucywgU3R4U2lnblRyYW5zYWN0aW9uT3B0aW9ucywgU3R4VHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgU3R4TGliIH0gZnJvbSAnLic7XG5cbmV4cG9ydCBjbGFzcyBTdHggZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfc3RhdGljc0NvaW46IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgU3R4KGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgZ2V0RmFtaWx5KCk6IENvaW5GYW1pbHkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mYW1pbHk7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mdWxsTmFtZTtcbiAgfVxuXG4gIGdldEJhc2VGYWN0b3IoKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXRpY3NDb2luLmRlY2ltYWxQbGFjZXMpO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgd2hlbiBhdmFpbGFibGUgb24gdGhlIFNESy5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhZGRyZXNzIGlzIHZhbGlkLCB0aGVuIG1ha2Ugc3VyZSBpdCBtYXRjaGVzIHRoZSBiYXNlIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7VmVyaWZ5QWRkcmVzc09wdGlvbnN9IHBhcmFtc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLmFkZHJlc3MgLSB0aGUgYWRkcmVzcyB0byB2ZXJpZnlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5iYXNlQWRkcmVzcyAtIHRoZSBiYXNlIGFkZHJlc3MgZnJvbSB0aGUgd2FsbGV0XG4gICAqL1xuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHsgYWRkcmVzcywga2V5Y2hhaW5zIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFrZXljaGFpbnMgfHwga2V5Y2hhaW5zLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleWNoYWlucycpO1xuICAgIH1cbiAgICBjb25zdCBwdWJzID0ga2V5Y2hhaW5zLm1hcCgoa2V5Y2hhaW4pID0+IFN0eExpYi5VdGlscy54cHViVG9TVFhQdWJrZXkoa2V5Y2hhaW4ucHViKSk7XG4gICAgY29uc3QgYWRkcmVzc1ZlcnNpb24gPSBTdHhMaWIuVXRpbHMuZ2V0QWRkcmVzc1ZlcnNpb24oYWRkcmVzcyk7XG4gICAgY29uc3QgYmFzZUFkZHJlc3MgPSBTdHhMaWIuVXRpbHMuZ2V0U1RYQWRkcmVzc0Zyb21QdWJLZXlzKHB1YnMsIGFkZHJlc3NWZXJzaW9uKS5hZGRyZXNzO1xuICAgIHJldHVybiBTdHhMaWIuVXRpbHMuaXNTYW1lQmFzZUFkZHJlc3MoYWRkcmVzcywgYmFzZUFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIFN0YWNrcyBrZXkgcGFpclxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2VlZCAtIFNlZWQgZnJvbSB3aGljaCB0aGUgbmV3IGtleXBhaXIgc2hvdWxkIGJlIGdlbmVyYXRlZCwgb3RoZXJ3aXNlIGEgcmFuZG9tIHNlZWQgaXMgdXNlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViIGFuZCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlZWQgPyBuZXcgU3R4TGliLktleVBhaXIoeyBzZWVkIH0pIDogbmV3IFN0eExpYi5LZXlQYWlyKCk7XG4gICAgY29uc3Qga2V5cyA9IGtleVBhaXIuZ2V0RXh0ZW5kZWRLZXlzKCk7XG5cbiAgICBpZiAoIWtleXMueHBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHhwcnYgaW4ga2V5IGdlbmVyYXRpb24uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yjoga2V5cy54cHViLFxuICAgICAgcHJ2OiBrZXlzLnhwcnYsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBTdHhMaWIuVXRpbHMuaXNWYWxpZFB1YmxpY0tleShwdWIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHByaXZhdGUga2V5IGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJ2IHRoZSBwcnYgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQcnYocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFN0eExpYi5VdGlscy5pc1ZhbGlkUHJpdmF0ZUtleShwcnYpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFN0eExpYi5VdGlscy5pc1ZhbGlkQWRkcmVzc1dpdGhQYXltZW50SWQoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBzdGFja3MgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU3R4U2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBmYWN0b3J5ID0gbmV3IFN0eExpYi5UcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5KGNvaW5zLmdldCh0aGlzLmdldENoYWluKCkpKTtcbiAgICBjb25zdCB0eEJ1aWxkZXIgPSBmYWN0b3J5LmZyb20ocGFyYW1zLnR4UHJlYnVpbGQudHhIZXgpO1xuICAgIGNvbnN0IHBydktleXMgPSBwYXJhbXMucHJ2IGluc3RhbmNlb2YgQXJyYXkgPyBwYXJhbXMucHJ2IDogW3BhcmFtcy5wcnZdO1xuICAgIHBydktleXMuZm9yRWFjaCgocHJ2KSA9PiB0eEJ1aWxkZXIuc2lnbih7IGtleTogcHJ2IH0pKTtcbiAgICBpZiAocGFyYW1zLnB1YktleXMpIHR4QnVpbGRlci5mcm9tUHViS2V5KHBhcmFtcy5wdWJLZXlzKTtcbiAgICAvLyBpZiAocGFyYW1zLm51bWJlclNpZ25hdHVyZSkgdHhCdWlsZGVyLm51bWJlclNpZ25hdHVyZXMocGFyYW1zLm51bWJlclNpZ25hdHVyZSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcblxuICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlIHBhc3NlZCB0byBzaWduTWVzc2FnZScpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eEhleDogdHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKSxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gYSBTdGFja3MgdHJhbnNhY3Rpb24gZnJvbSB0eEhleFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxTdHhUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICBpZiAoIXR4SGV4IHx8ICFwYXJhbXMuZmVlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgU3R4TGliLlRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkoY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSkpO1xuICAgIGNvbnN0IHR4QnVpbGRlciA9IGZhY3RvcnkuZnJvbSh0eEhleCk7XG5cbiAgICBpZiAocGFyYW1zLnB1YmxpY0tleXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHhCdWlsZGVyLmZyb21QdWJLZXkocGFyYW1zLnB1YmxpY0tleXMpO1xuICAgICAgaWYgKHBhcmFtcy5wdWJsaWNLZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBkZWZpbml0ZWx5IGEgc2luZ2xlIHNpZyB0eFxuICAgICAgICB0eEJ1aWxkZXIubnVtYmVyU2lnbmF0dXJlcygxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGNvbnN0IHR4SnNvbiA9IHR4LnRvSnNvbigpO1xuXG4gICAgaWYgKHR4LnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5TZW5kKSB7XG4gICAgICBjb25zdCBvdXRwdXRzOiBUcmFuc2FjdGlvblJlY2lwaWVudFtdID0gW1xuICAgICAgICB7XG4gICAgICAgICAgYWRkcmVzczogdHhKc29uLnBheWxvYWQudG8sXG4gICAgICAgICAgYW1vdW50OiB0eEpzb24ucGF5bG9hZC5hbW91bnQsXG4gICAgICAgICAgbWVtbzogdHhKc29uLnBheWxvYWQubWVtbyxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGRpc3BsYXlPcmRlciA9IFsnaWQnLCAnb3V0cHV0QW1vdW50JywgJ2NoYW5nZUFtb3VudCcsICdvdXRwdXRzJywgJ2NoYW5nZU91dHB1dHMnLCAnZmVlJywgJ21lbW8nLCAndHlwZSddO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHhKc29uLmlkLFxuICAgICAgICBvdXRwdXRBbW91bnQ6IHR4SnNvbi5wYXlsb2FkLmFtb3VudC50b1N0cmluZygpLFxuICAgICAgICBjaGFuZ2VBbW91bnQ6ICcwJyxcbiAgICAgICAgb3V0cHV0cyxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICAgIGZlZTogdHhKc29uLmZlZSxcbiAgICAgICAgbWVtbzogdHhKc29uLnBheWxvYWQubWVtbyxcbiAgICAgICAgdHlwZTogdHgudHlwZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR4LnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5Db250cmFjdENhbGwpIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlPcmRlciA9IFtcbiAgICAgICAgJ2lkJyxcbiAgICAgICAgJ2ZlZScsXG4gICAgICAgICd0eXBlJyxcbiAgICAgICAgJ2NvbnRyYWN0QWRkcmVzcycsXG4gICAgICAgICdjb250cmFjdE5hbWUnLFxuICAgICAgICAnY29udHJhY3RGdW5jdGlvbicsXG4gICAgICAgICdjb250cmFjdEZ1bmN0aW9uQXJncycsXG4gICAgICBdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHhKc29uLmlkLFxuICAgICAgICBjaGFuZ2VBbW91bnQ6ICcwJyxcbiAgICAgICAgb3V0cHV0QW1vdW50OiAnJyxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgICBmZWU6IHR4SnNvbi5mZWUsXG4gICAgICAgIHR5cGU6IHR4LnR5cGUsXG4gICAgICAgIGNvbnRyYWN0QWRkcmVzczogdHhKc29uLnBheWxvYWQuY29udHJhY3RBZGRyZXNzLFxuICAgICAgICBjb250cmFjdE5hbWU6IHR4SnNvbi5wYXlsb2FkLmNvbnRyYWN0TmFtZSxcbiAgICAgICAgY29udHJhY3RGdW5jdGlvbjogdHhKc29uLnBheWxvYWQuZnVuY3Rpb25OYW1lLFxuICAgICAgICBjb250cmFjdEZ1bmN0aW9uQXJnczogdHhKc29uLnBheWxvYWQuZnVuY3Rpb25BcmdzLFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==