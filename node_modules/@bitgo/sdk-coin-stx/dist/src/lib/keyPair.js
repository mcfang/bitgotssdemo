"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
const crypto_1 = require("crypto");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const transactions_1 = require("@stacks/transactions");
const sdk_core_1 = require("@bitgo/sdk-core");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
class KeyPair extends sdk_core_1.Secp256k1ExtendedKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    constructor(source) {
        super(source);
        if (!source) {
            const seed = crypto_1.randomBytes(constants_1.DEFAULT_SEED_SIZE_BYTES);
            this.hdNode = utxo_lib_1.bip32.fromSeed(seed);
        }
        else if (sdk_core_1.isSeed(source)) {
            this.hdNode = utxo_lib_1.bip32.fromSeed(source.seed);
        }
        else if (sdk_core_1.isPrivateKey(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if (sdk_core_1.isPublicKey(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (this.hdNode) {
            this.keyPair = sdk_core_1.Secp256k1ExtendedKeyPair.toKeyPair(this.hdNode);
        }
    }
    /**
     * Build a keypair from a protocol private key or extended private key.
     *
     * The protocol private key is either 32 or 33 bytes long (64 or 66
     * characters hex).  If it is 32 bytes long, set the keypair's "compressed"
     * field to false to later generate uncompressed public keys (the default).
     * A 33 byte key has 0x01 as the last byte.
     *
     * @param {string} prv A raw private key
     */
    recordKeysFromPrivateKey(prv) {
        if (!utils_1.isValidPrivateKey(prv)) {
            throw new Error('Unsupported private key');
        }
        if (sdk_core_1.isValidXprv(prv)) {
            this.hdNode = utxo_lib_1.bip32.fromBase58(prv);
        }
        else {
            this.keyPair = utxo_lib_1.ECPair.fromPrivateKey(Buffer.from(prv.slice(0, 64), 'hex'));
        }
    }
    /**
     * Build an ECPair from a protocol public key or extended public key.
     *
     * The protocol public key is either 32 bytes or 64 bytes long, with a
     * one-byte prefix (a total of 66 or 130 characters in hex).  If the
     * prefix is 0x02 or 0x03, it is a compressed public key.  A prefix of 0x04
     * denotes an uncompressed public key.
     *
     * @param {string} pub A raw public key
     */
    recordKeysFromPublicKey(pub) {
        if (!utils_1.isValidPublicKey(pub)) {
            throw new Error('Unsupported public key');
        }
        if (sdk_core_1.isValidXpub(pub)) {
            this.hdNode = utxo_lib_1.bip32.fromBase58(pub);
        }
        else {
            this.keyPair = utxo_lib_1.ECPair.fromPublicKey(Buffer.from(pub, 'hex'));
        }
    }
    /**
     * Stacks default keys format is raw private and uncompressed public key
     *
     * @param {boolean} compressed - Compress public key (defaults to false)
     * @returns {DefaultKeys} The keys in the protocol default key format
     */
    getKeys(compressed = false) {
        var _a;
        let prv = (_a = this.getPrivateKey()) === null || _a === void 0 ? void 0 : _a.toString('hex');
        if (prv && compressed) {
            prv += '01';
        }
        return {
            pub: this.getPublicKey({ compressed }).toString('hex'),
            prv,
        };
    }
    getCompressed() {
        return this.keyPair.compressed;
    }
    /**
     * Get a public address of an uncompressed public key.
     *
     * @returns {string} The public address
     */
    getAddress() {
        return this.getSTXAddress(false, transactions_1.TransactionVersion.Mainnet);
    }
    /**
     * Get a public address of an uncompressed public key.
     *
     * @param {boolean} compressed - Compress public key (defaults to false)
     * @param {TransactionVersion} network - select Mainnet or Testnet for the address
     * @returns {string} The public address
     */
    getSTXAddress(compressed = false, network = transactions_1.TransactionVersion.Mainnet) {
        return transactions_1.getAddressFromPublicKey(this.getKeys(compressed).pub, network);
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBcUM7QUFDckMsOENBQWdEO0FBQ2hELHVEQUFtRjtBQUNuRiw4Q0FTeUI7QUFDekIsbUNBQThEO0FBQzlELDJDQUFzRDtBQUV0RCxNQUFhLE9BQVEsU0FBUSxtQ0FBd0I7SUFDbkQ7Ozs7T0FJRztJQUNILFlBQVksTUFBdUI7UUFDakMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sSUFBSSxHQUFHLG9CQUFXLENBQUMsbUNBQXVCLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BDO2FBQU0sSUFBSSxpQkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxNQUFNLEdBQUcsZ0JBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzNDO2FBQU0sSUFBSSx1QkFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0M7YUFBTSxJQUFJLHNCQUFXLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDOUIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMxQzthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO1NBQzdDO1FBRUQsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2YsSUFBSSxDQUFDLE9BQU8sR0FBRyxtQ0FBd0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2hFO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILHdCQUF3QixDQUFDLEdBQVc7UUFDbEMsSUFBSSxDQUFDLHlCQUFpQixDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztTQUM1QztRQUVELElBQUksc0JBQVcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNwQixJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3JDO2FBQU07WUFDTCxJQUFJLENBQUMsT0FBTyxHQUFHLGlCQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUM1RTtJQUNILENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCx1QkFBdUIsQ0FBQyxHQUFXO1FBQ2pDLElBQUksQ0FBQyx3QkFBZ0IsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7U0FDM0M7UUFFRCxJQUFJLHNCQUFXLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDcEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxnQkFBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNyQzthQUFNO1lBQ0wsSUFBSSxDQUFDLE9BQU8sR0FBRyxpQkFBTSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQzlEO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsT0FBTyxDQUFDLFVBQVUsR0FBRyxLQUFLOztRQUN4QixJQUFJLEdBQUcsR0FBRyxNQUFBLElBQUksQ0FBQyxhQUFhLEVBQUUsMENBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hELElBQUksR0FBRyxJQUFJLFVBQVUsRUFBRTtZQUNyQixHQUFHLElBQUksSUFBSSxDQUFDO1NBQ2I7UUFFRCxPQUFPO1lBQ0wsR0FBRyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7WUFDdEQsR0FBRztTQUNKLENBQUM7SUFDSixDQUFDO0lBRUQsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxpQ0FBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsYUFBYSxDQUFDLFVBQVUsR0FBRyxLQUFLLEVBQUUsVUFBOEIsaUNBQWtCLENBQUMsT0FBTztRQUN4RixPQUFPLHNDQUF1QixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3hFLENBQUM7Q0FDRjtBQS9HRCwwQkErR0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgeyBiaXAzMiwgRUNQYWlyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IGdldEFkZHJlc3NGcm9tUHVibGljS2V5LCBUcmFuc2FjdGlvblZlcnNpb24gfSBmcm9tICdAc3RhY2tzL3RyYW5zYWN0aW9ucyc7XG5pbXBvcnQge1xuICBEZWZhdWx0S2V5cyxcbiAgaXNQcml2YXRlS2V5LFxuICBpc1B1YmxpY0tleSxcbiAgaXNTZWVkLFxuICBpc1ZhbGlkWHBydixcbiAgaXNWYWxpZFhwdWIsXG4gIEtleVBhaXJPcHRpb25zLFxuICBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBpc1ZhbGlkUHJpdmF0ZUtleSwgaXNWYWxpZFB1YmxpY0tleSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgREVGQVVMVF9TRUVEX1NJWkVfQllURVMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBLZXlQYWlyIGV4dGVuZHMgU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyIHtcbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci4gQnkgZGVmYXVsdCwgY3JlYXRlcyBhIGtleSBwYWlyIHdpdGggYSByYW5kb20gbWFzdGVyIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7IEtleVBhaXJPcHRpb25zIH0gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5LCBvciBhIHB1YmxpYyBrZXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZT86IEtleVBhaXJPcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlKTtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgY29uc3Qgc2VlZCA9IHJhbmRvbUJ5dGVzKERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTKTtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1NlZWQoc291cmNlKSkge1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tU2VlZChzb3VyY2Uuc2VlZCk7XG4gICAgfSBlbHNlIGlmIChpc1ByaXZhdGVLZXkoc291cmNlKSkge1xuICAgICAgdGhpcy5yZWNvcmRLZXlzRnJvbVByaXZhdGVLZXkoc291cmNlLnBydik7XG4gICAgfSBlbHNlIGlmIChpc1B1YmxpY0tleShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnJlY29yZEtleXNGcm9tUHVibGljS2V5KHNvdXJjZS5wdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5IHBhaXIgb3B0aW9ucycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhkTm9kZSkge1xuICAgICAgdGhpcy5rZXlQYWlyID0gU2VjcDI1NmsxRXh0ZW5kZWRLZXlQYWlyLnRvS2V5UGFpcih0aGlzLmhkTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEga2V5cGFpciBmcm9tIGEgcHJvdG9jb2wgcHJpdmF0ZSBrZXkgb3IgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkuXG4gICAqXG4gICAqIFRoZSBwcm90b2NvbCBwcml2YXRlIGtleSBpcyBlaXRoZXIgMzIgb3IgMzMgYnl0ZXMgbG9uZyAoNjQgb3IgNjZcbiAgICogY2hhcmFjdGVycyBoZXgpLiAgSWYgaXQgaXMgMzIgYnl0ZXMgbG9uZywgc2V0IHRoZSBrZXlwYWlyJ3MgXCJjb21wcmVzc2VkXCJcbiAgICogZmllbGQgdG8gZmFsc2UgdG8gbGF0ZXIgZ2VuZXJhdGUgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlzICh0aGUgZGVmYXVsdCkuXG4gICAqIEEgMzMgYnl0ZSBrZXkgaGFzIDB4MDEgYXMgdGhlIGxhc3QgYnl0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBydiBBIHJhdyBwcml2YXRlIGtleVxuICAgKi9cbiAgcmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5KHBydjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFpc1ZhbGlkUHJpdmF0ZUtleShwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFsaWRYcHJ2KHBydikpIHtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChwcnYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSBFQ1BhaXIuZnJvbVByaXZhdGVLZXkoQnVmZmVyLmZyb20ocHJ2LnNsaWNlKDAsIDY0KSwgJ2hleCcpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYW4gRUNQYWlyIGZyb20gYSBwcm90b2NvbCBwdWJsaWMga2V5IG9yIGV4dGVuZGVkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIFRoZSBwcm90b2NvbCBwdWJsaWMga2V5IGlzIGVpdGhlciAzMiBieXRlcyBvciA2NCBieXRlcyBsb25nLCB3aXRoIGFcbiAgICogb25lLWJ5dGUgcHJlZml4IChhIHRvdGFsIG9mIDY2IG9yIDEzMCBjaGFyYWN0ZXJzIGluIGhleCkuICBJZiB0aGVcbiAgICogcHJlZml4IGlzIDB4MDIgb3IgMHgwMywgaXQgaXMgYSBjb21wcmVzc2VkIHB1YmxpYyBrZXkuICBBIHByZWZpeCBvZiAweDA0XG4gICAqIGRlbm90ZXMgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWIgQSByYXcgcHVibGljIGtleVxuICAgKi9cbiAgcmVjb3JkS2V5c0Zyb21QdWJsaWNLZXkocHViOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIWlzVmFsaWRQdWJsaWNLZXkocHViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBwdWJsaWMga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVmFsaWRYcHViKHB1YikpIHtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChwdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSBFQ1BhaXIuZnJvbVB1YmxpY0tleShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0YWNrcyBkZWZhdWx0IGtleXMgZm9ybWF0IGlzIHJhdyBwcml2YXRlIGFuZCB1bmNvbXByZXNzZWQgcHVibGljIGtleVxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWQgLSBDb21wcmVzcyBwdWJsaWMga2V5IChkZWZhdWx0cyB0byBmYWxzZSlcbiAgICogQHJldHVybnMge0RlZmF1bHRLZXlzfSBUaGUga2V5cyBpbiB0aGUgcHJvdG9jb2wgZGVmYXVsdCBrZXkgZm9ybWF0XG4gICAqL1xuICBnZXRLZXlzKGNvbXByZXNzZWQgPSBmYWxzZSk6IERlZmF1bHRLZXlzIHtcbiAgICBsZXQgcHJ2ID0gdGhpcy5nZXRQcml2YXRlS2V5KCk/LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAocHJ2ICYmIGNvbXByZXNzZWQpIHtcbiAgICAgIHBydiArPSAnMDEnO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHRoaXMuZ2V0UHVibGljS2V5KHsgY29tcHJlc3NlZCB9KS50b1N0cmluZygnaGV4JyksXG4gICAgICBwcnYsXG4gICAgfTtcbiAgfVxuXG4gIGdldENvbXByZXNzZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMua2V5UGFpci5jb21wcmVzc2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHB1YmxpYyBhZGRyZXNzIG9mIGFuIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcHVibGljIGFkZHJlc3NcbiAgICovXG4gIGdldEFkZHJlc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTVFhBZGRyZXNzKGZhbHNlLCBUcmFuc2FjdGlvblZlcnNpb24uTWFpbm5ldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcHVibGljIGFkZHJlc3Mgb2YgYW4gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZCAtIENvbXByZXNzIHB1YmxpYyBrZXkgKGRlZmF1bHRzIHRvIGZhbHNlKVxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uVmVyc2lvbn0gbmV0d29yayAtIHNlbGVjdCBNYWlubmV0IG9yIFRlc3RuZXQgZm9yIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwdWJsaWMgYWRkcmVzc1xuICAgKi9cbiAgZ2V0U1RYQWRkcmVzcyhjb21wcmVzc2VkID0gZmFsc2UsIG5ldHdvcms6IFRyYW5zYWN0aW9uVmVyc2lvbiA9IFRyYW5zYWN0aW9uVmVyc2lvbi5NYWlubmV0KTogc3RyaW5nIHtcbiAgICByZXR1cm4gZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkodGhpcy5nZXRLZXlzKGNvbXByZXNzZWQpLnB1YiwgbmV0d29yayk7XG4gIH1cbn1cbiJdfQ==