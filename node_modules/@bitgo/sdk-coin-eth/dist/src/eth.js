"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Eth = exports.optionalDeps = void 0;
/**
 * @prettier
 */
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bignumber_js_1 = require("bignumber.js");
const crypto_1 = require("crypto");
const debug_1 = __importDefault(require("debug"));
const keccak_1 = __importDefault(require("keccak"));
const lodash_1 = __importDefault(require("lodash"));
const secp256k1_1 = __importDefault(require("secp256k1"));
const superagent_1 = __importDefault(require("superagent"));
const erc20Token_1 = require("./erc20Token");
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const statics_1 = require("@bitgo/statics");
const tx_1 = require("@ethereumjs/tx");
const lib_1 = require("./lib");
const ethereumjs_util_1 = require("ethereumjs-util");
const bn_js_1 = __importDefault(require("bn.js"));
const eth_sig_util_1 = require("@metamask/eth-sig-util");
const debug = debug_1.default('bitgo:v2:eth');
exports.optionalDeps = {
    get ethAbi() {
        try {
            return require('ethereumjs-abi');
        }
        catch (e) {
            debug('unable to load ethereumjs-abi:');
            debug(e.stack);
            throw new sdk_core_1.EthereumLibraryUnavailableError(`ethereumjs-abi`);
        }
    },
    get ethUtil() {
        try {
            return require('ethereumjs-util');
        }
        catch (e) {
            debug('unable to load ethereumjs-util:');
            debug(e.stack);
            throw new sdk_core_1.EthereumLibraryUnavailableError(`ethereumjs-util`);
        }
    },
    get EthTx() {
        try {
            return require('@ethereumjs/tx');
        }
        catch (e) {
            debug('unable to load @ethereumjs/tx');
            debug(e.stack);
            throw new sdk_core_1.EthereumLibraryUnavailableError(`@ethereumjs/tx`);
        }
    },
    get EthCommon() {
        try {
            return require('@ethereumjs/common');
        }
        catch (e) {
            debug('unable to load @ethereumjs/common:');
            debug(e.stack);
            throw new sdk_core_1.EthereumLibraryUnavailableError(`@ethereumjs/common`);
        }
    },
};
class Eth extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        /**
         * Get the data required to make an ETH function call defined by the given types and values
         *
         * @param functionName The name of the function being called, e.g. transfer
         * @param types The types of the function call in order
         * @param values The values of the function call in order
         * @return {Buffer} The combined data for the function call
         */
        this.getMethodCallData = (functionName, types, values) => {
            return Buffer.concat([
                // function signature
                exports.optionalDeps.ethAbi.methodID(functionName, types),
                // function arguments
                exports.optionalDeps.ethAbi.rawEncode(types, values),
            ]);
        };
        this.staticsCoin = staticsCoin;
        this.sendMethodName = 'sendMultiSig';
    }
    static createInstance(bitgo, staticsCoin) {
        return new Eth(bitgo, staticsCoin);
    }
    /**
     * Gets correct Eth Common object based on params from either recovery or tx building
     * @param eip1559 {EIP1559} configs that specify whether we should construct an eip1559 tx
     * @param replayProtectionOptions {ReplayProtectionOptions} check if chain id supports replay protection
     */
    static getEthCommon(eip1559, replayProtectionOptions) {
        // if eip1559 params are specified, default to london hardfork, otherwise,
        // default to tangerine whistle to avoid replay protection issues
        const defaultHardfork = !!eip1559 ? 'london' : exports.optionalDeps.EthCommon.Hardfork.TangerineWhistle;
        const defaultCommon = new exports.optionalDeps.EthCommon.default({
            chain: exports.optionalDeps.EthCommon.Chain.Mainnet,
            hardfork: defaultHardfork,
        });
        // if replay protection options are set, override the default common setting
        const ethCommon = replayProtectionOptions
            ? exports.optionalDeps.EthCommon.default.isSupportedChainId(new exports.optionalDeps.ethUtil.BN(replayProtectionOptions.chain))
                ? new exports.optionalDeps.EthCommon.default({
                    chain: replayProtectionOptions.chain,
                    hardfork: replayProtectionOptions.hardfork,
                })
                : exports.optionalDeps.EthCommon.default.custom({
                    chainId: new exports.optionalDeps.ethUtil.BN(replayProtectionOptions.chain),
                    defaultHardfork: replayProtectionOptions.hardfork,
                })
            : defaultCommon;
        return ethCommon;
    }
    static buildTransaction(params) {
        // if eip1559 params are specified, default to london hardfork, otherwise,
        // default to tangerine whistle to avoid replay protection issues
        const ethCommon = Eth.getEthCommon(params.eip1559, params.replayProtectionOptions);
        const baseParams = {
            to: params.to,
            nonce: params.nonce,
            value: params.value,
            data: params.data,
            gasLimit: new exports.optionalDeps.ethUtil.BN(params.gasLimit),
        };
        const unsignedEthTx = !!params.eip1559
            ? exports.optionalDeps.EthTx.FeeMarketEIP1559Transaction.fromTxData({
                ...baseParams,
                maxFeePerGas: new exports.optionalDeps.ethUtil.BN(params.eip1559.maxFeePerGas),
                maxPriorityFeePerGas: new exports.optionalDeps.ethUtil.BN(params.eip1559.maxPriorityFeePerGas),
            }, { common: ethCommon })
            : exports.optionalDeps.EthTx.Transaction.fromTxData({
                ...baseParams,
                gasPrice: new exports.optionalDeps.ethUtil.BN(params.gasPrice),
            }, { common: ethCommon });
        return unsignedEthTx;
    }
    /** @inheritDoc */
    supportsTss() {
        return true;
    }
    /** @inheritDoc */
    isEVM() {
        return true;
    }
    getMPCAlgorithm() {
        return 'ecdsa';
    }
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor() {
        // 10^18
        return '1000000000000000000';
    }
    getChain() {
        return 'eth';
    }
    getFamily() {
        return 'eth';
    }
    getNetwork() {
        var _a;
        return (_a = this.staticsCoin) === null || _a === void 0 ? void 0 : _a.network;
    }
    getFullName() {
        return 'Ethereum';
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed() {
        return true;
    }
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    isValidAddress(address) {
        return exports.optionalDeps.ethUtil.isValidAddress(exports.optionalDeps.ethUtil.addHexPrefix(address));
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        try {
            return utxo_lib_1.bip32.fromBase58(pub).isNeutered();
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    getRecoveryGasPrice() {
        return new exports.optionalDeps.ethUtil.BN('20000000000');
    }
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    getRecoveryGasLimit() {
        return new exports.optionalDeps.ethUtil.BN('500000');
    }
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    getDefaultExpireTime() {
        return Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
    }
    /**
     * Query Etherscan for the balance of an address
     * @param address {String} the ETH address
     * @returns {BigNumber} address balance
     */
    async queryAddressBalance(address) {
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'account',
            action: 'balance',
            address: address,
        });
        // throw if the result does not exist or the result is not a valid number
        if (!result || !result.result || isNaN(result.result)) {
            throw new Error(`Could not obtain address balance for ${address} from Etherscan, got: ${result.result}`);
        }
        return new exports.optionalDeps.ethUtil.BN(result.result, 10);
    }
    /**
     * Query Etherscan for the balance of an address for a token
     * @param tokenContractAddress {String} address where the token smart contract is hosted
     * @param walletContractAddress {String} address of the wallet
     * @returns {BigNumber} token balaance in base units
     */
    async queryAddressTokenBalance(tokenContractAddress, walletContractAddress) {
        if (!exports.optionalDeps.ethUtil.isValidAddress(tokenContractAddress)) {
            throw new Error('cannot get balance for invalid token address');
        }
        if (!exports.optionalDeps.ethUtil.isValidAddress(walletContractAddress)) {
            throw new Error('cannot get token balance for invalid wallet address');
        }
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'account',
            action: 'tokenbalance',
            contractaddress: tokenContractAddress,
            address: walletContractAddress,
            tag: 'latest',
        });
        // throw if the result does not exist or the result is not a valid number
        if (!result || !result.result || isNaN(result.result)) {
            throw new Error(`Could not obtain token address balance for ${tokenContractAddress} from Etherscan, got: ${result.result}`);
        }
        return new exports.optionalDeps.ethUtil.BN(result.result, 10);
    }
    /**
     * Get transfer operation for coin
     * @param recipient recipient info
     * @param expireTime expiry time
     * @param contractSequenceId sequence id
     * @returns {Array} operation array
     */
    getOperation(recipient, expireTime, contractSequenceId) {
        return [
            ['string', 'address', 'uint', 'bytes', 'uint', 'uint'],
            [
                'ETHER',
                new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                recipient.amount,
                Buffer.from(exports.optionalDeps.ethUtil.stripHexPrefix(exports.optionalDeps.ethUtil.padToEven(recipient.data || '')), 'hex'),
                expireTime,
                contractSequenceId,
            ],
        ];
    }
    getOperationSha3ForExecuteAndConfirm(recipients, expireTime, contractSequenceId) {
        if (!recipients || !Array.isArray(recipients)) {
            throw new Error('expecting array of recipients');
        }
        // Right now we only support 1 recipient
        if (recipients.length !== 1) {
            throw new Error('must send to exactly 1 recipient');
        }
        if (!lodash_1.default.isNumber(expireTime)) {
            throw new Error('expireTime must be number of seconds since epoch');
        }
        if (!lodash_1.default.isNumber(contractSequenceId)) {
            throw new Error('contractSequenceId must be number');
        }
        // Check inputs
        recipients.forEach(function (recipient) {
            if (!lodash_1.default.isString(recipient.address) ||
                !exports.optionalDeps.ethUtil.isValidAddress(exports.optionalDeps.ethUtil.addHexPrefix(recipient.address))) {
                throw new Error('Invalid address: ' + recipient.address);
            }
            let amount;
            try {
                amount = new bignumber_js_1.BigNumber(recipient.amount);
            }
            catch (e) {
                throw new Error('Invalid amount for: ' + recipient.address + ' - should be numeric');
            }
            recipient.amount = amount.toFixed(0);
            if (recipient.data && !lodash_1.default.isString(recipient.data)) {
                throw new Error('Data for recipient ' + recipient.address + ' - should be of type hex string');
            }
        });
        const recipient = recipients[0];
        return exports.optionalDeps.ethUtil.bufferToHex(exports.optionalDeps.ethAbi.soliditySHA3(...this.getOperation(recipient, expireTime, contractSequenceId)));
    }
    /**
     * Queries the contract (via Etherscan) for the next sequence ID
     * @param address {String} address of the contract
     * @returns {Number} sequence ID
     */
    async querySequenceId(address) {
        // Get sequence ID using contract call
        const sequenceIdMethodSignature = exports.optionalDeps.ethAbi.methodID('getNextSequenceId', []);
        const sequenceIdArgs = exports.optionalDeps.ethAbi.rawEncode([], []);
        const sequenceIdData = Buffer.concat([sequenceIdMethodSignature, sequenceIdArgs]).toString('hex');
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'proxy',
            action: 'eth_call',
            to: address,
            data: sequenceIdData,
            tag: 'latest',
        });
        if (!result || !result.result) {
            throw new Error('Could not obtain sequence ID from Etherscan, got: ' + result.result);
        }
        const sequenceIdHex = result.result;
        return new exports.optionalDeps.ethUtil.BN(sequenceIdHex.slice(2), 16).toNumber();
    }
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.signingKeyNonce
     * @param params.walletContractAddress
     * @param params.prv
     * @returns {{txHex: *}}
     */
    signFinal(params) {
        const txPrebuild = params.txPrebuild;
        if (!lodash_1.default.isNumber(params.signingKeyNonce) && !lodash_1.default.isNumber(params.txPrebuild.halfSigned.backupKeyNonce)) {
            throw new Error('must have at least one of signingKeyNonce and backupKeyNonce as a parameter, and it must be a number');
        }
        if (lodash_1.default.isUndefined(params.walletContractAddress)) {
            throw new Error('params must include walletContractAddress, but got undefined');
        }
        const signingNode = utxo_lib_1.bip32.fromBase58(params.prv);
        const signingKey = signingNode.privateKey;
        if (lodash_1.default.isUndefined(signingKey)) {
            throw new Error('missing private key');
        }
        const txInfo = {
            recipient: txPrebuild.recipients[0],
            expireTime: txPrebuild.halfSigned.expireTime,
            contractSequenceId: txPrebuild.halfSigned.contractSequenceId,
            signature: txPrebuild.halfSigned.signature,
        };
        const sendMethodArgs = this.getSendMethodArgs(txInfo);
        const methodSignature = exports.optionalDeps.ethAbi.methodID(this.sendMethodName, lodash_1.default.map(sendMethodArgs, 'type'));
        const encodedArgs = exports.optionalDeps.ethAbi.rawEncode(lodash_1.default.map(sendMethodArgs, 'type'), lodash_1.default.map(sendMethodArgs, 'value'));
        const sendData = Buffer.concat([methodSignature, encodedArgs]);
        const ethTxParams = {
            to: params.walletContractAddress,
            nonce: params.signingKeyNonce !== undefined ? params.signingKeyNonce : params.txPrebuild.halfSigned.backupKeyNonce,
            value: 0,
            gasPrice: new exports.optionalDeps.ethUtil.BN(txPrebuild.gasPrice),
            gasLimit: new exports.optionalDeps.ethUtil.BN(txPrebuild.gasLimit),
            data: sendData,
        };
        const unsignedEthTx = Eth.buildTransaction({
            ...ethTxParams,
            eip1559: params.txPrebuild.eip1559,
            replayProtectionOptions: params.txPrebuild.replayProtectionOptions,
        });
        const ethTx = unsignedEthTx.sign(signingKey);
        return { txHex: ethTx.serialize().toString('hex') };
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {Promise<SignedTransaction>}
     */
    async signTransaction(params) {
        const txPrebuild = params.txPrebuild;
        const userPrv = params.prv;
        const EXPIRETIME_DEFAULT = 60 * 60 * 24 * 7; // This signature will be valid for 1 week
        if (lodash_1.default.isUndefined(txPrebuild) || !lodash_1.default.isObject(txPrebuild)) {
            if (!lodash_1.default.isUndefined(txPrebuild) && !lodash_1.default.isObject(txPrebuild)) {
                throw new Error(`txPrebuild must be an object, got type ${typeof txPrebuild}`);
            }
            throw new Error('missing txPrebuild parameter');
        }
        if (lodash_1.default.isUndefined(userPrv) || !lodash_1.default.isString(userPrv)) {
            if (!lodash_1.default.isUndefined(userPrv) && !lodash_1.default.isString(userPrv)) {
                throw new Error(`prv must be a string, got type ${typeof userPrv}`);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        params.recipients = txPrebuild.recipients || params.recipients;
        // if no recipients in either params or txPrebuild, then throw an error
        if (!params.recipients || !Array.isArray(params.recipients)) {
            throw new Error('recipients missing or not array');
        }
        if (params.recipients.length == 0) {
            throw new Error('recipients empty');
        }
        // Normally the SDK provides the first signature for an ETH tx, but occasionally it provides the second and final one.
        if (params.isLastSignature) {
            // In this case when we're doing the second (final) signature, the logic is different.
            return this.signFinal(params);
        }
        const secondsSinceEpoch = Math.floor(new Date().getTime() / 1000);
        const expireTime = params.expireTime || secondsSinceEpoch + EXPIRETIME_DEFAULT;
        const sequenceId = txPrebuild.nextContractSequenceId;
        if (lodash_1.default.isUndefined(sequenceId)) {
            throw new Error('transaction prebuild missing required property nextContractSequenceId');
        }
        const operationHash = this.getOperationSha3ForExecuteAndConfirm(params.recipients, expireTime, sequenceId);
        const signature = sdk_core_1.Util.ethSignMsgHash(operationHash, sdk_core_1.Util.xprvToEthPrivateKey(userPrv));
        const txParams = {
            eip1559: params.txPrebuild.eip1559,
            isBatch: params.txPrebuild.isBatch,
            recipients: params.recipients,
            expireTime: expireTime,
            contractSequenceId: sequenceId,
            sequenceId: params.sequenceId,
            operationHash: operationHash,
            signature: signature,
            gasLimit: params.gasLimit,
            gasPrice: params.gasPrice,
            hopTransaction: txPrebuild.hopTransaction,
            backupKeyNonce: txPrebuild.backupKeyNonce,
            custodianTransactionId: params.custodianTransactionId,
        };
        return { halfSigned: txParams };
    }
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params) {
        // We always need params object, since either enterprise or newFeeAddress is required
        if (!lodash_1.default.isObject(params)) {
            throw new Error(`preCreateBitGo must be passed a params object. Got ${params} (type ${typeof params})`);
        }
        if (lodash_1.default.isUndefined(params.enterprise) && lodash_1.default.isUndefined(params.newFeeAddress)) {
            throw new Error('expecting enterprise when adding BitGo key. If you want to create a new ETH bitgo key, set the newFeeAddress parameter to true.');
        }
        // Check whether key should be an enterprise key or a BitGo key for a new fee address
        if (!lodash_1.default.isUndefined(params.enterprise) && !lodash_1.default.isUndefined(params.newFeeAddress)) {
            throw new Error(`Incompatible arguments - cannot pass both enterprise and newFeeAddress parameter.`);
        }
        if (!lodash_1.default.isUndefined(params.enterprise) && !lodash_1.default.isString(params.enterprise)) {
            throw new Error(`enterprise should be a string - got ${params.enterprise} (type ${typeof params.enterprise})`);
        }
        if (!lodash_1.default.isUndefined(params.newFeeAddress) && !lodash_1.default.isBoolean(params.newFeeAddress)) {
            throw new Error(`newFeeAddress should be a boolean - got ${params.newFeeAddress} (type ${typeof params.newFeeAddress})`);
        }
    }
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @returns {*}
     */
    async getAddressNonce(address) {
        // Get nonce for backup key (should be 0)
        let nonce = 0;
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'account',
            action: 'txlist',
            address,
        });
        if (!result || !Array.isArray(result.result)) {
            throw new Error('Unable to find next nonce from Etherscan, got: ' + JSON.stringify(result));
        }
        const backupKeyTxList = result.result;
        if (backupKeyTxList.length > 0) {
            // Calculate last nonce used
            const outgoingTxs = backupKeyTxList.filter((tx) => tx.from === address);
            nonce = outgoingTxs.length;
        }
        return nonce;
    }
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param txInfo
     * @param ethTx
     * @param userKey
     * @param backupKey
     * @param gasPrice
     * @param gasLimit
     * @param eip1559
     * @param replayProtectionOptions
     * @returns {Promise<OfflineVaultTxInfo>}
     */
    async formatForOfflineVault(txInfo, ethTx, userKey, backupKey, gasPrice, gasLimit, eip1559, replayProtectionOptions) {
        if (!ethTx.to) {
            throw new Error('Eth tx must have a `to` address');
        }
        const backupHDNode = utxo_lib_1.bip32.fromBase58(backupKey);
        const backupSigningKey = backupHDNode.publicKey;
        const response = {
            tx: ethTx.serialize().toString('hex'),
            userKey,
            backupKey,
            coin: this.getChain(),
            gasPrice: exports.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
            gasLimit,
            recipients: [txInfo.recipient],
            walletContractAddress: ethTx.to.toString(),
            amount: txInfo.recipient.amount,
            backupKeyNonce: await this.getAddressNonce(`0x${exports.optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex')}`),
            eip1559,
            replayProtectionOptions,
        };
        lodash_1.default.extend(response, txInfo);
        response.nextContractSequenceId = response.contractSequenceId;
        return response;
    }
    /**
     * Helper function for recover()
     * This transforms the unsigned transaction information into a format the BitGo offline vault expects
     * @param txInfo
     * @param ethTx
     * @param userKey
     * @param backupKey
     * @param gasPrice
     * @param gasLimit
     * @param eip1559
     * @param replayProtectionOptions
     * @returns {Promise<OfflineVaultTxInfo>}
     */
    formatForOfflineVaultTSS(txInfo, ethTx, userKey, backupKey, gasPrice, gasLimit, backupKeyNonce, eip1559, replayProtectionOptions) {
        if (!ethTx.to) {
            throw new Error('Eth tx must have a `to` address');
        }
        const response = {
            tx: ethTx.serialize().toString('hex'),
            txHex: ethTx.getMessageToSign(false).toString('hex'),
            userKey,
            backupKey,
            coin: this.getChain(),
            gasPrice: exports.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
            gasLimit,
            recipients: [txInfo.recipient],
            walletContractAddress: ethTx.to.toString(),
            amount: txInfo.recipient.amount,
            backupKeyNonce: backupKeyNonce,
            eip1559,
            replayProtectionOptions,
        };
        lodash_1.default.extend(response, txInfo);
        return response;
    }
    /**
     * Check whether the gas price passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param userGasPrice user defined gas price
     * @returns the gas price to use for this transaction
     */
    setGasPrice(userGasPrice) {
        if (!userGasPrice) {
            return statics_1.ethGasConfigs.defaultGasPrice;
        }
        const gasPriceMax = statics_1.ethGasConfigs.maximumGasPrice;
        const gasPriceMin = statics_1.ethGasConfigs.minimumGasPrice;
        if (userGasPrice < gasPriceMin || userGasPrice > gasPriceMax) {
            throw new Error(`Gas price must be between ${gasPriceMin} and ${gasPriceMax}`);
        }
        return userGasPrice;
    }
    /**
     * Check whether gas limit passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param userGasLimit user defined gas limit
     * @returns the gas limit to use for this transaction
     */
    setGasLimit(userGasLimit) {
        if (!userGasLimit) {
            return statics_1.ethGasConfigs.defaultGasLimit;
        }
        const gasLimitMax = statics_1.ethGasConfigs.maximumGasLimit;
        const gasLimitMin = statics_1.ethGasConfigs.minimumGasLimit;
        if (userGasLimit < gasLimitMin || userGasLimit > gasLimitMax) {
            throw new Error(`Gas limit must be between ${gasLimitMin} and ${gasLimitMax}`);
        }
        return userGasLimit;
    }
    validateRecoveryParams(params) {
        if (lodash_1.default.isUndefined(params.userKey)) {
            throw new Error('missing userKey');
        }
        if (lodash_1.default.isUndefined(params.backupKey)) {
            throw new Error('missing backupKey');
        }
        if (lodash_1.default.isUndefined(params.walletPassphrase) && !params.userKey.startsWith('xpub') && !params.isTss) {
            throw new Error('missing wallet passphrase');
        }
        if (lodash_1.default.isUndefined(params.walletContractAddress) || !this.isValidAddress(params.walletContractAddress)) {
            throw new Error('invalid walletContractAddress');
        }
        if (lodash_1.default.isUndefined(params.recoveryDestination) || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
    }
    async signRecoveryTSS(userKeyCombined, backupKeyCombined, txHex, { rangeProofChallenge, } = {}) {
        const MPC = new sdk_core_1.Ecdsa();
        const signerOneIndex = userKeyCombined.xShare.i;
        const signerTwoIndex = backupKeyCombined.xShare.i;
        rangeProofChallenge =
            rangeProofChallenge !== null && rangeProofChallenge !== void 0 ? rangeProofChallenge : sdk_lib_mpc_1.EcdsaTypes.serializeNtildeWithProofs(await sdk_lib_mpc_1.EcdsaRangeProof.generateNtilde());
        const userToBackupPaillierChallenge = await sdk_lib_mpc_1.EcdsaPaillierProof.generateP(sdk_core_1.hexToBigInt(userKeyCombined.yShares[signerTwoIndex].n));
        const backupToUserPaillierChallenge = await sdk_lib_mpc_1.EcdsaPaillierProof.generateP(sdk_core_1.hexToBigInt(backupKeyCombined.yShares[signerOneIndex].n));
        const userXShare = MPC.appendChallenge(userKeyCombined.xShare, rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: userToBackupPaillierChallenge }));
        const userYShare = MPC.appendChallenge(userKeyCombined.yShares[signerTwoIndex], rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: backupToUserPaillierChallenge }));
        const backupXShare = MPC.appendChallenge(backupKeyCombined.xShare, rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: backupToUserPaillierChallenge }));
        const backupYShare = MPC.appendChallenge(backupKeyCombined.yShares[signerOneIndex], rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: userToBackupPaillierChallenge }));
        const signShares = await MPC.signShare(userXShare, userYShare);
        const signConvertS21 = await MPC.signConvertStep1({
            xShare: backupXShare,
            yShare: backupYShare,
            kShare: signShares.kShare,
        });
        const signConvertS12 = await MPC.signConvertStep2({
            aShare: signConvertS21.aShare,
            wShare: signShares.wShare,
        });
        const signConvertS21_2 = await MPC.signConvertStep3({
            muShare: signConvertS12.muShare,
            bShare: signConvertS21.bShare,
        });
        const [signCombineOne, signCombineTwo] = [
            MPC.signCombine({
                gShare: signConvertS12.gShare,
                signIndex: {
                    i: signConvertS12.muShare.i,
                    j: signConvertS12.muShare.j,
                },
            }),
            MPC.signCombine({
                gShare: signConvertS21_2.gShare,
                signIndex: {
                    i: signConvertS21_2.signIndex.i,
                    j: signConvertS21_2.signIndex.j,
                },
            }),
        ];
        const MESSAGE = Buffer.from(txHex, 'hex');
        const [signA, signB] = [
            MPC.sign(MESSAGE, signCombineOne.oShare, signCombineTwo.dShare, keccak_1.default('keccak256')),
            MPC.sign(MESSAGE, signCombineTwo.oShare, signCombineOne.dShare, keccak_1.default('keccak256')),
        ];
        return MPC.constructSignature([signA, signB]);
    }
    /**
     * Helper which combines key shares of user and backup
     * */
    getKeyCombinedFromTssKeyShares(userPublicOrPrivateKeyShare, backupPrivateOrPublicKeyShare, walletPassphrase) {
        let backupPrv;
        let userPrv;
        try {
            backupPrv = this.bitgo.decrypt({
                input: backupPrivateOrPublicKeyShare,
                password: walletPassphrase,
            });
            userPrv = this.bitgo.decrypt({
                input: userPublicOrPrivateKeyShare,
                password: walletPassphrase,
            });
        }
        catch (e) {
            throw new Error(`Error decrypting backup keychain: ${e.message}`);
        }
        const userSigningMaterial = JSON.parse(userPrv);
        const backupSigningMaterial = JSON.parse(backupPrv);
        if (!userSigningMaterial.backupNShare) {
            throw new Error('Invalid user key - missing backupNShare');
        }
        if (!backupSigningMaterial.userNShare) {
            throw new Error('Invalid backup key - missing userNShare');
        }
        const MPC = new sdk_core_1.Ecdsa();
        const userKeyCombined = MPC.keyCombine(userSigningMaterial.pShare, [
            userSigningMaterial.bitgoNShare,
            userSigningMaterial.backupNShare,
        ]);
        const backupKeyCombined = MPC.keyCombine(backupSigningMaterial.pShare, [
            backupSigningMaterial.bitgoNShare,
            backupSigningMaterial.userNShare,
        ]);
        if (userKeyCombined.xShare.y !== backupKeyCombined.xShare.y ||
            userKeyCombined.xShare.chaincode !== backupKeyCombined.xShare.chaincode) {
            throw new Error('Common keychains do not match');
        }
        return [userKeyCombined, backupKeyCombined];
    }
    /**
     * Helper which Adds signatures to tx object and re-serializes tx
     * */
    getSignedTxFromSignature(ethCommon, tx, signature) {
        // get signed Tx from signature
        const txData = tx.toJSON();
        const yParity = signature.recid;
        const baseParams = {
            to: txData.to,
            nonce: new bn_js_1.default(ethereumjs_util_1.stripHexPrefix(txData.nonce), 'hex'),
            value: new bn_js_1.default(ethereumjs_util_1.stripHexPrefix(txData.value), 'hex'),
            gasLimit: new bn_js_1.default(ethereumjs_util_1.stripHexPrefix(txData.gasLimit), 'hex'),
            data: txData.data,
            r: ethereumjs_util_1.addHexPrefix(signature.r),
            s: ethereumjs_util_1.addHexPrefix(signature.s),
        };
        let finalTx;
        if (txData.maxFeePerGas && txData.maxPriorityFeePerGas) {
            finalTx = tx_1.FeeMarketEIP1559Transaction.fromTxData({
                ...baseParams,
                maxPriorityFeePerGas: new bn_js_1.default(ethereumjs_util_1.stripHexPrefix(txData.maxPriorityFeePerGas), 'hex'),
                maxFeePerGas: new bn_js_1.default(ethereumjs_util_1.stripHexPrefix(txData.maxFeePerGas), 'hex'),
                v: new bn_js_1.default(yParity.toString()),
            }, { common: ethCommon });
        }
        else if (txData.gasPrice) {
            const v = BigInt(35) + BigInt(yParity) + BigInt(ethCommon.chainIdBN().toNumber()) * BigInt(2);
            finalTx = tx_1.Transaction.fromTxData({
                ...baseParams,
                v: new bn_js_1.default(v.toString()),
                gasPrice: new bn_js_1.default(ethereumjs_util_1.stripHexPrefix(txData.gasPrice.toString()), 'hex'),
            }, { common: ethCommon });
        }
        return finalTx;
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.krsProvider {String} necessary if backup key is held by KRS
     * @param params.recoveryDestination {String} target address to send recovered funds to
     * @param params.bitgoFeeAddress {String} wrong chain wallet fee address for evm based cross chain recovery txn
     * @param params.bitgoDestinationAddress {String} target bitgo address where fee will be sent for evm based cross chain recovery txn
     */
    async recover(params) {
        if (params.isTss) {
            return this.recoverTSS(params);
        }
        return this.recoverEthLike(params);
    }
    /**
     * Builds a unsigned (for cold, custody wallet) or
     * half-signed (for hot wallet) evm cross chain recovery transaction with
     * same expected arguments as recover method.
     * This helps recover funds from evm based wrong chain.
     */
    async recoverEthLikeforEvmBasedRecovery(params) {
        var _a, _b, _c, _d, _e;
        this.validateEvmBasedRecoveryParams(params);
        // Clean up whitespace from entered values
        const userKey = params.userKey.replace(/\s/g, '');
        const bitgoFeeAddress = (_a = params.bitgoFeeAddress) === null || _a === void 0 ? void 0 : _a.replace(/\s/g, '');
        const bitgoDestinationAddress = (_b = params.bitgoDestinationAddress) === null || _b === void 0 ? void 0 : _b.replace(/\s/g, '');
        const recoveryDestination = (_c = params.recoveryDestination) === null || _c === void 0 ? void 0 : _c.replace(/\s/g, '');
        const walletContractAddress = (_d = params.walletContractAddress) === null || _d === void 0 ? void 0 : _d.replace(/\s/g, '');
        const tokenContractAddress = (_e = params.tokenContractAddress) === null || _e === void 0 ? void 0 : _e.replace(/\s/g, '');
        let userSigningKey;
        let userKeyPrv;
        if (params.walletPassphrase) {
            if (!userKey.startsWith('xpub') && !userKey.startsWith('xprv')) {
                try {
                    userKeyPrv = this.bitgo.decrypt({
                        input: userKey,
                        password: params.walletPassphrase,
                    });
                }
                catch (e) {
                    throw new Error(`Error decrypting user keychain: ${e.message}`);
                }
            }
            const keyPair = new lib_1.KeyPair({ prv: userKeyPrv });
            userSigningKey = keyPair.getKeys().prv;
            if (!userSigningKey) {
                throw new Error('no private key');
            }
        }
        const gasLimit = new exports.optionalDeps.ethUtil.BN(this.setGasLimit(params.gasLimit));
        const gasPrice = params.eip1559
            ? new exports.optionalDeps.ethUtil.BN(params.eip1559.maxFeePerGas)
            : new exports.optionalDeps.ethUtil.BN(this.setGasPrice(params.gasPrice));
        const bitgoFeeAddressNonce = await this.getAddressNonce(bitgoFeeAddress);
        // get balance of bitgoFeeAddress to ensure funds are available to pay fees
        const bitgoFeeAddressBalance = await this.queryAddressBalance(bitgoFeeAddress);
        const totalGasNeeded = gasPrice.mul(gasLimit);
        const weiToGwei = 10 ** 9;
        if (bitgoFeeAddressBalance.lt(totalGasNeeded)) {
            throw new Error(`Fee address ${bitgoFeeAddressBalance} has balance ${(bitgoFeeAddressBalance / weiToGwei).toString()} Gwei.` +
                `This address must have a balance of at least ${(totalGasNeeded / weiToGwei).toString()}` +
                ` Gwei to perform recoveries. Try sending some ${this.getChain()} to this address then retry.`);
        }
        if (tokenContractAddress) {
            return this.recoverEthLikeTokenforEvmBasedRecovery(params, bitgoFeeAddressNonce, gasLimit, gasPrice, userKey, userSigningKey);
        }
        // get balance of wallet
        const txAmount = await this.queryAddressBalance(walletContractAddress);
        const bitgoFeePercentage = 0; // TODO: BG-71912 can change the fee% here.
        const bitgoFeeAmount = txAmount * (bitgoFeePercentage / 100);
        // build recipients object
        const recipients = [
            {
                address: recoveryDestination,
                amount: new bignumber_js_1.BigNumber(txAmount).minus(bitgoFeeAmount).toFixed(),
            },
        ];
        if (bitgoFeePercentage > 0) {
            if (lodash_1.default.isUndefined(bitgoDestinationAddress) || !this.isValidAddress(bitgoDestinationAddress)) {
                throw new Error('invalid bitgoDestinationAddress');
            }
            recipients.push({
                address: bitgoDestinationAddress,
                amount: bitgoFeeAmount.toString(10),
            });
        }
        // calculate batch data
        const BATCH_METHOD_NAME = 'batch';
        const BATCH_METHOD_TYPES = ['address[]', 'uint256[]'];
        const batchExecutionInfo = this.getBatchExecutionInfo(recipients);
        const batchData = exports.optionalDeps.ethUtil.addHexPrefix(this.getMethodCallData(BATCH_METHOD_NAME, BATCH_METHOD_TYPES, batchExecutionInfo.values).toString('hex'));
        // Get sequence ID using contract call
        // we need to wait between making two polygonscan calls to avoid getting banned
        await new Promise((resolve) => setTimeout(resolve, 1000));
        const sequenceId = await this.querySequenceId(walletContractAddress);
        const txInfo = {
            recipients: recipients,
            expireTime: this.getDefaultExpireTime(),
            contractSequenceId: sequenceId,
            gasLimit: gasLimit.toString(10),
            isEvmBasedCrossChainRecovery: true,
        };
        const network = this.getNetwork();
        const batcherContractAddress = network === null || network === void 0 ? void 0 : network.batcherContractAddress;
        const txBuilder = this.getTransactionBuilder();
        txBuilder.counter(bitgoFeeAddressNonce);
        txBuilder.contract(walletContractAddress);
        let txFee;
        if (params.eip1559) {
            txFee = {
                eip1559: {
                    maxPriorityFeePerGas: params.eip1559.maxPriorityFeePerGas,
                    maxFeePerGas: params.eip1559.maxFeePerGas,
                },
            };
        }
        else {
            txFee = { fee: gasPrice.toString() };
        }
        txBuilder.fee({
            ...txFee,
            gasLimit: gasLimit.toString(),
        });
        const transferBuilder = txBuilder.transfer();
        transferBuilder
            .amount(batchExecutionInfo.totalAmount)
            .contractSequenceId(sequenceId)
            .expirationTime(this.getDefaultExpireTime())
            .to(batcherContractAddress)
            .data(batchData);
        if (params.walletPassphrase) {
            txBuilder.transfer().key(userSigningKey);
        }
        const tx = await txBuilder.build();
        const response = {
            txHex: tx.toBroadcastFormat(),
            userKey,
            coin: this.getChain(),
            gasPrice: exports.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
            gasLimit,
            recipients: txInfo.recipients,
            walletContractAddress: tx.toJson().to,
            amount: batchExecutionInfo.totalAmount,
            backupKeyNonce: bitgoFeeAddressNonce,
            eip1559: params.eip1559,
        };
        lodash_1.default.extend(response, txInfo);
        response.nextContractSequenceId = response.contractSequenceId;
        if (params.walletPassphrase) {
            const halfSignedTxn = {
                halfSigned: {
                    txHex: tx.toBroadcastFormat(),
                    recipients: txInfo.recipients,
                    expireTime: txInfo.expireTime,
                },
            };
            lodash_1.default.extend(response, halfSignedTxn);
            const feesUsed = {
                gasPrice: exports.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
                gasLimit: exports.optionalDeps.ethUtil.bufferToInt(gasLimit).toFixed(),
            };
            response['feesUsed'] = feesUsed;
        }
        return response;
    }
    async recoverEthLikeTokenforEvmBasedRecovery(params, bitgoFeeAddressNonce, gasLimit, gasPrice, userKey, userSigningKey) {
        var _a;
        // get token balance of wallet
        const txAmount = await this.queryAddressTokenBalance(params.tokenContractAddress, params.walletContractAddress);
        // build recipients object
        const recipients = [
            {
                address: params.recoveryDestination,
                amount: new bignumber_js_1.BigNumber(txAmount).toFixed(),
            },
        ];
        // Get sequence ID using contract call
        // we need to wait between making two polygonscan calls to avoid getting banned
        await new Promise((resolve) => setTimeout(resolve, 1000));
        const sequenceId = await this.querySequenceId(params.walletContractAddress);
        const txInfo = {
            recipients: recipients,
            expireTime: this.getDefaultExpireTime(),
            contractSequenceId: sequenceId,
            gasLimit: gasLimit.toString(10),
            isEvmBasedCrossChainRecovery: true,
        };
        const txBuilder = this.getTransactionBuilder();
        txBuilder.counter(bitgoFeeAddressNonce);
        txBuilder.contract(params.walletContractAddress);
        let txFee;
        if (params.eip1559) {
            txFee = {
                eip1559: {
                    maxPriorityFeePerGas: params.eip1559.maxPriorityFeePerGas,
                    maxFeePerGas: params.eip1559.maxFeePerGas,
                },
            };
        }
        else {
            txFee = { fee: gasPrice.toString() };
        }
        txBuilder.fee({
            ...txFee,
            gasLimit: gasLimit.toString(),
        });
        const transferBuilder = txBuilder.transfer();
        const network = this.getNetwork();
        const token = (_a = lib_1.getToken(params.tokenContractAddress, network)) === null || _a === void 0 ? void 0 : _a.name;
        transferBuilder
            .amount(txAmount)
            .contractSequenceId(sequenceId)
            .expirationTime(this.getDefaultExpireTime())
            .to(params.recoveryDestination)
            .coin(token);
        if (params.walletPassphrase) {
            txBuilder.transfer().key(userSigningKey);
        }
        const tx = await txBuilder.build();
        const response = {
            txHex: tx.toBroadcastFormat(),
            userKey,
            coin: token,
            gasPrice: exports.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
            gasLimit,
            recipients: txInfo.recipients,
            walletContractAddress: tx.toJson().to,
            amount: txAmount.toString(),
            backupKeyNonce: bitgoFeeAddressNonce,
            eip1559: params.eip1559,
        };
        lodash_1.default.extend(response, txInfo);
        response.nextContractSequenceId = response.contractSequenceId;
        if (params.walletPassphrase) {
            const halfSignedTxn = {
                halfSigned: {
                    txHex: tx.toBroadcastFormat(),
                    recipients: txInfo.recipients,
                    expireTime: txInfo.expireTime,
                },
            };
            lodash_1.default.extend(response, halfSignedTxn);
            const feesUsed = {
                gasPrice: exports.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
                gasLimit: exports.optionalDeps.ethUtil.bufferToInt(gasLimit).toFixed(),
            };
            response['feesUsed'] = feesUsed;
        }
        return response;
    }
    validateEvmBasedRecoveryParams(params) {
        if (lodash_1.default.isUndefined(params.bitgoFeeAddress) || !this.isValidAddress(params.bitgoFeeAddress)) {
            throw new Error('invalid bitgoFeeAddress');
        }
        if (lodash_1.default.isUndefined(params.walletContractAddress) || !this.isValidAddress(params.walletContractAddress)) {
            throw new Error('invalid walletContractAddress');
        }
        if (lodash_1.default.isUndefined(params.recoveryDestination) || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
    }
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    getTransactionBuilder() {
        return new lib_1.TransactionBuilder(statics_1.coins.get(this.getBaseChain()));
    }
    /**
     * Get the base chain that the coin exists on.
     */
    getBaseChain() {
        return this.getChain();
    }
    /**
     * Return types, values, and total amount in wei to send in a batch transaction, using the method signature
     * `distributeBatch(address[], uint256[])`
     * @param {Recipient[]} recipients - transaction recipients
     * @returns {GetBatchExecutionInfoRT} information needed to execute the batch transaction
     */
    getBatchExecutionInfo(recipients) {
        const addresses = [];
        const amounts = [];
        let sum = new bignumber_js_1.BigNumber('0');
        lodash_1.default.forEach(recipients, ({ address, amount }) => {
            addresses.push(address);
            amounts.push(amount);
            sum = sum.plus(amount);
        });
        return {
            values: [addresses, amounts],
            totalAmount: sum.toFixed(),
        };
    }
    /**
     * Recovers a tx with TSS key shares
     * same expected arguments as recover method, but with TSS key shares
     */
    async recoverTSS(params) {
        this.validateRecoveryParams(params);
        const isUnsignedSweep = sdk_core_1.getIsUnsignedSweep(params);
        // Clean up whitespace from entered values
        const userPublicOrPrivateKeyShare = params.userKey.replace(/\s/g, '');
        const backupPrivateOrPublicKeyShare = params.backupKey.replace(/\s/g, '');
        // Set new eth tx fees (using default config values from platform)
        const gasLimit = new exports.optionalDeps.ethUtil.BN(this.setGasLimit(params.gasLimit));
        const gasPrice = params.eip1559
            ? new exports.optionalDeps.ethUtil.BN(params.eip1559.maxFeePerGas)
            : new exports.optionalDeps.ethUtil.BN(this.setGasPrice(params.gasPrice));
        const [backupKeyAddress, userKeyCombined, backupKeyCombined] = (() => {
            if (isUnsignedSweep) {
                const backupKeyPair = new lib_1.KeyPair({ pub: backupPrivateOrPublicKeyShare });
                return [backupKeyPair.getAddress(), undefined, undefined];
            }
            else {
                const [userKeyCombined, backupKeyCombined] = this.getKeyCombinedFromTssKeyShares(userPublicOrPrivateKeyShare, backupPrivateOrPublicKeyShare, params.walletPassphrase);
                const backupKeyPair = new lib_1.KeyPair({ pub: backupKeyCombined.xShare.y });
                return [backupKeyPair.getAddress(), userKeyCombined, backupKeyCombined];
            }
        })();
        const backupKeyNonce = await this.getAddressNonce(backupKeyAddress);
        // get balance of backupKey to ensure funds are available to pay fees
        const backupKeyBalance = await this.queryAddressBalance(backupKeyAddress);
        const totalGasNeeded = gasPrice.mul(gasLimit);
        const weiToGwei = 10 ** 9;
        if (backupKeyBalance.lt(totalGasNeeded)) {
            throw new Error(`Backup key address ${backupKeyAddress} has balance ${(backupKeyBalance / weiToGwei).toString()} Gwei.` +
                `This address must have a balance of at least ${(totalGasNeeded / weiToGwei).toString()}` +
                ` Gwei to perform recoveries. Try sending some ETH to this address then retry.`);
        }
        // get balance of wallet and deduct fees to get transaction amount, wallet contract address acts as base address for tss?
        const txAmount = backupKeyBalance.sub(totalGasNeeded);
        // build recipients object
        const recipients = [
            {
                address: params.recoveryDestination,
                amount: txAmount.toString(10),
            },
        ];
        const txInfo = {
            recipient: recipients[0],
            expireTime: this.getDefaultExpireTime(),
            gasLimit: gasLimit.toString(10),
        };
        const txParams = {
            to: params.recoveryDestination,
            nonce: backupKeyNonce,
            value: txAmount,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            data: Buffer.from('0x'),
            eip1559: params.eip1559,
            replayProtectionOptions: params.replayProtectionOptions,
        };
        let tx = Eth.buildTransaction(txParams);
        if (isUnsignedSweep) {
            return this.formatForOfflineVaultTSS(txInfo, tx, userPublicOrPrivateKeyShare, backupPrivateOrPublicKeyShare, gasPrice, gasLimit, backupKeyNonce, params.eip1559, params.replayProtectionOptions);
        }
        const signableHex = tx.getMessageToSign(false).toString('hex');
        if (!userKeyCombined || !backupKeyCombined) {
            throw new Error('Missing key combined shares for user or backup');
        }
        const signature = await this.signRecoveryTSS(userKeyCombined, backupKeyCombined, signableHex);
        const ethCommmon = Eth.getEthCommon(params.eip1559, params.replayProtectionOptions);
        tx = this.getSignedTxFromSignature(ethCommmon, tx, signature);
        return {
            id: ethereumjs_util_1.addHexPrefix(tx.hash().toString('hex')),
            tx: ethereumjs_util_1.addHexPrefix(tx.serialize().toString('hex')),
        };
    }
    /**
     * Recovers a tx with non-TSS keys
     * same expected arguments as recover method (original logic before adding TSS recover path)
     */
    async recoverEthLike(params) {
        // bitgoFeeAddress is only defined when it is a evm cross chain recovery
        // as we use fee from this wrong chain address for the recovery txn on the correct chain.
        if (params.bitgoFeeAddress) {
            return this.recoverEthLikeforEvmBasedRecovery(params);
        }
        this.validateRecoveryParams(params);
        const isKrsRecovery = sdk_core_1.getIsKrsRecovery(params);
        const isUnsignedSweep = sdk_core_1.getIsUnsignedSweep(params);
        if (isKrsRecovery) {
            sdk_core_1.checkKrsProvider(this, params.krsProvider, { checkCoinFamilySupport: false });
        }
        // Clean up whitespace from entered values
        let userKey = params.userKey.replace(/\s/g, '');
        const backupKey = params.backupKey.replace(/\s/g, '');
        // Set new eth tx fees (using default config values from platform)
        const gasLimit = new exports.optionalDeps.ethUtil.BN(this.setGasLimit(params.gasLimit));
        const gasPrice = params.eip1559
            ? new exports.optionalDeps.ethUtil.BN(params.eip1559.maxFeePerGas)
            : new exports.optionalDeps.ethUtil.BN(this.setGasPrice(params.gasPrice));
        if (!userKey.startsWith('xpub') && !userKey.startsWith('xprv')) {
            try {
                userKey = this.bitgo.decrypt({
                    input: userKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting user keychain: ${e.message}`);
            }
        }
        let backupKeyAddress;
        let backupSigningKey;
        if (isKrsRecovery || isUnsignedSweep) {
            const backupHDNode = utxo_lib_1.bip32.fromBase58(backupKey);
            backupSigningKey = backupHDNode.publicKey;
            backupKeyAddress = `0x${exports.optionalDeps.ethUtil.publicToAddress(backupSigningKey, true).toString('hex')}`;
        }
        else {
            // Decrypt backup private key and get address
            let backupPrv;
            try {
                backupPrv = this.bitgo.decrypt({
                    input: backupKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting backup keychain: ${e.message}`);
            }
            const backupHDNode = utxo_lib_1.bip32.fromBase58(backupPrv);
            backupSigningKey = backupHDNode.privateKey;
            if (!backupHDNode) {
                throw new Error('no private key');
            }
            backupKeyAddress = `0x${exports.optionalDeps.ethUtil.privateToAddress(backupSigningKey).toString('hex')}`;
        }
        const backupKeyNonce = await this.getAddressNonce(backupKeyAddress);
        // get balance of backupKey to ensure funds are available to pay fees
        const backupKeyBalance = await this.queryAddressBalance(backupKeyAddress);
        const totalGasNeeded = gasPrice.mul(gasLimit);
        const weiToGwei = 10 ** 9;
        if (backupKeyBalance.lt(totalGasNeeded)) {
            throw new Error(`Backup key address ${backupKeyAddress} has balance ${(backupKeyBalance / weiToGwei).toString()} Gwei.` +
                `This address must have a balance of at least ${(totalGasNeeded / weiToGwei).toString()}` +
                ` Gwei to perform recoveries. Try sending some ETH to this address then retry.`);
        }
        // get balance of wallet and deduct fees to get transaction amount
        const txAmount = await this.queryAddressBalance(params.walletContractAddress);
        // build recipients object
        const recipients = [
            {
                address: params.recoveryDestination,
                amount: txAmount.toString(10),
            },
        ];
        // Get sequence ID using contract call
        // we need to wait between making two etherscan calls to avoid getting banned
        await new Promise((resolve) => setTimeout(resolve, 1000));
        const sequenceId = await this.querySequenceId(params.walletContractAddress);
        let operationHash, signature;
        // Get operation hash and sign it
        if (!isUnsignedSweep) {
            operationHash = this.getOperationSha3ForExecuteAndConfirm(recipients, this.getDefaultExpireTime(), sequenceId);
            signature = sdk_core_1.Util.ethSignMsgHash(operationHash, sdk_core_1.Util.xprvToEthPrivateKey(userKey));
            try {
                sdk_core_1.Util.ecRecoverEthAddress(operationHash, signature);
            }
            catch (e) {
                throw new Error('Invalid signature');
            }
        }
        const txInfo = {
            recipient: recipients[0],
            expireTime: this.getDefaultExpireTime(),
            contractSequenceId: sequenceId,
            operationHash: operationHash,
            signature: signature,
            gasLimit: gasLimit.toString(10),
        };
        // calculate send data
        const sendMethodArgs = this.getSendMethodArgs(txInfo);
        const methodSignature = exports.optionalDeps.ethAbi.methodID(this.sendMethodName, lodash_1.default.map(sendMethodArgs, 'type'));
        const encodedArgs = exports.optionalDeps.ethAbi.rawEncode(lodash_1.default.map(sendMethodArgs, 'type'), lodash_1.default.map(sendMethodArgs, 'value'));
        const sendData = Buffer.concat([methodSignature, encodedArgs]);
        const txParams = {
            to: params.walletContractAddress,
            nonce: backupKeyNonce,
            value: 0,
            gasPrice: gasPrice,
            gasLimit: gasLimit,
            data: sendData,
            eip1559: params.eip1559,
            replayProtectionOptions: params.replayProtectionOptions,
        };
        // Build contract call and sign it
        let tx = Eth.buildTransaction(txParams);
        if (isUnsignedSweep) {
            return this.formatForOfflineVault(txInfo, tx, userKey, backupKey, gasPrice, gasLimit, params.eip1559, params.replayProtectionOptions);
        }
        if (!isKrsRecovery) {
            tx = tx.sign(backupSigningKey);
        }
        const signedTx = {
            id: exports.optionalDeps.ethUtil.bufferToHex(tx.hash()),
            tx: tx.serialize().toString('hex'),
        };
        if (isKrsRecovery) {
            signedTx.backupKey = backupKey;
            signedTx.coin = this.getChain();
        }
        return signedTx;
    }
    /**
     * Recover an unsupported token from a BitGo multisig wallet
     * This builds a half-signed transaction, for which there will be an admin route to co-sign and broadcast. Optionally
     * the user can set params.broadcast = true and the half-signed tx will be sent to BitGo for cosigning and broadcasting
     * @param params
     * @param params.wallet the wallet to recover the token from
     * @param params.tokenContractAddress the contract address of the unsupported token
     * @param params.recipient the destination address recovered tokens should be sent to
     * @param params.walletPassphrase the wallet passphrase
     * @param params.prv the xprv
     * @param params.broadcast if true, we will automatically submit the half-signed tx to BitGo for cosigning and broadcasting
     */
    async recoverToken(params) {
        if (!lodash_1.default.isObject(params)) {
            throw new Error(`recoverToken must be passed a params object. Got ${params} (type ${typeof params})`);
        }
        if (lodash_1.default.isUndefined(params.tokenContractAddress) || !lodash_1.default.isString(params.tokenContractAddress)) {
            throw new Error(`tokenContractAddress must be a string, got ${params.tokenContractAddress} (type ${typeof params.tokenContractAddress})`);
        }
        if (!this.isValidAddress(params.tokenContractAddress)) {
            throw new Error('tokenContractAddress not a valid address');
        }
        if (lodash_1.default.isUndefined(params.wallet) || !(params.wallet instanceof sdk_core_1.Wallet)) {
            throw new Error(`wallet must be a wallet instance, got ${params.wallet} (type ${typeof params.wallet})`);
        }
        if (lodash_1.default.isUndefined(params.recipient) || !lodash_1.default.isString(params.recipient)) {
            throw new Error(`recipient must be a string, got ${params.recipient} (type ${typeof params.recipient})`);
        }
        if (!this.isValidAddress(params.recipient)) {
            throw new Error('recipient not a valid address');
        }
        if (!exports.optionalDeps.ethUtil.bufferToHex || !exports.optionalDeps.ethAbi.soliditySHA3) {
            throw new Error('ethereum not fully supported in this environment');
        }
        // Get token balance from external API
        const coinSpecific = params.wallet.coinSpecific();
        if (!coinSpecific || !lodash_1.default.isString(coinSpecific.baseAddress)) {
            throw new Error('missing required coin specific property baseAddress');
        }
        const recoveryAmount = await this.queryAddressTokenBalance(params.tokenContractAddress, coinSpecific.baseAddress);
        if (params.broadcast) {
            // We're going to create a normal ETH transaction that sends an amount of 0 ETH to the
            // tokenContractAddress and encode the unsupported-token-send data in the data field
            // #tricksy
            const sendMethodArgs = [
                {
                    name: '_to',
                    type: 'address',
                    value: params.recipient,
                },
                {
                    name: '_value',
                    type: 'uint256',
                    value: recoveryAmount.toString(10),
                },
            ];
            const methodSignature = exports.optionalDeps.ethAbi.methodID('transfer', lodash_1.default.map(sendMethodArgs, 'type'));
            const encodedArgs = exports.optionalDeps.ethAbi.rawEncode(lodash_1.default.map(sendMethodArgs, 'type'), lodash_1.default.map(sendMethodArgs, 'value'));
            const sendData = Buffer.concat([methodSignature, encodedArgs]);
            const broadcastParams = {
                address: params.tokenContractAddress,
                amount: '0',
                data: sendData.toString('hex'),
            };
            if (params.walletPassphrase) {
                broadcastParams.walletPassphrase = params.walletPassphrase;
            }
            else if (params.prv) {
                broadcastParams.prv = params.prv;
            }
            return await params.wallet.send(broadcastParams);
        }
        const recipient = {
            address: params.recipient,
            amount: recoveryAmount.toString(10),
        };
        // This signature will be valid for one week
        const expireTime = Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
        // Get sequence ID. We do this by building a 'fake' eth transaction, so the platform will increment and return us the new sequence id
        // This _does_ require the user to have a non-zero wallet balance
        const { nextContractSequenceId, gasPrice, gasLimit } = (await params.wallet.prebuildTransaction({
            recipients: [
                {
                    address: params.recipient,
                    amount: '1',
                },
            ],
        }));
        // these recoveries need to be processed by support, but if the customer sends any transactions before recovery is
        // complete the sequence ID will be invalid. artificially inflate the sequence ID to allow more time for processing
        const safeSequenceId = nextContractSequenceId + 1000;
        // Build sendData for ethereum tx
        const operationTypes = ['string', 'address', 'uint', 'address', 'uint', 'uint'];
        const operationArgs = [
            // "ERC20" has been added here so that ether operation hashes, signatures cannot be re-used for tokenSending
            'ERC20',
            new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
            recipient.amount,
            new exports.optionalDeps.ethUtil.BN(exports.optionalDeps.ethUtil.stripHexPrefix(params.tokenContractAddress), 16),
            expireTime,
            safeSequenceId,
        ];
        const operationHash = exports.optionalDeps.ethUtil.bufferToHex(exports.optionalDeps.ethAbi.soliditySHA3(operationTypes, operationArgs));
        const userPrv = await params.wallet.getPrv({
            prv: params.prv,
            walletPassphrase: params.walletPassphrase,
        });
        const signature = sdk_core_1.Util.ethSignMsgHash(operationHash, sdk_core_1.Util.xprvToEthPrivateKey(userPrv));
        return {
            halfSigned: {
                recipient: recipient,
                expireTime: expireTime,
                contractSequenceId: safeSequenceId,
                operationHash: operationHash,
                signature: signature,
                gasLimit: gasLimit,
                gasPrice: gasPrice,
                tokenContractAddress: params.tokenContractAddress,
                walletId: params.wallet.id(),
            },
        };
    }
    /**
     * Build arguments to call the send method on the wallet contract
     * @param txInfo
     */
    getSendMethodArgs(txInfo) {
        // Method signature is
        // sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature)
        return [
            {
                name: 'toAddress',
                type: 'address',
                value: txInfo.recipient.address,
            },
            {
                name: 'value',
                type: 'uint',
                value: txInfo.recipient.amount,
            },
            {
                name: 'data',
                type: 'bytes',
                value: exports.optionalDeps.ethUtil.toBuffer(exports.optionalDeps.ethUtil.addHexPrefix(txInfo.recipient.data || '')),
            },
            {
                name: 'expireTime',
                type: 'uint',
                value: txInfo.expireTime,
            },
            {
                name: 'sequenceId',
                type: 'uint',
                value: txInfo.contractSequenceId,
            },
            {
                name: 'signature',
                type: 'bytes',
                value: exports.optionalDeps.ethUtil.toBuffer(exports.optionalDeps.ethUtil.addHexPrefix(txInfo.signature)),
            },
        ];
    }
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Etherscan
     */
    async recoveryBlockchainExplorerQuery(query) {
        const token = sdk_core_1.common.Environments[this.bitgo.getEnv()].etherscanApiToken;
        if (token) {
            query.apikey = token;
        }
        const response = await superagent_1.default.get(sdk_core_1.common.Environments[this.bitgo.getEnv()].etherscanBaseUrl + '/api').query(query);
        if (!response.ok) {
            throw new Error('could not reach Etherscan');
        }
        if (response.body.status === '0' && response.body.message === 'NOTOK') {
            throw new Error('Etherscan rate limit reached');
        }
        return response.body;
    }
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param buildParams The original build parameters
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    async createHopTransactionParams(buildParams) {
        const wallet = buildParams.wallet;
        const recipients = buildParams.recipients;
        const walletPassphrase = buildParams.walletPassphrase;
        const userKeychain = await this.keychains().get({ id: wallet.keyIds()[0] });
        const userPrv = wallet.getUserPrv({ keychain: userKeychain, walletPassphrase });
        const userPrvBuffer = utxo_lib_1.bip32.fromBase58(userPrv).privateKey;
        if (!userPrvBuffer) {
            throw new Error('invalid userPrv');
        }
        if (!recipients || !Array.isArray(recipients)) {
            throw new Error('expecting array of recipients');
        }
        // Right now we only support 1 recipient
        if (recipients.length !== 1) {
            throw new Error('must send to exactly 1 recipient');
        }
        const recipientAddress = recipients[0].address;
        const recipientAmount = recipients[0].amount;
        const feeEstimateParams = {
            recipient: recipientAddress,
            amount: recipientAmount,
            hop: true,
        };
        const feeEstimate = await this.feeEstimate(feeEstimateParams);
        const gasLimit = feeEstimate.gasLimitEstimate;
        const gasPrice = Math.round(feeEstimate.feeEstimate / gasLimit);
        const gasPriceMax = gasPrice * 5;
        // Payment id a random number so its different for every tx
        const paymentId = Math.floor(Math.random() * 10000000000).toString();
        const hopDigest = Eth.getHopDigest([
            recipientAddress,
            recipientAmount,
            gasPriceMax.toString(),
            gasLimit.toString(),
            paymentId,
        ]);
        const userReqSig = exports.optionalDeps.ethUtil.addHexPrefix(Buffer.from(secp256k1_1.default.ecdsaSign(hopDigest, userPrvBuffer).signature).toString('hex'));
        return {
            hopParams: {
                gasPriceMax,
                userReqSig,
                paymentId,
            },
            gasLimit,
        };
    }
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    async validateHopPrebuild(wallet, hopPrebuild, originalParams) {
        const { tx, id, signature } = hopPrebuild;
        // first, validate the HSM signature
        const serverXpub = sdk_core_1.common.Environments[this.bitgo.getEnv()].hsmXpub;
        const serverPubkeyBuffer = utxo_lib_1.bip32.fromBase58(serverXpub).publicKey;
        const signatureBuffer = Buffer.from(exports.optionalDeps.ethUtil.stripHexPrefix(signature), 'hex');
        const messageBuffer = Buffer.from(exports.optionalDeps.ethUtil.padToEven(exports.optionalDeps.ethUtil.stripHexPrefix(id)), 'hex');
        const sig = new Uint8Array(signatureBuffer.slice(1));
        const isValidSignature = secp256k1_1.default.ecdsaVerify(sig, messageBuffer, serverPubkeyBuffer);
        if (!isValidSignature) {
            throw new Error(`Hop txid signature invalid - pub: ${serverXpub}, msg: ${messageBuffer === null || messageBuffer === void 0 ? void 0 : messageBuffer.toString()}, sig: ${signatureBuffer === null || signatureBuffer === void 0 ? void 0 : signatureBuffer.toString()}`);
        }
        const builtHopTx = exports.optionalDeps.EthTx.TransactionFactory.fromSerializedData(exports.optionalDeps.ethUtil.toBuffer(tx));
        // If original params are given, we can check them against the transaction prebuild params
        if (!lodash_1.default.isNil(originalParams)) {
            const { recipients } = originalParams;
            // Then validate that the tx params actually equal the requested params
            const originalAmount = new bignumber_js_1.BigNumber(recipients[0].amount);
            const originalDestination = recipients[0].address;
            const hopAmount = new bignumber_js_1.BigNumber(exports.optionalDeps.ethUtil.bufferToHex(builtHopTx.value));
            if (!builtHopTx.to) {
                throw new Error(`Transaction does not have a destination address`);
            }
            const hopDestination = builtHopTx.to.toString();
            if (!hopAmount.eq(originalAmount)) {
                throw new Error(`Hop amount: ${hopAmount} does not equal original amount: ${originalAmount}`);
            }
            if (hopDestination.toLowerCase() !== originalDestination.toLowerCase()) {
                throw new Error(`Hop destination: ${hopDestination} does not equal original recipient: ${hopDestination}`);
            }
        }
        if (!builtHopTx.verifySignature()) {
            // We dont want to continue at all in this case, at risk of ETH being stuck on the hop address
            throw new Error(`Invalid hop transaction signature, txid: ${id}`);
        }
        if (exports.optionalDeps.ethUtil.addHexPrefix(builtHopTx.hash().toString('hex')) !== id) {
            throw new Error(`Signed hop txid does not equal actual txid`);
        }
    }
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    static getHopDigest(paramsArr) {
        const hash = keccak_1.default('keccak256');
        hash.update([Eth.hopTransactionSalt, ...paramsArr].join('$'));
        return hash.digest();
    }
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     */
    async getExtraPrebuildParams(buildParams) {
        if (!lodash_1.default.isUndefined(buildParams.hop) &&
            buildParams.hop &&
            !lodash_1.default.isUndefined(buildParams.wallet) &&
            !lodash_1.default.isUndefined(buildParams.recipients) &&
            !lodash_1.default.isUndefined(buildParams.walletPassphrase)) {
            if (this instanceof erc20Token_1.Erc20Token) {
                throw new Error(`Hop transactions are not enabled for ERC-20 tokens, nor are they necessary. Please remove the 'hop' parameter and try again.`);
            }
            return (await this.createHopTransactionParams({
                wallet: buildParams.wallet,
                recipients: buildParams.recipients,
                walletPassphrase: buildParams.walletPassphrase,
            }));
        }
        return {};
    }
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    async postProcessPrebuild(params) {
        if (!lodash_1.default.isUndefined(params.hopTransaction) && !lodash_1.default.isUndefined(params.wallet) && !lodash_1.default.isUndefined(params.buildParams)) {
            await this.validateHopPrebuild(params.wallet, params.hopTransaction, params.buildParams);
        }
        return params;
    }
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     */
    async presignTransaction(params) {
        if (!lodash_1.default.isUndefined(params.hopTransaction) && !lodash_1.default.isUndefined(params.wallet) && !lodash_1.default.isUndefined(params.buildParams)) {
            await this.validateHopPrebuild(params.wallet, params.hopTransaction);
        }
        return params;
    }
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @returns {Object} The fee info returned from the server
     */
    async feeEstimate(params) {
        const query = {};
        if (params && params.hop) {
            query.hop = params.hop;
        }
        if (params && params.recipient) {
            query.recipient = params.recipient;
        }
        if (params && params.data) {
            query.data = params.data;
        }
        if (params && params.amount) {
            query.amount = params.amount;
        }
        return await this.bitgo.get(this.url('/tx/fee')).query(query).result();
    }
    /**
     * Generate secp256k1 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        const extendedKey = utxo_lib_1.bip32.fromSeed(seed);
        const xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Make sure an address is a wallet address and throw an error if it's not.
     * @param {Object} params
     * @param {String} params.address The derived address string on the network
     * @param {Object} params.coinSpecific Coin-specific details for the address such as a forwarderVersion
     * @param {String} params.baseAddress The base address of the wallet on the network
     * @throws {InvalidAddressError}
     * @throws {InvalidAddressVerificationObjectPropertyError}
     * @throws {UnexpectedAddressError}
     * @returns {Boolean} True iff address is a wallet address
     */
    async isWalletAddress(params) {
        const ethUtil = exports.optionalDeps.ethUtil;
        let expectedAddress;
        let actualAddress;
        const { address, coinSpecific, baseAddress, impliedForwarderVersion = coinSpecific === null || coinSpecific === void 0 ? void 0 : coinSpecific.forwarderVersion } = params;
        if (address && !this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        // base address is required to calculate the salt which is used in calculateForwarderV1Address method
        if (lodash_1.default.isUndefined(baseAddress) || !this.isValidAddress(baseAddress)) {
            throw new sdk_core_1.InvalidAddressError('invalid base address');
        }
        if (!lodash_1.default.isObject(coinSpecific)) {
            throw new sdk_core_1.InvalidAddressVerificationObjectPropertyError('address validation failure: coinSpecific field must be an object');
        }
        if (impliedForwarderVersion === 0 || impliedForwarderVersion === 3) {
            return true;
        }
        else {
            const ethNetwork = this.getNetwork();
            const forwarderFactoryAddress = ethNetwork === null || ethNetwork === void 0 ? void 0 : ethNetwork.forwarderFactoryAddress;
            const forwarderImplementationAddress = ethNetwork === null || ethNetwork === void 0 ? void 0 : ethNetwork.forwarderImplementationAddress;
            const initcode = lib_1.getProxyInitcode(forwarderImplementationAddress);
            const saltBuffer = ethUtil.setLengthLeft(Buffer.from(ethUtil.padToEven(ethUtil.stripHexPrefix(coinSpecific.salt || '')), 'hex'), 32);
            // Hash the wallet base address with the given salt, so the address directly relies on the base address
            const calculationSalt = exports.optionalDeps.ethUtil.bufferToHex(exports.optionalDeps.ethAbi.soliditySHA3(['address', 'bytes32'], [baseAddress, saltBuffer]));
            expectedAddress = lib_1.calculateForwarderV1Address(forwarderFactoryAddress, calculationSalt, initcode);
            actualAddress = address;
        }
        if (expectedAddress !== actualAddress) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: expected ${expectedAddress} but got ${address}`);
        }
        return true;
    }
    verifyCoin(txPrebuild) {
        return txPrebuild.coin === this.getChain();
    }
    verifyTssTransaction(params) {
        var _a;
        const { txParams, txPrebuild, wallet } = params;
        if (!(txParams === null || txParams === void 0 ? void 0 : txParams.recipients) &&
            !(((_a = txParams.prebuildTx) === null || _a === void 0 ? void 0 : _a.consolidateId) ||
                (txParams.type && ['acceleration', 'fillNonce', 'transferToken'].includes(txParams.type)))) {
            throw new Error(`missing txParams`);
        }
        if (!wallet || !txPrebuild) {
            throw new Error(`missing params`);
        }
        if (txParams.hop && txParams.recipients && txParams.recipients.length > 1) {
            throw new Error(`tx cannot be both a batch and hop transaction`);
        }
        return true;
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.wallet Wallet object to obtain keys to verify against
     * @returns {boolean}
     */
    async verifyTransaction(params) {
        const ethNetwork = this.getNetwork();
        const { txParams, txPrebuild, wallet, walletType } = params;
        if (walletType === 'tss') {
            return this.verifyTssTransaction(params);
        }
        if (!(txParams === null || txParams === void 0 ? void 0 : txParams.recipients) || !(txPrebuild === null || txPrebuild === void 0 ? void 0 : txPrebuild.recipients) || !wallet) {
            throw new Error(`missing params`);
        }
        if (txParams.hop && txParams.recipients.length > 1) {
            throw new Error(`tx cannot be both a batch and hop transaction`);
        }
        if (txPrebuild.recipients.length !== 1) {
            throw new Error(`txPrebuild should only have 1 recipient but ${txPrebuild.recipients.length} found`);
        }
        if (txParams.hop && txPrebuild.hopTransaction) {
            // Check recipient amount for hop transaction
            if (txParams.recipients.length !== 1) {
                throw new Error(`hop transaction only supports 1 recipient but ${txParams.recipients.length} found`);
            }
            // Check tx sends to hop address
            const decodedHopTx = exports.optionalDeps.EthTx.TransactionFactory.fromSerializedData(exports.optionalDeps.ethUtil.toBuffer(txPrebuild.hopTransaction.tx));
            const expectedHopAddress = exports.optionalDeps.ethUtil.stripHexPrefix(decodedHopTx.getSenderAddress().toString());
            const actualHopAddress = exports.optionalDeps.ethUtil.stripHexPrefix(txPrebuild.recipients[0].address);
            if (expectedHopAddress.toLowerCase() !== actualHopAddress.toLowerCase()) {
                throw new Error('recipient address of txPrebuild does not match hop address');
            }
            // Convert TransactionRecipient array to Recipient array
            const recipients = txParams.recipients.map((r) => {
                return {
                    address: r.address,
                    amount: typeof r.amount === 'number' ? r.amount.toString() : r.amount,
                };
            });
            // Check destination address and amount
            await this.validateHopPrebuild(wallet, txPrebuild.hopTransaction, { recipients });
        }
        else if (txParams.recipients.length > 1) {
            // Check total amount for batch transaction
            let expectedTotalAmount = new bignumber_js_1.BigNumber(0);
            for (let i = 0; i < txParams.recipients.length; i++) {
                expectedTotalAmount = expectedTotalAmount.plus(txParams.recipients[i].amount);
            }
            if (!expectedTotalAmount.isEqualTo(txPrebuild.recipients[0].amount)) {
                throw new Error('batch transaction amount in txPrebuild received from BitGo servers does not match txParams supplied by client');
            }
            // Check batch transaction is sent to the batcher contract address for the chain
            const batcherContractAddress = ethNetwork === null || ethNetwork === void 0 ? void 0 : ethNetwork.batcherContractAddress;
            if (!batcherContractAddress ||
                batcherContractAddress.toLowerCase() !== txPrebuild.recipients[0].address.toLowerCase()) {
                throw new Error('recipient address of txPrebuild does not match batcher address');
            }
        }
        else {
            // Check recipient address and amount for normal transaction
            if (txParams.recipients.length !== 1) {
                throw new Error(`normal transaction only supports 1 recipient but ${txParams.recipients.length} found`);
            }
            const expectedAmount = new bignumber_js_1.BigNumber(txParams.recipients[0].amount);
            if (!expectedAmount.isEqualTo(txPrebuild.recipients[0].amount)) {
                throw new Error('normal transaction amount in txPrebuild received from BitGo servers does not match txParams supplied by client');
            }
            if (this.isETHAddress(txParams.recipients[0].address) &&
                txParams.recipients[0].address !== txPrebuild.recipients[0].address) {
                throw new Error('destination address in normal txPrebuild does not match that in txParams supplied by client');
            }
        }
        // Check coin is correct for all transaction types
        if (!this.verifyCoin(txPrebuild)) {
            throw new Error(`coin in txPrebuild did not match that in txParams supplied by client`);
        }
        return true;
    }
    /** @inheritDoc */
    supportsMessageSigning() {
        return true;
    }
    /** @inheritDoc */
    supportsSigningTypedData() {
        return true;
    }
    /**
     * Transform message to accommodate specific blockchain requirements.
     * @param message the message to prepare
     * @return string the prepared message.
     */
    encodeMessage(message) {
        const prefix = `\u0019Ethereum Signed Message:\n${message.length}`;
        return prefix.concat(message);
    }
    /**
     * Transform the Typed data to accomodate the blockchain requirements (EIP-712)
     * @param typedData the typed data to prepare
     * @return a buffer of the result
     */
    encodeTypedData(typedData) {
        const version = typedData.version;
        if (version === eth_sig_util_1.SignTypedDataVersion.V1) {
            throw new Error('SignTypedData v1 is not supported due to security concerns');
        }
        const typedDataRaw = JSON.parse(typedData.typedDataRaw);
        const sanitizedData = eth_sig_util_1.TypedDataUtils.sanitizeData(typedDataRaw);
        const parts = [Buffer.from('1901', 'hex')];
        const eip712Domain = 'EIP712Domain';
        parts.push(eth_sig_util_1.TypedDataUtils.hashStruct(eip712Domain, sanitizedData.domain, sanitizedData.types, version));
        if (sanitizedData.primaryType !== eip712Domain) {
            parts.push(eth_sig_util_1.TypedDataUtils.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, version));
        }
        return Buffer.concat(parts);
    }
    isETHAddress(address) {
        return !!address.match(/0x[a-fA-F0-9]{40}/);
    }
}
exports.Eth = Eth;
Eth.hopTransactionSalt = 'bitgoHopAddressRequestSalt';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXRoLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2V0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7R0FFRztBQUNILDhDQUF3QztBQUN4QywrQ0FBeUM7QUFDekMsbUNBQXFDO0FBQ3JDLGtEQUE2QjtBQUM3QixvREFBNEI7QUFDNUIsb0RBQXVCO0FBQ3ZCLDBEQUFrQztBQUNsQyw0REFBaUM7QUFFakMsNkNBQTBDO0FBQzFDLDhDQW9DeUI7QUFDekIsb0RBQXFGO0FBRXJGLDRDQUFvRztBQUVwRyx1Q0FBK0Y7QUFFL0YsK0JBT2U7QUFDZixxREFBK0Q7QUFDL0Qsa0RBQXVCO0FBQ3ZCLHlEQUE0RjtBQUk1RixNQUFNLEtBQUssR0FBRyxlQUFRLENBQUMsY0FBYyxDQUFDLENBQUM7QUFFMUIsUUFBQSxZQUFZLEdBQUc7SUFDMUIsSUFBSSxNQUFNO1FBQ1IsSUFBSTtZQUNGLE9BQU8sT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDbEM7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO1lBQ3hDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDZixNQUFNLElBQUksMENBQStCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUM3RDtJQUNILENBQUM7SUFFRCxJQUFJLE9BQU87UUFDVCxJQUFJO1lBQ0YsT0FBTyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUNuQztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7WUFDekMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNmLE1BQU0sSUFBSSwwQ0FBK0IsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQzlEO0lBQ0gsQ0FBQztJQUVELElBQUksS0FBSztRQUNQLElBQUk7WUFDRixPQUFPLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FB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YSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBRXhHLElBQUksYUFBYSxDQUFDLFdBQVcsS0FBSyxZQUFZLEVBQUU7WUFDOUMsS0FBSyxDQUFDLElBQUksQ0FDUiw2QkFBYyxDQUFDLFVBQVUsQ0FDdkIsYUFBYSxDQUFDLFdBQXFCLEVBQ25DLGFBQWEsQ0FBQyxPQUFPLEVBQ3JCLGFBQWEsQ0FBQyxLQUFLLEVBQ25CLE9BQU8sQ0FDUixDQUNGLENBQUM7U0FDSDtRQUNELE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRU8sWUFBWSxDQUFDLE9BQWU7UUFDbEMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBQzlDLENBQUM7O0FBM3BFSCxrQkE0cEVDO0FBM3BFUSxzQkFBa0IsR0FBRyw0QkFBNEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCB7IGJpcDMyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuaW1wb3J0IEtlY2NhayBmcm9tICdrZWNjYWsnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBzZWNwMjU2azEgZnJvbSAnc2VjcDI1NmsxJztcbmltcG9ydCByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuXG5pbXBvcnQgeyBFcmMyMFRva2VuIH0gZnJvbSAnLi9lcmMyMFRva2VuJztcbmltcG9ydCB7XG4gIEFkZHJlc3NDb2luU3BlY2lmaWMsXG4gIEJhc2VDb2luLFxuICBCaXRHb0Jhc2UsXG4gIGNoZWNrS3JzUHJvdmlkZXIsXG4gIGNvbW1vbixcbiAgRUNEU0EsXG4gIEVjZHNhLFxuICBFQ0RTQU1ldGhvZFR5cGVzLFxuICBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yLFxuICBGZWVFc3RpbWF0ZU9wdGlvbnMsXG4gIEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb24sXG4gIGdldElzS3JzUmVjb3ZlcnksXG4gIGdldElzVW5zaWduZWRTd2VlcCxcbiAgSGFsZlNpZ25lZFRyYW5zYWN0aW9uLFxuICBoZXhUb0JpZ0ludCxcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgSW52YWxpZEFkZHJlc3NWZXJpZmljYXRpb25PYmplY3RQcm9wZXJ0eUVycm9yLFxuICBJV2FsbGV0LFxuICBLZXlQYWlyLFxuICBNUENBbGdvcml0aG0sXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdCxcbiAgUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUmVjaXBpZW50LFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvblBhcmFtcyxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQsXG4gIFR5cGVkRGF0YSxcbiAgVW5leHBlY3RlZEFkZHJlc3NFcnJvcixcbiAgVXRpbCxcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMgYXMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFdhbGxldCxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEVjZHNhUGFpbGxpZXJQcm9vZiwgRWNkc2FSYW5nZVByb29mLCBFY2RzYVR5cGVzIH0gZnJvbSAnQGJpdGdvL3Nkay1saWItbXBjJztcblxuaW1wb3J0IHsgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luLCBjb2lucywgRXRoZXJldW1OZXR3b3JrLCBldGhHYXNDb25maWdzIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHR5cGUgKiBhcyBFdGhUeExpYiBmcm9tICdAZXRoZXJldW1qcy90eCc7XG5pbXBvcnQgeyBGZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uIGFzIExlZ2FjeVRyYW5zYWN0aW9uIH0gZnJvbSAnQGV0aGVyZXVtanMvdHgnO1xuaW1wb3J0IHR5cGUgKiBhcyBFdGhDb21tb24gZnJvbSAnQGV0aGVyZXVtanMvY29tbW9uJztcbmltcG9ydCB7XG4gIGNhbGN1bGF0ZUZvcndhcmRlclYxQWRkcmVzcyxcbiAgZ2V0UHJveHlJbml0Y29kZSxcbiAgZ2V0VG9rZW4sXG4gIEtleVBhaXIgYXMgS2V5UGFpckxpYixcbiAgVHJhbnNhY3Rpb25CdWlsZGVyLFxuICBUcmFuc2ZlckJ1aWxkZXIsXG59IGZyb20gJy4vbGliJztcbmltcG9ydCB7IGFkZEhleFByZWZpeCwgc3RyaXBIZXhQcmVmaXggfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCB7IFNpZ25UeXBlZERhdGFWZXJzaW9uLCBUeXBlZERhdGFVdGlscywgVHlwZWRNZXNzYWdlIH0gZnJvbSAnQG1ldGFtYXNrL2V0aC1zaWctdXRpbCc7XG5cbmV4cG9ydCB7IFJlY2lwaWVudCwgSGFsZlNpZ25lZFRyYW5zYWN0aW9uLCBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIH07XG5cbmNvbnN0IGRlYnVnID0gZGVidWdMaWIoJ2JpdGdvOnYyOmV0aCcpO1xuXG5leHBvcnQgY29uc3Qgb3B0aW9uYWxEZXBzID0ge1xuICBnZXQgZXRoQWJpKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVxdWlyZSgnZXRoZXJldW1qcy1hYmknKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygndW5hYmxlIHRvIGxvYWQgZXRoZXJldW1qcy1hYmk6Jyk7XG4gICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIHRocm93IG5ldyBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yKGBldGhlcmV1bWpzLWFiaWApO1xuICAgIH1cbiAgfSxcblxuICBnZXQgZXRoVXRpbCgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCd1bmFibGUgdG8gbG9hZCBldGhlcmV1bWpzLXV0aWw6Jyk7XG4gICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIHRocm93IG5ldyBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yKGBldGhlcmV1bWpzLXV0aWxgKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0IEV0aFR4KCk6IHR5cGVvZiBFdGhUeExpYiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCd1bmFibGUgdG8gbG9hZCBAZXRoZXJldW1qcy90eCcpO1xuICAgICAgZGVidWcoZS5zdGFjayk7XG4gICAgICB0aHJvdyBuZXcgRXRoZXJldW1MaWJyYXJ5VW5hdmFpbGFibGVFcnJvcihgQGV0aGVyZXVtanMvdHhgKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0IEV0aENvbW1vbigpOiB0eXBlb2YgRXRoQ29tbW9uIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlcXVpcmUoJ0BldGhlcmV1bWpzL2NvbW1vbicpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCd1bmFibGUgdG8gbG9hZCBAZXRoZXJldW1qcy9jb21tb246Jyk7XG4gICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIHRocm93IG5ldyBFdGhlcmV1bUxpYnJhcnlVbmF2YWlsYWJsZUVycm9yKGBAZXRoZXJldW1qcy9jb21tb25gKTtcbiAgICB9XG4gIH0sXG59O1xuXG4vKipcbiAqIFRoZSBleHRyYSBwYXJhbWV0ZXJzIHRvIHNlbmQgdG8gcGxhdGZvcm0gYnVpbGQgcm91dGUgZm9yIGhvcCB0cmFuc2FjdGlvbnNcbiAqL1xuaW50ZXJmYWNlIEhvcFBhcmFtcyB7XG4gIGhvcFBhcmFtczoge1xuICAgIGdhc1ByaWNlTWF4OiBudW1iZXI7XG4gICAgdXNlclJlcVNpZzogc3RyaW5nO1xuICAgIHBheW1lbnRJZDogc3RyaW5nO1xuICB9O1xuICBnYXNMaW1pdDogbnVtYmVyO1xufVxuXG4vKipcbiAqIFRoZSBwcmVidWlsdCBob3AgdHJhbnNhY3Rpb24gcmV0dXJuZWQgZnJvbSB0aGUgSFNNXG4gKi9cbmludGVyZmFjZSBIb3BQcmVidWlsZCB7XG4gIHR4OiBzdHJpbmc7XG4gIGlkOiBzdHJpbmc7XG4gIHNpZ25hdHVyZTogc3RyaW5nO1xuICBwYXltZW50SWQ6IHN0cmluZztcbiAgZ2FzUHJpY2U6IG51bWJlcjtcbiAgZ2FzTGltaXQ6IG51bWJlcjtcbiAgYW1vdW50OiBudW1iZXI7XG4gIHJlY2lwaWVudDogc3RyaW5nO1xuICBub25jZTogbnVtYmVyO1xuICB1c2VyUmVxU2lnOiBzdHJpbmc7XG4gIGdhc1ByaWNlTWF4OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBFSVAxNTU5IHtcbiAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG51bWJlcjtcbiAgbWF4RmVlUGVyR2FzOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBSZXBsYXlQcm90ZWN0aW9uT3B0aW9ucyB7XG4gIGNoYWluOiBzdHJpbmcgfCBudW1iZXI7XG4gIGhhcmRmb3JrOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbkZpbmFsT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IHtcbiAgICBlaXAxNTU5PzogRUlQMTU1OTtcbiAgICByZXBsYXlQcm90ZWN0aW9uT3B0aW9ucz86IFJlcGxheVByb3RlY3Rpb25PcHRpb25zO1xuICAgIGdhc1ByaWNlPzogc3RyaW5nO1xuICAgIGdhc0xpbWl0OiBzdHJpbmc7XG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gICAgaGFsZlNpZ25lZDoge1xuICAgICAgZXhwaXJlVGltZTogbnVtYmVyO1xuICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXI7XG4gICAgICBiYWNrdXBLZXlOb25jZT86IG51bWJlcjtcbiAgICAgIHNpZ25hdHVyZTogc3RyaW5nO1xuICAgICAgdHhIZXg/OiBzdHJpbmc7XG4gICAgfTtcbiAgICBuZXh0Q29udHJhY3RTZXF1ZW5jZUlkPzogbnVtYmVyO1xuICAgIGhvcFRyYW5zYWN0aW9uPzogc3RyaW5nO1xuICAgIGJhY2t1cEtleU5vbmNlPzogbnVtYmVyO1xuICAgIGlzQmF0Y2g/OiBib29sZWFuO1xuICAgIHR4SGV4Pzogc3RyaW5nO1xuICAgIGV4cGlyZVRpbWU/OiBudW1iZXI7XG4gIH07XG4gIHNpZ25pbmdLZXlOb25jZTogbnVtYmVyO1xuICB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHN0cmluZztcbiAgcHJ2OiBzdHJpbmc7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucywgU2lnbkZpbmFsT3B0aW9ucyB7XG4gIGlzTGFzdFNpZ25hdHVyZT86IGJvb2xlYW47XG4gIGV4cGlyZVRpbWU6IG51bWJlcjtcbiAgc2VxdWVuY2VJZDogbnVtYmVyO1xuICBnYXNMaW1pdDogbnVtYmVyO1xuICBnYXNQcmljZTogbnVtYmVyO1xuICBjdXN0b2RpYW5UcmFuc2FjdGlvbklkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBTaWduZWRUcmFuc2FjdGlvbiA9IEhhbGZTaWduZWRUcmFuc2FjdGlvbiB8IEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb247XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmVlc1VzZWQge1xuICBnYXNQcmljZTogbnVtYmVyO1xuICBnYXNMaW1pdDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgUHJlY3JlYXRlQml0R29PcHRpb25zIHtcbiAgZW50ZXJwcmlzZT86IHN0cmluZztcbiAgbmV3RmVlQWRkcmVzcz86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPZmZsaW5lVmF1bHRUeEluZm8ge1xuICBuZXh0Q29udHJhY3RTZXF1ZW5jZUlkPzogc3RyaW5nO1xuICBjb250cmFjdFNlcXVlbmNlSWQ/OiBzdHJpbmc7XG4gIHR4Pzogc3RyaW5nO1xuICB0eEhleD86IHN0cmluZztcbiAgdXNlcktleT86IHN0cmluZztcbiAgYmFja3VwS2V5Pzogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGdhc1ByaWNlOiBudW1iZXI7XG4gIGdhc0xpbWl0OiBudW1iZXI7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIGJhY2t1cEtleU5vbmNlOiBudW1iZXI7XG4gIC8vIEZvciBFdGggU3BlY2lmaWMgQ29pbnNcbiAgZWlwMTU1OT86IEVJUDE1NTk7XG4gIHJlcGxheVByb3RlY3Rpb25PcHRpb25zPzogUmVwbGF5UHJvdGVjdGlvbk9wdGlvbnM7XG4gIC8vIEZvciBIb3QgV2FsbGV0IEV2bUJhc2VkQ3Jvc3NDaGFpblJlY292ZXJ5IFNwZWNpZmljXG4gIGhhbGZTaWduZWQ/OiBIYWxmU2lnbmVkVHJhbnNhY3Rpb247XG4gIGZlZXNVc2VkPzogRmVlc1VzZWQ7XG4gIGlzRXZtQmFzZWRDcm9zc0NoYWluUmVjb3Zlcnk/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgVW5mb3JtYXR0ZWRUeEluZm8ge1xuICByZWNpcGllbnQ6IFJlY2lwaWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyT3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHdhbGxldENvbnRyYWN0QWRkcmVzczogc3RyaW5nOyAvLyB1c2UgdGhpcyBhcyB3YWxsZXRCYXNlQWRkcmVzcyBmb3IgVFNTXG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZztcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG4gIGdhc1ByaWNlPzogbnVtYmVyO1xuICBnYXNMaW1pdD86IG51bWJlcjtcbiAgZWlwMTU1OT86IEVJUDE1NTk7XG4gIHJlcGxheVByb3RlY3Rpb25PcHRpb25zPzogUmVwbGF5UHJvdGVjdGlvbk9wdGlvbnM7XG4gIGlzVHNzPzogYm9vbGVhbjtcbiAgYml0Z29GZWVBZGRyZXNzPzogc3RyaW5nO1xuICBiaXRnb0Rlc3RpbmF0aW9uQWRkcmVzcz86IHN0cmluZztcbiAgdG9rZW5Db250cmFjdEFkZHJlc3M/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIEdldEJhdGNoRXhlY3V0aW9uSW5mb1JUID0ge1xuICB2YWx1ZXM6IFtzdHJpbmdbXSwgc3RyaW5nW11dO1xuICB0b3RhbEFtb3VudDogc3RyaW5nO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBCdWlsZFRyYW5zYWN0aW9uUGFyYW1zIHtcbiAgdG86IHN0cmluZztcbiAgbm9uY2U/OiBudW1iZXI7XG4gIHZhbHVlOiBudW1iZXI7XG4gIGRhdGE/OiBCdWZmZXI7XG4gIGdhc1ByaWNlPzogbnVtYmVyO1xuICBnYXNMaW1pdD86IG51bWJlcjtcbiAgZWlwMTU1OT86IEVJUDE1NTk7XG4gIHJlcGxheVByb3RlY3Rpb25PcHRpb25zPzogUmVwbGF5UHJvdGVjdGlvbk9wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlcnlJbmZvIHtcbiAgaWQ6IHN0cmluZztcbiAgdHg6IHN0cmluZztcbiAgYmFja3VwS2V5Pzogc3RyaW5nO1xuICBjb2luPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlclRva2VuT3B0aW9ucyB7XG4gIHRva2VuQ29udHJhY3RBZGRyZXNzOiBzdHJpbmc7XG4gIHdhbGxldDogV2FsbGV0O1xuICByZWNpcGllbnQ6IHN0cmluZztcbiAgYnJvYWRjYXN0PzogYm9vbGVhbjtcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgcHJ2Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldFNlbmRNZXRob2RBcmdzT3B0aW9ucyB7XG4gIHJlY2lwaWVudDogUmVjaXBpZW50O1xuICBleHBpcmVUaW1lOiBudW1iZXI7XG4gIGNvbnRyYWN0U2VxdWVuY2VJZDogbnVtYmVyO1xuICBzaWduYXR1cmU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZW5kTWV0aG9kQXJncyB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xuICB2YWx1ZTogYW55O1xufVxuXG5pbnRlcmZhY2UgSG9wVHJhbnNhY3Rpb25CdWlsZE9wdGlvbnMge1xuICB3YWxsZXQ6IFdhbGxldDtcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEJ1aWxkT3B0aW9ucyB7XG4gIGhvcD86IGJvb2xlYW47XG4gIHdhbGxldD86IFdhbGxldDtcbiAgcmVjaXBpZW50cz86IFJlY2lwaWVudFtdO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBbaW5kZXg6IHN0cmluZ106IHVua25vd247XG59XG5cbmludGVyZmFjZSBGZWVFc3RpbWF0ZSB7XG4gIGdhc0xpbWl0RXN0aW1hdGU6IG51bWJlcjtcbiAgZmVlRXN0aW1hdGU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblByZWJ1aWxkIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQge1xuICBob3BUcmFuc2FjdGlvbj86IEhvcFByZWJ1aWxkO1xuICBidWlsZFBhcmFtczoge1xuICAgIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICB9O1xuICByZWNpcGllbnRzOiBUcmFuc2FjdGlvblJlY2lwaWVudFtdO1xuICBuZXh0Q29udHJhY3RTZXF1ZW5jZUlkOiBzdHJpbmc7XG4gIGdhc1ByaWNlOiBudW1iZXI7XG4gIGdhc0xpbWl0OiBudW1iZXI7XG4gIGlzQmF0Y2g6IGJvb2xlYW47XG4gIGNvaW46IHN0cmluZztcbiAgdG9rZW4/OiBzdHJpbmc7XG59XG5cbi8vIFRPRE86IFRoaXMgaW50ZXJmYWNlIHdpbGwgbmVlZCB0byBiZSB1cGRhdGVkIGZvciB0aGUgbmV3IGZlZSBtb2RlbCBpbnRyb2R1Y2VkIGluIHRoZSBMb25kb24gSGFyZCBGb3JrXG5pbnRlcmZhY2UgRXRoVHJhbnNhY3Rpb25QYXJhbXMgZXh0ZW5kcyBUcmFuc2FjdGlvblBhcmFtcyB7XG4gIGdhc1ByaWNlPzogbnVtYmVyO1xuICBnYXNMaW1pdD86IG51bWJlcjtcbiAgaG9wUGFyYW1zPzogSG9wUGFyYW1zO1xuICBob3A/OiBib29sZWFuO1xuICBwcmVidWlsZFR4PzogUHJlYnVpbGRUcmFuc2FjdGlvblJlc3VsdDtcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUV0aFRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHR4UGFyYW1zOiBFdGhUcmFuc2FjdGlvblBhcmFtcztcbn1cblxuaW50ZXJmYWNlIFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBUcmFuc2FjdGlvblByZWJ1aWxkLCBCYXNlUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHdhbGxldDogV2FsbGV0O1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlclRva2VuVHJhbnNhY3Rpb24ge1xuICBoYWxmU2lnbmVkOiB7XG4gICAgcmVjaXBpZW50OiBSZWNpcGllbnQ7XG4gICAgZXhwaXJlVGltZTogbnVtYmVyO1xuICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogbnVtYmVyO1xuICAgIG9wZXJhdGlvbkhhc2g6IHN0cmluZztcbiAgICBzaWduYXR1cmU6IHN0cmluZztcbiAgICBnYXNMaW1pdDogbnVtYmVyO1xuICAgIGdhc1ByaWNlOiBudW1iZXI7XG4gICAgdG9rZW5Db250cmFjdEFkZHJlc3M6IHN0cmluZztcbiAgICB3YWxsZXRJZDogc3RyaW5nO1xuICB9O1xufVxuXG5pbnRlcmZhY2UgRXRoQWRkcmVzc0NvaW5TcGVjaWZpY3MgZXh0ZW5kcyBBZGRyZXNzQ29pblNwZWNpZmljIHtcbiAgZm9yd2FyZGVyVmVyc2lvbjogbnVtYmVyO1xuICBzYWx0Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVmVyaWZ5RXRoQWRkcmVzc09wdGlvbnMgZXh0ZW5kcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMge1xuICBiYXNlQWRkcmVzczogc3RyaW5nO1xuICBjb2luU3BlY2lmaWM6IEV0aEFkZHJlc3NDb2luU3BlY2lmaWNzO1xuICBmb3J3YXJkZXJWZXJzaW9uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBFdGggZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHN0YXRpYyBob3BUcmFuc2FjdGlvblNhbHQgPSAnYml0Z29Ib3BBZGRyZXNzUmVxdWVzdFNhbHQnO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc2VuZE1ldGhvZE5hbWU6ICdzZW5kTXVsdGlTaWcnIHwgJ3NlbmRNdWx0aVNpZ1Rva2VuJztcblxuICByZWFkb25seSBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj47XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcbiAgICB0aGlzLnN0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gICAgdGhpcy5zZW5kTWV0aG9kTmFtZSA9ICdzZW5kTXVsdGlTaWcnO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IEV0aChiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY29ycmVjdCBFdGggQ29tbW9uIG9iamVjdCBiYXNlZCBvbiBwYXJhbXMgZnJvbSBlaXRoZXIgcmVjb3Zlcnkgb3IgdHggYnVpbGRpbmdcbiAgICogQHBhcmFtIGVpcDE1NTkge0VJUDE1NTl9IGNvbmZpZ3MgdGhhdCBzcGVjaWZ5IHdoZXRoZXIgd2Ugc2hvdWxkIGNvbnN0cnVjdCBhbiBlaXAxNTU5IHR4XG4gICAqIEBwYXJhbSByZXBsYXlQcm90ZWN0aW9uT3B0aW9ucyB7UmVwbGF5UHJvdGVjdGlvbk9wdGlvbnN9IGNoZWNrIGlmIGNoYWluIGlkIHN1cHBvcnRzIHJlcGxheSBwcm90ZWN0aW9uXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBnZXRFdGhDb21tb24oZWlwMTU1OT86IEVJUDE1NTksIHJlcGxheVByb3RlY3Rpb25PcHRpb25zPzogUmVwbGF5UHJvdGVjdGlvbk9wdGlvbnMpIHtcbiAgICAvLyBpZiBlaXAxNTU5IHBhcmFtcyBhcmUgc3BlY2lmaWVkLCBkZWZhdWx0IHRvIGxvbmRvbiBoYXJkZm9yaywgb3RoZXJ3aXNlLFxuICAgIC8vIGRlZmF1bHQgdG8gdGFuZ2VyaW5lIHdoaXN0bGUgdG8gYXZvaWQgcmVwbGF5IHByb3RlY3Rpb24gaXNzdWVzXG4gICAgY29uc3QgZGVmYXVsdEhhcmRmb3JrID0gISFlaXAxNTU5ID8gJ2xvbmRvbicgOiBvcHRpb25hbERlcHMuRXRoQ29tbW9uLkhhcmRmb3JrLlRhbmdlcmluZVdoaXN0bGU7XG4gICAgY29uc3QgZGVmYXVsdENvbW1vbiA9IG5ldyBvcHRpb25hbERlcHMuRXRoQ29tbW9uLmRlZmF1bHQoe1xuICAgICAgY2hhaW46IG9wdGlvbmFsRGVwcy5FdGhDb21tb24uQ2hhaW4uTWFpbm5ldCxcbiAgICAgIGhhcmRmb3JrOiBkZWZhdWx0SGFyZGZvcmssXG4gICAgfSk7XG5cbiAgICAvLyBpZiByZXBsYXkgcHJvdGVjdGlvbiBvcHRpb25zIGFyZSBzZXQsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGNvbW1vbiBzZXR0aW5nXG4gICAgY29uc3QgZXRoQ29tbW9uID0gcmVwbGF5UHJvdGVjdGlvbk9wdGlvbnNcbiAgICAgID8gb3B0aW9uYWxEZXBzLkV0aENvbW1vbi5kZWZhdWx0LmlzU3VwcG9ydGVkQ2hhaW5JZChuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocmVwbGF5UHJvdGVjdGlvbk9wdGlvbnMuY2hhaW4pKVxuICAgICAgICA/IG5ldyBvcHRpb25hbERlcHMuRXRoQ29tbW9uLmRlZmF1bHQoe1xuICAgICAgICAgICAgY2hhaW46IHJlcGxheVByb3RlY3Rpb25PcHRpb25zLmNoYWluLFxuICAgICAgICAgICAgaGFyZGZvcms6IHJlcGxheVByb3RlY3Rpb25PcHRpb25zLmhhcmRmb3JrLFxuICAgICAgICAgIH0pXG4gICAgICAgIDogb3B0aW9uYWxEZXBzLkV0aENvbW1vbi5kZWZhdWx0LmN1c3RvbSh7XG4gICAgICAgICAgICBjaGFpbklkOiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocmVwbGF5UHJvdGVjdGlvbk9wdGlvbnMuY2hhaW4pLFxuICAgICAgICAgICAgZGVmYXVsdEhhcmRmb3JrOiByZXBsYXlQcm90ZWN0aW9uT3B0aW9ucy5oYXJkZm9yayxcbiAgICAgICAgICB9KVxuICAgICAgOiBkZWZhdWx0Q29tbW9uO1xuICAgIHJldHVybiBldGhDb21tb247XG4gIH1cblxuICBzdGF0aWMgYnVpbGRUcmFuc2FjdGlvbihwYXJhbXM6IEJ1aWxkVHJhbnNhY3Rpb25QYXJhbXMpOiBFdGhUeExpYi5GZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24gfCBFdGhUeExpYi5UcmFuc2FjdGlvbiB7XG4gICAgLy8gaWYgZWlwMTU1OSBwYXJhbXMgYXJlIHNwZWNpZmllZCwgZGVmYXVsdCB0byBsb25kb24gaGFyZGZvcmssIG90aGVyd2lzZSxcbiAgICAvLyBkZWZhdWx0IHRvIHRhbmdlcmluZSB3aGlzdGxlIHRvIGF2b2lkIHJlcGxheSBwcm90ZWN0aW9uIGlzc3Vlc1xuICAgIGNvbnN0IGV0aENvbW1vbiA9IEV0aC5nZXRFdGhDb21tb24ocGFyYW1zLmVpcDE1NTksIHBhcmFtcy5yZXBsYXlQcm90ZWN0aW9uT3B0aW9ucyk7XG5cbiAgICBjb25zdCBiYXNlUGFyYW1zID0ge1xuICAgICAgdG86IHBhcmFtcy50byxcbiAgICAgIG5vbmNlOiBwYXJhbXMubm9uY2UsXG4gICAgICB2YWx1ZTogcGFyYW1zLnZhbHVlLFxuICAgICAgZGF0YTogcGFyYW1zLmRhdGEsXG4gICAgICBnYXNMaW1pdDogbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHBhcmFtcy5nYXNMaW1pdCksXG4gICAgfTtcblxuICAgIGNvbnN0IHVuc2lnbmVkRXRoVHggPSAhIXBhcmFtcy5laXAxNTU5XG4gICAgICA/IG9wdGlvbmFsRGVwcy5FdGhUeC5GZWVNYXJrZXRFSVAxNTU5VHJhbnNhY3Rpb24uZnJvbVR4RGF0YShcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi5iYXNlUGFyYW1zLFxuICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocGFyYW1zLmVpcDE1NTkubWF4RmVlUGVyR2FzKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocGFyYW1zLmVpcDE1NTkubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBjb21tb246IGV0aENvbW1vbiB9XG4gICAgICAgIClcbiAgICAgIDogb3B0aW9uYWxEZXBzLkV0aFR4LlRyYW5zYWN0aW9uLmZyb21UeERhdGEoXG4gICAgICAgICAge1xuICAgICAgICAgICAgLi4uYmFzZVBhcmFtcyxcbiAgICAgICAgICAgIGdhc1ByaWNlOiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocGFyYW1zLmdhc1ByaWNlKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgY29tbW9uOiBldGhDb21tb24gfVxuICAgICAgICApO1xuXG4gICAgcmV0dXJuIHVuc2lnbmVkRXRoVHg7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgc3VwcG9ydHNUc3MoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgaXNFVk0oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXRNUENBbGdvcml0aG0oKTogTVBDQWxnb3JpdGhtIHtcbiAgICByZXR1cm4gJ2VjZHNhJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRCYXNlRmFjdG9yKCk6IHN0cmluZyB7XG4gICAgLy8gMTBeMThcbiAgICByZXR1cm4gJzEwMDAwMDAwMDAwMDAwMDAwMDAnO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2V0aCc7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2V0aCc7XG4gIH1cblxuICBnZXROZXR3b3JrKCk6IEV0aGVyZXVtTmV0d29yayB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGljc0NvaW4/Lm5ldHdvcmsgYXMgRXRoZXJldW1OZXR3b3JrO1xuICB9XG5cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0V0aGVyZXVtJztcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgZGF0YSBhbG9uZyB3aXRoIHRyYW5zYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgdHggZGF0YSAoRVRIKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB0cmFuc2FjdGlvbkRhdGFBbGxvd2VkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB3aGV0aGVyIGFuIGFkZHJlc3Mgc3RyaW5nIGlzIHZhbGlkIGZvciB0aGlzIGNvaW5cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBvcHRpb25hbERlcHMuZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyhvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgoYWRkcmVzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYmlwMzIuZnJvbUJhc2U1OChwdWIpLmlzTmV1dGVyZWQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZ2FzIHByaWNlIGZyb20gcGxhdGZvcm1cbiAgICogQHJldHVybnMge0JpZ051bWJlcn1cbiAgICovXG4gIGdldFJlY292ZXJ5R2FzUHJpY2UoKTogYW55IHtcbiAgICByZXR1cm4gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKCcyMDAwMDAwMDAwMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZ2FzIGxpbWl0IGZyb20gcGxhdGZvcm1cbiAgICogQHJldHVybnMge0JpZ051bWJlcn1cbiAgICovXG4gIGdldFJlY292ZXJ5R2FzTGltaXQoKTogYW55IHtcbiAgICByZXR1cm4gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKCc1MDAwMDAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGV4cGlyZSB0aW1lIGZvciBhIGNvbnRyYWN0IGNhbGwgKDEgd2VlaylcbiAgICogQHJldHVybnMge251bWJlcn0gVGltZSBpbiBzZWNvbmRzXG4gICAqL1xuICBnZXREZWZhdWx0RXhwaXJlVGltZSgpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyA2MCAqIDYwICogMjQgKiA3O1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IEV0aGVyc2NhbiBmb3IgdGhlIGJhbGFuY2Ugb2YgYW4gYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSB0aGUgRVRIIGFkZHJlc3NcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gYWRkcmVzcyBiYWxhbmNlXG4gICAqL1xuICBhc3luYyBxdWVyeUFkZHJlc3NCYWxhbmNlKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWNvdmVyeUJsb2NrY2hhaW5FeHBsb3JlclF1ZXJ5KHtcbiAgICAgIG1vZHVsZTogJ2FjY291bnQnLFxuICAgICAgYWN0aW9uOiAnYmFsYW5jZScsXG4gICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgIH0pO1xuICAgIC8vIHRocm93IGlmIHRoZSByZXN1bHQgZG9lcyBub3QgZXhpc3Qgb3IgdGhlIHJlc3VsdCBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnJlc3VsdCB8fCBpc05hTihyZXN1bHQucmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3Qgb2J0YWluIGFkZHJlc3MgYmFsYW5jZSBmb3IgJHthZGRyZXNzfSBmcm9tIEV0aGVyc2NhbiwgZ290OiAke3Jlc3VsdC5yZXN1bHR9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocmVzdWx0LnJlc3VsdCwgMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJ5IEV0aGVyc2NhbiBmb3IgdGhlIGJhbGFuY2Ugb2YgYW4gYWRkcmVzcyBmb3IgYSB0b2tlblxuICAgKiBAcGFyYW0gdG9rZW5Db250cmFjdEFkZHJlc3Mge1N0cmluZ30gYWRkcmVzcyB3aGVyZSB0aGUgdG9rZW4gc21hcnQgY29udHJhY3QgaXMgaG9zdGVkXG4gICAqIEBwYXJhbSB3YWxsZXRDb250cmFjdEFkZHJlc3Mge1N0cmluZ30gYWRkcmVzcyBvZiB0aGUgd2FsbGV0XG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IHRva2VuIGJhbGFhbmNlIGluIGJhc2UgdW5pdHNcbiAgICovXG4gIGFzeW5jIHF1ZXJ5QWRkcmVzc1Rva2VuQmFsYW5jZSh0b2tlbkNvbnRyYWN0QWRkcmVzczogc3RyaW5nLCB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFvcHRpb25hbERlcHMuZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyh0b2tlbkNvbnRyYWN0QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdldCBiYWxhbmNlIGZvciBpbnZhbGlkIHRva2VuIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25hbERlcHMuZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyh3YWxsZXRDb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgdG9rZW4gYmFsYW5jZSBmb3IgaW52YWxpZCB3YWxsZXQgYWRkcmVzcycpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeSh7XG4gICAgICBtb2R1bGU6ICdhY2NvdW50JyxcbiAgICAgIGFjdGlvbjogJ3Rva2VuYmFsYW5jZScsXG4gICAgICBjb250cmFjdGFkZHJlc3M6IHRva2VuQ29udHJhY3RBZGRyZXNzLFxuICAgICAgYWRkcmVzczogd2FsbGV0Q29udHJhY3RBZGRyZXNzLFxuICAgICAgdGFnOiAnbGF0ZXN0JyxcbiAgICB9KTtcbiAgICAvLyB0aHJvdyBpZiB0aGUgcmVzdWx0IGRvZXMgbm90IGV4aXN0IG9yIHRoZSByZXN1bHQgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5yZXN1bHQgfHwgaXNOYU4ocmVzdWx0LnJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvdWxkIG5vdCBvYnRhaW4gdG9rZW4gYWRkcmVzcyBiYWxhbmNlIGZvciAke3Rva2VuQ29udHJhY3RBZGRyZXNzfSBmcm9tIEV0aGVyc2NhbiwgZ290OiAke3Jlc3VsdC5yZXN1bHR9YFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihyZXN1bHQucmVzdWx0LCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRyYW5zZmVyIG9wZXJhdGlvbiBmb3IgY29pblxuICAgKiBAcGFyYW0gcmVjaXBpZW50IHJlY2lwaWVudCBpbmZvXG4gICAqIEBwYXJhbSBleHBpcmVUaW1lIGV4cGlyeSB0aW1lXG4gICAqIEBwYXJhbSBjb250cmFjdFNlcXVlbmNlSWQgc2VxdWVuY2UgaWRcbiAgICogQHJldHVybnMge0FycmF5fSBvcGVyYXRpb24gYXJyYXlcbiAgICovXG4gIGdldE9wZXJhdGlvbihyZWNpcGllbnQ6IFJlY2lwaWVudCwgZXhwaXJlVGltZTogbnVtYmVyLCBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlcik6IChzdHJpbmcgfCBCdWZmZXIpW11bXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFsnc3RyaW5nJywgJ2FkZHJlc3MnLCAndWludCcsICdieXRlcycsICd1aW50JywgJ3VpbnQnXSxcbiAgICAgIFtcbiAgICAgICAgJ0VUSEVSJyxcbiAgICAgICAgbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KHJlY2lwaWVudC5hZGRyZXNzKSwgMTYpLFxuICAgICAgICByZWNpcGllbnQuYW1vdW50LFxuICAgICAgICBCdWZmZXIuZnJvbShvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChvcHRpb25hbERlcHMuZXRoVXRpbC5wYWRUb0V2ZW4ocmVjaXBpZW50LmRhdGEgfHwgJycpKSwgJ2hleCcpLFxuICAgICAgICBleHBpcmVUaW1lLFxuICAgICAgICBjb250cmFjdFNlcXVlbmNlSWQsXG4gICAgICBdLFxuICAgIF07XG4gIH1cblxuICBnZXRPcGVyYXRpb25TaGEzRm9yRXhlY3V0ZUFuZENvbmZpcm0oXG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W10sXG4gICAgZXhwaXJlVGltZTogbnVtYmVyLFxuICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogbnVtYmVyXG4gICk6IHN0cmluZyB7XG4gICAgaWYgKCFyZWNpcGllbnRzIHx8ICFBcnJheS5pc0FycmF5KHJlY2lwaWVudHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBhcnJheSBvZiByZWNpcGllbnRzJyk7XG4gICAgfVxuXG4gICAgLy8gUmlnaHQgbm93IHdlIG9ubHkgc3VwcG9ydCAxIHJlY2lwaWVudFxuICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNlbmQgdG8gZXhhY3RseSAxIHJlY2lwaWVudCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc051bWJlcihleHBpcmVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBpcmVUaW1lIG11c3QgYmUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgZXBvY2gnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIoY29udHJhY3RTZXF1ZW5jZUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb250cmFjdFNlcXVlbmNlSWQgbXVzdCBiZSBudW1iZXInKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpbnB1dHNcbiAgICByZWNpcGllbnRzLmZvckVhY2goZnVuY3Rpb24gKHJlY2lwaWVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAhXy5pc1N0cmluZyhyZWNpcGllbnQuYWRkcmVzcykgfHxcbiAgICAgICAgIW9wdGlvbmFsRGVwcy5ldGhVdGlsLmlzVmFsaWRBZGRyZXNzKG9wdGlvbmFsRGVwcy5ldGhVdGlsLmFkZEhleFByZWZpeChyZWNpcGllbnQuYWRkcmVzcykpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3M6ICcgKyByZWNpcGllbnQuYWRkcmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBhbW91bnQ7XG4gICAgICB0cnkge1xuICAgICAgICBhbW91bnQgPSBuZXcgQmlnTnVtYmVyKHJlY2lwaWVudC5hbW91bnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYW1vdW50IGZvcjogJyArIHJlY2lwaWVudC5hZGRyZXNzICsgJyAtIHNob3VsZCBiZSBudW1lcmljJyk7XG4gICAgICB9XG5cbiAgICAgIHJlY2lwaWVudC5hbW91bnQgPSBhbW91bnQudG9GaXhlZCgwKTtcblxuICAgICAgaWYgKHJlY2lwaWVudC5kYXRhICYmICFfLmlzU3RyaW5nKHJlY2lwaWVudC5kYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgZm9yIHJlY2lwaWVudCAnICsgcmVjaXBpZW50LmFkZHJlc3MgKyAnIC0gc2hvdWxkIGJlIG9mIHR5cGUgaGV4IHN0cmluZycpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVjaXBpZW50ID0gcmVjaXBpZW50c1swXTtcbiAgICByZXR1cm4gb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgoXG4gICAgICBvcHRpb25hbERlcHMuZXRoQWJpLnNvbGlkaXR5U0hBMyguLi50aGlzLmdldE9wZXJhdGlvbihyZWNpcGllbnQsIGV4cGlyZVRpbWUsIGNvbnRyYWN0U2VxdWVuY2VJZCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyaWVzIHRoZSBjb250cmFjdCAodmlhIEV0aGVyc2NhbikgZm9yIHRoZSBuZXh0IHNlcXVlbmNlIElEXG4gICAqIEBwYXJhbSBhZGRyZXNzIHtTdHJpbmd9IGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHNlcXVlbmNlIElEXG4gICAqL1xuICBhc3luYyBxdWVyeVNlcXVlbmNlSWQoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBHZXQgc2VxdWVuY2UgSUQgdXNpbmcgY29udHJhY3QgY2FsbFxuICAgIGNvbnN0IHNlcXVlbmNlSWRNZXRob2RTaWduYXR1cmUgPSBvcHRpb25hbERlcHMuZXRoQWJpLm1ldGhvZElEKCdnZXROZXh0U2VxdWVuY2VJZCcsIFtdKTtcbiAgICBjb25zdCBzZXF1ZW5jZUlkQXJncyA9IG9wdGlvbmFsRGVwcy5ldGhBYmkucmF3RW5jb2RlKFtdLCBbXSk7XG4gICAgY29uc3Qgc2VxdWVuY2VJZERhdGEgPSBCdWZmZXIuY29uY2F0KFtzZXF1ZW5jZUlkTWV0aG9kU2lnbmF0dXJlLCBzZXF1ZW5jZUlkQXJnc10pLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkoe1xuICAgICAgbW9kdWxlOiAncHJveHknLFxuICAgICAgYWN0aW9uOiAnZXRoX2NhbGwnLFxuICAgICAgdG86IGFkZHJlc3MsXG4gICAgICBkYXRhOiBzZXF1ZW5jZUlkRGF0YSxcbiAgICAgIHRhZzogJ2xhdGVzdCcsXG4gICAgfSk7XG4gICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5yZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IG9idGFpbiBzZXF1ZW5jZSBJRCBmcm9tIEV0aGVyc2NhbiwgZ290OiAnICsgcmVzdWx0LnJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IHNlcXVlbmNlSWRIZXggPSByZXN1bHQucmVzdWx0O1xuICAgIHJldHVybiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4oc2VxdWVuY2VJZEhleC5zbGljZSgyKSwgMTYpLnRvTnVtYmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBzaWduVHJhbnNhY3Rpb24gZm9yIHRoZSByYXJlIGNhc2UgdGhhdCBTREsgaXMgZG9pbmcgdGhlIHNlY29uZCBzaWduYXR1cmVcbiAgICogTm90ZTogd2UgYXJlIGV4cGVjdGluZyB0aGlzIHRvIGJlIGNhbGxlZCBmcm9tIHRoZSBvZmZsaW5lIHZhdWx0XG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZFxuICAgKiBAcGFyYW0gcGFyYW1zLnNpZ25pbmdLZXlOb25jZVxuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzc1xuICAgKiBAcGFyYW0gcGFyYW1zLnBydlxuICAgKiBAcmV0dXJucyB7e3R4SGV4OiAqfX1cbiAgICovXG4gIHNpZ25GaW5hbChwYXJhbXM6IFNpZ25GaW5hbE9wdGlvbnMpOiBGdWxseVNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCB0eFByZWJ1aWxkID0gcGFyYW1zLnR4UHJlYnVpbGQ7XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLnNpZ25pbmdLZXlOb25jZSkgJiYgIV8uaXNOdW1iZXIocGFyYW1zLnR4UHJlYnVpbGQuaGFsZlNpZ25lZC5iYWNrdXBLZXlOb25jZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ211c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb2Ygc2lnbmluZ0tleU5vbmNlIGFuZCBiYWNrdXBLZXlOb25jZSBhcyBhIHBhcmFtZXRlciwgYW5kIGl0IG11c3QgYmUgYSBudW1iZXInXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJhbXMgbXVzdCBpbmNsdWRlIHdhbGxldENvbnRyYWN0QWRkcmVzcywgYnV0IGdvdCB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWduaW5nTm9kZSA9IGJpcDMyLmZyb21CYXNlNTgocGFyYW1zLnBydik7XG4gICAgY29uc3Qgc2lnbmluZ0tleSA9IHNpZ25pbmdOb2RlLnByaXZhdGVLZXk7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoc2lnbmluZ0tleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwcml2YXRlIGtleScpO1xuICAgIH1cblxuICAgIGNvbnN0IHR4SW5mbyA9IHtcbiAgICAgIHJlY2lwaWVudDogdHhQcmVidWlsZC5yZWNpcGllbnRzWzBdLFxuICAgICAgZXhwaXJlVGltZTogdHhQcmVidWlsZC5oYWxmU2lnbmVkLmV4cGlyZVRpbWUsXG4gICAgICBjb250cmFjdFNlcXVlbmNlSWQ6IHR4UHJlYnVpbGQuaGFsZlNpZ25lZC5jb250cmFjdFNlcXVlbmNlSWQsXG4gICAgICBzaWduYXR1cmU6IHR4UHJlYnVpbGQuaGFsZlNpZ25lZC5zaWduYXR1cmUsXG4gICAgfTtcblxuICAgIGNvbnN0IHNlbmRNZXRob2RBcmdzID0gdGhpcy5nZXRTZW5kTWV0aG9kQXJncyh0eEluZm8pO1xuICAgIGNvbnN0IG1ldGhvZFNpZ25hdHVyZSA9IG9wdGlvbmFsRGVwcy5ldGhBYmkubWV0aG9kSUQodGhpcy5zZW5kTWV0aG9kTmFtZSwgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJykpO1xuICAgIGNvbnN0IGVuY29kZWRBcmdzID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5yYXdFbmNvZGUoXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJyksIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndmFsdWUnKSk7XG4gICAgY29uc3Qgc2VuZERhdGEgPSBCdWZmZXIuY29uY2F0KFttZXRob2RTaWduYXR1cmUsIGVuY29kZWRBcmdzXSk7XG5cbiAgICBjb25zdCBldGhUeFBhcmFtcyA9IHtcbiAgICAgIHRvOiBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzLFxuICAgICAgbm9uY2U6XG4gICAgICAgIHBhcmFtcy5zaWduaW5nS2V5Tm9uY2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtcy5zaWduaW5nS2V5Tm9uY2UgOiBwYXJhbXMudHhQcmVidWlsZC5oYWxmU2lnbmVkLmJhY2t1cEtleU5vbmNlLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBnYXNQcmljZTogbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHR4UHJlYnVpbGQuZ2FzUHJpY2UpLFxuICAgICAgZ2FzTGltaXQ6IG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTih0eFByZWJ1aWxkLmdhc0xpbWl0KSxcbiAgICAgIGRhdGE6IHNlbmREYXRhLFxuICAgIH07XG5cbiAgICBjb25zdCB1bnNpZ25lZEV0aFR4ID0gRXRoLmJ1aWxkVHJhbnNhY3Rpb24oe1xuICAgICAgLi4uZXRoVHhQYXJhbXMsXG4gICAgICBlaXAxNTU5OiBwYXJhbXMudHhQcmVidWlsZC5laXAxNTU5LFxuICAgICAgcmVwbGF5UHJvdGVjdGlvbk9wdGlvbnM6IHBhcmFtcy50eFByZWJ1aWxkLnJlcGxheVByb3RlY3Rpb25PcHRpb25zLFxuICAgIH0pO1xuXG4gICAgY29uc3QgZXRoVHggPSB1bnNpZ25lZEV0aFR4LnNpZ24oc2lnbmluZ0tleSk7XG5cbiAgICByZXR1cm4geyB0eEhleDogZXRoVHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpIH07XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gdHhQcmVidWlsZFxuICAgKiAtIHBydlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj59XG4gICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHR4UHJlYnVpbGQgPSBwYXJhbXMudHhQcmVidWlsZDtcblxuICAgIGNvbnN0IHVzZXJQcnYgPSBwYXJhbXMucHJ2O1xuICAgIGNvbnN0IEVYUElSRVRJTUVfREVGQVVMVCA9IDYwICogNjAgKiAyNCAqIDc7IC8vIFRoaXMgc2lnbmF0dXJlIHdpbGwgYmUgdmFsaWQgZm9yIDEgd2Vla1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgfHwgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh0eFByZWJ1aWxkKSAmJiAhXy5pc09iamVjdCh0eFByZWJ1aWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4UHJlYnVpbGR9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh1c2VyUHJ2KSB8fCAhXy5pc1N0cmluZyh1c2VyUHJ2KSkge1xuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHVzZXJQcnYpICYmICFfLmlzU3RyaW5nKHVzZXJQcnYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHVzZXJQcnZ9YCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgcGFyYW1zLnJlY2lwaWVudHMgPSB0eFByZWJ1aWxkLnJlY2lwaWVudHMgfHwgcGFyYW1zLnJlY2lwaWVudHM7XG5cbiAgICAvLyBpZiBubyByZWNpcGllbnRzIGluIGVpdGhlciBwYXJhbXMgb3IgdHhQcmVidWlsZCwgdGhlbiB0aHJvdyBhbiBlcnJvclxuICAgIGlmICghcGFyYW1zLnJlY2lwaWVudHMgfHwgIUFycmF5LmlzQXJyYXkocGFyYW1zLnJlY2lwaWVudHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2lwaWVudHMgbWlzc2luZyBvciBub3QgYXJyYXknKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVjaXBpZW50cyBlbXB0eScpO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGx5IHRoZSBTREsgcHJvdmlkZXMgdGhlIGZpcnN0IHNpZ25hdHVyZSBmb3IgYW4gRVRIIHR4LCBidXQgb2NjYXNpb25hbGx5IGl0IHByb3ZpZGVzIHRoZSBzZWNvbmQgYW5kIGZpbmFsIG9uZS5cbiAgICBpZiAocGFyYW1zLmlzTGFzdFNpZ25hdHVyZSkge1xuICAgICAgLy8gSW4gdGhpcyBjYXNlIHdoZW4gd2UncmUgZG9pbmcgdGhlIHNlY29uZCAoZmluYWwpIHNpZ25hdHVyZSwgdGhlIGxvZ2ljIGlzIGRpZmZlcmVudC5cbiAgICAgIHJldHVybiB0aGlzLnNpZ25GaW5hbChwYXJhbXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY29uZHNTaW5jZUVwb2NoID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApO1xuICAgIGNvbnN0IGV4cGlyZVRpbWUgPSBwYXJhbXMuZXhwaXJlVGltZSB8fCBzZWNvbmRzU2luY2VFcG9jaCArIEVYUElSRVRJTUVfREVGQVVMVDtcbiAgICBjb25zdCBzZXF1ZW5jZUlkID0gdHhQcmVidWlsZC5uZXh0Q29udHJhY3RTZXF1ZW5jZUlkO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQoc2VxdWVuY2VJZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBuZXh0Q29udHJhY3RTZXF1ZW5jZUlkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3BlcmF0aW9uSGFzaCA9IHRoaXMuZ2V0T3BlcmF0aW9uU2hhM0ZvckV4ZWN1dGVBbmRDb25maXJtKHBhcmFtcy5yZWNpcGllbnRzLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBVdGlsLmV0aFNpZ25Nc2dIYXNoKG9wZXJhdGlvbkhhc2gsIFV0aWwueHBydlRvRXRoUHJpdmF0ZUtleSh1c2VyUHJ2KSk7XG5cbiAgICBjb25zdCB0eFBhcmFtcyA9IHtcbiAgICAgIGVpcDE1NTk6IHBhcmFtcy50eFByZWJ1aWxkLmVpcDE1NTksXG4gICAgICBpc0JhdGNoOiBwYXJhbXMudHhQcmVidWlsZC5pc0JhdGNoLFxuICAgICAgcmVjaXBpZW50czogcGFyYW1zLnJlY2lwaWVudHMsXG4gICAgICBleHBpcmVUaW1lOiBleHBpcmVUaW1lLFxuICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiBzZXF1ZW5jZUlkLFxuICAgICAgc2VxdWVuY2VJZDogcGFyYW1zLnNlcXVlbmNlSWQsXG4gICAgICBvcGVyYXRpb25IYXNoOiBvcGVyYXRpb25IYXNoLFxuICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICBnYXNMaW1pdDogcGFyYW1zLmdhc0xpbWl0LFxuICAgICAgZ2FzUHJpY2U6IHBhcmFtcy5nYXNQcmljZSxcbiAgICAgIGhvcFRyYW5zYWN0aW9uOiB0eFByZWJ1aWxkLmhvcFRyYW5zYWN0aW9uLFxuICAgICAgYmFja3VwS2V5Tm9uY2U6IHR4UHJlYnVpbGQuYmFja3VwS2V5Tm9uY2UsXG4gICAgICBjdXN0b2RpYW5UcmFuc2FjdGlvbklkOiBwYXJhbXMuY3VzdG9kaWFuVHJhbnNhY3Rpb25JZCxcbiAgICB9O1xuICAgIHJldHVybiB7IGhhbGZTaWduZWQ6IHR4UGFyYW1zIH07XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGVpdGhlciBlbnRlcnByaXNlIG9yIG5ld0ZlZUFkZHJlc3MgaXMgcGFzc2VkLCB0byBrbm93IHdoZXRoZXIgdG8gY3JlYXRlIG5ldyBrZXkgb3IgdXNlIGVudGVycHJpc2Uga2V5XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5lbnRlcnByaXNlIHtTdHJpbmd9IHRoZSBlbnRlcnByaXNlIGlkIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMga2V5XG4gICAqIEBwYXJhbSBwYXJhbXMubmV3RmVlQWRkcmVzcyB7Qm9vbGVhbn0gY3JlYXRlIGEgbmV3IGZlZSBhZGRyZXNzIChlbnRlcnByaXNlIG5vdCBuZWVkZWQgaW4gdGhpcyBjYXNlKVxuICAgKi9cbiAgcHJlQ3JlYXRlQml0R28ocGFyYW1zOiBQcmVjcmVhdGVCaXRHb09wdGlvbnMpOiB2b2lkIHtcbiAgICAvLyBXZSBhbHdheXMgbmVlZCBwYXJhbXMgb2JqZWN0LCBzaW5jZSBlaXRoZXIgZW50ZXJwcmlzZSBvciBuZXdGZWVBZGRyZXNzIGlzIHJlcXVpcmVkXG4gICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJlQ3JlYXRlQml0R28gbXVzdCBiZSBwYXNzZWQgYSBwYXJhbXMgb2JqZWN0LiBHb3QgJHtwYXJhbXN9ICh0eXBlICR7dHlwZW9mIHBhcmFtc30pYCk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpICYmIF8uaXNVbmRlZmluZWQocGFyYW1zLm5ld0ZlZUFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdleHBlY3RpbmcgZW50ZXJwcmlzZSB3aGVuIGFkZGluZyBCaXRHbyBrZXkuIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG5ldyBFVEggYml0Z28ga2V5LCBzZXQgdGhlIG5ld0ZlZUFkZHJlc3MgcGFyYW1ldGVyIHRvIHRydWUuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB3aGV0aGVyIGtleSBzaG91bGQgYmUgYW4gZW50ZXJwcmlzZSBrZXkgb3IgYSBCaXRHbyBrZXkgZm9yIGEgbmV3IGZlZSBhZGRyZXNzXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5lbnRlcnByaXNlKSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMubmV3RmVlQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wYXRpYmxlIGFyZ3VtZW50cyAtIGNhbm5vdCBwYXNzIGJvdGggZW50ZXJwcmlzZSBhbmQgbmV3RmVlQWRkcmVzcyBwYXJhbWV0ZXIuYCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5lbnRlcnByaXNlKSAmJiAhXy5pc1N0cmluZyhwYXJhbXMuZW50ZXJwcmlzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZW50ZXJwcmlzZSBzaG91bGQgYmUgYSBzdHJpbmcgLSBnb3QgJHtwYXJhbXMuZW50ZXJwcmlzZX0gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLmVudGVycHJpc2V9KWApO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMubmV3RmVlQWRkcmVzcykgJiYgIV8uaXNCb29sZWFuKHBhcmFtcy5uZXdGZWVBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgbmV3RmVlQWRkcmVzcyBzaG91bGQgYmUgYSBib29sZWFuIC0gZ290ICR7cGFyYW1zLm5ld0ZlZUFkZHJlc3N9ICh0eXBlICR7dHlwZW9mIHBhcmFtcy5uZXdGZWVBZGRyZXNzfSlgXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyaWVzIHB1YmxpYyBibG9jayBleHBsb3JlciB0byBnZXQgdGhlIG5leHQgRVRIIG5vbmNlIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIHRoZSBnaXZlbiBFVEggYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGdldEFkZHJlc3NOb25jZShhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIC8vIEdldCBub25jZSBmb3IgYmFja3VwIGtleSAoc2hvdWxkIGJlIDApXG4gICAgbGV0IG5vbmNlID0gMDtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeSh7XG4gICAgICBtb2R1bGU6ICdhY2NvdW50JyxcbiAgICAgIGFjdGlvbjogJ3R4bGlzdCcsXG4gICAgICBhZGRyZXNzLFxuICAgIH0pO1xuICAgIGlmICghcmVzdWx0IHx8ICFBcnJheS5pc0FycmF5KHJlc3VsdC5yZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5leHQgbm9uY2UgZnJvbSBFdGhlcnNjYW4sIGdvdDogJyArIEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xuICAgIH1cbiAgICBjb25zdCBiYWNrdXBLZXlUeExpc3QgPSByZXN1bHQucmVzdWx0O1xuICAgIGlmIChiYWNrdXBLZXlUeExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIGxhc3Qgbm9uY2UgdXNlZFxuICAgICAgY29uc3Qgb3V0Z29pbmdUeHMgPSBiYWNrdXBLZXlUeExpc3QuZmlsdGVyKCh0eCkgPT4gdHguZnJvbSA9PT0gYWRkcmVzcyk7XG4gICAgICBub25jZSA9IG91dGdvaW5nVHhzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG5vbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcmVjb3ZlcigpXG4gICAqIFRoaXMgdHJhbnNmb3JtcyB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb24gaW5mb3JtYXRpb24gaW50byBhIGZvcm1hdCB0aGUgQml0R28gb2ZmbGluZSB2YXVsdCBleHBlY3RzXG4gICAqIEBwYXJhbSB0eEluZm9cbiAgICogQHBhcmFtIGV0aFR4XG4gICAqIEBwYXJhbSB1c2VyS2V5XG4gICAqIEBwYXJhbSBiYWNrdXBLZXlcbiAgICogQHBhcmFtIGdhc1ByaWNlXG4gICAqIEBwYXJhbSBnYXNMaW1pdFxuICAgKiBAcGFyYW0gZWlwMTU1OVxuICAgKiBAcGFyYW0gcmVwbGF5UHJvdGVjdGlvbk9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8T2ZmbGluZVZhdWx0VHhJbmZvPn1cbiAgICovXG4gIGFzeW5jIGZvcm1hdEZvck9mZmxpbmVWYXVsdChcbiAgICB0eEluZm86IFVuZm9ybWF0dGVkVHhJbmZvLFxuICAgIGV0aFR4OiBFdGhUeExpYi5UcmFuc2FjdGlvbiB8IEV0aFR4TGliLkZlZU1hcmtldEVJUDE1NTlUcmFuc2FjdGlvbixcbiAgICB1c2VyS2V5OiBzdHJpbmcsXG4gICAgYmFja3VwS2V5OiBzdHJpbmcsXG4gICAgZ2FzUHJpY2U6IEJ1ZmZlcixcbiAgICBnYXNMaW1pdDogbnVtYmVyLFxuICAgIGVpcDE1NTk/OiBFSVAxNTU5LFxuICAgIHJlcGxheVByb3RlY3Rpb25PcHRpb25zPzogUmVwbGF5UHJvdGVjdGlvbk9wdGlvbnNcbiAgKTogUHJvbWlzZTxPZmZsaW5lVmF1bHRUeEluZm8+IHtcbiAgICBpZiAoIWV0aFR4LnRvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aCB0eCBtdXN0IGhhdmUgYSBgdG9gIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgY29uc3QgYmFja3VwSEROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChiYWNrdXBLZXkpO1xuICAgIGNvbnN0IGJhY2t1cFNpZ25pbmdLZXkgPSBiYWNrdXBIRE5vZGUucHVibGljS2V5O1xuICAgIGNvbnN0IHJlc3BvbnNlOiBPZmZsaW5lVmF1bHRUeEluZm8gPSB7XG4gICAgICB0eDogZXRoVHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgdXNlcktleSxcbiAgICAgIGJhY2t1cEtleSxcbiAgICAgIGNvaW46IHRoaXMuZ2V0Q2hhaW4oKSxcbiAgICAgIGdhc1ByaWNlOiBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0ludChnYXNQcmljZSkudG9GaXhlZCgpLFxuICAgICAgZ2FzTGltaXQsXG4gICAgICByZWNpcGllbnRzOiBbdHhJbmZvLnJlY2lwaWVudF0sXG4gICAgICB3YWxsZXRDb250cmFjdEFkZHJlc3M6IGV0aFR4LnRvLnRvU3RyaW5nKCksXG4gICAgICBhbW91bnQ6IHR4SW5mby5yZWNpcGllbnQuYW1vdW50LFxuICAgICAgYmFja3VwS2V5Tm9uY2U6IGF3YWl0IHRoaXMuZ2V0QWRkcmVzc05vbmNlKFxuICAgICAgICBgMHgke29wdGlvbmFsRGVwcy5ldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhiYWNrdXBTaWduaW5nS2V5LCB0cnVlKS50b1N0cmluZygnaGV4Jyl9YFxuICAgICAgKSxcbiAgICAgIGVpcDE1NTksXG4gICAgICByZXBsYXlQcm90ZWN0aW9uT3B0aW9ucyxcbiAgICB9O1xuICAgIF8uZXh0ZW5kKHJlc3BvbnNlLCB0eEluZm8pO1xuICAgIHJlc3BvbnNlLm5leHRDb250cmFjdFNlcXVlbmNlSWQgPSByZXNwb25zZS5jb250cmFjdFNlcXVlbmNlSWQ7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcmVjb3ZlcigpXG4gICAqIFRoaXMgdHJhbnNmb3JtcyB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb24gaW5mb3JtYXRpb24gaW50byBhIGZvcm1hdCB0aGUgQml0R28gb2ZmbGluZSB2YXVsdCBleHBlY3RzXG4gICAqIEBwYXJhbSB0eEluZm9cbiAgICogQHBhcmFtIGV0aFR4XG4gICAqIEBwYXJhbSB1c2VyS2V5XG4gICAqIEBwYXJhbSBiYWNrdXBLZXlcbiAgICogQHBhcmFtIGdhc1ByaWNlXG4gICAqIEBwYXJhbSBnYXNMaW1pdFxuICAgKiBAcGFyYW0gZWlwMTU1OVxuICAgKiBAcGFyYW0gcmVwbGF5UHJvdGVjdGlvbk9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8T2ZmbGluZVZhdWx0VHhJbmZvPn1cbiAgICovXG4gIGZvcm1hdEZvck9mZmxpbmVWYXVsdFRTUyhcbiAgICB0eEluZm86IFVuZm9ybWF0dGVkVHhJbmZvLFxuICAgIGV0aFR4OiBFdGhUeExpYi5UcmFuc2FjdGlvbiB8IEV0aFR4TGliLkZlZU1hcmtldEVJUDE1NTlUcmFuc2FjdGlvbixcbiAgICB1c2VyS2V5OiBzdHJpbmcsXG4gICAgYmFja3VwS2V5OiBzdHJpbmcsXG4gICAgZ2FzUHJpY2U6IEJ1ZmZlcixcbiAgICBnYXNMaW1pdDogbnVtYmVyLFxuICAgIGJhY2t1cEtleU5vbmNlOiBudW1iZXIsXG4gICAgZWlwMTU1OT86IEVJUDE1NTksXG4gICAgcmVwbGF5UHJvdGVjdGlvbk9wdGlvbnM/OiBSZXBsYXlQcm90ZWN0aW9uT3B0aW9uc1xuICApOiBPZmZsaW5lVmF1bHRUeEluZm8ge1xuICAgIGlmICghZXRoVHgudG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXRoIHR4IG11c3QgaGF2ZSBhIGB0b2AgYWRkcmVzcycpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZTogT2ZmbGluZVZhdWx0VHhJbmZvID0ge1xuICAgICAgdHg6IGV0aFR4LnNlcmlhbGl6ZSgpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHR4SGV4OiBldGhUeC5nZXRNZXNzYWdlVG9TaWduKGZhbHNlKS50b1N0cmluZygnaGV4JyksXG4gICAgICB1c2VyS2V5LFxuICAgICAgYmFja3VwS2V5LFxuICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgZ2FzUHJpY2U6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSW50KGdhc1ByaWNlKS50b0ZpeGVkKCksXG4gICAgICBnYXNMaW1pdCxcbiAgICAgIHJlY2lwaWVudHM6IFt0eEluZm8ucmVjaXBpZW50XSxcbiAgICAgIHdhbGxldENvbnRyYWN0QWRkcmVzczogZXRoVHgudG8udG9TdHJpbmcoKSxcbiAgICAgIGFtb3VudDogdHhJbmZvLnJlY2lwaWVudC5hbW91bnQsXG4gICAgICBiYWNrdXBLZXlOb25jZTogYmFja3VwS2V5Tm9uY2UsXG4gICAgICBlaXAxNTU5LFxuICAgICAgcmVwbGF5UHJvdGVjdGlvbk9wdGlvbnMsXG4gICAgfTtcbiAgICBfLmV4dGVuZChyZXNwb25zZSwgdHhJbmZvKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2FzIHByaWNlIHBhc3NlZCBpbiBieSB1c2VyIGFyZSB3aXRoaW4gb3VyIG1heCBhbmQgbWluIGJvdW5kc1xuICAgKiBJZiB0aGV5IGFyZSBub3Qgc2V0LCBzZXQgdGhlbSB0byB0aGUgZGVmYXVsdHNcbiAgICogQHBhcmFtIHVzZXJHYXNQcmljZSB1c2VyIGRlZmluZWQgZ2FzIHByaWNlXG4gICAqIEByZXR1cm5zIHRoZSBnYXMgcHJpY2UgdG8gdXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uXG4gICAqL1xuICBzZXRHYXNQcmljZSh1c2VyR2FzUHJpY2U/OiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmICghdXNlckdhc1ByaWNlKSB7XG4gICAgICByZXR1cm4gZXRoR2FzQ29uZmlncy5kZWZhdWx0R2FzUHJpY2U7XG4gICAgfVxuXG4gICAgY29uc3QgZ2FzUHJpY2VNYXggPSBldGhHYXNDb25maWdzLm1heGltdW1HYXNQcmljZTtcbiAgICBjb25zdCBnYXNQcmljZU1pbiA9IGV0aEdhc0NvbmZpZ3MubWluaW11bUdhc1ByaWNlO1xuICAgIGlmICh1c2VyR2FzUHJpY2UgPCBnYXNQcmljZU1pbiB8fCB1c2VyR2FzUHJpY2UgPiBnYXNQcmljZU1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBHYXMgcHJpY2UgbXVzdCBiZSBiZXR3ZWVuICR7Z2FzUHJpY2VNaW59IGFuZCAke2dhc1ByaWNlTWF4fWApO1xuICAgIH1cbiAgICByZXR1cm4gdXNlckdhc1ByaWNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGdhcyBsaW1pdCBwYXNzZWQgaW4gYnkgdXNlciBhcmUgd2l0aGluIG91ciBtYXggYW5kIG1pbiBib3VuZHNcbiAgICogSWYgdGhleSBhcmUgbm90IHNldCwgc2V0IHRoZW0gdG8gdGhlIGRlZmF1bHRzXG4gICAqIEBwYXJhbSB1c2VyR2FzTGltaXQgdXNlciBkZWZpbmVkIGdhcyBsaW1pdFxuICAgKiBAcmV0dXJucyB0aGUgZ2FzIGxpbWl0IHRvIHVzZSBmb3IgdGhpcyB0cmFuc2FjdGlvblxuICAgKi9cbiAgc2V0R2FzTGltaXQodXNlckdhc0xpbWl0PzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoIXVzZXJHYXNMaW1pdCkge1xuICAgICAgcmV0dXJuIGV0aEdhc0NvbmZpZ3MuZGVmYXVsdEdhc0xpbWl0O1xuICAgIH1cbiAgICBjb25zdCBnYXNMaW1pdE1heCA9IGV0aEdhc0NvbmZpZ3MubWF4aW11bUdhc0xpbWl0O1xuICAgIGNvbnN0IGdhc0xpbWl0TWluID0gZXRoR2FzQ29uZmlncy5taW5pbXVtR2FzTGltaXQ7XG4gICAgaWYgKHVzZXJHYXNMaW1pdCA8IGdhc0xpbWl0TWluIHx8IHVzZXJHYXNMaW1pdCA+IGdhc0xpbWl0TWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdhcyBsaW1pdCBtdXN0IGJlIGJldHdlZW4gJHtnYXNMaW1pdE1pbn0gYW5kICR7Z2FzTGltaXRNYXh9YCk7XG4gICAgfVxuICAgIHJldHVybiB1c2VyR2FzTGltaXQ7XG4gIH1cblxuICB2YWxpZGF0ZVJlY292ZXJ5UGFyYW1zKHBhcmFtczogUmVjb3Zlck9wdGlvbnMpOiB2b2lkIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlcktleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB1c2VyS2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmJhY2t1cEtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkgJiYgIXBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiAhcGFyYW1zLmlzVHNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKSB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHdhbGxldENvbnRyYWN0QWRkcmVzcycpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzaWduUmVjb3ZlcnlUU1MoXG4gICAgdXNlcktleUNvbWJpbmVkOiBFQ0RTQS5LZXlDb21iaW5lZCxcbiAgICBiYWNrdXBLZXlDb21iaW5lZDogRUNEU0EuS2V5Q29tYmluZWQsXG4gICAgdHhIZXg6IHN0cmluZyxcbiAgICB7XG4gICAgICByYW5nZVByb29mQ2hhbGxlbmdlLFxuICAgIH06IHtcbiAgICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2U/OiBFY2RzYVR5cGVzLlNlcmlhbGl6ZWROdGlsZGU7XG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8RUNEU0FNZXRob2RUeXBlcy5TaWduYXR1cmU+IHtcbiAgICBjb25zdCBNUEMgPSBuZXcgRWNkc2EoKTtcbiAgICBjb25zdCBzaWduZXJPbmVJbmRleCA9IHVzZXJLZXlDb21iaW5lZC54U2hhcmUuaTtcbiAgICBjb25zdCBzaWduZXJUd29JbmRleCA9IGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZS5pO1xuXG4gICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSA9XG4gICAgICByYW5nZVByb29mQ2hhbGxlbmdlID8/IEVjZHNhVHlwZXMuc2VyaWFsaXplTnRpbGRlV2l0aFByb29mcyhhd2FpdCBFY2RzYVJhbmdlUHJvb2YuZ2VuZXJhdGVOdGlsZGUoKSk7XG5cbiAgICBjb25zdCB1c2VyVG9CYWNrdXBQYWlsbGllckNoYWxsZW5nZSA9IGF3YWl0IEVjZHNhUGFpbGxpZXJQcm9vZi5nZW5lcmF0ZVAoXG4gICAgICBoZXhUb0JpZ0ludCh1c2VyS2V5Q29tYmluZWQueVNoYXJlc1tzaWduZXJUd29JbmRleF0ubilcbiAgICApO1xuICAgIGNvbnN0IGJhY2t1cFRvVXNlclBhaWxsaWVyQ2hhbGxlbmdlID0gYXdhaXQgRWNkc2FQYWlsbGllclByb29mLmdlbmVyYXRlUChcbiAgICAgIGhleFRvQmlnSW50KGJhY2t1cEtleUNvbWJpbmVkLnlTaGFyZXNbc2lnbmVyT25lSW5kZXhdLm4pXG4gICAgKTtcblxuICAgIGNvbnN0IHVzZXJYU2hhcmUgPSBNUEMuYXBwZW5kQ2hhbGxlbmdlKFxuICAgICAgdXNlcktleUNvbWJpbmVkLnhTaGFyZSxcbiAgICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2UsXG4gICAgICBFY2RzYVR5cGVzLnNlcmlhbGl6ZVBhaWxsaWVyQ2hhbGxlbmdlKHsgcDogdXNlclRvQmFja3VwUGFpbGxpZXJDaGFsbGVuZ2UgfSlcbiAgICApO1xuICAgIGNvbnN0IHVzZXJZU2hhcmUgPSBNUEMuYXBwZW5kQ2hhbGxlbmdlKFxuICAgICAgdXNlcktleUNvbWJpbmVkLnlTaGFyZXNbc2lnbmVyVHdvSW5kZXhdLFxuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSxcbiAgICAgIEVjZHNhVHlwZXMuc2VyaWFsaXplUGFpbGxpZXJDaGFsbGVuZ2UoeyBwOiBiYWNrdXBUb1VzZXJQYWlsbGllckNoYWxsZW5nZSB9KVxuICAgICk7XG4gICAgY29uc3QgYmFja3VwWFNoYXJlID0gTVBDLmFwcGVuZENoYWxsZW5nZShcbiAgICAgIGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZSxcbiAgICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2UsXG4gICAgICBFY2RzYVR5cGVzLnNlcmlhbGl6ZVBhaWxsaWVyQ2hhbGxlbmdlKHsgcDogYmFja3VwVG9Vc2VyUGFpbGxpZXJDaGFsbGVuZ2UgfSlcbiAgICApO1xuICAgIGNvbnN0IGJhY2t1cFlTaGFyZSA9IE1QQy5hcHBlbmRDaGFsbGVuZ2UoXG4gICAgICBiYWNrdXBLZXlDb21iaW5lZC55U2hhcmVzW3NpZ25lck9uZUluZGV4XSxcbiAgICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2UsXG4gICAgICBFY2RzYVR5cGVzLnNlcmlhbGl6ZVBhaWxsaWVyQ2hhbGxlbmdlKHsgcDogdXNlclRvQmFja3VwUGFpbGxpZXJDaGFsbGVuZ2UgfSlcbiAgICApO1xuXG4gICAgY29uc3Qgc2lnblNoYXJlczogRUNEU0EuU2lnblNoYXJlUlQgPSBhd2FpdCBNUEMuc2lnblNoYXJlKHVzZXJYU2hhcmUsIHVzZXJZU2hhcmUpO1xuXG4gICAgY29uc3Qgc2lnbkNvbnZlcnRTMjEgPSBhd2FpdCBNUEMuc2lnbkNvbnZlcnRTdGVwMSh7XG4gICAgICB4U2hhcmU6IGJhY2t1cFhTaGFyZSxcbiAgICAgIHlTaGFyZTogYmFja3VwWVNoYXJlLCAvLyBZU2hhcmUgY29ycmVzcG9uZGluZyB0byB0aGUgb3RoZXIgcGFydGljaXBhbnQgc2lnbmVyT25lXG4gICAgICBrU2hhcmU6IHNpZ25TaGFyZXMua1NoYXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25Db252ZXJ0UzEyID0gYXdhaXQgTVBDLnNpZ25Db252ZXJ0U3RlcDIoe1xuICAgICAgYVNoYXJlOiBzaWduQ29udmVydFMyMS5hU2hhcmUsXG4gICAgICB3U2hhcmU6IHNpZ25TaGFyZXMud1NoYXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25Db252ZXJ0UzIxXzIgPSBhd2FpdCBNUEMuc2lnbkNvbnZlcnRTdGVwMyh7XG4gICAgICBtdVNoYXJlOiBzaWduQ29udmVydFMxMi5tdVNoYXJlLFxuICAgICAgYlNoYXJlOiBzaWduQ29udmVydFMyMS5iU2hhcmUsXG4gICAgfSk7XG5cbiAgICBjb25zdCBbc2lnbkNvbWJpbmVPbmUsIHNpZ25Db21iaW5lVHdvXSA9IFtcbiAgICAgIE1QQy5zaWduQ29tYmluZSh7XG4gICAgICAgIGdTaGFyZTogc2lnbkNvbnZlcnRTMTIuZ1NoYXJlLFxuICAgICAgICBzaWduSW5kZXg6IHtcbiAgICAgICAgICBpOiBzaWduQ29udmVydFMxMi5tdVNoYXJlLmksXG4gICAgICAgICAgajogc2lnbkNvbnZlcnRTMTIubXVTaGFyZS5qLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgICBNUEMuc2lnbkNvbWJpbmUoe1xuICAgICAgICBnU2hhcmU6IHNpZ25Db252ZXJ0UzIxXzIuZ1NoYXJlLFxuICAgICAgICBzaWduSW5kZXg6IHtcbiAgICAgICAgICBpOiBzaWduQ29udmVydFMyMV8yLnNpZ25JbmRleC5pLFxuICAgICAgICAgIGo6IHNpZ25Db252ZXJ0UzIxXzIuc2lnbkluZGV4LmosXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICBdO1xuXG4gICAgY29uc3QgTUVTU0FHRSA9IEJ1ZmZlci5mcm9tKHR4SGV4LCAnaGV4Jyk7XG5cbiAgICBjb25zdCBbc2lnbkEsIHNpZ25CXSA9IFtcbiAgICAgIE1QQy5zaWduKE1FU1NBR0UsIHNpZ25Db21iaW5lT25lLm9TaGFyZSwgc2lnbkNvbWJpbmVUd28uZFNoYXJlLCBLZWNjYWsoJ2tlY2NhazI1NicpKSxcbiAgICAgIE1QQy5zaWduKE1FU1NBR0UsIHNpZ25Db21iaW5lVHdvLm9TaGFyZSwgc2lnbkNvbWJpbmVPbmUuZFNoYXJlLCBLZWNjYWsoJ2tlY2NhazI1NicpKSxcbiAgICBdO1xuXG4gICAgcmV0dXJuIE1QQy5jb25zdHJ1Y3RTaWduYXR1cmUoW3NpZ25BLCBzaWduQl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB3aGljaCBjb21iaW5lcyBrZXkgc2hhcmVzIG9mIHVzZXIgYW5kIGJhY2t1cFxuICAgKiAqL1xuICBwcml2YXRlIGdldEtleUNvbWJpbmVkRnJvbVRzc0tleVNoYXJlcyhcbiAgICB1c2VyUHVibGljT3JQcml2YXRlS2V5U2hhcmU6IHN0cmluZyxcbiAgICBiYWNrdXBQcml2YXRlT3JQdWJsaWNLZXlTaGFyZTogc3RyaW5nLFxuICAgIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmdcbiAgKTogW0VDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWQsIEVDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWRdIHtcbiAgICBsZXQgYmFja3VwUHJ2O1xuICAgIGxldCB1c2VyUHJ2O1xuICAgIHRyeSB7XG4gICAgICBiYWNrdXBQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDogYmFja3VwUHJpdmF0ZU9yUHVibGljS2V5U2hhcmUsXG4gICAgICAgIHBhc3N3b3JkOiB3YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgfSk7XG4gICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IHVzZXJQdWJsaWNPclByaXZhdGVLZXlTaGFyZSxcbiAgICAgICAgcGFzc3dvcmQ6IHdhbGxldFBhc3NwaHJhc2UsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgYmFja3VwIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZSh1c2VyUHJ2KSBhcyBFQ0RTQU1ldGhvZFR5cGVzLlNpZ25pbmdNYXRlcmlhbDtcbiAgICBjb25zdCBiYWNrdXBTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKGJhY2t1cFBydikgYXMgRUNEU0FNZXRob2RUeXBlcy5TaWduaW5nTWF0ZXJpYWw7XG5cbiAgICBpZiAoIXVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXkgLSBtaXNzaW5nIGJhY2t1cE5TaGFyZScpO1xuICAgIH1cblxuICAgIGlmICghYmFja3VwU2lnbmluZ01hdGVyaWFsLnVzZXJOU2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYWNrdXAga2V5IC0gbWlzc2luZyB1c2VyTlNoYXJlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG5cbiAgICBjb25zdCB1c2VyS2V5Q29tYmluZWQgPSBNUEMua2V5Q29tYmluZSh1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZSwgW1xuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb05TaGFyZSxcbiAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlLFxuICAgIF0pO1xuICAgIGNvbnN0IGJhY2t1cEtleUNvbWJpbmVkID0gTVBDLmtleUNvbWJpbmUoYmFja3VwU2lnbmluZ01hdGVyaWFsLnBTaGFyZSwgW1xuICAgICAgYmFja3VwU2lnbmluZ01hdGVyaWFsLmJpdGdvTlNoYXJlLFxuICAgICAgYmFja3VwU2lnbmluZ01hdGVyaWFsLnVzZXJOU2hhcmUsXG4gICAgXSk7XG5cbiAgICBpZiAoXG4gICAgICB1c2VyS2V5Q29tYmluZWQueFNoYXJlLnkgIT09IGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZS55IHx8XG4gICAgICB1c2VyS2V5Q29tYmluZWQueFNoYXJlLmNoYWluY29kZSAhPT0gYmFja3VwS2V5Q29tYmluZWQueFNoYXJlLmNoYWluY29kZVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21tb24ga2V5Y2hhaW5zIGRvIG5vdCBtYXRjaCcpO1xuICAgIH1cblxuICAgIHJldHVybiBbdXNlcktleUNvbWJpbmVkLCBiYWNrdXBLZXlDb21iaW5lZF07XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHdoaWNoIEFkZHMgc2lnbmF0dXJlcyB0byB0eCBvYmplY3QgYW5kIHJlLXNlcmlhbGl6ZXMgdHhcbiAgICogKi9cbiAgcHJpdmF0ZSBnZXRTaWduZWRUeEZyb21TaWduYXR1cmUoXG4gICAgZXRoQ29tbW9uOiBFdGhDb21tb24uZGVmYXVsdCxcbiAgICB0eDogRXRoVHhMaWIuRmVlTWFya2V0RUlQMTU1OVRyYW5zYWN0aW9uIHwgRXRoVHhMaWIuVHJhbnNhY3Rpb24sXG4gICAgc2lnbmF0dXJlOiBFQ0RTQU1ldGhvZFR5cGVzLlNpZ25hdHVyZVxuICApIHtcbiAgICAvLyBnZXQgc2lnbmVkIFR4IGZyb20gc2lnbmF0dXJlXG4gICAgY29uc3QgdHhEYXRhID0gdHgudG9KU09OKCk7XG4gICAgY29uc3QgeVBhcml0eSA9IHNpZ25hdHVyZS5yZWNpZDtcbiAgICBjb25zdCBiYXNlUGFyYW1zID0ge1xuICAgICAgdG86IHR4RGF0YS50byxcbiAgICAgIG5vbmNlOiBuZXcgQk4oc3RyaXBIZXhQcmVmaXgodHhEYXRhLm5vbmNlISksICdoZXgnKSxcbiAgICAgIHZhbHVlOiBuZXcgQk4oc3RyaXBIZXhQcmVmaXgodHhEYXRhLnZhbHVlISksICdoZXgnKSxcbiAgICAgIGdhc0xpbWl0OiBuZXcgQk4oc3RyaXBIZXhQcmVmaXgodHhEYXRhLmdhc0xpbWl0ISksICdoZXgnKSxcbiAgICAgIGRhdGE6IHR4RGF0YS5kYXRhLFxuICAgICAgcjogYWRkSGV4UHJlZml4KHNpZ25hdHVyZS5yKSxcbiAgICAgIHM6IGFkZEhleFByZWZpeChzaWduYXR1cmUucyksXG4gICAgfTtcblxuICAgIGxldCBmaW5hbFR4O1xuICAgIGlmICh0eERhdGEubWF4RmVlUGVyR2FzICYmIHR4RGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcykge1xuICAgICAgZmluYWxUeCA9IEZlZU1hcmtldEVJUDE1NTlUcmFuc2FjdGlvbi5mcm9tVHhEYXRhKFxuICAgICAgICB7XG4gICAgICAgICAgLi4uYmFzZVBhcmFtcyxcbiAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbmV3IEJOKHN0cmlwSGV4UHJlZml4KHR4RGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyEpLCAnaGV4JyksXG4gICAgICAgICAgbWF4RmVlUGVyR2FzOiBuZXcgQk4oc3RyaXBIZXhQcmVmaXgodHhEYXRhLm1heEZlZVBlckdhcyEpLCAnaGV4JyksXG4gICAgICAgICAgdjogbmV3IEJOKHlQYXJpdHkudG9TdHJpbmcoKSksXG4gICAgICAgIH0sXG4gICAgICAgIHsgY29tbW9uOiBldGhDb21tb24gfVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHR4RGF0YS5nYXNQcmljZSkge1xuICAgICAgY29uc3QgdiA9IEJpZ0ludCgzNSkgKyBCaWdJbnQoeVBhcml0eSkgKyBCaWdJbnQoZXRoQ29tbW9uLmNoYWluSWRCTigpLnRvTnVtYmVyKCkpICogQmlnSW50KDIpO1xuICAgICAgZmluYWxUeCA9IExlZ2FjeVRyYW5zYWN0aW9uLmZyb21UeERhdGEoXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5iYXNlUGFyYW1zLFxuICAgICAgICAgIHY6IG5ldyBCTih2LnRvU3RyaW5nKCkpLFxuICAgICAgICAgIGdhc1ByaWNlOiBuZXcgQk4oc3RyaXBIZXhQcmVmaXgodHhEYXRhLmdhc1ByaWNlIS50b1N0cmluZygpKSwgJ2hleCcpLFxuICAgICAgICB9LFxuICAgICAgICB7IGNvbW1vbjogZXRoQ29tbW9uIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmFsVHg7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudXNlcktleSB7U3RyaW5nfSBbZW5jcnlwdGVkXSB4cHJ2XG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwS2V5IHtTdHJpbmd9IFtlbmNyeXB0ZWRdIHhwcnYgb3IgeHB1YiBpZiB0aGUgeHBydiBpcyBoZWxkIGJ5IGEgS1JTIHByb3ZpZGVyXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSB7U3RyaW5nfSB1c2VkIHRvIGRlY3J5cHQgdXNlcktleSBhbmQgYmFja3VwS2V5XG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzIHtTdHJpbmd9IHRoZSBFVEggYWRkcmVzcyBvZiB0aGUgd2FsbGV0IGNvbnRyYWN0XG4gICAqIEBwYXJhbSBwYXJhbXMua3JzUHJvdmlkZXIge1N0cmluZ30gbmVjZXNzYXJ5IGlmIGJhY2t1cCBrZXkgaXMgaGVsZCBieSBLUlNcbiAgICogQHBhcmFtIHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIHtTdHJpbmd9IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqIEBwYXJhbSBwYXJhbXMuYml0Z29GZWVBZGRyZXNzIHtTdHJpbmd9IHdyb25nIGNoYWluIHdhbGxldCBmZWUgYWRkcmVzcyBmb3IgZXZtIGJhc2VkIGNyb3NzIGNoYWluIHJlY292ZXJ5IHR4blxuICAgKiBAcGFyYW0gcGFyYW1zLmJpdGdvRGVzdGluYXRpb25BZGRyZXNzIHtTdHJpbmd9IHRhcmdldCBiaXRnbyBhZGRyZXNzIHdoZXJlIGZlZSB3aWxsIGJlIHNlbnQgZm9yIGV2bSBiYXNlZCBjcm9zcyBjaGFpbiByZWNvdmVyeSB0eG5cbiAgICovXG4gIGFzeW5jIHJlY292ZXIocGFyYW1zOiBSZWNvdmVyT3B0aW9ucyk6IFByb21pc2U8UmVjb3ZlcnlJbmZvIHwgT2ZmbGluZVZhdWx0VHhJbmZvPiB7XG4gICAgaWYgKHBhcmFtcy5pc1Rzcykge1xuICAgICAgcmV0dXJuIHRoaXMucmVjb3ZlclRTUyhwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWNvdmVyRXRoTGlrZShwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHVuc2lnbmVkIChmb3IgY29sZCwgY3VzdG9keSB3YWxsZXQpIG9yXG4gICAqIGhhbGYtc2lnbmVkIChmb3IgaG90IHdhbGxldCkgZXZtIGNyb3NzIGNoYWluIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhcbiAgICogc2FtZSBleHBlY3RlZCBhcmd1bWVudHMgYXMgcmVjb3ZlciBtZXRob2QuXG4gICAqIFRoaXMgaGVscHMgcmVjb3ZlciBmdW5kcyBmcm9tIGV2bSBiYXNlZCB3cm9uZyBjaGFpbi5cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyByZWNvdmVyRXRoTGlrZWZvckV2bUJhc2VkUmVjb3ZlcnkoXG4gICAgcGFyYW1zOiBSZWNvdmVyT3B0aW9uc1xuICApOiBQcm9taXNlPFJlY292ZXJ5SW5mbyB8IE9mZmxpbmVWYXVsdFR4SW5mbz4ge1xuICAgIHRoaXMudmFsaWRhdGVFdm1CYXNlZFJlY292ZXJ5UGFyYW1zKHBhcmFtcyk7XG5cbiAgICAvLyBDbGVhbiB1cCB3aGl0ZXNwYWNlIGZyb20gZW50ZXJlZCB2YWx1ZXNcbiAgICBjb25zdCB1c2VyS2V5ID0gcGFyYW1zLnVzZXJLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBjb25zdCBiaXRnb0ZlZUFkZHJlc3MgPSBwYXJhbXMuYml0Z29GZWVBZGRyZXNzPy5yZXBsYWNlKC9cXHMvZywgJycpIGFzIHN0cmluZztcbiAgICBjb25zdCBiaXRnb0Rlc3RpbmF0aW9uQWRkcmVzcyA9IHBhcmFtcy5iaXRnb0Rlc3RpbmF0aW9uQWRkcmVzcz8ucmVwbGFjZSgvXFxzL2csICcnKSBhcyBzdHJpbmc7XG4gICAgY29uc3QgcmVjb3ZlcnlEZXN0aW5hdGlvbiA9IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uPy5yZXBsYWNlKC9cXHMvZywgJycpIGFzIHN0cmluZztcbiAgICBjb25zdCB3YWxsZXRDb250cmFjdEFkZHJlc3MgPSBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzPy5yZXBsYWNlKC9cXHMvZywgJycpIGFzIHN0cmluZztcbiAgICBjb25zdCB0b2tlbkNvbnRyYWN0QWRkcmVzcyA9IHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcz8ucmVwbGFjZSgvXFxzL2csICcnKSBhcyBzdHJpbmc7XG5cbiAgICBsZXQgdXNlclNpZ25pbmdLZXk7XG4gICAgbGV0IHVzZXJLZXlQcnY7XG4gICAgaWYgKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICBpZiAoIXVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICF1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwcnYnKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVzZXJLZXlQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgICAgICBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgdXNlciBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qga2V5UGFpciA9IG5ldyBLZXlQYWlyTGliKHsgcHJ2OiB1c2VyS2V5UHJ2IH0pO1xuICAgICAgdXNlclNpZ25pbmdLZXkgPSBrZXlQYWlyLmdldEtleXMoKS5wcnY7XG4gICAgICBpZiAoIXVzZXJTaWduaW5nS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJpdmF0ZSBrZXknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBnYXNMaW1pdCA9IG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTih0aGlzLnNldEdhc0xpbWl0KHBhcmFtcy5nYXNMaW1pdCkpO1xuICAgIGNvbnN0IGdhc1ByaWNlID0gcGFyYW1zLmVpcDE1NTlcbiAgICAgID8gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHBhcmFtcy5laXAxNTU5Lm1heEZlZVBlckdhcylcbiAgICAgIDogbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHRoaXMuc2V0R2FzUHJpY2UocGFyYW1zLmdhc1ByaWNlKSk7XG5cbiAgICBjb25zdCBiaXRnb0ZlZUFkZHJlc3NOb25jZSA9IGF3YWl0IHRoaXMuZ2V0QWRkcmVzc05vbmNlKGJpdGdvRmVlQWRkcmVzcyk7XG5cbiAgICAvLyBnZXQgYmFsYW5jZSBvZiBiaXRnb0ZlZUFkZHJlc3MgdG8gZW5zdXJlIGZ1bmRzIGFyZSBhdmFpbGFibGUgdG8gcGF5IGZlZXNcbiAgICBjb25zdCBiaXRnb0ZlZUFkZHJlc3NCYWxhbmNlID0gYXdhaXQgdGhpcy5xdWVyeUFkZHJlc3NCYWxhbmNlKGJpdGdvRmVlQWRkcmVzcyk7XG4gICAgY29uc3QgdG90YWxHYXNOZWVkZWQgPSBnYXNQcmljZS5tdWwoZ2FzTGltaXQpO1xuICAgIGNvbnN0IHdlaVRvR3dlaSA9IDEwICoqIDk7XG4gICAgaWYgKGJpdGdvRmVlQWRkcmVzc0JhbGFuY2UubHQodG90YWxHYXNOZWVkZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGZWUgYWRkcmVzcyAke2JpdGdvRmVlQWRkcmVzc0JhbGFuY2V9IGhhcyBiYWxhbmNlICR7KGJpdGdvRmVlQWRkcmVzc0JhbGFuY2UgLyB3ZWlUb0d3ZWkpLnRvU3RyaW5nKCl9IEd3ZWkuYCArXG4gICAgICAgICAgYFRoaXMgYWRkcmVzcyBtdXN0IGhhdmUgYSBiYWxhbmNlIG9mIGF0IGxlYXN0ICR7KHRvdGFsR2FzTmVlZGVkIC8gd2VpVG9Hd2VpKS50b1N0cmluZygpfWAgK1xuICAgICAgICAgIGAgR3dlaSB0byBwZXJmb3JtIHJlY292ZXJpZXMuIFRyeSBzZW5kaW5nIHNvbWUgJHt0aGlzLmdldENoYWluKCl9IHRvIHRoaXMgYWRkcmVzcyB0aGVuIHJldHJ5LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuQ29udHJhY3RBZGRyZXNzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNvdmVyRXRoTGlrZVRva2VuZm9yRXZtQmFzZWRSZWNvdmVyeShcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBiaXRnb0ZlZUFkZHJlc3NOb25jZSxcbiAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgIGdhc1ByaWNlLFxuICAgICAgICB1c2VyS2V5LFxuICAgICAgICB1c2VyU2lnbmluZ0tleVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYmFsYW5jZSBvZiB3YWxsZXRcbiAgICBjb25zdCB0eEFtb3VudCA9IGF3YWl0IHRoaXMucXVlcnlBZGRyZXNzQmFsYW5jZSh3YWxsZXRDb250cmFjdEFkZHJlc3MpO1xuXG4gICAgY29uc3QgYml0Z29GZWVQZXJjZW50YWdlID0gMDsgLy8gVE9ETzogQkctNzE5MTIgY2FuIGNoYW5nZSB0aGUgZmVlJSBoZXJlLlxuICAgIGNvbnN0IGJpdGdvRmVlQW1vdW50ID0gdHhBbW91bnQgKiAoYml0Z29GZWVQZXJjZW50YWdlIC8gMTAwKTtcblxuICAgIC8vIGJ1aWxkIHJlY2lwaWVudHMgb2JqZWN0XG4gICAgY29uc3QgcmVjaXBpZW50czogUmVjaXBpZW50W10gPSBbXG4gICAgICB7XG4gICAgICAgIGFkZHJlc3M6IHJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgIGFtb3VudDogbmV3IEJpZ051bWJlcih0eEFtb3VudCkubWludXMoYml0Z29GZWVBbW91bnQpLnRvRml4ZWQoKSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGlmIChiaXRnb0ZlZVBlcmNlbnRhZ2UgPiAwKSB7XG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChiaXRnb0Rlc3RpbmF0aW9uQWRkcmVzcykgfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MoYml0Z29EZXN0aW5hdGlvbkFkZHJlc3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaXRnb0Rlc3RpbmF0aW9uQWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICByZWNpcGllbnRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzOiBiaXRnb0Rlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBiaXRnb0ZlZUFtb3VudC50b1N0cmluZygxMCksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgYmF0Y2ggZGF0YVxuICAgIGNvbnN0IEJBVENIX01FVEhPRF9OQU1FID0gJ2JhdGNoJztcbiAgICBjb25zdCBCQVRDSF9NRVRIT0RfVFlQRVMgPSBbJ2FkZHJlc3NbXScsICd1aW50MjU2W10nXTtcbiAgICBjb25zdCBiYXRjaEV4ZWN1dGlvbkluZm8gPSB0aGlzLmdldEJhdGNoRXhlY3V0aW9uSW5mbyhyZWNpcGllbnRzKTtcbiAgICBjb25zdCBiYXRjaERhdGEgPSBvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgoXG4gICAgICB0aGlzLmdldE1ldGhvZENhbGxEYXRhKEJBVENIX01FVEhPRF9OQU1FLCBCQVRDSF9NRVRIT0RfVFlQRVMsIGJhdGNoRXhlY3V0aW9uSW5mby52YWx1ZXMpLnRvU3RyaW5nKCdoZXgnKVxuICAgICk7XG5cbiAgICAvLyBHZXQgc2VxdWVuY2UgSUQgdXNpbmcgY29udHJhY3QgY2FsbFxuICAgIC8vIHdlIG5lZWQgdG8gd2FpdCBiZXR3ZWVuIG1ha2luZyB0d28gcG9seWdvbnNjYW4gY2FsbHMgdG8gYXZvaWQgZ2V0dGluZyBiYW5uZWRcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgY29uc3Qgc2VxdWVuY2VJZCA9IGF3YWl0IHRoaXMucXVlcnlTZXF1ZW5jZUlkKHdhbGxldENvbnRyYWN0QWRkcmVzcyk7XG5cbiAgICBjb25zdCB0eEluZm8gPSB7XG4gICAgICByZWNpcGllbnRzOiByZWNpcGllbnRzLFxuICAgICAgZXhwaXJlVGltZTogdGhpcy5nZXREZWZhdWx0RXhwaXJlVGltZSgpLFxuICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiBzZXF1ZW5jZUlkLFxuICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LnRvU3RyaW5nKDEwKSxcbiAgICAgIGlzRXZtQmFzZWRDcm9zc0NoYWluUmVjb3Zlcnk6IHRydWUsXG4gICAgfTtcblxuICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICBjb25zdCBiYXRjaGVyQ29udHJhY3RBZGRyZXNzID0gbmV0d29yaz8uYmF0Y2hlckNvbnRyYWN0QWRkcmVzcyBhcyBzdHJpbmc7XG5cbiAgICBjb25zdCB0eEJ1aWxkZXIgPSB0aGlzLmdldFRyYW5zYWN0aW9uQnVpbGRlcigpIGFzIFRyYW5zYWN0aW9uQnVpbGRlcjtcbiAgICB0eEJ1aWxkZXIuY291bnRlcihiaXRnb0ZlZUFkZHJlc3NOb25jZSk7XG4gICAgdHhCdWlsZGVyLmNvbnRyYWN0KHdhbGxldENvbnRyYWN0QWRkcmVzcyk7XG4gICAgbGV0IHR4RmVlO1xuICAgIGlmIChwYXJhbXMuZWlwMTU1OSkge1xuICAgICAgdHhGZWUgPSB7XG4gICAgICAgIGVpcDE1NTk6IHtcbiAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogcGFyYW1zLmVpcDE1NTkubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgbWF4RmVlUGVyR2FzOiBwYXJhbXMuZWlwMTU1OS5tYXhGZWVQZXJHYXMsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0eEZlZSA9IHsgZmVlOiBnYXNQcmljZS50b1N0cmluZygpIH07XG4gICAgfVxuICAgIHR4QnVpbGRlci5mZWUoe1xuICAgICAgLi4udHhGZWUsXG4gICAgICBnYXNMaW1pdDogZ2FzTGltaXQudG9TdHJpbmcoKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHRyYW5zZmVyQnVpbGRlciA9IHR4QnVpbGRlci50cmFuc2ZlcigpIGFzIFRyYW5zZmVyQnVpbGRlcjtcblxuICAgIHRyYW5zZmVyQnVpbGRlclxuICAgICAgLmFtb3VudChiYXRjaEV4ZWN1dGlvbkluZm8udG90YWxBbW91bnQpXG4gICAgICAuY29udHJhY3RTZXF1ZW5jZUlkKHNlcXVlbmNlSWQpXG4gICAgICAuZXhwaXJhdGlvblRpbWUodGhpcy5nZXREZWZhdWx0RXhwaXJlVGltZSgpKVxuICAgICAgLnRvKGJhdGNoZXJDb250cmFjdEFkZHJlc3MpXG4gICAgICAuZGF0YShiYXRjaERhdGEpO1xuXG4gICAgaWYgKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICB0eEJ1aWxkZXIudHJhbnNmZXIoKS5rZXkodXNlclNpZ25pbmdLZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IHR4ID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG5cbiAgICBjb25zdCByZXNwb25zZTogT2ZmbGluZVZhdWx0VHhJbmZvID0ge1xuICAgICAgdHhIZXg6IHR4LnRvQnJvYWRjYXN0Rm9ybWF0KCksXG4gICAgICB1c2VyS2V5LFxuICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgZ2FzUHJpY2U6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSW50KGdhc1ByaWNlKS50b0ZpeGVkKCksXG4gICAgICBnYXNMaW1pdCxcbiAgICAgIHJlY2lwaWVudHM6IHR4SW5mby5yZWNpcGllbnRzLFxuICAgICAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiB0eC50b0pzb24oKS50byxcbiAgICAgIGFtb3VudDogYmF0Y2hFeGVjdXRpb25JbmZvLnRvdGFsQW1vdW50LFxuICAgICAgYmFja3VwS2V5Tm9uY2U6IGJpdGdvRmVlQWRkcmVzc05vbmNlLFxuICAgICAgZWlwMTU1OTogcGFyYW1zLmVpcDE1NTksXG4gICAgfTtcbiAgICBfLmV4dGVuZChyZXNwb25zZSwgdHhJbmZvKTtcbiAgICByZXNwb25zZS5uZXh0Q29udHJhY3RTZXF1ZW5jZUlkID0gcmVzcG9uc2UuY29udHJhY3RTZXF1ZW5jZUlkO1xuXG4gICAgaWYgKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICBjb25zdCBoYWxmU2lnbmVkVHhuOiBIYWxmU2lnbmVkVHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGhhbGZTaWduZWQ6IHtcbiAgICAgICAgICB0eEhleDogdHgudG9Ccm9hZGNhc3RGb3JtYXQoKSxcbiAgICAgICAgICByZWNpcGllbnRzOiB0eEluZm8ucmVjaXBpZW50cyxcbiAgICAgICAgICBleHBpcmVUaW1lOiB0eEluZm8uZXhwaXJlVGltZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgICBfLmV4dGVuZChyZXNwb25zZSwgaGFsZlNpZ25lZFR4bik7XG5cbiAgICAgIGNvbnN0IGZlZXNVc2VkOiBGZWVzVXNlZCA9IHtcbiAgICAgICAgZ2FzUHJpY2U6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSW50KGdhc1ByaWNlKS50b0ZpeGVkKCksXG4gICAgICAgIGdhc0xpbWl0OiBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0ludChnYXNMaW1pdCkudG9GaXhlZCgpLFxuICAgICAgfTtcbiAgICAgIHJlc3BvbnNlWydmZWVzVXNlZCddID0gZmVlc1VzZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgYXN5bmMgcmVjb3ZlckV0aExpa2VUb2tlbmZvckV2bUJhc2VkUmVjb3ZlcnkoXG4gICAgcGFyYW1zOiBSZWNvdmVyT3B0aW9ucyxcbiAgICBiaXRnb0ZlZUFkZHJlc3NOb25jZTogbnVtYmVyLFxuICAgIGdhc0xpbWl0LFxuICAgIGdhc1ByaWNlLFxuICAgIHVzZXJLZXksXG4gICAgdXNlclNpZ25pbmdLZXlcbiAgKSB7XG4gICAgLy8gZ2V0IHRva2VuIGJhbGFuY2Ugb2Ygd2FsbGV0XG4gICAgY29uc3QgdHhBbW91bnQgPSBhd2FpdCB0aGlzLnF1ZXJ5QWRkcmVzc1Rva2VuQmFsYW5jZShcbiAgICAgIHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyBhcyBzdHJpbmcsXG4gICAgICBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzXG4gICAgKTtcblxuICAgIC8vIGJ1aWxkIHJlY2lwaWVudHMgb2JqZWN0XG4gICAgY29uc3QgcmVjaXBpZW50czogUmVjaXBpZW50W10gPSBbXG4gICAgICB7XG4gICAgICAgIGFkZHJlc3M6IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLFxuICAgICAgICBhbW91bnQ6IG5ldyBCaWdOdW1iZXIodHhBbW91bnQpLnRvRml4ZWQoKSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIC8vIEdldCBzZXF1ZW5jZSBJRCB1c2luZyBjb250cmFjdCBjYWxsXG4gICAgLy8gd2UgbmVlZCB0byB3YWl0IGJldHdlZW4gbWFraW5nIHR3byBwb2x5Z29uc2NhbiBjYWxscyB0byBhdm9pZCBnZXR0aW5nIGJhbm5lZFxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICBjb25zdCBzZXF1ZW5jZUlkID0gYXdhaXQgdGhpcy5xdWVyeVNlcXVlbmNlSWQocGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcyk7XG5cbiAgICBjb25zdCB0eEluZm8gPSB7XG4gICAgICByZWNpcGllbnRzOiByZWNpcGllbnRzLFxuICAgICAgZXhwaXJlVGltZTogdGhpcy5nZXREZWZhdWx0RXhwaXJlVGltZSgpLFxuICAgICAgY29udHJhY3RTZXF1ZW5jZUlkOiBzZXF1ZW5jZUlkLFxuICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LnRvU3RyaW5nKDEwKSxcbiAgICAgIGlzRXZtQmFzZWRDcm9zc0NoYWluUmVjb3Zlcnk6IHRydWUsXG4gICAgfTtcblxuICAgIGNvbnN0IHR4QnVpbGRlciA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25CdWlsZGVyKCkgYXMgVHJhbnNhY3Rpb25CdWlsZGVyO1xuICAgIHR4QnVpbGRlci5jb3VudGVyKGJpdGdvRmVlQWRkcmVzc05vbmNlKTtcbiAgICB0eEJ1aWxkZXIuY29udHJhY3QocGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcyBhcyBzdHJpbmcpO1xuICAgIGxldCB0eEZlZTtcbiAgICBpZiAocGFyYW1zLmVpcDE1NTkpIHtcbiAgICAgIHR4RmVlID0ge1xuICAgICAgICBlaXAxNTU5OiB7XG4gICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHBhcmFtcy5laXAxNTU5Lm1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgIG1heEZlZVBlckdhczogcGFyYW1zLmVpcDE1NTkubWF4RmVlUGVyR2FzLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHhGZWUgPSB7IGZlZTogZ2FzUHJpY2UudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICB0eEJ1aWxkZXIuZmVlKHtcbiAgICAgIC4uLnR4RmVlLFxuICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LnRvU3RyaW5nKCksXG4gICAgfSk7XG5cbiAgICBjb25zdCB0cmFuc2ZlckJ1aWxkZXIgPSB0eEJ1aWxkZXIudHJhbnNmZXIoKSBhcyBUcmFuc2ZlckJ1aWxkZXI7XG5cbiAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgY29uc3QgdG9rZW4gPSBnZXRUb2tlbihwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MgYXMgc3RyaW5nLCBuZXR3b3JrIGFzIEV0aGVyZXVtTmV0d29yayk/Lm5hbWUgYXMgc3RyaW5nO1xuXG4gICAgdHJhbnNmZXJCdWlsZGVyXG4gICAgICAuYW1vdW50KHR4QW1vdW50KVxuICAgICAgLmNvbnRyYWN0U2VxdWVuY2VJZChzZXF1ZW5jZUlkKVxuICAgICAgLmV4cGlyYXRpb25UaW1lKHRoaXMuZ2V0RGVmYXVsdEV4cGlyZVRpbWUoKSlcbiAgICAgIC50byhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbilcbiAgICAgIC5jb2luKHRva2VuKTtcblxuICAgIGlmIChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgdHhCdWlsZGVyLnRyYW5zZmVyKCkua2V5KHVzZXJTaWduaW5nS2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuXG4gICAgY29uc3QgcmVzcG9uc2U6IE9mZmxpbmVWYXVsdFR4SW5mbyA9IHtcbiAgICAgIHR4SGV4OiB0eC50b0Jyb2FkY2FzdEZvcm1hdCgpLFxuICAgICAgdXNlcktleSxcbiAgICAgIGNvaW46IHRva2VuLFxuICAgICAgZ2FzUHJpY2U6IG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSW50KGdhc1ByaWNlKS50b0ZpeGVkKCksXG4gICAgICBnYXNMaW1pdCxcbiAgICAgIHJlY2lwaWVudHM6IHR4SW5mby5yZWNpcGllbnRzLFxuICAgICAgd2FsbGV0Q29udHJhY3RBZGRyZXNzOiB0eC50b0pzb24oKS50byxcbiAgICAgIGFtb3VudDogdHhBbW91bnQudG9TdHJpbmcoKSxcbiAgICAgIGJhY2t1cEtleU5vbmNlOiBiaXRnb0ZlZUFkZHJlc3NOb25jZSxcbiAgICAgIGVpcDE1NTk6IHBhcmFtcy5laXAxNTU5LFxuICAgIH07XG4gICAgXy5leHRlbmQocmVzcG9uc2UsIHR4SW5mbyk7XG4gICAgcmVzcG9uc2UubmV4dENvbnRyYWN0U2VxdWVuY2VJZCA9IHJlc3BvbnNlLmNvbnRyYWN0U2VxdWVuY2VJZDtcblxuICAgIGlmIChwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgY29uc3QgaGFsZlNpZ25lZFR4bjogSGFsZlNpZ25lZFRyYW5zYWN0aW9uID0ge1xuICAgICAgICBoYWxmU2lnbmVkOiB7XG4gICAgICAgICAgdHhIZXg6IHR4LnRvQnJvYWRjYXN0Rm9ybWF0KCksXG4gICAgICAgICAgcmVjaXBpZW50czogdHhJbmZvLnJlY2lwaWVudHMsXG4gICAgICAgICAgZXhwaXJlVGltZTogdHhJbmZvLmV4cGlyZVRpbWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgXy5leHRlbmQocmVzcG9uc2UsIGhhbGZTaWduZWRUeG4pO1xuXG4gICAgICBjb25zdCBmZWVzVXNlZDogRmVlc1VzZWQgPSB7XG4gICAgICAgIGdhc1ByaWNlOiBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0ludChnYXNQcmljZSkudG9GaXhlZCgpLFxuICAgICAgICBnYXNMaW1pdDogb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9JbnQoZ2FzTGltaXQpLnRvRml4ZWQoKSxcbiAgICAgIH07XG4gICAgICByZXNwb25zZVsnZmVlc1VzZWQnXSA9IGZlZXNVc2VkO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIHZhbGlkYXRlRXZtQmFzZWRSZWNvdmVyeVBhcmFtcyhwYXJhbXM6IFJlY292ZXJPcHRpb25zKTogdm9pZCB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmJpdGdvRmVlQWRkcmVzcykgfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLmJpdGdvRmVlQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBiaXRnb0ZlZUFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKSB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHdhbGxldENvbnRyYWN0QWRkcmVzcycpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB0cmFuc2FjdGlvbiBidWlsZGVyIGZvciB0aGUgY3VycmVudCBjaGFpblxuICAgKiBAcmV0dXJuIGEgbmV3IHRyYW5zYWN0aW9uIGJ1aWxkZXJcbiAgICovXG4gIHByb3RlY3RlZCBnZXRUcmFuc2FjdGlvbkJ1aWxkZXIoKTogVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uQnVpbGRlcihjb2lucy5nZXQodGhpcy5nZXRCYXNlQ2hhaW4oKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmFzZSBjaGFpbiB0aGF0IHRoZSBjb2luIGV4aXN0cyBvbi5cbiAgICovXG4gIGdldEJhc2VDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldENoYWluKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHR5cGVzLCB2YWx1ZXMsIGFuZCB0b3RhbCBhbW91bnQgaW4gd2VpIHRvIHNlbmQgaW4gYSBiYXRjaCB0cmFuc2FjdGlvbiwgdXNpbmcgdGhlIG1ldGhvZCBzaWduYXR1cmVcbiAgICogYGRpc3RyaWJ1dGVCYXRjaChhZGRyZXNzW10sIHVpbnQyNTZbXSlgXG4gICAqIEBwYXJhbSB7UmVjaXBpZW50W119IHJlY2lwaWVudHMgLSB0cmFuc2FjdGlvbiByZWNpcGllbnRzXG4gICAqIEByZXR1cm5zIHtHZXRCYXRjaEV4ZWN1dGlvbkluZm9SVH0gaW5mb3JtYXRpb24gbmVlZGVkIHRvIGV4ZWN1dGUgdGhlIGJhdGNoIHRyYW5zYWN0aW9uXG4gICAqL1xuICBnZXRCYXRjaEV4ZWN1dGlvbkluZm8ocmVjaXBpZW50czogUmVjaXBpZW50W10pOiBHZXRCYXRjaEV4ZWN1dGlvbkluZm9SVCB7XG4gICAgY29uc3QgYWRkcmVzc2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGFtb3VudHM6IHN0cmluZ1tdID0gW107XG4gICAgbGV0IHN1bSA9IG5ldyBCaWdOdW1iZXIoJzAnKTtcbiAgICBfLmZvckVhY2gocmVjaXBpZW50cywgKHsgYWRkcmVzcywgYW1vdW50IH0pID0+IHtcbiAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgYW1vdW50cy5wdXNoKGFtb3VudCk7XG4gICAgICBzdW0gPSBzdW0ucGx1cyhhbW91bnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlczogW2FkZHJlc3NlcywgYW1vdW50c10sXG4gICAgICB0b3RhbEFtb3VudDogc3VtLnRvRml4ZWQoKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF0YSByZXF1aXJlZCB0byBtYWtlIGFuIEVUSCBmdW5jdGlvbiBjYWxsIGRlZmluZWQgYnkgdGhlIGdpdmVuIHR5cGVzIGFuZCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSBUaGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gYmVpbmcgY2FsbGVkLCBlLmcuIHRyYW5zZmVyXG4gICAqIEBwYXJhbSB0eXBlcyBUaGUgdHlwZXMgb2YgdGhlIGZ1bmN0aW9uIGNhbGwgaW4gb3JkZXJcbiAgICogQHBhcmFtIHZhbHVlcyBUaGUgdmFsdWVzIG9mIHRoZSBmdW5jdGlvbiBjYWxsIGluIG9yZGVyXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbWJpbmVkIGRhdGEgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAqL1xuICBnZXRNZXRob2RDYWxsRGF0YSA9IChmdW5jdGlvbk5hbWUsIHR5cGVzLCB2YWx1ZXMpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICAvLyBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgIG9wdGlvbmFsRGVwcy5ldGhBYmkubWV0aG9kSUQoZnVuY3Rpb25OYW1lLCB0eXBlcyksXG4gICAgICAvLyBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIG9wdGlvbmFsRGVwcy5ldGhBYmkucmF3RW5jb2RlKHR5cGVzLCB2YWx1ZXMpLFxuICAgIF0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWNvdmVycyBhIHR4IHdpdGggVFNTIGtleSBzaGFyZXNcbiAgICogc2FtZSBleHBlY3RlZCBhcmd1bWVudHMgYXMgcmVjb3ZlciBtZXRob2QsIGJ1dCB3aXRoIFRTUyBrZXkgc2hhcmVzXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgcmVjb3ZlclRTUyhwYXJhbXM6IFJlY292ZXJPcHRpb25zKTogUHJvbWlzZTxSZWNvdmVyeUluZm8gfCBPZmZsaW5lVmF1bHRUeEluZm8+IHtcbiAgICB0aGlzLnZhbGlkYXRlUmVjb3ZlcnlQYXJhbXMocGFyYW1zKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBnZXRJc1Vuc2lnbmVkU3dlZXAocGFyYW1zKTtcblxuICAgIC8vIENsZWFuIHVwIHdoaXRlc3BhY2UgZnJvbSBlbnRlcmVkIHZhbHVlc1xuICAgIGNvbnN0IHVzZXJQdWJsaWNPclByaXZhdGVLZXlTaGFyZSA9IHBhcmFtcy51c2VyS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgYmFja3VwUHJpdmF0ZU9yUHVibGljS2V5U2hhcmUgPSBwYXJhbXMuYmFja3VwS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgICAvLyBTZXQgbmV3IGV0aCB0eCBmZWVzICh1c2luZyBkZWZhdWx0IGNvbmZpZyB2YWx1ZXMgZnJvbSBwbGF0Zm9ybSlcbiAgICBjb25zdCBnYXNMaW1pdCA9IG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTih0aGlzLnNldEdhc0xpbWl0KHBhcmFtcy5nYXNMaW1pdCkpO1xuICAgIGNvbnN0IGdhc1ByaWNlID0gcGFyYW1zLmVpcDE1NTlcbiAgICAgID8gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHBhcmFtcy5laXAxNTU5Lm1heEZlZVBlckdhcylcbiAgICAgIDogbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHRoaXMuc2V0R2FzUHJpY2UocGFyYW1zLmdhc1ByaWNlKSk7XG5cbiAgICBjb25zdCBbYmFja3VwS2V5QWRkcmVzcywgdXNlcktleUNvbWJpbmVkLCBiYWNrdXBLZXlDb21iaW5lZF0gPSAoKCk6IFtcbiAgICAgIHN0cmluZyxcbiAgICAgIEVDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWQgfCB1bmRlZmluZWQsXG4gICAgICBFQ0RTQU1ldGhvZFR5cGVzLktleUNvbWJpbmVkIHwgdW5kZWZpbmVkXG4gICAgXSA9PiB7XG4gICAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIGNvbnN0IGJhY2t1cEtleVBhaXIgPSBuZXcgS2V5UGFpckxpYih7IHB1YjogYmFja3VwUHJpdmF0ZU9yUHVibGljS2V5U2hhcmUgfSk7XG4gICAgICAgIHJldHVybiBbYmFja3VwS2V5UGFpci5nZXRBZGRyZXNzKCksIHVuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IFt1c2VyS2V5Q29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXSA9IHRoaXMuZ2V0S2V5Q29tYmluZWRGcm9tVHNzS2V5U2hhcmVzKFxuICAgICAgICAgIHVzZXJQdWJsaWNPclByaXZhdGVLZXlTaGFyZSxcbiAgICAgICAgICBiYWNrdXBQcml2YXRlT3JQdWJsaWNLZXlTaGFyZSxcbiAgICAgICAgICBwYXJhbXMud2FsbGV0UGFzc3BocmFzZVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBiYWNrdXBLZXlQYWlyID0gbmV3IEtleVBhaXJMaWIoeyBwdWI6IGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZS55IH0pO1xuICAgICAgICByZXR1cm4gW2JhY2t1cEtleVBhaXIuZ2V0QWRkcmVzcygpLCB1c2VyS2V5Q29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXTtcbiAgICAgIH1cbiAgICB9KSgpO1xuXG4gICAgY29uc3QgYmFja3VwS2V5Tm9uY2UgPSBhd2FpdCB0aGlzLmdldEFkZHJlc3NOb25jZShiYWNrdXBLZXlBZGRyZXNzKTtcblxuICAgIC8vIGdldCBiYWxhbmNlIG9mIGJhY2t1cEtleSB0byBlbnN1cmUgZnVuZHMgYXJlIGF2YWlsYWJsZSB0byBwYXkgZmVlc1xuICAgIGNvbnN0IGJhY2t1cEtleUJhbGFuY2UgPSBhd2FpdCB0aGlzLnF1ZXJ5QWRkcmVzc0JhbGFuY2UoYmFja3VwS2V5QWRkcmVzcyk7XG5cbiAgICBjb25zdCB0b3RhbEdhc05lZWRlZCA9IGdhc1ByaWNlLm11bChnYXNMaW1pdCk7XG4gICAgY29uc3Qgd2VpVG9Hd2VpID0gMTAgKiogOTtcbiAgICBpZiAoYmFja3VwS2V5QmFsYW5jZS5sdCh0b3RhbEdhc05lZWRlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJhY2t1cCBrZXkgYWRkcmVzcyAke2JhY2t1cEtleUFkZHJlc3N9IGhhcyBiYWxhbmNlICR7KGJhY2t1cEtleUJhbGFuY2UgLyB3ZWlUb0d3ZWkpLnRvU3RyaW5nKCl9IEd3ZWkuYCArXG4gICAgICAgICAgYFRoaXMgYWRkcmVzcyBtdXN0IGhhdmUgYSBiYWxhbmNlIG9mIGF0IGxlYXN0ICR7KHRvdGFsR2FzTmVlZGVkIC8gd2VpVG9Hd2VpKS50b1N0cmluZygpfWAgK1xuICAgICAgICAgIGAgR3dlaSB0byBwZXJmb3JtIHJlY292ZXJpZXMuIFRyeSBzZW5kaW5nIHNvbWUgRVRIIHRvIHRoaXMgYWRkcmVzcyB0aGVuIHJldHJ5LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGJhbGFuY2Ugb2Ygd2FsbGV0IGFuZCBkZWR1Y3QgZmVlcyB0byBnZXQgdHJhbnNhY3Rpb24gYW1vdW50LCB3YWxsZXQgY29udHJhY3QgYWRkcmVzcyBhY3RzIGFzIGJhc2UgYWRkcmVzcyBmb3IgdHNzP1xuICAgIGNvbnN0IHR4QW1vdW50ID0gYmFja3VwS2V5QmFsYW5jZS5zdWIodG90YWxHYXNOZWVkZWQpO1xuXG4gICAgLy8gYnVpbGQgcmVjaXBpZW50cyBvYmplY3RcbiAgICBjb25zdCByZWNpcGllbnRzID0gW1xuICAgICAge1xuICAgICAgICBhZGRyZXNzOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgICAgYW1vdW50OiB0eEFtb3VudC50b1N0cmluZygxMCksXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCB0eEluZm8gPSB7XG4gICAgICByZWNpcGllbnQ6IHJlY2lwaWVudHNbMF0sXG4gICAgICBleHBpcmVUaW1lOiB0aGlzLmdldERlZmF1bHRFeHBpcmVUaW1lKCksXG4gICAgICBnYXNMaW1pdDogZ2FzTGltaXQudG9TdHJpbmcoMTApLFxuICAgIH07XG5cbiAgICBjb25zdCB0eFBhcmFtcyA9IHtcbiAgICAgIHRvOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiwgLy8gbm8gY29udHJhY3QgYWRkcmVzcywgc28gdGhpcyBmaWVsZCBzaG91bGQgbm90IGJlIHVzZWQgYW55d2F5c1xuICAgICAgbm9uY2U6IGJhY2t1cEtleU5vbmNlLFxuICAgICAgdmFsdWU6IHR4QW1vdW50LFxuICAgICAgZ2FzUHJpY2U6IGdhc1ByaWNlLFxuICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LFxuICAgICAgZGF0YTogQnVmZmVyLmZyb20oJzB4JyksIC8vIG5vIGNvbnRyYWN0IGNhbGxcbiAgICAgIGVpcDE1NTk6IHBhcmFtcy5laXAxNTU5LFxuICAgICAgcmVwbGF5UHJvdGVjdGlvbk9wdGlvbnM6IHBhcmFtcy5yZXBsYXlQcm90ZWN0aW9uT3B0aW9ucyxcbiAgICB9O1xuXG4gICAgbGV0IHR4ID0gRXRoLmJ1aWxkVHJhbnNhY3Rpb24odHhQYXJhbXMpO1xuXG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm9yT2ZmbGluZVZhdWx0VFNTKFxuICAgICAgICB0eEluZm8sXG4gICAgICAgIHR4LFxuICAgICAgICB1c2VyUHVibGljT3JQcml2YXRlS2V5U2hhcmUsXG4gICAgICAgIGJhY2t1cFByaXZhdGVPclB1YmxpY0tleVNoYXJlLFxuICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgIGJhY2t1cEtleU5vbmNlLFxuICAgICAgICBwYXJhbXMuZWlwMTU1OSxcbiAgICAgICAgcGFyYW1zLnJlcGxheVByb3RlY3Rpb25PcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25hYmxlSGV4ID0gdHguZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGlmICghdXNlcktleUNvbWJpbmVkIHx8ICFiYWNrdXBLZXlDb21iaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGtleSBjb21iaW5lZCBzaGFyZXMgZm9yIHVzZXIgb3IgYmFja3VwJyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuc2lnblJlY292ZXJ5VFNTKHVzZXJLZXlDb21iaW5lZCwgYmFja3VwS2V5Q29tYmluZWQsIHNpZ25hYmxlSGV4KTtcbiAgICBjb25zdCBldGhDb21tbW9uID0gRXRoLmdldEV0aENvbW1vbihwYXJhbXMuZWlwMTU1OSwgcGFyYW1zLnJlcGxheVByb3RlY3Rpb25PcHRpb25zKTtcbiAgICB0eCA9IHRoaXMuZ2V0U2lnbmVkVHhGcm9tU2lnbmF0dXJlKGV0aENvbW1tb24sIHR4LCBzaWduYXR1cmUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBhZGRIZXhQcmVmaXgodHguaGFzaCgpLnRvU3RyaW5nKCdoZXgnKSksXG4gICAgICB0eDogYWRkSGV4UHJlZml4KHR4LnNlcmlhbGl6ZSgpLnRvU3RyaW5nKCdoZXgnKSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvdmVycyBhIHR4IHdpdGggbm9uLVRTUyBrZXlzXG4gICAqIHNhbWUgZXhwZWN0ZWQgYXJndW1lbnRzIGFzIHJlY292ZXIgbWV0aG9kIChvcmlnaW5hbCBsb2dpYyBiZWZvcmUgYWRkaW5nIFRTUyByZWNvdmVyIHBhdGgpXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgcmVjb3ZlckV0aExpa2UocGFyYW1zOiBSZWNvdmVyT3B0aW9ucyk6IFByb21pc2U8UmVjb3ZlcnlJbmZvIHwgT2ZmbGluZVZhdWx0VHhJbmZvPiB7XG4gICAgLy8gYml0Z29GZWVBZGRyZXNzIGlzIG9ubHkgZGVmaW5lZCB3aGVuIGl0IGlzIGEgZXZtIGNyb3NzIGNoYWluIHJlY292ZXJ5XG4gICAgLy8gYXMgd2UgdXNlIGZlZSBmcm9tIHRoaXMgd3JvbmcgY2hhaW4gYWRkcmVzcyBmb3IgdGhlIHJlY292ZXJ5IHR4biBvbiB0aGUgY29ycmVjdCBjaGFpbi5cbiAgICBpZiAocGFyYW1zLmJpdGdvRmVlQWRkcmVzcykge1xuICAgICAgcmV0dXJuIHRoaXMucmVjb3ZlckV0aExpa2Vmb3JFdm1CYXNlZFJlY292ZXJ5KHBhcmFtcyk7XG4gICAgfVxuXG4gICAgdGhpcy52YWxpZGF0ZVJlY292ZXJ5UGFyYW1zKHBhcmFtcyk7XG4gICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGdldElzS3JzUmVjb3ZlcnkocGFyYW1zKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBnZXRJc1Vuc2lnbmVkU3dlZXAocGFyYW1zKTtcblxuICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICBjaGVja0tyc1Byb3ZpZGVyKHRoaXMsIHBhcmFtcy5rcnNQcm92aWRlciwgeyBjaGVja0NvaW5GYW1pbHlTdXBwb3J0OiBmYWxzZSB9KTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCB3aGl0ZXNwYWNlIGZyb20gZW50ZXJlZCB2YWx1ZXNcbiAgICBsZXQgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuXG4gICAgLy8gU2V0IG5ldyBldGggdHggZmVlcyAodXNpbmcgZGVmYXVsdCBjb25maWcgdmFsdWVzIGZyb20gcGxhdGZvcm0pXG5cbiAgICBjb25zdCBnYXNMaW1pdCA9IG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTih0aGlzLnNldEdhc0xpbWl0KHBhcmFtcy5nYXNMaW1pdCkpO1xuICAgIGNvbnN0IGdhc1ByaWNlID0gcGFyYW1zLmVpcDE1NTlcbiAgICAgID8gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHBhcmFtcy5laXAxNTU5Lm1heEZlZVBlckdhcylcbiAgICAgIDogbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHRoaXMuc2V0R2FzUHJpY2UocGFyYW1zLmdhc1ByaWNlKSk7XG4gICAgaWYgKCF1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiAhdXNlcktleS5zdGFydHNXaXRoKCd4cHJ2JykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHVzZXJLZXkgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiB1c2VyS2V5LFxuICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyB1c2VyIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgYmFja3VwS2V5QWRkcmVzcztcbiAgICBsZXQgYmFja3VwU2lnbmluZ0tleTtcblxuICAgIGlmIChpc0tyc1JlY292ZXJ5IHx8IGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgY29uc3QgYmFja3VwSEROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChiYWNrdXBLZXkpO1xuICAgICAgYmFja3VwU2lnbmluZ0tleSA9IGJhY2t1cEhETm9kZS5wdWJsaWNLZXk7XG4gICAgICBiYWNrdXBLZXlBZGRyZXNzID0gYDB4JHtvcHRpb25hbERlcHMuZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MoYmFja3VwU2lnbmluZ0tleSwgdHJ1ZSkudG9TdHJpbmcoJ2hleCcpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlY3J5cHQgYmFja3VwIHByaXZhdGUga2V5IGFuZCBnZXQgYWRkcmVzc1xuICAgICAgbGV0IGJhY2t1cFBydjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYmFja3VwUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyBiYWNrdXAga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiYWNrdXBIRE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KGJhY2t1cFBydik7XG4gICAgICBiYWNrdXBTaWduaW5nS2V5ID0gYmFja3VwSEROb2RlLnByaXZhdGVLZXk7XG4gICAgICBpZiAoIWJhY2t1cEhETm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByaXZhdGUga2V5Jyk7XG4gICAgICB9XG4gICAgICBiYWNrdXBLZXlBZGRyZXNzID0gYDB4JHtvcHRpb25hbERlcHMuZXRoVXRpbC5wcml2YXRlVG9BZGRyZXNzKGJhY2t1cFNpZ25pbmdLZXkpLnRvU3RyaW5nKCdoZXgnKX1gO1xuICAgIH1cblxuICAgIGNvbnN0IGJhY2t1cEtleU5vbmNlID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzTm9uY2UoYmFja3VwS2V5QWRkcmVzcyk7XG5cbiAgICAvLyBnZXQgYmFsYW5jZSBvZiBiYWNrdXBLZXkgdG8gZW5zdXJlIGZ1bmRzIGFyZSBhdmFpbGFibGUgdG8gcGF5IGZlZXNcbiAgICBjb25zdCBiYWNrdXBLZXlCYWxhbmNlID0gYXdhaXQgdGhpcy5xdWVyeUFkZHJlc3NCYWxhbmNlKGJhY2t1cEtleUFkZHJlc3MpO1xuXG4gICAgY29uc3QgdG90YWxHYXNOZWVkZWQgPSBnYXNQcmljZS5tdWwoZ2FzTGltaXQpO1xuICAgIGNvbnN0IHdlaVRvR3dlaSA9IDEwICoqIDk7XG4gICAgaWYgKGJhY2t1cEtleUJhbGFuY2UubHQodG90YWxHYXNOZWVkZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYWNrdXAga2V5IGFkZHJlc3MgJHtiYWNrdXBLZXlBZGRyZXNzfSBoYXMgYmFsYW5jZSAkeyhiYWNrdXBLZXlCYWxhbmNlIC8gd2VpVG9Hd2VpKS50b1N0cmluZygpfSBHd2VpLmAgK1xuICAgICAgICAgIGBUaGlzIGFkZHJlc3MgbXVzdCBoYXZlIGEgYmFsYW5jZSBvZiBhdCBsZWFzdCAkeyh0b3RhbEdhc05lZWRlZCAvIHdlaVRvR3dlaSkudG9TdHJpbmcoKX1gICtcbiAgICAgICAgICBgIEd3ZWkgdG8gcGVyZm9ybSByZWNvdmVyaWVzLiBUcnkgc2VuZGluZyBzb21lIEVUSCB0byB0aGlzIGFkZHJlc3MgdGhlbiByZXRyeS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGdldCBiYWxhbmNlIG9mIHdhbGxldCBhbmQgZGVkdWN0IGZlZXMgdG8gZ2V0IHRyYW5zYWN0aW9uIGFtb3VudFxuICAgIGNvbnN0IHR4QW1vdW50ID0gYXdhaXQgdGhpcy5xdWVyeUFkZHJlc3NCYWxhbmNlKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpO1xuXG4gICAgLy8gYnVpbGQgcmVjaXBpZW50cyBvYmplY3RcbiAgICBjb25zdCByZWNpcGllbnRzID0gW1xuICAgICAge1xuICAgICAgICBhZGRyZXNzOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgICAgYW1vdW50OiB0eEFtb3VudC50b1N0cmluZygxMCksXG4gICAgICB9LFxuICAgIF07XG5cbiAgICAvLyBHZXQgc2VxdWVuY2UgSUQgdXNpbmcgY29udHJhY3QgY2FsbFxuICAgIC8vIHdlIG5lZWQgdG8gd2FpdCBiZXR3ZWVuIG1ha2luZyB0d28gZXRoZXJzY2FuIGNhbGxzIHRvIGF2b2lkIGdldHRpbmcgYmFubmVkXG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgIGNvbnN0IHNlcXVlbmNlSWQgPSBhd2FpdCB0aGlzLnF1ZXJ5U2VxdWVuY2VJZChwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKTtcblxuICAgIGxldCBvcGVyYXRpb25IYXNoLCBzaWduYXR1cmU7XG4gICAgLy8gR2V0IG9wZXJhdGlvbiBoYXNoIGFuZCBzaWduIGl0XG4gICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIG9wZXJhdGlvbkhhc2ggPSB0aGlzLmdldE9wZXJhdGlvblNoYTNGb3JFeGVjdXRlQW5kQ29uZmlybShyZWNpcGllbnRzLCB0aGlzLmdldERlZmF1bHRFeHBpcmVUaW1lKCksIHNlcXVlbmNlSWQpO1xuICAgICAgc2lnbmF0dXJlID0gVXRpbC5ldGhTaWduTXNnSGFzaChvcGVyYXRpb25IYXNoLCBVdGlsLnhwcnZUb0V0aFByaXZhdGVLZXkodXNlcktleSkpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBVdGlsLmVjUmVjb3ZlckV0aEFkZHJlc3Mob3BlcmF0aW9uSGFzaCwgc2lnbmF0dXJlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHR4SW5mbyA9IHtcbiAgICAgIHJlY2lwaWVudDogcmVjaXBpZW50c1swXSxcbiAgICAgIGV4cGlyZVRpbWU6IHRoaXMuZ2V0RGVmYXVsdEV4cGlyZVRpbWUoKSxcbiAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogc2VxdWVuY2VJZCxcbiAgICAgIG9wZXJhdGlvbkhhc2g6IG9wZXJhdGlvbkhhc2gsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgIGdhc0xpbWl0OiBnYXNMaW1pdC50b1N0cmluZygxMCksXG4gICAgfTtcblxuICAgIC8vIGNhbGN1bGF0ZSBzZW5kIGRhdGFcbiAgICBjb25zdCBzZW5kTWV0aG9kQXJncyA9IHRoaXMuZ2V0U2VuZE1ldGhvZEFyZ3ModHhJbmZvKTtcbiAgICBjb25zdCBtZXRob2RTaWduYXR1cmUgPSBvcHRpb25hbERlcHMuZXRoQWJpLm1ldGhvZElEKHRoaXMuc2VuZE1ldGhvZE5hbWUsIF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndHlwZScpKTtcbiAgICBjb25zdCBlbmNvZGVkQXJncyA9IG9wdGlvbmFsRGVwcy5ldGhBYmkucmF3RW5jb2RlKF8ubWFwKHNlbmRNZXRob2RBcmdzLCAndHlwZScpLCBfLm1hcChzZW5kTWV0aG9kQXJncywgJ3ZhbHVlJykpO1xuICAgIGNvbnN0IHNlbmREYXRhID0gQnVmZmVyLmNvbmNhdChbbWV0aG9kU2lnbmF0dXJlLCBlbmNvZGVkQXJnc10pO1xuXG4gICAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgICB0bzogcGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcyxcbiAgICAgIG5vbmNlOiBiYWNrdXBLZXlOb25jZSxcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgZ2FzUHJpY2U6IGdhc1ByaWNlLFxuICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LFxuICAgICAgZGF0YTogc2VuZERhdGEsXG4gICAgICBlaXAxNTU5OiBwYXJhbXMuZWlwMTU1OSxcbiAgICAgIHJlcGxheVByb3RlY3Rpb25PcHRpb25zOiBwYXJhbXMucmVwbGF5UHJvdGVjdGlvbk9wdGlvbnMsXG4gICAgfTtcblxuICAgIC8vIEJ1aWxkIGNvbnRyYWN0IGNhbGwgYW5kIHNpZ24gaXRcbiAgICBsZXQgdHggPSBFdGguYnVpbGRUcmFuc2FjdGlvbih0eFBhcmFtcyk7XG5cbiAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRGb3JPZmZsaW5lVmF1bHQoXG4gICAgICAgIHR4SW5mbyxcbiAgICAgICAgdHgsXG4gICAgICAgIHVzZXJLZXksXG4gICAgICAgIGJhY2t1cEtleSxcbiAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgIGdhc0xpbWl0LFxuICAgICAgICBwYXJhbXMuZWlwMTU1OSxcbiAgICAgICAgcGFyYW1zLnJlcGxheVByb3RlY3Rpb25PcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNLcnNSZWNvdmVyeSkge1xuICAgICAgdHggPSB0eC5zaWduKGJhY2t1cFNpZ25pbmdLZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25lZFR4OiBSZWNvdmVyeUluZm8gPSB7XG4gICAgICBpZDogb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgodHguaGFzaCgpKSxcbiAgICAgIHR4OiB0eC5zZXJpYWxpemUoKS50b1N0cmluZygnaGV4JyksXG4gICAgfTtcblxuICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICBzaWduZWRUeC5iYWNrdXBLZXkgPSBiYWNrdXBLZXk7XG4gICAgICBzaWduZWRUeC5jb2luID0gdGhpcy5nZXRDaGFpbigpO1xuICAgIH1cblxuICAgIHJldHVybiBzaWduZWRUeDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvdmVyIGFuIHVuc3VwcG9ydGVkIHRva2VuIGZyb20gYSBCaXRHbyBtdWx0aXNpZyB3YWxsZXRcbiAgICogVGhpcyBidWlsZHMgYSBoYWxmLXNpZ25lZCB0cmFuc2FjdGlvbiwgZm9yIHdoaWNoIHRoZXJlIHdpbGwgYmUgYW4gYWRtaW4gcm91dGUgdG8gY28tc2lnbiBhbmQgYnJvYWRjYXN0LiBPcHRpb25hbGx5XG4gICAqIHRoZSB1c2VyIGNhbiBzZXQgcGFyYW1zLmJyb2FkY2FzdCA9IHRydWUgYW5kIHRoZSBoYWxmLXNpZ25lZCB0eCB3aWxsIGJlIHNlbnQgdG8gQml0R28gZm9yIGNvc2lnbmluZyBhbmQgYnJvYWRjYXN0aW5nXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQgdGhlIHdhbGxldCB0byByZWNvdmVyIHRoZSB0b2tlbiBmcm9tXG4gICAqIEBwYXJhbSBwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MgdGhlIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIHVuc3VwcG9ydGVkIHRva2VuXG4gICAqIEBwYXJhbSBwYXJhbXMucmVjaXBpZW50IHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzIHJlY292ZXJlZCB0b2tlbnMgc2hvdWxkIGJlIHNlbnQgdG9cbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIHRoZSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0gcGFyYW1zLnBydiB0aGUgeHBydlxuICAgKiBAcGFyYW0gcGFyYW1zLmJyb2FkY2FzdCBpZiB0cnVlLCB3ZSB3aWxsIGF1dG9tYXRpY2FsbHkgc3VibWl0IHRoZSBoYWxmLXNpZ25lZCB0eCB0byBCaXRHbyBmb3IgY29zaWduaW5nIGFuZCBicm9hZGNhc3RpbmdcbiAgICovXG4gIGFzeW5jIHJlY292ZXJUb2tlbihwYXJhbXM6IFJlY292ZXJUb2tlbk9wdGlvbnMpOiBQcm9taXNlPFJlY292ZXJUb2tlblRyYW5zYWN0aW9uPiB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcmVjb3ZlclRva2VuIG11c3QgYmUgcGFzc2VkIGEgcGFyYW1zIG9iamVjdC4gR290ICR7cGFyYW1zfSAodHlwZSAke3R5cGVvZiBwYXJhbXN9KWApO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcykgfHwgIV8uaXNTdHJpbmcocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgdG9rZW5Db250cmFjdEFkZHJlc3MgbXVzdCBiZSBhIHN0cmluZywgZ290ICR7XG4gICAgICAgICAgcGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzXG4gICAgICAgIH0gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzfSlgXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMudG9rZW5Db250cmFjdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rva2VuQ29udHJhY3RBZGRyZXNzIG5vdCBhIHZhbGlkIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0KSB8fCAhKHBhcmFtcy53YWxsZXQgaW5zdGFuY2VvZiBXYWxsZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHdhbGxldCBtdXN0IGJlIGEgd2FsbGV0IGluc3RhbmNlLCBnb3QgJHtwYXJhbXMud2FsbGV0fSAodHlwZSAke3R5cGVvZiBwYXJhbXMud2FsbGV0fSlgKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMucmVjaXBpZW50KSB8fCAhXy5pc1N0cmluZyhwYXJhbXMucmVjaXBpZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWNpcGllbnQgbXVzdCBiZSBhIHN0cmluZywgZ290ICR7cGFyYW1zLnJlY2lwaWVudH0gKHR5cGUgJHt0eXBlb2YgcGFyYW1zLnJlY2lwaWVudH0pYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNpcGllbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2lwaWVudCBub3QgYSB2YWxpZCBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0hleCB8fCAhb3B0aW9uYWxEZXBzLmV0aEFiaS5zb2xpZGl0eVNIQTMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXRoZXJldW0gbm90IGZ1bGx5IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50Jyk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRva2VuIGJhbGFuY2UgZnJvbSBleHRlcm5hbCBBUElcbiAgICBjb25zdCBjb2luU3BlY2lmaWMgPSBwYXJhbXMud2FsbGV0LmNvaW5TcGVjaWZpYygpO1xuICAgIGlmICghY29pblNwZWNpZmljIHx8ICFfLmlzU3RyaW5nKGNvaW5TcGVjaWZpYy5iYXNlQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb2luIHNwZWNpZmljIHByb3BlcnR5IGJhc2VBZGRyZXNzJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlY292ZXJ5QW1vdW50ID0gYXdhaXQgdGhpcy5xdWVyeUFkZHJlc3NUb2tlbkJhbGFuY2UocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzLCBjb2luU3BlY2lmaWMuYmFzZUFkZHJlc3MpO1xuXG4gICAgaWYgKHBhcmFtcy5icm9hZGNhc3QpIHtcbiAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNyZWF0ZSBhIG5vcm1hbCBFVEggdHJhbnNhY3Rpb24gdGhhdCBzZW5kcyBhbiBhbW91bnQgb2YgMCBFVEggdG8gdGhlXG4gICAgICAvLyB0b2tlbkNvbnRyYWN0QWRkcmVzcyBhbmQgZW5jb2RlIHRoZSB1bnN1cHBvcnRlZC10b2tlbi1zZW5kIGRhdGEgaW4gdGhlIGRhdGEgZmllbGRcbiAgICAgIC8vICN0cmlja3N5XG4gICAgICBjb25zdCBzZW5kTWV0aG9kQXJncyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdfdG8nLFxuICAgICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgICB2YWx1ZTogcGFyYW1zLnJlY2lwaWVudCxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdfdmFsdWUnLFxuICAgICAgICAgIHR5cGU6ICd1aW50MjU2JyxcbiAgICAgICAgICB2YWx1ZTogcmVjb3ZlcnlBbW91bnQudG9TdHJpbmcoMTApLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICAgIGNvbnN0IG1ldGhvZFNpZ25hdHVyZSA9IG9wdGlvbmFsRGVwcy5ldGhBYmkubWV0aG9kSUQoJ3RyYW5zZmVyJywgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd0eXBlJykpO1xuICAgICAgY29uc3QgZW5jb2RlZEFyZ3MgPSBvcHRpb25hbERlcHMuZXRoQWJpLnJhd0VuY29kZShfLm1hcChzZW5kTWV0aG9kQXJncywgJ3R5cGUnKSwgXy5tYXAoc2VuZE1ldGhvZEFyZ3MsICd2YWx1ZScpKTtcbiAgICAgIGNvbnN0IHNlbmREYXRhID0gQnVmZmVyLmNvbmNhdChbbWV0aG9kU2lnbmF0dXJlLCBlbmNvZGVkQXJnc10pO1xuXG4gICAgICBjb25zdCBicm9hZGNhc3RQYXJhbXM6IGFueSA9IHtcbiAgICAgICAgYWRkcmVzczogcGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzLFxuICAgICAgICBhbW91bnQ6ICcwJyxcbiAgICAgICAgZGF0YTogc2VuZERhdGEudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgfTtcblxuICAgICAgaWYgKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICAgIGJyb2FkY2FzdFBhcmFtcy53YWxsZXRQYXNzcGhyYXNlID0gcGFyYW1zLndhbGxldFBhc3NwaHJhc2U7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcy5wcnYpIHtcbiAgICAgICAgYnJvYWRjYXN0UGFyYW1zLnBydiA9IHBhcmFtcy5wcnY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCBwYXJhbXMud2FsbGV0LnNlbmQoYnJvYWRjYXN0UGFyYW1zKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWNpcGllbnQgPSB7XG4gICAgICBhZGRyZXNzOiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgYW1vdW50OiByZWNvdmVyeUFtb3VudC50b1N0cmluZygxMCksXG4gICAgfTtcblxuICAgIC8vIFRoaXMgc2lnbmF0dXJlIHdpbGwgYmUgdmFsaWQgZm9yIG9uZSB3ZWVrXG4gICAgY29uc3QgZXhwaXJlVGltZSA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKSArIDYwICogNjAgKiAyNCAqIDc7XG5cbiAgICAvLyBHZXQgc2VxdWVuY2UgSUQuIFdlIGRvIHRoaXMgYnkgYnVpbGRpbmcgYSAnZmFrZScgZXRoIHRyYW5zYWN0aW9uLCBzbyB0aGUgcGxhdGZvcm0gd2lsbCBpbmNyZW1lbnQgYW5kIHJldHVybiB1cyB0aGUgbmV3IHNlcXVlbmNlIGlkXG4gICAgLy8gVGhpcyBfZG9lc18gcmVxdWlyZSB0aGUgdXNlciB0byBoYXZlIGEgbm9uLXplcm8gd2FsbGV0IGJhbGFuY2VcbiAgICBjb25zdCB7IG5leHRDb250cmFjdFNlcXVlbmNlSWQsIGdhc1ByaWNlLCBnYXNMaW1pdCB9ID0gKGF3YWl0IHBhcmFtcy53YWxsZXQucHJlYnVpbGRUcmFuc2FjdGlvbih7XG4gICAgICByZWNpcGllbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBhZGRyZXNzOiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgICAgIGFtb3VudDogJzEnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9KSkgYXMgYW55O1xuXG4gICAgLy8gdGhlc2UgcmVjb3ZlcmllcyBuZWVkIHRvIGJlIHByb2Nlc3NlZCBieSBzdXBwb3J0LCBidXQgaWYgdGhlIGN1c3RvbWVyIHNlbmRzIGFueSB0cmFuc2FjdGlvbnMgYmVmb3JlIHJlY292ZXJ5IGlzXG4gICAgLy8gY29tcGxldGUgdGhlIHNlcXVlbmNlIElEIHdpbGwgYmUgaW52YWxpZC4gYXJ0aWZpY2lhbGx5IGluZmxhdGUgdGhlIHNlcXVlbmNlIElEIHRvIGFsbG93IG1vcmUgdGltZSBmb3IgcHJvY2Vzc2luZ1xuICAgIGNvbnN0IHNhZmVTZXF1ZW5jZUlkID0gbmV4dENvbnRyYWN0U2VxdWVuY2VJZCArIDEwMDA7XG5cbiAgICAvLyBCdWlsZCBzZW5kRGF0YSBmb3IgZXRoZXJldW0gdHhcbiAgICBjb25zdCBvcGVyYXRpb25UeXBlcyA9IFsnc3RyaW5nJywgJ2FkZHJlc3MnLCAndWludCcsICdhZGRyZXNzJywgJ3VpbnQnLCAndWludCddO1xuICAgIGNvbnN0IG9wZXJhdGlvbkFyZ3MgPSBbXG4gICAgICAvLyBcIkVSQzIwXCIgaGFzIGJlZW4gYWRkZWQgaGVyZSBzbyB0aGF0IGV0aGVyIG9wZXJhdGlvbiBoYXNoZXMsIHNpZ25hdHVyZXMgY2Fubm90IGJlIHJlLXVzZWQgZm9yIHRva2VuU2VuZGluZ1xuICAgICAgJ0VSQzIwJyxcbiAgICAgIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChyZWNpcGllbnQuYWRkcmVzcyksIDE2KSxcbiAgICAgIHJlY2lwaWVudC5hbW91bnQsXG4gICAgICBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ob3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgocGFyYW1zLnRva2VuQ29udHJhY3RBZGRyZXNzKSwgMTYpLFxuICAgICAgZXhwaXJlVGltZSxcbiAgICAgIHNhZmVTZXF1ZW5jZUlkLFxuICAgIF07XG5cbiAgICBjb25zdCBvcGVyYXRpb25IYXNoID0gb3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgoXG4gICAgICBvcHRpb25hbERlcHMuZXRoQWJpLnNvbGlkaXR5U0hBMyhvcGVyYXRpb25UeXBlcywgb3BlcmF0aW9uQXJncylcbiAgICApO1xuXG4gICAgY29uc3QgdXNlclBydiA9IGF3YWl0IHBhcmFtcy53YWxsZXQuZ2V0UHJ2KHtcbiAgICAgIHBydjogcGFyYW1zLnBydixcbiAgICAgIHdhbGxldFBhc3NwaHJhc2U6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gVXRpbC5ldGhTaWduTXNnSGFzaChvcGVyYXRpb25IYXNoLCBVdGlsLnhwcnZUb0V0aFByaXZhdGVLZXkodXNlclBydikpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbGZTaWduZWQ6IHtcbiAgICAgICAgcmVjaXBpZW50OiByZWNpcGllbnQsXG4gICAgICAgIGV4cGlyZVRpbWU6IGV4cGlyZVRpbWUsXG4gICAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogc2FmZVNlcXVlbmNlSWQsXG4gICAgICAgIG9wZXJhdGlvbkhhc2g6IG9wZXJhdGlvbkhhc2gsXG4gICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICBnYXNMaW1pdDogZ2FzTGltaXQsXG4gICAgICAgIGdhc1ByaWNlOiBnYXNQcmljZSxcbiAgICAgICAgdG9rZW5Db250cmFjdEFkZHJlc3M6IHBhcmFtcy50b2tlbkNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgd2FsbGV0SWQ6IHBhcmFtcy53YWxsZXQuaWQoKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhcmd1bWVudHMgdG8gY2FsbCB0aGUgc2VuZCBtZXRob2Qgb24gdGhlIHdhbGxldCBjb250cmFjdFxuICAgKiBAcGFyYW0gdHhJbmZvXG4gICAqL1xuICBnZXRTZW5kTWV0aG9kQXJncyh0eEluZm86IEdldFNlbmRNZXRob2RBcmdzT3B0aW9ucyk6IFNlbmRNZXRob2RBcmdzW10ge1xuICAgIC8vIE1ldGhvZCBzaWduYXR1cmUgaXNcbiAgICAvLyBzZW5kTXVsdGlTaWcoYWRkcmVzcyB0b0FkZHJlc3MsIHVpbnQgdmFsdWUsIGJ5dGVzIGRhdGEsIHVpbnQgZXhwaXJlVGltZSwgdWludCBzZXF1ZW5jZUlkLCBieXRlcyBzaWduYXR1cmUpXG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3RvQWRkcmVzcycsXG4gICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAgICAgICAgdmFsdWU6IHR4SW5mby5yZWNpcGllbnQuYWRkcmVzcyxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICAgIHR5cGU6ICd1aW50JyxcbiAgICAgICAgdmFsdWU6IHR4SW5mby5yZWNpcGllbnQuYW1vdW50LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICB2YWx1ZTogb3B0aW9uYWxEZXBzLmV0aFV0aWwudG9CdWZmZXIob3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KHR4SW5mby5yZWNpcGllbnQuZGF0YSB8fCAnJykpLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2V4cGlyZVRpbWUnLFxuICAgICAgICB0eXBlOiAndWludCcsXG4gICAgICAgIHZhbHVlOiB0eEluZm8uZXhwaXJlVGltZSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzZXF1ZW5jZUlkJyxcbiAgICAgICAgdHlwZTogJ3VpbnQnLFxuICAgICAgICB2YWx1ZTogdHhJbmZvLmNvbnRyYWN0U2VxdWVuY2VJZCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzaWduYXR1cmUnLFxuICAgICAgICB0eXBlOiAnYnl0ZXMnLFxuICAgICAgICB2YWx1ZTogb3B0aW9uYWxEZXBzLmV0aFV0aWwudG9CdWZmZXIob3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KHR4SW5mby5zaWduYXR1cmUpKSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgcXVlcnkgdG8gRXRoZXJzY2FuIGZvciBpbmZvcm1hdGlvbiBzdWNoIGFzIGJhbGFuY2UsIHRva2VuIGJhbGFuY2UsIHNvbGlkaXR5IGNhbGxzXG4gICAqIEBwYXJhbSBxdWVyeSB7T2JqZWN0fSBrZXktdmFsdWUgcGFpcnMgb2YgcGFyYW1ldGVycyB0byBhcHBlbmQgYWZ0ZXIgL2FwaVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXNwb25zZSBmcm9tIEV0aGVyc2NhblxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeShxdWVyeTogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgdG9rZW4gPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLmV0aGVyc2NhbkFwaVRva2VuO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgcXVlcnkuYXBpa2V5ID0gdG9rZW47XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdC5nZXQoY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmdldEVudigpXS5ldGhlcnNjYW5CYXNlVXJsICsgJy9hcGknKS5xdWVyeShxdWVyeSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFjaCBFdGhlcnNjYW4nKTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2UuYm9keS5zdGF0dXMgPT09ICcwJyAmJiByZXNwb25zZS5ib2R5Lm1lc3NhZ2UgPT09ICdOT1RPSycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXRoZXJzY2FuIHJhdGUgbGltaXQgcmVhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBleHRyYSBwYXJhbWV0ZXJzIG5lZWRlZCB0byBidWlsZCBhIGhvcCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMgVGhlIG9yaWdpbmFsIGJ1aWxkIHBhcmFtZXRlcnNcbiAgICogQHJldHVybnMgZXh0cmEgcGFyYW1ldGVycyBvYmplY3QgdG8gbWVyZ2Ugd2l0aCB0aGUgb3JpZ2luYWwgYnVpbGQgcGFyYW1ldGVycyBvYmplY3QgYW5kIHNlbmQgdG8gdGhlIHBsYXRmb3JtXG4gICAqL1xuICBhc3luYyBjcmVhdGVIb3BUcmFuc2FjdGlvblBhcmFtcyhidWlsZFBhcmFtczogSG9wVHJhbnNhY3Rpb25CdWlsZE9wdGlvbnMpOiBQcm9taXNlPEhvcFBhcmFtcz4ge1xuICAgIGNvbnN0IHdhbGxldCA9IGJ1aWxkUGFyYW1zLndhbGxldDtcbiAgICBjb25zdCByZWNpcGllbnRzID0gYnVpbGRQYXJhbXMucmVjaXBpZW50cztcbiAgICBjb25zdCB3YWxsZXRQYXNzcGhyYXNlID0gYnVpbGRQYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcblxuICAgIGNvbnN0IHVzZXJLZXljaGFpbiA9IGF3YWl0IHRoaXMua2V5Y2hhaW5zKCkuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVswXSB9KTtcbiAgICBjb25zdCB1c2VyUHJ2ID0gd2FsbGV0LmdldFVzZXJQcnYoeyBrZXljaGFpbjogdXNlcktleWNoYWluLCB3YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgIGNvbnN0IHVzZXJQcnZCdWZmZXIgPSBiaXAzMi5mcm9tQmFzZTU4KHVzZXJQcnYpLnByaXZhdGVLZXk7XG4gICAgaWYgKCF1c2VyUHJ2QnVmZmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdXNlclBydicpO1xuICAgIH1cbiAgICBpZiAoIXJlY2lwaWVudHMgfHwgIUFycmF5LmlzQXJyYXkocmVjaXBpZW50cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0aW5nIGFycmF5IG9mIHJlY2lwaWVudHMnKTtcbiAgICB9XG5cbiAgICAvLyBSaWdodCBub3cgd2Ugb25seSBzdXBwb3J0IDEgcmVjaXBpZW50XG4gICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc2VuZCB0byBleGFjdGx5IDEgcmVjaXBpZW50Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJlY2lwaWVudEFkZHJlc3MgPSByZWNpcGllbnRzWzBdLmFkZHJlc3M7XG4gICAgY29uc3QgcmVjaXBpZW50QW1vdW50ID0gcmVjaXBpZW50c1swXS5hbW91bnQ7XG4gICAgY29uc3QgZmVlRXN0aW1hdGVQYXJhbXMgPSB7XG4gICAgICByZWNpcGllbnQ6IHJlY2lwaWVudEFkZHJlc3MsXG4gICAgICBhbW91bnQ6IHJlY2lwaWVudEFtb3VudCxcbiAgICAgIGhvcDogdHJ1ZSxcbiAgICB9O1xuICAgIGNvbnN0IGZlZUVzdGltYXRlOiBGZWVFc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZmVlRXN0aW1hdGUoZmVlRXN0aW1hdGVQYXJhbXMpO1xuXG4gICAgY29uc3QgZ2FzTGltaXQgPSBmZWVFc3RpbWF0ZS5nYXNMaW1pdEVzdGltYXRlO1xuICAgIGNvbnN0IGdhc1ByaWNlID0gTWF0aC5yb3VuZChmZWVFc3RpbWF0ZS5mZWVFc3RpbWF0ZSAvIGdhc0xpbWl0KTtcbiAgICBjb25zdCBnYXNQcmljZU1heCA9IGdhc1ByaWNlICogNTtcbiAgICAvLyBQYXltZW50IGlkIGEgcmFuZG9tIG51bWJlciBzbyBpdHMgZGlmZmVyZW50IGZvciBldmVyeSB0eFxuICAgIGNvbnN0IHBheW1lbnRJZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKS50b1N0cmluZygpO1xuICAgIGNvbnN0IGhvcERpZ2VzdDogQnVmZmVyID0gRXRoLmdldEhvcERpZ2VzdChbXG4gICAgICByZWNpcGllbnRBZGRyZXNzLFxuICAgICAgcmVjaXBpZW50QW1vdW50LFxuICAgICAgZ2FzUHJpY2VNYXgudG9TdHJpbmcoKSxcbiAgICAgIGdhc0xpbWl0LnRvU3RyaW5nKCksXG4gICAgICBwYXltZW50SWQsXG4gICAgXSk7XG5cbiAgICBjb25zdCB1c2VyUmVxU2lnID0gb3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KFxuICAgICAgQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZHNhU2lnbihob3BEaWdlc3QsIHVzZXJQcnZCdWZmZXIpLnNpZ25hdHVyZSkudG9TdHJpbmcoJ2hleCcpXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBob3BQYXJhbXM6IHtcbiAgICAgICAgZ2FzUHJpY2VNYXgsXG4gICAgICAgIHVzZXJSZXFTaWcsXG4gICAgICAgIHBheW1lbnRJZCxcbiAgICAgIH0sXG4gICAgICBnYXNMaW1pdCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHRoZSBob3AgcHJlYnVpbGQgZnJvbSB0aGUgSFNNIGlzIHZhbGlkIGFuZCBjb3JyZWN0XG4gICAqIEBwYXJhbSB3YWxsZXQgVGhlIHdhbGxldCB0aGF0IHRoZSBwcmVidWlsZCBpcyBmb3JcbiAgICogQHBhcmFtIGhvcFByZWJ1aWxkIFRoZSBwcmVidWlsZCB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0gb3JpZ2luYWxQYXJhbXMgVGhlIG9yaWdpbmFsIHBhcmFtZXRlcnMgcGFzc2VkIHRvIHByZWJ1aWxkVHJhbnNhY3Rpb25cbiAgICogQHJldHVybnMgdm9pZFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIFRoZSBwcmVidWlsZCBpcyBpbnZhbGlkXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZUhvcFByZWJ1aWxkKFxuICAgIHdhbGxldDogSVdhbGxldCxcbiAgICBob3BQcmVidWlsZDogSG9wUHJlYnVpbGQsXG4gICAgb3JpZ2luYWxQYXJhbXM/OiB7IHJlY2lwaWVudHM6IFJlY2lwaWVudFtdIH1cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyB0eCwgaWQsIHNpZ25hdHVyZSB9ID0gaG9wUHJlYnVpbGQ7XG5cbiAgICAvLyBmaXJzdCwgdmFsaWRhdGUgdGhlIEhTTSBzaWduYXR1cmVcbiAgICBjb25zdCBzZXJ2ZXJYcHViID0gY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmdldEVudigpXS5oc21YcHViO1xuICAgIGNvbnN0IHNlcnZlclB1YmtleUJ1ZmZlcjogQnVmZmVyID0gYmlwMzIuZnJvbUJhc2U1OChzZXJ2ZXJYcHViKS5wdWJsaWNLZXk7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyOiBCdWZmZXIgPSBCdWZmZXIuZnJvbShvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChzaWduYXR1cmUpLCAnaGV4Jyk7XG4gICAgY29uc3QgbWVzc2FnZUJ1ZmZlcjogQnVmZmVyID0gQnVmZmVyLmZyb20oXG4gICAgICBvcHRpb25hbERlcHMuZXRoVXRpbC5wYWRUb0V2ZW4ob3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoaWQpKSxcbiAgICAgICdoZXgnXG4gICAgKTtcblxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZUJ1ZmZlci5zbGljZSgxKSk7XG4gICAgY29uc3QgaXNWYWxpZFNpZ25hdHVyZTogYm9vbGVhbiA9IHNlY3AyNTZrMS5lY2RzYVZlcmlmeShzaWcsIG1lc3NhZ2VCdWZmZXIsIHNlcnZlclB1YmtleUJ1ZmZlcik7XG4gICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBIb3AgdHhpZCBzaWduYXR1cmUgaW52YWxpZCAtIHB1YjogJHtzZXJ2ZXJYcHVifSwgbXNnOiAke21lc3NhZ2VCdWZmZXI/LnRvU3RyaW5nKCl9LCBzaWc6ICR7c2lnbmF0dXJlQnVmZmVyPy50b1N0cmluZygpfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgYnVpbHRIb3BUeCA9IG9wdGlvbmFsRGVwcy5FdGhUeC5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVNlcmlhbGl6ZWREYXRhKG9wdGlvbmFsRGVwcy5ldGhVdGlsLnRvQnVmZmVyKHR4KSk7XG4gICAgLy8gSWYgb3JpZ2luYWwgcGFyYW1zIGFyZSBnaXZlbiwgd2UgY2FuIGNoZWNrIHRoZW0gYWdhaW5zdCB0aGUgdHJhbnNhY3Rpb24gcHJlYnVpbGQgcGFyYW1zXG4gICAgaWYgKCFfLmlzTmlsKG9yaWdpbmFsUGFyYW1zKSkge1xuICAgICAgY29uc3QgeyByZWNpcGllbnRzIH0gPSBvcmlnaW5hbFBhcmFtcztcblxuICAgICAgLy8gVGhlbiB2YWxpZGF0ZSB0aGF0IHRoZSB0eCBwYXJhbXMgYWN0dWFsbHkgZXF1YWwgdGhlIHJlcXVlc3RlZCBwYXJhbXNcbiAgICAgIGNvbnN0IG9yaWdpbmFsQW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnRzWzBdLmFtb3VudCk7XG4gICAgICBjb25zdCBvcmlnaW5hbERlc3RpbmF0aW9uOiBzdHJpbmcgPSByZWNpcGllbnRzWzBdLmFkZHJlc3M7XG5cbiAgICAgIGNvbnN0IGhvcEFtb3VudCA9IG5ldyBCaWdOdW1iZXIob3B0aW9uYWxEZXBzLmV0aFV0aWwuYnVmZmVyVG9IZXgoYnVpbHRIb3BUeC52YWx1ZSkpO1xuICAgICAgaWYgKCFidWlsdEhvcFR4LnRvKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gZG9lcyBub3QgaGF2ZSBhIGRlc3RpbmF0aW9uIGFkZHJlc3NgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhvcERlc3RpbmF0aW9uID0gYnVpbHRIb3BUeC50by50b1N0cmluZygpO1xuICAgICAgaWYgKCFob3BBbW91bnQuZXEob3JpZ2luYWxBbW91bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSG9wIGFtb3VudDogJHtob3BBbW91bnR9IGRvZXMgbm90IGVxdWFsIG9yaWdpbmFsIGFtb3VudDogJHtvcmlnaW5hbEFtb3VudH1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChob3BEZXN0aW5hdGlvbi50b0xvd2VyQ2FzZSgpICE9PSBvcmlnaW5hbERlc3RpbmF0aW9uLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIb3AgZGVzdGluYXRpb246ICR7aG9wRGVzdGluYXRpb259IGRvZXMgbm90IGVxdWFsIG9yaWdpbmFsIHJlY2lwaWVudDogJHtob3BEZXN0aW5hdGlvbn1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWJ1aWx0SG9wVHgudmVyaWZ5U2lnbmF0dXJlKCkpIHtcbiAgICAgIC8vIFdlIGRvbnQgd2FudCB0byBjb250aW51ZSBhdCBhbGwgaW4gdGhpcyBjYXNlLCBhdCByaXNrIG9mIEVUSCBiZWluZyBzdHVjayBvbiB0aGUgaG9wIGFkZHJlc3NcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3AgdHJhbnNhY3Rpb24gc2lnbmF0dXJlLCB0eGlkOiAke2lkfWApO1xuICAgIH1cbiAgICBpZiAob3B0aW9uYWxEZXBzLmV0aFV0aWwuYWRkSGV4UHJlZml4KGJ1aWx0SG9wVHguaGFzaCgpLnRvU3RyaW5nKCdoZXgnKSkgIT09IGlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25lZCBob3AgdHhpZCBkb2VzIG5vdCBlcXVhbCBhY3R1YWwgdHhpZGApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBob3AgZGlnZXN0IGZvciB0aGUgdXNlciB0byBzaWduLiBUaGlzIGlzIHZhbGlkYXRlZCBpbiB0aGUgSFNNIHRvIHByb3ZlIHRoYXQgdGhlIHVzZXIgcmVxdWVzdGVkIHRoaXMgdHhcbiAgICogQHBhcmFtIHBhcmFtc0FyciBUaGUgcGFyYW1ldGVycyB0byBoYXNoIHRvZ2V0aGVyIGZvciB0aGUgZGlnZXN0XG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBnZXRIb3BEaWdlc3QocGFyYW1zQXJyOiBzdHJpbmdbXSk6IEJ1ZmZlciB7XG4gICAgY29uc3QgaGFzaCA9IEtlY2Nhaygna2VjY2FrMjU2Jyk7XG4gICAgaGFzaC51cGRhdGUoW0V0aC5ob3BUcmFuc2FjdGlvblNhbHQsIC4uLnBhcmFtc0Fycl0uam9pbignJCcpKTtcbiAgICByZXR1cm4gaGFzaC5kaWdlc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2RpZnkgcHJlYnVpbGQgYmVmb3JlIHNlbmRpbmcgaXQgdG8gdGhlIHNlcnZlci4gQWRkIHRoaW5ncyBsaWtlIGhvcCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zIFRoZSB3aGl0ZWxpc3RlZCBwYXJhbWV0ZXJzIGZvciB0aGlzIHByZWJ1aWxkXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcy5ob3AgVHJ1ZSBpZiB0aGlzIHNob3VsZCBwcmVidWlsZCBhIGhvcCB0eCwgZWxzZSBmYWxzZVxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMucmVjaXBpZW50cyBUaGUgcmVjaXBpZW50cyBhcnJheSBvZiB0aGlzIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcy53YWxsZXQgVGhlIHdhbGxldCBzZW5kaW5nIHRoaXMgdHhcbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zLndhbGxldFBhc3NwaHJhc2UgdGhlIHBhc3NwaHJhc2UgZm9yIHRoaXMgd2FsbGV0XG4gICAqL1xuICBhc3luYyBnZXRFeHRyYVByZWJ1aWxkUGFyYW1zKGJ1aWxkUGFyYW1zOiBCdWlsZE9wdGlvbnMpOiBQcm9taXNlPEJ1aWxkT3B0aW9ucz4ge1xuICAgIGlmIChcbiAgICAgICFfLmlzVW5kZWZpbmVkKGJ1aWxkUGFyYW1zLmhvcCkgJiZcbiAgICAgIGJ1aWxkUGFyYW1zLmhvcCAmJlxuICAgICAgIV8uaXNVbmRlZmluZWQoYnVpbGRQYXJhbXMud2FsbGV0KSAmJlxuICAgICAgIV8uaXNVbmRlZmluZWQoYnVpbGRQYXJhbXMucmVjaXBpZW50cykgJiZcbiAgICAgICFfLmlzVW5kZWZpbmVkKGJ1aWxkUGFyYW1zLndhbGxldFBhc3NwaHJhc2UpXG4gICAgKSB7XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEVyYzIwVG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBIb3AgdHJhbnNhY3Rpb25zIGFyZSBub3QgZW5hYmxlZCBmb3IgRVJDLTIwIHRva2Vucywgbm9yIGFyZSB0aGV5IG5lY2Vzc2FyeS4gUGxlYXNlIHJlbW92ZSB0aGUgJ2hvcCcgcGFyYW1ldGVyIGFuZCB0cnkgYWdhaW4uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmNyZWF0ZUhvcFRyYW5zYWN0aW9uUGFyYW1zKHtcbiAgICAgICAgd2FsbGV0OiBidWlsZFBhcmFtcy53YWxsZXQsXG4gICAgICAgIHJlY2lwaWVudHM6IGJ1aWxkUGFyYW1zLnJlY2lwaWVudHMsXG4gICAgICAgIHdhbGxldFBhc3NwaHJhc2U6IGJ1aWxkUGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgICB9KSkgYXMgYW55O1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZ5IHByZWJ1aWxkIGFmdGVyIHJlY2VpdmluZyBpdCBmcm9tIHRoZSBzZXJ2ZXIuIEFkZCB0aGluZ3MgbGlrZSBubG9ja3RpbWVcbiAgICovXG4gIGFzeW5jIHBvc3RQcm9jZXNzUHJlYnVpbGQocGFyYW1zOiBUcmFuc2FjdGlvblByZWJ1aWxkKTogUHJvbWlzZTxUcmFuc2FjdGlvblByZWJ1aWxkPiB7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5ob3BUcmFuc2FjdGlvbikgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldCkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLmJ1aWxkUGFyYW1zKSkge1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUhvcFByZWJ1aWxkKHBhcmFtcy53YWxsZXQsIHBhcmFtcy5ob3BUcmFuc2FjdGlvbiwgcGFyYW1zLmJ1aWxkUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2luLXNwZWNpZmljIHRoaW5ncyBkb25lIGJlZm9yZSBzaWduaW5nIGEgdHJhbnNhY3Rpb24sIGkuZS4gdmVyaWZpY2F0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIHByZXNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnM+IHtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmhvcFRyYW5zYWN0aW9uKSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMud2FsbGV0KSAmJiAhXy5pc1VuZGVmaW5lZChwYXJhbXMuYnVpbGRQYXJhbXMpKSB7XG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlSG9wUHJlYnVpbGQocGFyYW1zLndhbGxldCwgcGFyYW1zLmhvcFRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBmZWUgZXN0aW1hdGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHBhcmFtcyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmhvcF0gVHJ1ZSBpZiB3ZSBzaG91bGQgZXN0aW1hdGUgZmVlIGZvciBhIGhvcCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5yZWNpcGllbnRdIFRoZSByZWNpcGllbnQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGVzdGltYXRlIGEgc2VuZCB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5kYXRhXSBUaGUgRVRIIHR4IGRhdGEgdG8gZXN0aW1hdGUgYSBzZW5kIGZvclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZmVlIGluZm8gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICBhc3luYyBmZWVFc3RpbWF0ZShwYXJhbXM6IEZlZUVzdGltYXRlT3B0aW9ucyk6IFByb21pc2U8RmVlRXN0aW1hdGU+IHtcbiAgICBjb25zdCBxdWVyeTogRmVlRXN0aW1hdGVPcHRpb25zID0ge307XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuaG9wKSB7XG4gICAgICBxdWVyeS5ob3AgPSBwYXJhbXMuaG9wO1xuICAgIH1cbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5yZWNpcGllbnQpIHtcbiAgICAgIHF1ZXJ5LnJlY2lwaWVudCA9IHBhcmFtcy5yZWNpcGllbnQ7XG4gICAgfVxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmRhdGEpIHtcbiAgICAgIHF1ZXJ5LmRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuYW1vdW50KSB7XG4gICAgICBxdWVyeS5hbW91bnQgPSBwYXJhbXMuYW1vdW50O1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3R4L2ZlZScpKS5xdWVyeShxdWVyeSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgc2VjcDI1NmsxIGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ6IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGlmICghc2VlZCkge1xuICAgICAgLy8gQW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaGFzIGJvdGggYSBub3JtYWwgMjU2IGJpdCBwcml2YXRlIGtleSBhbmQgYSAyNTZcbiAgICAgIC8vIGJpdCBjaGFpbiBjb2RlLCBib3RoIG9mIHdoaWNoIG11c3QgYmUgcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlXG4gICAgICAvLyBtYXhpbXVtIGVudHJvcHkgYW5kIGdpdmVzIHVzIG1heGltdW0gc2VjdXJpdHkgYWdhaW5zdCBjcmFja2luZy5cbiAgICAgIHNlZWQgPSByYW5kb21CeXRlcyg1MTIgLyA4KTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5kZWRLZXkgPSBiaXAzMi5mcm9tU2VlZChzZWVkKTtcbiAgICBjb25zdCB4cHViID0gZXh0ZW5kZWRLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwdWI6IHhwdWIsXG4gICAgICBwcnY6IGV4dGVuZGVkS2V5LnRvQmFzZTU4KCksXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHBhcnNlVHJhbnNhY3Rpb24ocGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBzdXJlIGFuIGFkZHJlc3MgaXMgYSB3YWxsZXQgYWRkcmVzcyBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBub3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5hZGRyZXNzIFRoZSBkZXJpdmVkIGFkZHJlc3Mgc3RyaW5nIG9uIHRoZSBuZXR3b3JrXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMuY29pblNwZWNpZmljIENvaW4tc3BlY2lmaWMgZGV0YWlscyBmb3IgdGhlIGFkZHJlc3Mgc3VjaCBhcyBhIGZvcndhcmRlclZlcnNpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5iYXNlQWRkcmVzcyBUaGUgYmFzZSBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgb24gdGhlIG5ldHdvcmtcbiAgICogQHRocm93cyB7SW52YWxpZEFkZHJlc3NFcnJvcn1cbiAgICogQHRocm93cyB7SW52YWxpZEFkZHJlc3NWZXJpZmljYXRpb25PYmplY3RQcm9wZXJ0eUVycm9yfVxuICAgKiBAdGhyb3dzIHtVbmV4cGVjdGVkQWRkcmVzc0Vycm9yfVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgYWRkcmVzcyBpcyBhIHdhbGxldCBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlFdGhBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGV0aFV0aWwgPSBvcHRpb25hbERlcHMuZXRoVXRpbDtcblxuICAgIGxldCBleHBlY3RlZEFkZHJlc3M7XG4gICAgbGV0IGFjdHVhbEFkZHJlc3M7XG5cbiAgICBjb25zdCB7IGFkZHJlc3MsIGNvaW5TcGVjaWZpYywgYmFzZUFkZHJlc3MsIGltcGxpZWRGb3J3YXJkZXJWZXJzaW9uID0gY29pblNwZWNpZmljPy5mb3J3YXJkZXJWZXJzaW9uIH0gPSBwYXJhbXM7XG5cbiAgICBpZiAoYWRkcmVzcyAmJiAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIC8vIGJhc2UgYWRkcmVzcyBpcyByZXF1aXJlZCB0byBjYWxjdWxhdGUgdGhlIHNhbHQgd2hpY2ggaXMgdXNlZCBpbiBjYWxjdWxhdGVGb3J3YXJkZXJWMUFkZHJlc3MgbWV0aG9kXG4gICAgaWYgKF8uaXNVbmRlZmluZWQoYmFzZUFkZHJlc3MpIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKGJhc2VBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ2ludmFsaWQgYmFzZSBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzT2JqZWN0KGNvaW5TcGVjaWZpYykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc1ZlcmlmaWNhdGlvbk9iamVjdFByb3BlcnR5RXJyb3IoXG4gICAgICAgICdhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogY29pblNwZWNpZmljIGZpZWxkIG11c3QgYmUgYW4gb2JqZWN0J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaW1wbGllZEZvcndhcmRlclZlcnNpb24gPT09IDAgfHwgaW1wbGllZEZvcndhcmRlclZlcnNpb24gPT09IDMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBldGhOZXR3b3JrID0gdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICBjb25zdCBmb3J3YXJkZXJGYWN0b3J5QWRkcmVzcyA9IGV0aE5ldHdvcms/LmZvcndhcmRlckZhY3RvcnlBZGRyZXNzIGFzIHN0cmluZztcbiAgICAgIGNvbnN0IGZvcndhcmRlckltcGxlbWVudGF0aW9uQWRkcmVzcyA9IGV0aE5ldHdvcms/LmZvcndhcmRlckltcGxlbWVudGF0aW9uQWRkcmVzcyBhcyBzdHJpbmc7XG5cbiAgICAgIGNvbnN0IGluaXRjb2RlID0gZ2V0UHJveHlJbml0Y29kZShmb3J3YXJkZXJJbXBsZW1lbnRhdGlvbkFkZHJlc3MpO1xuICAgICAgY29uc3Qgc2FsdEJ1ZmZlciA9IGV0aFV0aWwuc2V0TGVuZ3RoTGVmdChcbiAgICAgICAgQnVmZmVyLmZyb20oZXRoVXRpbC5wYWRUb0V2ZW4oZXRoVXRpbC5zdHJpcEhleFByZWZpeChjb2luU3BlY2lmaWMuc2FsdCB8fCAnJykpLCAnaGV4JyksXG4gICAgICAgIDMyXG4gICAgICApO1xuXG4gICAgICAvLyBIYXNoIHRoZSB3YWxsZXQgYmFzZSBhZGRyZXNzIHdpdGggdGhlIGdpdmVuIHNhbHQsIHNvIHRoZSBhZGRyZXNzIGRpcmVjdGx5IHJlbGllcyBvbiB0aGUgYmFzZSBhZGRyZXNzXG4gICAgICBjb25zdCBjYWxjdWxhdGlvblNhbHQgPSBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0hleChcbiAgICAgICAgb3B0aW9uYWxEZXBzLmV0aEFiaS5zb2xpZGl0eVNIQTMoWydhZGRyZXNzJywgJ2J5dGVzMzInXSwgW2Jhc2VBZGRyZXNzLCBzYWx0QnVmZmVyXSlcbiAgICAgICk7XG5cbiAgICAgIGV4cGVjdGVkQWRkcmVzcyA9IGNhbGN1bGF0ZUZvcndhcmRlclYxQWRkcmVzcyhmb3J3YXJkZXJGYWN0b3J5QWRkcmVzcywgY2FsY3VsYXRpb25TYWx0LCBpbml0Y29kZSk7XG4gICAgICBhY3R1YWxBZGRyZXNzID0gYWRkcmVzcztcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0ZWRBZGRyZXNzICE9PSBhY3R1YWxBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6IGV4cGVjdGVkICR7ZXhwZWN0ZWRBZGRyZXNzfSBidXQgZ290ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZlcmlmeUNvaW4odHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eFByZWJ1aWxkLmNvaW4gPT09IHRoaXMuZ2V0Q2hhaW4oKTtcbiAgfVxuXG4gIHZlcmlmeVRzc1RyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5RXRoVHJhbnNhY3Rpb25PcHRpb25zKTogYm9vbGVhbiB7XG4gICAgY29uc3QgeyB0eFBhcmFtcywgdHhQcmVidWlsZCwgd2FsbGV0IH0gPSBwYXJhbXM7XG4gICAgaWYgKFxuICAgICAgIXR4UGFyYW1zPy5yZWNpcGllbnRzICYmXG4gICAgICAhKFxuICAgICAgICB0eFBhcmFtcy5wcmVidWlsZFR4Py5jb25zb2xpZGF0ZUlkIHx8XG4gICAgICAgICh0eFBhcmFtcy50eXBlICYmIFsnYWNjZWxlcmF0aW9uJywgJ2ZpbGxOb25jZScsICd0cmFuc2ZlclRva2VuJ10uaW5jbHVkZXModHhQYXJhbXMudHlwZSkpXG4gICAgICApXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdHhQYXJhbXNgKTtcbiAgICB9XG4gICAgaWYgKCF3YWxsZXQgfHwgIXR4UHJlYnVpbGQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBwYXJhbXNgKTtcbiAgICB9XG4gICAgaWYgKHR4UGFyYW1zLmhvcCAmJiB0eFBhcmFtcy5yZWNpcGllbnRzICYmIHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eCBjYW5ub3QgYmUgYm90aCBhIGJhdGNoIGFuZCBob3AgdHJhbnNhY3Rpb25gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBjb21wbGllcyB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnR4UGFyYW1zIHBhcmFtcyBvYmplY3QgcGFzc2VkIHRvIHNlbmRcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBzZXJ2ZXJcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQgV2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGFzeW5jIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5RXRoVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZXRoTmV0d29yayA9IHRoaXMuZ2V0TmV0d29yaygpO1xuICAgIGNvbnN0IHsgdHhQYXJhbXMsIHR4UHJlYnVpbGQsIHdhbGxldCwgd2FsbGV0VHlwZSB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKHdhbGxldFR5cGUgPT09ICd0c3MnKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXJpZnlUc3NUcmFuc2FjdGlvbihwYXJhbXMpO1xuICAgIH1cblxuICAgIGlmICghdHhQYXJhbXM/LnJlY2lwaWVudHMgfHwgIXR4UHJlYnVpbGQ/LnJlY2lwaWVudHMgfHwgIXdhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtaXNzaW5nIHBhcmFtc2ApO1xuICAgIH1cbiAgICBpZiAodHhQYXJhbXMuaG9wICYmIHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eCBjYW5ub3QgYmUgYm90aCBhIGJhdGNoIGFuZCBob3AgdHJhbnNhY3Rpb25gKTtcbiAgICB9XG4gICAgaWYgKHR4UHJlYnVpbGQucmVjaXBpZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBzaG91bGQgb25seSBoYXZlIDEgcmVjaXBpZW50IGJ1dCAke3R4UHJlYnVpbGQucmVjaXBpZW50cy5sZW5ndGh9IGZvdW5kYCk7XG4gICAgfVxuICAgIGlmICh0eFBhcmFtcy5ob3AgJiYgdHhQcmVidWlsZC5ob3BUcmFuc2FjdGlvbikge1xuICAgICAgLy8gQ2hlY2sgcmVjaXBpZW50IGFtb3VudCBmb3IgaG9wIHRyYW5zYWN0aW9uXG4gICAgICBpZiAodHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBob3AgdHJhbnNhY3Rpb24gb25seSBzdXBwb3J0cyAxIHJlY2lwaWVudCBidXQgJHt0eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aH0gZm91bmRgKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdHggc2VuZHMgdG8gaG9wIGFkZHJlc3NcbiAgICAgIGNvbnN0IGRlY29kZWRIb3BUeCA9IG9wdGlvbmFsRGVwcy5FdGhUeC5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVNlcmlhbGl6ZWREYXRhKFxuICAgICAgICBvcHRpb25hbERlcHMuZXRoVXRpbC50b0J1ZmZlcih0eFByZWJ1aWxkLmhvcFRyYW5zYWN0aW9uLnR4KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGV4cGVjdGVkSG9wQWRkcmVzcyA9IG9wdGlvbmFsRGVwcy5ldGhVdGlsLnN0cmlwSGV4UHJlZml4KGRlY29kZWRIb3BUeC5nZXRTZW5kZXJBZGRyZXNzKCkudG9TdHJpbmcoKSk7XG4gICAgICBjb25zdCBhY3R1YWxIb3BBZGRyZXNzID0gb3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgodHhQcmVidWlsZC5yZWNpcGllbnRzWzBdLmFkZHJlc3MpO1xuICAgICAgaWYgKGV4cGVjdGVkSG9wQWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSBhY3R1YWxIb3BBZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNpcGllbnQgYWRkcmVzcyBvZiB0eFByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGhvcCBhZGRyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnZlcnQgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXJyYXkgdG8gUmVjaXBpZW50IGFycmF5XG4gICAgICBjb25zdCByZWNpcGllbnRzOiBSZWNpcGllbnRbXSA9IHR4UGFyYW1zLnJlY2lwaWVudHMubWFwKChyKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYWRkcmVzczogci5hZGRyZXNzLFxuICAgICAgICAgIGFtb3VudDogdHlwZW9mIHIuYW1vdW50ID09PSAnbnVtYmVyJyA/IHIuYW1vdW50LnRvU3RyaW5nKCkgOiByLmFtb3VudCxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDaGVjayBkZXN0aW5hdGlvbiBhZGRyZXNzIGFuZCBhbW91bnRcbiAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVIb3BQcmVidWlsZCh3YWxsZXQsIHR4UHJlYnVpbGQuaG9wVHJhbnNhY3Rpb24sIHsgcmVjaXBpZW50cyB9KTtcbiAgICB9IGVsc2UgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gQ2hlY2sgdG90YWwgYW1vdW50IGZvciBiYXRjaCB0cmFuc2FjdGlvblxuICAgICAgbGV0IGV4cGVjdGVkVG90YWxBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cGVjdGVkVG90YWxBbW91bnQgPSBleHBlY3RlZFRvdGFsQW1vdW50LnBsdXModHhQYXJhbXMucmVjaXBpZW50c1tpXS5hbW91bnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFleHBlY3RlZFRvdGFsQW1vdW50LmlzRXF1YWxUbyh0eFByZWJ1aWxkLnJlY2lwaWVudHNbMF0uYW1vdW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ2JhdGNoIHRyYW5zYWN0aW9uIGFtb3VudCBpbiB0eFByZWJ1aWxkIHJlY2VpdmVkIGZyb20gQml0R28gc2VydmVycyBkb2VzIG5vdCBtYXRjaCB0eFBhcmFtcyBzdXBwbGllZCBieSBjbGllbnQnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJhdGNoIHRyYW5zYWN0aW9uIGlzIHNlbnQgdG8gdGhlIGJhdGNoZXIgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhlIGNoYWluXG4gICAgICBjb25zdCBiYXRjaGVyQ29udHJhY3RBZGRyZXNzID0gZXRoTmV0d29yaz8uYmF0Y2hlckNvbnRyYWN0QWRkcmVzcztcbiAgICAgIGlmIChcbiAgICAgICAgIWJhdGNoZXJDb250cmFjdEFkZHJlc3MgfHxcbiAgICAgICAgYmF0Y2hlckNvbnRyYWN0QWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSB0eFByZWJ1aWxkLnJlY2lwaWVudHNbMF0uYWRkcmVzcy50b0xvd2VyQ2FzZSgpXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNpcGllbnQgYWRkcmVzcyBvZiB0eFByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGJhdGNoZXIgYWRkcmVzcycpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDaGVjayByZWNpcGllbnQgYWRkcmVzcyBhbmQgYW1vdW50IGZvciBub3JtYWwgdHJhbnNhY3Rpb25cbiAgICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vcm1hbCB0cmFuc2FjdGlvbiBvbmx5IHN1cHBvcnRzIDEgcmVjaXBpZW50IGJ1dCAke3R4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RofSBmb3VuZGApO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhwZWN0ZWRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKHR4UGFyYW1zLnJlY2lwaWVudHNbMF0uYW1vdW50KTtcbiAgICAgIGlmICghZXhwZWN0ZWRBbW91bnQuaXNFcXVhbFRvKHR4UHJlYnVpbGQucmVjaXBpZW50c1swXS5hbW91bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnbm9ybWFsIHRyYW5zYWN0aW9uIGFtb3VudCBpbiB0eFByZWJ1aWxkIHJlY2VpdmVkIGZyb20gQml0R28gc2VydmVycyBkb2VzIG5vdCBtYXRjaCB0eFBhcmFtcyBzdXBwbGllZCBieSBjbGllbnQnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuaXNFVEhBZGRyZXNzKHR4UGFyYW1zLnJlY2lwaWVudHNbMF0uYWRkcmVzcykgJiZcbiAgICAgICAgdHhQYXJhbXMucmVjaXBpZW50c1swXS5hZGRyZXNzICE9PSB0eFByZWJ1aWxkLnJlY2lwaWVudHNbMF0uYWRkcmVzc1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdGluYXRpb24gYWRkcmVzcyBpbiBub3JtYWwgdHhQcmVidWlsZCBkb2VzIG5vdCBtYXRjaCB0aGF0IGluIHR4UGFyYW1zIHN1cHBsaWVkIGJ5IGNsaWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBDaGVjayBjb2luIGlzIGNvcnJlY3QgZm9yIGFsbCB0cmFuc2FjdGlvbiB0eXBlc1xuICAgIGlmICghdGhpcy52ZXJpZnlDb2luKHR4UHJlYnVpbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvaW4gaW4gdHhQcmVidWlsZCBkaWQgbm90IG1hdGNoIHRoYXQgaW4gdHhQYXJhbXMgc3VwcGxpZWQgYnkgY2xpZW50YCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHN1cHBvcnRzTWVzc2FnZVNpZ25pbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgc3VwcG9ydHNTaWduaW5nVHlwZWREYXRhKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBtZXNzYWdlIHRvIGFjY29tbW9kYXRlIHNwZWNpZmljIGJsb2NrY2hhaW4gcmVxdWlyZW1lbnRzLlxuICAgKiBAcGFyYW0gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBwcmVwYXJlXG4gICAqIEByZXR1cm4gc3RyaW5nIHRoZSBwcmVwYXJlZCBtZXNzYWdlLlxuICAgKi9cbiAgZW5jb2RlTWVzc2FnZShtZXNzYWdlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHByZWZpeCA9IGBcXHUwMDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJHttZXNzYWdlLmxlbmd0aH1gO1xuICAgIHJldHVybiBwcmVmaXguY29uY2F0KG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgVHlwZWQgZGF0YSB0byBhY2NvbW9kYXRlIHRoZSBibG9ja2NoYWluIHJlcXVpcmVtZW50cyAoRUlQLTcxMilcbiAgICogQHBhcmFtIHR5cGVkRGF0YSB0aGUgdHlwZWQgZGF0YSB0byBwcmVwYXJlXG4gICAqIEByZXR1cm4gYSBidWZmZXIgb2YgdGhlIHJlc3VsdFxuICAgKi9cbiAgZW5jb2RlVHlwZWREYXRhKHR5cGVkRGF0YTogVHlwZWREYXRhKTogQnVmZmVyIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gdHlwZWREYXRhLnZlcnNpb247XG4gICAgaWYgKHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25UeXBlZERhdGEgdjEgaXMgbm90IHN1cHBvcnRlZCBkdWUgdG8gc2VjdXJpdHkgY29uY2VybnMnKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZWREYXRhUmF3ID0gSlNPTi5wYXJzZSh0eXBlZERhdGEudHlwZWREYXRhUmF3KTtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0gVHlwZWREYXRhVXRpbHMuc2FuaXRpemVEYXRhKHR5cGVkRGF0YVJhdyBhcyB1bmtub3duIGFzIFR5cGVkTWVzc2FnZTxhbnk+KTtcbiAgICBjb25zdCBwYXJ0cyA9IFtCdWZmZXIuZnJvbSgnMTkwMScsICdoZXgnKV07XG4gICAgY29uc3QgZWlwNzEyRG9tYWluID0gJ0VJUDcxMkRvbWFpbic7XG4gICAgcGFydHMucHVzaChUeXBlZERhdGFVdGlscy5oYXNoU3RydWN0KGVpcDcxMkRvbWFpbiwgc2FuaXRpemVkRGF0YS5kb21haW4sIHNhbml0aXplZERhdGEudHlwZXMsIHZlcnNpb24pKTtcblxuICAgIGlmIChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlICE9PSBlaXA3MTJEb21haW4pIHtcbiAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgIFR5cGVkRGF0YVV0aWxzLmhhc2hTdHJ1Y3QoXG4gICAgICAgICAgc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSBhcyBzdHJpbmcsXG4gICAgICAgICAgc2FuaXRpemVkRGF0YS5tZXNzYWdlLFxuICAgICAgICAgIHNhbml0aXplZERhdGEudHlwZXMsXG4gICAgICAgICAgdmVyc2lvblxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChwYXJ0cyk7XG4gIH1cblxuICBwcml2YXRlIGlzRVRIQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISFhZGRyZXNzLm1hdGNoKC8weFthLWZBLUYwLTldezQwfS8pO1xuICB9XG59XG4iXX0=