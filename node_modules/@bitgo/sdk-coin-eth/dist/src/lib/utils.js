"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeForwarderCreationData = exports.getV1AddressInitializationData = exports.getV1WalletInitializationData = exports.getToken = exports.getBufferedByteCode = exports.getRawDecoded = exports.hasSignature = exports.toStringSig = exports.getProxyInitcode = exports.calculateForwarderV1Address = exports.calculateForwarderAddress = exports.hexStringToNumber = exports.numberToHexString = exports.classifyTransaction = exports.decodeFlushTokensData = exports.decodeNativeTransferData = exports.decodeERC1155TransferData = exports.decodeERC721TransferData = exports.decodeTokenTransferData = exports.decodeTransferData = exports.decodeWalletCreationData = exports.isValidAmount = exports.isValidEthAddress = exports.getAddressInitializationData = exports.flushCoinsData = exports.flushTokensData = exports.sendMultiSigTokenData = exports.sendMultiSigData = exports.sign = exports.signInternal = exports.getCommon = void 0;
const buffer_1 = require("buffer");
const assert_1 = __importDefault(require("assert"));
const ethereumjs_util_1 = require("ethereumjs-util");
const statics_1 = require("@bitgo/statics");
const ethereumjs_abi_1 = __importDefault(require("ethereumjs-abi"));
const common_1 = __importDefault(require("@ethereumjs/common"));
const bn_js_1 = __importDefault(require("bn.js"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_core_1 = require("@bitgo/sdk-core");
const walletUtil_1 = require("./walletUtil");
const types_1 = require("./types");
/**
 * @param network
 */
function getCommon(network) {
    return common_1.default.forCustomChain(
    // use the mainnet config as a base, override chain ids and network name
    'mainnet', {
        name: network.type,
        networkId: network.chainId,
        chainId: network.chainId,
    }, 'london');
}
exports.getCommon = getCommon;
/**
 * Signs the transaction using the appropriate algorithm
 * and the provided common for the blockchain
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @param {EthereumCommon} customCommon the network's custom common
 * @returns {string} the transaction signed and encoded
 */
async function signInternal(transactionData, keyPair, customCommon) {
    if (!keyPair.getKeys().prv) {
        throw new sdk_core_1.SigningError('Missing private key');
    }
    const ethTx = types_1.EthTransactionData.fromJson(transactionData, customCommon);
    ethTx.sign(keyPair);
    return ethTx.toSerialized();
}
exports.signInternal = signInternal;
/**
 * Signs the transaction using the appropriate algorithm
 *
 * @param {TxData} transactionData the transaction data to sign
 * @param {KeyPair} keyPair the signer's keypair
 * @returns {string} the transaction signed and encoded
 */
async function sign(transactionData, keyPair) {
    return signInternal(transactionData, keyPair, getCommon(statics_1.coins.get('teth').network));
}
exports.sign = sign;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} data aditional method call data
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigData(to, value, data, expireTime, sequenceId, signature) {
    const params = [to, value, ethereumjs_util_1.toBuffer(data), expireTime, sequenceId, ethereumjs_util_1.toBuffer(signature)];
    const method = ethereumjs_abi_1.default.methodID('sendMultiSig', walletUtil_1.sendMultiSigTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTypes, params);
    return ethereumjs_util_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigData = sendMultiSigData;
/**
 * Returns the contract method encoded data
 *
 * @param {string} to destination address
 * @param {number} value Amount to tranfer
 * @param {string} tokenContractAddress the address of the erc20 token contract
 * @param {number} expireTime expiration time for the transaction in seconds
 * @param {number} sequenceId sequence id
 * @param {string} signature signature of the call
 * @returns {string} -- the contract method encoded data
 */
function sendMultiSigTokenData(to, value, tokenContractAddress, expireTime, sequenceId, signature) {
    const params = [to, value, tokenContractAddress, expireTime, sequenceId, ethereumjs_util_1.toBuffer(signature)];
    const method = ethereumjs_abi_1.default.methodID('sendMultiSigToken', walletUtil_1.sendMultiSigTokenTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.sendMultiSigTokenTypes, params);
    return ethereumjs_util_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.sendMultiSigTokenData = sendMultiSigTokenData;
/**
 * Get the data required to make a flush tokens contract call
 *
 * @param forwarderAddress The forwarder address to flush
 * @param tokenAddress The token address to flush from
 */
function flushTokensData(forwarderAddress, tokenAddress) {
    const params = [forwarderAddress, tokenAddress];
    const method = ethereumjs_abi_1.default.methodID('flushForwarderTokens', walletUtil_1.flushTokensTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushTokensTypes, params);
    return ethereumjs_util_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.flushTokensData = flushTokensData;
/**
 * Get the data required to make a flush native coins contract call
 */
function flushCoinsData() {
    const params = [];
    const method = ethereumjs_abi_1.default.methodID('flush', walletUtil_1.flushCoinsTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.flushCoinsTypes, params);
    return ethereumjs_util_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.flushCoinsData = flushCoinsData;
/**
 * Returns the create forwarder method calling data
 *
 * @returns {string} - the createForwarder method encoded
 */
function getAddressInitializationData() {
    return walletUtil_1.createForwarderMethodId;
}
exports.getAddressInitializationData = getAddressInitializationData;
/**
 * Returns whether or not the string is a valid Eth address
 *
 * @param {string} address - the tx hash to validate
 * @returns {boolean} - the validation result
 */
function isValidEthAddress(address) {
    return ethereumjs_util_1.isValidAddress(address);
}
exports.isValidEthAddress = isValidEthAddress;
/**
 * Returns whether or not the string is a valid amount number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    const bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Returns the smart contract encoded data
 *
 * @param {string} data The wallet creation data to decode
 * @returns {string[]} - The list of signer addresses
 */
function decodeWalletCreationData(data) {
    if (!(data.startsWith(walletUtil_1.walletInitializationFirstBytes) || data.startsWith(walletUtil_1.v1CreateWalletMethodId))) {
        throw new sdk_core_1.BuildTransactionError(`Invalid wallet bytecode: ${data}`);
    }
    if (data.startsWith(walletUtil_1.walletInitializationFirstBytes)) {
        const dataBuffer = buffer_1.Buffer.from(data.slice(2), 'hex');
        // the last 160 bytes contain the serialized address array
        const serializedSigners = dataBuffer.slice(-160);
        const resultEncodedParameters = ethereumjs_abi_1.default.rawDecode(walletUtil_1.walletSimpleConstructor, serializedSigners);
        if (resultEncodedParameters.length !== 1) {
            throw new sdk_core_1.BuildTransactionError(`Could not decode wallet constructor bytecode: ${resultEncodedParameters}`);
        }
        const addresses = resultEncodedParameters[0];
        if (addresses.length !== 3) {
            throw new sdk_core_1.BuildTransactionError(`invalid number of addresses in parsed constructor: ${addresses}`);
        }
        // sometimes ethereumjs-abi removes 0 padding at the start of addresses,
        // so we should pad until they are the standard 20 bytes
        const paddedAddresses = addresses.map((address) => ethereumjs_util_1.stripHexPrefix(address.toString('hex')).padStart(40, '0'));
        return { owners: paddedAddresses.map((address) => ethereumjs_util_1.addHexPrefix(address)) };
    }
    else {
        const decodedDataForWalletCreation = getRawDecoded(walletUtil_1.createV1WalletTypes, getBufferedByteCode(walletUtil_1.v1CreateWalletMethodId, data));
        const addresses = decodedDataForWalletCreation[0];
        const saltBuffer = decodedDataForWalletCreation[1];
        const salt = ethereumjs_util_1.bufferToHex(saltBuffer);
        const paddedAddresses = addresses.map((address) => ethereumjs_util_1.stripHexPrefix(address.toString()).padStart(40, '0'));
        const owners = paddedAddresses.map((address) => ethereumjs_util_1.addHexPrefix(address));
        return {
            owners,
            salt,
        };
    }
}
exports.decodeWalletCreationData = decodeWalletCreationData;
/**
 * Decode the given ABI-encoded transfer data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeTransferData(data) {
    if (data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        return decodeNativeTransferData(data);
    }
    else if (data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        return decodeTokenTransferData(data);
    }
    else {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
}
exports.decodeTransferData = decodeTransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisigToken function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed token transfer data
 */
function decodeTokenTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigTokenMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, tokenContractAddress, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTokenTypes, getBufferedByteCode(walletUtil_1.sendMultisigTokenMethodId, data));
    return {
        to: ethereumjs_util_1.addHexPrefix(to),
        amount: new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(amount)).toFixed(),
        expireTime: ethereumjs_util_1.bufferToInt(expireTime),
        sequenceId: ethereumjs_util_1.bufferToInt(sequenceId),
        signature: ethereumjs_util_1.bufferToHex(signature),
        tokenContractAddress: ethereumjs_util_1.addHexPrefix(tokenContractAddress),
    };
}
exports.decodeTokenTransferData = decodeTokenTransferData;
function decodeERC721TransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, internalData, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data));
    const internalDataHex = ethereumjs_util_1.bufferToHex(internalData);
    if (!internalDataHex.startsWith(walletUtil_1.ERC721SafeTransferTypeMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [from, receiver, tokenId, userSentData] = getRawDecoded(walletUtil_1.ERC721SafeTransferTypes, getBufferedByteCode(walletUtil_1.ERC721SafeTransferTypeMethodId, internalDataHex));
    return {
        to: ethereumjs_util_1.addHexPrefix(receiver),
        from: ethereumjs_util_1.addHexPrefix(from),
        expireTime: ethereumjs_util_1.bufferToInt(expireTime),
        amount: new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(amount)).toFixed(),
        tokenId: new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(tokenId)).toFixed(),
        sequenceId: ethereumjs_util_1.bufferToInt(sequenceId),
        signature: ethereumjs_util_1.bufferToHex(signature),
        tokenContractAddress: ethereumjs_util_1.addHexPrefix(to),
        userData: ethereumjs_util_1.bufferToHex(userSentData),
    };
}
exports.decodeERC721TransferData = decodeERC721TransferData;
function decodeERC1155TransferData(data) {
    let from, receiver, userSentData;
    let tokenIds;
    let values;
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, internalData, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data));
    const internalDataHex = ethereumjs_util_1.bufferToHex(internalData);
    if (internalDataHex.startsWith(walletUtil_1.ERC1155SafeTransferTypeMethodId)) {
        let tokenId;
        let value;
        [from, receiver, tokenId, value, userSentData] = getRawDecoded(walletUtil_1.ERC1155SafeTransferTypes, getBufferedByteCode(walletUtil_1.ERC1155SafeTransferTypeMethodId, internalDataHex));
        tokenIds = [new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(tokenId)).toFixed()];
        values = [new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(value)).toFixed()];
    }
    else if (ethereumjs_util_1.bufferToHex(internalData).startsWith(walletUtil_1.ERC1155BatchTransferTypeMethodId)) {
        let tempTokenIds, tempValues;
        [from, receiver, tempTokenIds, tempValues, userSentData] = getRawDecoded(walletUtil_1.ERC1155BatchTransferTypes, getBufferedByteCode(walletUtil_1.ERC1155BatchTransferTypeMethodId, internalDataHex));
        tokenIds = tempTokenIds.map((x) => new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(x)).toFixed());
        values = tempValues.map((x) => new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(x)).toFixed());
    }
    else {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    return {
        to: ethereumjs_util_1.addHexPrefix(receiver),
        from: ethereumjs_util_1.addHexPrefix(from),
        expireTime: ethereumjs_util_1.bufferToInt(expireTime),
        amount: new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(amount)).toFixed(),
        tokenIds,
        values,
        sequenceId: ethereumjs_util_1.bufferToInt(sequenceId),
        signature: ethereumjs_util_1.bufferToHex(signature),
        tokenContractAddress: ethereumjs_util_1.addHexPrefix(to),
        userData: userSentData,
    };
}
exports.decodeERC1155TransferData = decodeERC1155TransferData;
/**
 * Decode the given ABI-encoded transfer data for the sendMultisig function and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeNativeTransferData(data) {
    if (!data.startsWith(walletUtil_1.sendMultisigMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [to, amount, internalData, expireTime, sequenceId, signature] = getRawDecoded(walletUtil_1.sendMultiSigTypes, getBufferedByteCode(walletUtil_1.sendMultisigMethodId, data));
    return {
        to: ethereumjs_util_1.addHexPrefix(to),
        amount: new bignumber_js_1.default(ethereumjs_util_1.bufferToHex(amount)).toFixed(),
        expireTime: ethereumjs_util_1.bufferToInt(expireTime),
        sequenceId: ethereumjs_util_1.bufferToInt(sequenceId),
        signature: ethereumjs_util_1.bufferToHex(signature),
        data: ethereumjs_util_1.bufferToHex(internalData),
    };
}
exports.decodeNativeTransferData = decodeNativeTransferData;
/**
 * Decode the given ABI-encoded flush tokens data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeFlushTokensData(data) {
    if (!data.startsWith(walletUtil_1.flushForwarderTokensMethodId)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid transfer bytecode: ${data}`);
    }
    const [forwarderAddress, tokenAddress] = getRawDecoded(walletUtil_1.flushTokensTypes, getBufferedByteCode(walletUtil_1.flushForwarderTokensMethodId, data));
    return {
        forwarderAddress: ethereumjs_util_1.addHexPrefix(forwarderAddress),
        tokenAddress: ethereumjs_util_1.addHexPrefix(tokenAddress),
    };
}
exports.decodeFlushTokensData = decodeFlushTokensData;
/**
 * Classify the given transaction data based as a transaction type.
 * ETH transactions are defined by the first 8 bytes of the transaction data, also known as the method id
 *
 * @param {string} data The data to classify the transaction with
 * @returns {TransactionType} The classified transaction type
 */
function classifyTransaction(data) {
    if (data.length < 10) {
        // contract calls must have at least 4 bytes (method id) and '0x'
        // if it doesn't have enough data to be a contract call it must be a single sig send
        return sdk_core_1.TransactionType.SingleSigSend;
    }
    // TODO(STLX-1970): validate if we are going to constraint to some methods allowed
    let transactionType = transactionTypesMap[data.slice(0, 10).toLowerCase()];
    if (transactionType === undefined) {
        transactionType = sdk_core_1.TransactionType.ContractCall;
    }
    return transactionType;
}
exports.classifyTransaction = classifyTransaction;
/**
 * A transaction types map according to the starting part of the encoded data
 */
const transactionTypesMap = {
    [walletUtil_1.walletInitializationFirstBytes]: sdk_core_1.TransactionType.WalletInitialization,
    [walletUtil_1.recoveryWalletInitializationFirstBytes]: sdk_core_1.TransactionType.RecoveryWalletDeployment,
    [walletUtil_1.v1CreateWalletMethodId]: sdk_core_1.TransactionType.WalletInitialization,
    [walletUtil_1.createForwarderMethodId]: sdk_core_1.TransactionType.AddressInitialization,
    [walletUtil_1.v1CreateForwarderMethodId]: sdk_core_1.TransactionType.AddressInitialization,
    [walletUtil_1.sendMultisigMethodId]: sdk_core_1.TransactionType.Send,
    [walletUtil_1.flushForwarderTokensMethodId]: sdk_core_1.TransactionType.FlushTokens,
    [walletUtil_1.flushCoinsMethodId]: sdk_core_1.TransactionType.FlushCoins,
    [walletUtil_1.sendMultisigTokenMethodId]: sdk_core_1.TransactionType.Send,
    [sdk_core_1.LockMethodId]: sdk_core_1.TransactionType.StakingLock,
    [sdk_core_1.VoteMethodId]: sdk_core_1.TransactionType.StakingVote,
    [sdk_core_1.ActivateMethodId]: sdk_core_1.TransactionType.StakingActivate,
    [sdk_core_1.UnvoteMethodId]: sdk_core_1.TransactionType.StakingUnvote,
    [sdk_core_1.UnlockMethodId]: sdk_core_1.TransactionType.StakingUnlock,
    [sdk_core_1.WithdrawMethodId]: sdk_core_1.TransactionType.StakingWithdraw,
};
/**
 *
 * @param {number} num number to be converted to hex
 * @returns {string} the hex number
 */
function numberToHexString(num) {
    const hex = num.toString(16);
    return hex.length % 2 === 0 ? '0x' + hex : '0x0' + hex;
}
exports.numberToHexString = numberToHexString;
/**
 *
 * @param {string} hex The hex string to be converted
 * @returns {number} the resulting number
 */
function hexStringToNumber(hex) {
    return parseInt(hex.slice(2), 16);
}
exports.hexStringToNumber = hexStringToNumber;
/**
 * Generates an address of the forwarder address to be deployed
 *
 * @param {string} contractAddress the address which is creating this new address
 * @param {number} contractCounter the nonce of the contract address
 * @returns {string} the calculated forwarder contract address
 */
function calculateForwarderAddress(contractAddress, contractCounter) {
    const forwarderAddress = ethereumjs_util_1.generateAddress(buffer_1.Buffer.from(ethereumjs_util_1.stripHexPrefix(contractAddress), 'hex'), buffer_1.Buffer.from(ethereumjs_util_1.padToEven(ethereumjs_util_1.stripHexPrefix(numberToHexString(contractCounter))), 'hex'));
    return ethereumjs_util_1.addHexPrefix(forwarderAddress.toString('hex'));
}
exports.calculateForwarderAddress = calculateForwarderAddress;
/**
 * Calculate the forwarder v1 address that will be generated if `creatorAddress` creates it with salt `salt`
 * and initcode `inicode using the create2 opcode
 * @param {string} creatorAddress The address that is sending the tx to create a new address, hex string
 * @param {string} salt The salt to create the address with using create2, hex string
 * @param {string} initcode The initcode that will be deployed to the address, hex string
 * @return {string} The calculated address
 */
function calculateForwarderV1Address(creatorAddress, salt, initcode) {
    const forwarderV1Address = ethereumjs_util_1.generateAddress2(buffer_1.Buffer.from(ethereumjs_util_1.stripHexPrefix(creatorAddress), 'hex'), buffer_1.Buffer.from(ethereumjs_util_1.stripHexPrefix(salt), 'hex'), buffer_1.Buffer.from(ethereumjs_util_1.padToEven(ethereumjs_util_1.stripHexPrefix(initcode)), 'hex'));
    return ethereumjs_util_1.addHexPrefix(forwarderV1Address.toString('hex'));
}
exports.calculateForwarderV1Address = calculateForwarderV1Address;
/**
 * Take the implementation address for the proxy contract, and get the binary initcode for the associated proxy
 * @param {string} implementationAddress The address of the implementation contract for the proxy
 * @return {string} Binary hex string of the proxy
 */
function getProxyInitcode(implementationAddress) {
    const target = ethereumjs_util_1.stripHexPrefix(implementationAddress.toLowerCase()).padStart(40, '0');
    // bytecode of the proxy, from:
    // https://github.com/BitGo/eth-multisig-v4/blob/d546a937f90f93e83b3423a5bf933d1d77c677c3/contracts/CloneFactory.sol#L42-L56
    return `0x3d602d80600a3d3981f3363d3d373d3d3d363d73${target}5af43d82803e903d91602b57fd5bf3`;
}
exports.getProxyInitcode = getProxyInitcode;
/**
 * Convert the given signature parts to a string representation
 *
 * @param {SignatureParts} sig The signature to convert to string
 * @returns {string} String representation of the signature
 */
function toStringSig(sig) {
    return ethereumjs_util_1.bufferToHex(buffer_1.Buffer.concat([
        ethereumjs_util_1.setLengthLeft(buffer_1.Buffer.from(ethereumjs_util_1.stripHexPrefix(sig.r), 'hex'), 32),
        ethereumjs_util_1.setLengthLeft(buffer_1.Buffer.from(ethereumjs_util_1.stripHexPrefix(sig.s), 'hex'), 32),
        ethereumjs_util_1.toBuffer(sig.v),
    ]));
}
exports.toStringSig = toStringSig;
/**
 * Return whether or not the given tx data has a signature
 *
 * @param {TxData} txData The transaction data to check for signature
 * @returns {boolean} true if the tx has a signature, else false
 */
function hasSignature(txData) {
    return (txData.v !== undefined &&
        txData.r !== undefined &&
        txData.s !== undefined &&
        txData.v.length > 0 &&
        txData.r.length > 0 &&
        txData.s.length > 0);
}
exports.hasSignature = hasSignature;
/**
 * Get the raw data decoded for some types
 *
 * @param {string[]} types ABI types definition
 * @param {Buffer} serializedArgs encoded args
 * @returns {Buffer[]} the decoded raw
 */
function getRawDecoded(types, serializedArgs) {
    function normalize(v, i) {
        if (bn_js_1.default.isBN(v)) {
            return v;
        }
        else if (typeof v === 'string' || buffer_1.Buffer.isBuffer(v)) {
            return v;
        }
        else if (Array.isArray(v)) {
            return v.map(normalize);
        }
        else {
            throw new Error(`For ${types}[${i}] got ${typeof v}`);
        }
    }
    return ethereumjs_abi_1.default.rawDecode(types, serializedArgs).map(normalize);
}
exports.getRawDecoded = getRawDecoded;
/**
 * Get the buffered bytecode from rawData using a methodId as delimiter
 *
 * @param {string} methodId the hex encoded method Id
 * @param {string} rawData the hex encoded raw data
 * @returns {Buffer} data buffered bytecode
 */
function getBufferedByteCode(methodId, rawData) {
    const splitBytecode = rawData.split(methodId);
    if (splitBytecode.length !== 2) {
        throw new sdk_core_1.BuildTransactionError(`Invalid send bytecode: ${rawData}`);
    }
    if (splitBytecode[1].length % 2 !== 0) {
        throw new sdk_core_1.BuildTransactionError(`Invalid send bytecode: ${rawData} (wrong lenght)`);
    }
    return buffer_1.Buffer.from(splitBytecode[1], 'hex');
}
exports.getBufferedByteCode = getBufferedByteCode;
/**
 * Get the statics coin object matching a given contract address if it exists
 *
 * @param tokenContractAddress The contract address to match against
 * @returns statics BaseCoin object for the matching token
 */
function getToken(tokenContractAddress, network) {
    const tokens = statics_1.coins.filter((coin) => {
        if (coin instanceof statics_1.ContractAddressDefinedToken) {
            return (coin.network.type === network.type && coin.contractAddress.toLowerCase() === tokenContractAddress.toLowerCase());
        }
        return false;
    });
    // if length of tokens is 1, return the first, else return undefined
    // Can't directly index into tokens, or call `length`, so we use map to get an array
    const tokensArray = tokens.map((token) => token);
    if (tokensArray.length >= 1) {
        // there should never be two tokens with the same contract address, so we assert that here
        assert_1.default(tokensArray.length === 1);
        return tokensArray[0];
    }
    return undefined;
}
exports.getToken = getToken;
/**
 * Returns the create wallet method calling data for v1 wallets
 *
 * @param {string[]} walletOwners - wallet owner addresses for wallet initialization transactions
 * @param {string} salt - The salt for wallet initialization transactions
 * @returns {string} - the createWallet method encoded
 */
function getV1WalletInitializationData(walletOwners, salt) {
    const saltBuffer = ethereumjs_util_1.setLengthLeft(ethereumjs_util_1.toBuffer(salt), 32);
    const params = [walletOwners, saltBuffer];
    const method = ethereumjs_abi_1.default.methodID('createWallet', walletUtil_1.createV1WalletTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.createV1WalletTypes, params);
    return ethereumjs_util_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.getV1WalletInitializationData = getV1WalletInitializationData;
/**
 * Returns the create address method calling data for v1 wallets
 *
 * @param {string} baseAddress - The address of the wallet contract
 * @param {string} salt - The salt for address initialization transactions
 * @returns {string} - the createForwarder method encoded
 */
function getV1AddressInitializationData(baseAddress, salt) {
    const saltBuffer = ethereumjs_util_1.setLengthLeft(ethereumjs_util_1.toBuffer(salt), 32);
    const params = [baseAddress, saltBuffer];
    const method = ethereumjs_abi_1.default.methodID('createForwarder', walletUtil_1.createV1ForwarderTypes);
    const args = ethereumjs_abi_1.default.rawEncode(walletUtil_1.createV1ForwarderTypes, params);
    return ethereumjs_util_1.addHexPrefix(buffer_1.Buffer.concat([method, args]).toString('hex'));
}
exports.getV1AddressInitializationData = getV1AddressInitializationData;
/**
 * Decode the given ABI-encoded create forwarder data and return parsed fields
 *
 * @param data The data to decode
 * @returns parsed transfer data
 */
function decodeForwarderCreationData(data) {
    if (!(data.startsWith(walletUtil_1.v1CreateForwarderMethodId) || data.startsWith(walletUtil_1.createForwarderMethodId))) {
        throw new sdk_core_1.BuildTransactionError(`Invalid address bytecode: ${data}`);
    }
    if (data.startsWith(walletUtil_1.createForwarderMethodId)) {
        return {
            baseAddress: undefined,
            addressCreationSalt: undefined,
        };
    }
    else {
        const [baseAddress, saltBuffer] = getRawDecoded(walletUtil_1.createV1ForwarderTypes, getBufferedByteCode(walletUtil_1.v1CreateForwarderMethodId, data));
        return {
            baseAddress: ethereumjs_util_1.addHexPrefix(baseAddress),
            addressCreationSalt: ethereumjs_util_1.bufferToHex(saltBuffer),
        };
    }
}
exports.decodeForwarderCreationData = decodeForwarderCreationData;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1DQUFnQztBQUNoQyxvREFBNEI7QUFDNUIscURBV3lCO0FBQ3pCLDRDQUE0RztBQUM1RyxvRUFBeUM7QUFDekMsZ0VBQWdEO0FBQ2hELGtEQUF1QjtBQUN2QixnRUFBcUM7QUFDckMsOENBVXlCO0FBZXpCLDZDQXVCc0I7QUFDdEIsbUNBQTZDO0FBRTdDOztHQUVHO0FBQ0gsU0FBZ0IsU0FBUyxDQUFDLE9BQXdCO0lBQ2hELE9BQU8sZ0JBQWMsQ0FBQyxjQUFjO0lBQ2xDLHdFQUF3RTtJQUN4RSxTQUFTLEVBQ1Q7UUFDRSxJQUFJLEVBQUUsT0FBTyxDQUFDLElBQUk7UUFDbEIsU0FBUyxFQUFFLE9BQU8sQ0FBQyxPQUFPO1FBQzFCLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTztLQUN6QixFQUNELFFBQVEsQ0FDVCxDQUFDO0FBQ0osQ0FBQztBQVhELDhCQVdDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSSxLQUFLLFVBQVUsWUFBWSxDQUNoQyxlQUF1QixFQUN2QixPQUFnQixFQUNoQixZQUE0QjtJQUU1QixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsRUFBRTtRQUMxQixNQUFNLElBQUksdUJBQVksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0tBQy9DO0lBQ0QsTUFBTSxLQUFLLEdBQUcsMEJBQWtCLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUN6RSxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3BCLE9BQU8sS0FBSyxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQzlCLENBQUM7QUFYRCxvQ0FXQztBQUVEOzs7Ozs7R0FNRztBQUNJLEtBQUssVUFBVSxJQUFJLENBQUMsZUFBdUIsRUFBRSxPQUFnQjtJQUNsRSxPQUFP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R0FBRyxhQUFhLENBQzdDLG1DQUFzQixFQUN0QixtQkFBbUIsQ0FBQyxzQ0FBeUIsRUFBRSxJQUFJLENBQUMsQ0FDckQsQ0FBQztRQUVGLE9BQU87WUFDTCxXQUFXLEVBQUUsOEJBQVksQ0FBQyxXQUFxQixDQUFDO1lBQ2hELG1CQUFtQixFQUFFLDZCQUFXLENBQUMsVUFBb0IsQ0FBQztTQUN2RCxDQUFDO0tBQ0g7QUFDSCxDQUFDO0FBckJELGtFQXFCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQge1xuICBhZGRIZXhQcmVmaXgsXG4gIGJ1ZmZlclRvSGV4LFxuICBidWZmZXJUb0ludCxcbiAgZ2VuZXJhdGVBZGRyZXNzLFxuICBpc1ZhbGlkQWRkcmVzcyxcbiAgc2V0TGVuZ3RoTGVmdCxcbiAgc3RyaXBIZXhQcmVmaXgsXG4gIHRvQnVmZmVyLFxuICBnZW5lcmF0ZUFkZHJlc3MyLFxuICBwYWRUb0V2ZW4sXG59IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgeyBCYXNlQ29pbiwgQmFzZU5ldHdvcmssIGNvaW5zLCBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4sIEV0aGVyZXVtTmV0d29yayB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCBFdGhlcmV1bUFiaSBmcm9tICdldGhlcmV1bWpzLWFiaSc7XG5pbXBvcnQgRXRoZXJldW1Db21tb24gZnJvbSAnQGV0aGVyZXVtanMvY29tbW9uJztcbmltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQge1xuICBBY3RpdmF0ZU1ldGhvZElkLFxuICBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsXG4gIExvY2tNZXRob2RJZCxcbiAgU2lnbmluZ0Vycm9yLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFVubG9ja01ldGhvZElkLFxuICBVbnZvdGVNZXRob2RJZCxcbiAgVm90ZU1ldGhvZElkLFxuICBXaXRoZHJhd01ldGhvZElkLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuXG5pbXBvcnQge1xuICBFUkMxMTU1VHJhbnNmZXJEYXRhLFxuICBFUkM3MjFUcmFuc2ZlckRhdGEsXG4gIEZsdXNoVG9rZW5zRGF0YSxcbiAgTmF0aXZlVHJhbnNmZXJEYXRhLFxuICBTaWduYXR1cmVQYXJ0cyxcbiAgVG9rZW5UcmFuc2ZlckRhdGEsXG4gIFRyYW5zZmVyRGF0YSxcbiAgVHhEYXRhLFxuICBXYWxsZXRJbml0aWFsaXphdGlvbkRhdGEsXG4gIEZvcndhcmRlckluaXRpYWxpemF0aW9uRGF0YSxcbn0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcbmltcG9ydCB7XG4gIGNyZWF0ZUZvcndhcmRlck1ldGhvZElkLFxuICBFUkMxMTU1QmF0Y2hUcmFuc2ZlclR5cGVNZXRob2RJZCxcbiAgRVJDMTE1NUJhdGNoVHJhbnNmZXJUeXBlcyxcbiAgRVJDMTE1NVNhZmVUcmFuc2ZlclR5cGVNZXRob2RJZCxcbiAgRVJDMTE1NVNhZmVUcmFuc2ZlclR5cGVzLFxuICBFUkM3MjFTYWZlVHJhbnNmZXJUeXBlTWV0aG9kSWQsXG4gIEVSQzcyMVNhZmVUcmFuc2ZlclR5cGVzLFxuICBmbHVzaENvaW5zTWV0aG9kSWQsXG4gIGZsdXNoQ29pbnNUeXBlcyxcbiAgZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZCxcbiAgZmx1c2hUb2tlbnNUeXBlcyxcbiAgc2VuZE11bHRpc2lnTWV0aG9kSWQsXG4gIHNlbmRNdWx0aXNpZ1Rva2VuTWV0aG9kSWQsXG4gIHNlbmRNdWx0aVNpZ1Rva2VuVHlwZXMsXG4gIHNlbmRNdWx0aVNpZ1R5cGVzLFxuICB3YWxsZXRJbml0aWFsaXphdGlvbkZpcnN0Qnl0ZXMsXG4gIHYxQ3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQsXG4gIHdhbGxldFNpbXBsZUNvbnN0cnVjdG9yLFxuICBjcmVhdGVWMVdhbGxldFR5cGVzLFxuICB2MUNyZWF0ZVdhbGxldE1ldGhvZElkLFxuICBjcmVhdGVWMUZvcndhcmRlclR5cGVzLFxuICByZWNvdmVyeVdhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlcyxcbn0gZnJvbSAnLi93YWxsZXRVdGlsJztcbmltcG9ydCB7IEV0aFRyYW5zYWN0aW9uRGF0YSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIEBwYXJhbSBuZXR3b3JrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21tb24obmV0d29yazogRXRoZXJldW1OZXR3b3JrKTogRXRoZXJldW1Db21tb24ge1xuICByZXR1cm4gRXRoZXJldW1Db21tb24uZm9yQ3VzdG9tQ2hhaW4oXG4gICAgLy8gdXNlIHRoZSBtYWlubmV0IGNvbmZpZyBhcyBhIGJhc2UsIG92ZXJyaWRlIGNoYWluIGlkcyBhbmQgbmV0d29yayBuYW1lXG4gICAgJ21haW5uZXQnLFxuICAgIHtcbiAgICAgIG5hbWU6IG5ldHdvcmsudHlwZSxcbiAgICAgIG5ldHdvcmtJZDogbmV0d29yay5jaGFpbklkLFxuICAgICAgY2hhaW5JZDogbmV0d29yay5jaGFpbklkLFxuICAgIH0sXG4gICAgJ2xvbmRvbidcbiAgKTtcbn1cblxuLyoqXG4gKiBTaWducyB0aGUgdHJhbnNhY3Rpb24gdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGFsZ29yaXRobVxuICogYW5kIHRoZSBwcm92aWRlZCBjb21tb24gZm9yIHRoZSBibG9ja2NoYWluXG4gKlxuICogQHBhcmFtIHtUeERhdGF9IHRyYW5zYWN0aW9uRGF0YSB0aGUgdHJhbnNhY3Rpb24gZGF0YSB0byBzaWduXG4gKiBAcGFyYW0ge0tleVBhaXJ9IGtleVBhaXIgdGhlIHNpZ25lcidzIGtleXBhaXJcbiAqIEBwYXJhbSB7RXRoZXJldW1Db21tb259IGN1c3RvbUNvbW1vbiB0aGUgbmV0d29yaydzIGN1c3RvbSBjb21tb25cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0cmFuc2FjdGlvbiBzaWduZWQgYW5kIGVuY29kZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25JbnRlcm5hbChcbiAgdHJhbnNhY3Rpb25EYXRhOiBUeERhdGEsXG4gIGtleVBhaXI6IEtleVBhaXIsXG4gIGN1c3RvbUNvbW1vbjogRXRoZXJldW1Db21tb25cbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGlmICgha2V5UGFpci5nZXRLZXlzKCkucHJ2KSB7XG4gICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignTWlzc2luZyBwcml2YXRlIGtleScpO1xuICB9XG4gIGNvbnN0IGV0aFR4ID0gRXRoVHJhbnNhY3Rpb25EYXRhLmZyb21Kc29uKHRyYW5zYWN0aW9uRGF0YSwgY3VzdG9tQ29tbW9uKTtcbiAgZXRoVHguc2lnbihrZXlQYWlyKTtcbiAgcmV0dXJuIGV0aFR4LnRvU2VyaWFsaXplZCgpO1xufVxuXG4vKipcbiAqIFNpZ25zIHRoZSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgYXBwcm9wcmlhdGUgYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIHtUeERhdGF9IHRyYW5zYWN0aW9uRGF0YSB0aGUgdHJhbnNhY3Rpb24gZGF0YSB0byBzaWduXG4gKiBAcGFyYW0ge0tleVBhaXJ9IGtleVBhaXIgdGhlIHNpZ25lcidzIGtleXBhaXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0cmFuc2FjdGlvbiBzaWduZWQgYW5kIGVuY29kZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ24odHJhbnNhY3Rpb25EYXRhOiBUeERhdGEsIGtleVBhaXI6IEtleVBhaXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gc2lnbkludGVybmFsKHRyYW5zYWN0aW9uRGF0YSwga2V5UGFpciwgZ2V0Q29tbW9uKGNvaW5zLmdldCgndGV0aCcpLm5ldHdvcmsgYXMgRXRoZXJldW1OZXR3b3JrKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udHJhY3QgbWV0aG9kIGVuY29kZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0byBkZXN0aW5hdGlvbiBhZGRyZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgQW1vdW50IHRvIHRyYW5mZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIGFkaXRpb25hbCBtZXRob2QgY2FsbCBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwaXJlVGltZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0cmFuc2FjdGlvbiBpbiBzZWNvbmRzXG4gKiBAcGFyYW0ge251bWJlcn0gc2VxdWVuY2VJZCBzZXF1ZW5jZSBpZFxuICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSBzaWduYXR1cmUgb2YgdGhlIGNhbGxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0tIHRoZSBjb250cmFjdCBtZXRob2QgZW5jb2RlZCBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kTXVsdGlTaWdEYXRhKFxuICB0bzogc3RyaW5nLFxuICB2YWx1ZTogc3RyaW5nLFxuICBkYXRhOiBzdHJpbmcsXG4gIGV4cGlyZVRpbWU6IG51bWJlcixcbiAgc2VxdWVuY2VJZDogbnVtYmVyLFxuICBzaWduYXR1cmU6IHN0cmluZ1xuKTogc3RyaW5nIHtcbiAgY29uc3QgcGFyYW1zID0gW3RvLCB2YWx1ZSwgdG9CdWZmZXIoZGF0YSksIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHRvQnVmZmVyKHNpZ25hdHVyZSldO1xuICBjb25zdCBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnc2VuZE11bHRpU2lnJywgc2VuZE11bHRpU2lnVHlwZXMpO1xuICBjb25zdCBhcmdzID0gRXRoZXJldW1BYmkucmF3RW5jb2RlKHNlbmRNdWx0aVNpZ1R5cGVzLCBwYXJhbXMpO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KEJ1ZmZlci5jb25jYXQoW21ldGhvZCwgYXJnc10pLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udHJhY3QgbWV0aG9kIGVuY29kZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0byBkZXN0aW5hdGlvbiBhZGRyZXNzXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgQW1vdW50IHRvIHRyYW5mZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbkNvbnRyYWN0QWRkcmVzcyB0aGUgYWRkcmVzcyBvZiB0aGUgZXJjMjAgdG9rZW4gY29udHJhY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBpcmVUaW1lIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGluIHNlY29uZHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZXF1ZW5jZUlkIHNlcXVlbmNlIGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlIHNpZ25hdHVyZSBvZiB0aGUgY2FsbFxuICogQHJldHVybnMge3N0cmluZ30gLS0gdGhlIGNvbnRyYWN0IG1ldGhvZCBlbmNvZGVkIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRNdWx0aVNpZ1Rva2VuRGF0YShcbiAgdG86IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyxcbiAgdG9rZW5Db250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZXhwaXJlVGltZTogbnVtYmVyLFxuICBzZXF1ZW5jZUlkOiBudW1iZXIsXG4gIHNpZ25hdHVyZTogc3RyaW5nXG4pOiBzdHJpbmcge1xuICBjb25zdCBwYXJhbXMgPSBbdG8sIHZhbHVlLCB0b2tlbkNvbnRyYWN0QWRkcmVzcywgZXhwaXJlVGltZSwgc2VxdWVuY2VJZCwgdG9CdWZmZXIoc2lnbmF0dXJlKV07XG5cbiAgY29uc3QgbWV0aG9kID0gRXRoZXJldW1BYmkubWV0aG9kSUQoJ3NlbmRNdWx0aVNpZ1Rva2VuJywgc2VuZE11bHRpU2lnVG9rZW5UeXBlcyk7XG4gIGNvbnN0IGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoc2VuZE11bHRpU2lnVG9rZW5UeXBlcywgcGFyYW1zKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZGF0YSByZXF1aXJlZCB0byBtYWtlIGEgZmx1c2ggdG9rZW5zIGNvbnRyYWN0IGNhbGxcbiAqXG4gKiBAcGFyYW0gZm9yd2FyZGVyQWRkcmVzcyBUaGUgZm9yd2FyZGVyIGFkZHJlc3MgdG8gZmx1c2hcbiAqIEBwYXJhbSB0b2tlbkFkZHJlc3MgVGhlIHRva2VuIGFkZHJlc3MgdG8gZmx1c2ggZnJvbVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmx1c2hUb2tlbnNEYXRhKGZvcndhcmRlckFkZHJlc3M6IHN0cmluZywgdG9rZW5BZGRyZXNzOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXJhbXMgPSBbZm9yd2FyZGVyQWRkcmVzcywgdG9rZW5BZGRyZXNzXTtcbiAgY29uc3QgbWV0aG9kID0gRXRoZXJldW1BYmkubWV0aG9kSUQoJ2ZsdXNoRm9yd2FyZGVyVG9rZW5zJywgZmx1c2hUb2tlbnNUeXBlcyk7XG4gIGNvbnN0IGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoZmx1c2hUb2tlbnNUeXBlcywgcGFyYW1zKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZGF0YSByZXF1aXJlZCB0byBtYWtlIGEgZmx1c2ggbmF0aXZlIGNvaW5zIGNvbnRyYWN0IGNhbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoQ29pbnNEYXRhKCk6IHN0cmluZyB7XG4gIGNvbnN0IHBhcmFtcyA9IFtdO1xuICBjb25zdCBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnZmx1c2gnLCBmbHVzaENvaW5zVHlwZXMpO1xuICBjb25zdCBhcmdzID0gRXRoZXJldW1BYmkucmF3RW5jb2RlKGZsdXNoQ29pbnNUeXBlcywgcGFyYW1zKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNyZWF0ZSBmb3J3YXJkZXIgbWV0aG9kIGNhbGxpbmcgZGF0YVxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGNyZWF0ZUZvcndhcmRlciBtZXRob2QgZW5jb2RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzc0luaXRpYWxpemF0aW9uRGF0YSgpOiBzdHJpbmcge1xuICByZXR1cm4gY3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgRXRoIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIHRoZSB0eCBoYXNoIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgYW1vdW50IG51bWJlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnQgLSB0aGUgc3RyaW5nIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBbW91bnQoYW1vdW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgYmlnTnVtYmVyQW1vdW50ID0gbmV3IEJpZ051bWJlcihhbW91bnQpO1xuICByZXR1cm4gYmlnTnVtYmVyQW1vdW50LmlzSW50ZWdlcigpICYmIGJpZ051bWJlckFtb3VudC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvKDApO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNtYXJ0IGNvbnRyYWN0IGVuY29kZWQgZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIFRoZSB3YWxsZXQgY3JlYXRpb24gZGF0YSB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBUaGUgbGlzdCBvZiBzaWduZXIgYWRkcmVzc2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVXYWxsZXRDcmVhdGlvbkRhdGEoZGF0YTogc3RyaW5nKTogV2FsbGV0SW5pdGlhbGl6YXRpb25EYXRhIHtcbiAgaWYgKCEoZGF0YS5zdGFydHNXaXRoKHdhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlcykgfHwgZGF0YS5zdGFydHNXaXRoKHYxQ3JlYXRlV2FsbGV0TWV0aG9kSWQpKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgd2FsbGV0IGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBpZiAoZGF0YS5zdGFydHNXaXRoKHdhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlcykpIHtcbiAgICBjb25zdCBkYXRhQnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YS5zbGljZSgyKSwgJ2hleCcpO1xuXG4gICAgLy8gdGhlIGxhc3QgMTYwIGJ5dGVzIGNvbnRhaW4gdGhlIHNlcmlhbGl6ZWQgYWRkcmVzcyBhcnJheVxuICAgIGNvbnN0IHNlcmlhbGl6ZWRTaWduZXJzID0gZGF0YUJ1ZmZlci5zbGljZSgtMTYwKTtcblxuICAgIGNvbnN0IHJlc3VsdEVuY29kZWRQYXJhbWV0ZXJzID0gRXRoZXJldW1BYmkucmF3RGVjb2RlKHdhbGxldFNpbXBsZUNvbnN0cnVjdG9yLCBzZXJpYWxpemVkU2lnbmVycyk7XG4gICAgaWYgKHJlc3VsdEVuY29kZWRQYXJhbWV0ZXJzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgQ291bGQgbm90IGRlY29kZSB3YWxsZXQgY29uc3RydWN0b3IgYnl0ZWNvZGU6ICR7cmVzdWx0RW5jb2RlZFBhcmFtZXRlcnN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzc2VzOiBCTltdID0gcmVzdWx0RW5jb2RlZFBhcmFtZXRlcnNbMF07XG4gICAgaWYgKGFkZHJlc3Nlcy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYGludmFsaWQgbnVtYmVyIG9mIGFkZHJlc3NlcyBpbiBwYXJzZWQgY29uc3RydWN0b3I6ICR7YWRkcmVzc2VzfWApO1xuICAgIH1cblxuICAgIC8vIHNvbWV0aW1lcyBldGhlcmV1bWpzLWFiaSByZW1vdmVzIDAgcGFkZGluZyBhdCB0aGUgc3RhcnQgb2YgYWRkcmVzc2VzLFxuICAgIC8vIHNvIHdlIHNob3VsZCBwYWQgdW50aWwgdGhleSBhcmUgdGhlIHN0YW5kYXJkIDIwIGJ5dGVzXG4gICAgY29uc3QgcGFkZGVkQWRkcmVzc2VzID0gYWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gc3RyaXBIZXhQcmVmaXgoYWRkcmVzcy50b1N0cmluZygnaGV4JykpLnBhZFN0YXJ0KDQwLCAnMCcpKTtcblxuICAgIHJldHVybiB7IG93bmVyczogcGFkZGVkQWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gYWRkSGV4UHJlZml4KGFkZHJlc3MpKSB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGRlY29kZWREYXRhRm9yV2FsbGV0Q3JlYXRpb24gPSBnZXRSYXdEZWNvZGVkKFxuICAgICAgY3JlYXRlVjFXYWxsZXRUeXBlcyxcbiAgICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUodjFDcmVhdGVXYWxsZXRNZXRob2RJZCwgZGF0YSlcbiAgICApO1xuICAgIGNvbnN0IGFkZHJlc3NlcyA9IGRlY29kZWREYXRhRm9yV2FsbGV0Q3JlYXRpb25bMF0gYXMgc3RyaW5nW107XG4gICAgY29uc3Qgc2FsdEJ1ZmZlciA9IGRlY29kZWREYXRhRm9yV2FsbGV0Q3JlYXRpb25bMV07XG4gICAgY29uc3Qgc2FsdCA9IGJ1ZmZlclRvSGV4KHNhbHRCdWZmZXIgYXMgQnVmZmVyKTtcbiAgICBjb25zdCBwYWRkZWRBZGRyZXNzZXMgPSBhZGRyZXNzZXMubWFwKChhZGRyZXNzKSA9PiBzdHJpcEhleFByZWZpeChhZGRyZXNzLnRvU3RyaW5nKCkpLnBhZFN0YXJ0KDQwLCAnMCcpKTtcbiAgICBjb25zdCBvd25lcnMgPSBwYWRkZWRBZGRyZXNzZXMubWFwKChhZGRyZXNzKSA9PiBhZGRIZXhQcmVmaXgoYWRkcmVzcykpO1xuICAgIHJldHVybiB7XG4gICAgICBvd25lcnMsXG4gICAgICBzYWx0LFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIEFCSS1lbmNvZGVkIHRyYW5zZmVyIGRhdGEgYW5kIHJldHVybiBwYXJzZWQgZmllbGRzXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyBwYXJzZWQgdHJhbnNmZXIgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVHJhbnNmZXJEYXRhKGRhdGE6IHN0cmluZyk6IFRyYW5zZmVyRGF0YSB7XG4gIGlmIChkYXRhLnN0YXJ0c1dpdGgoc2VuZE11bHRpc2lnTWV0aG9kSWQpKSB7XG4gICAgcmV0dXJuIGRlY29kZU5hdGl2ZVRyYW5zZmVyRGF0YShkYXRhKTtcbiAgfSBlbHNlIGlmIChkYXRhLnN0YXJ0c1dpdGgoc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZCkpIHtcbiAgICByZXR1cm4gZGVjb2RlVG9rZW5UcmFuc2ZlckRhdGEoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCB0cmFuc2ZlciBieXRlY29kZTogJHtkYXRhfWApO1xuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBBQkktZW5jb2RlZCB0cmFuc2ZlciBkYXRhIGZvciB0aGUgc2VuZE11bHRpc2lnVG9rZW4gZnVuY3Rpb24gYW5kIHJldHVybiBwYXJzZWQgZmllbGRzXG4gKlxuICogQHBhcmFtIGRhdGEgVGhlIGRhdGEgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyBwYXJzZWQgdG9rZW4gdHJhbnNmZXIgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVG9rZW5UcmFuc2ZlckRhdGEoZGF0YTogc3RyaW5nKTogVG9rZW5UcmFuc2ZlckRhdGEge1xuICBpZiAoIWRhdGEuc3RhcnRzV2l0aChzZW5kTXVsdGlzaWdUb2tlbk1ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFt0bywgYW1vdW50LCB0b2tlbkNvbnRyYWN0QWRkcmVzcywgZXhwaXJlVGltZSwgc2VxdWVuY2VJZCwgc2lnbmF0dXJlXSA9IGdldFJhd0RlY29kZWQoXG4gICAgc2VuZE11bHRpU2lnVG9rZW5UeXBlcyxcbiAgICBnZXRCdWZmZXJlZEJ5dGVDb2RlKHNlbmRNdWx0aXNpZ1Rva2VuTWV0aG9kSWQsIGRhdGEpXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICB0bzogYWRkSGV4UHJlZml4KHRvIGFzIHN0cmluZyksXG4gICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KGFtb3VudCBhcyBCdWZmZXIpKS50b0ZpeGVkKCksXG4gICAgZXhwaXJlVGltZTogYnVmZmVyVG9JbnQoZXhwaXJlVGltZSBhcyBCdWZmZXIpLFxuICAgIHNlcXVlbmNlSWQ6IGJ1ZmZlclRvSW50KHNlcXVlbmNlSWQgYXMgQnVmZmVyKSxcbiAgICBzaWduYXR1cmU6IGJ1ZmZlclRvSGV4KHNpZ25hdHVyZSBhcyBCdWZmZXIpLFxuICAgIHRva2VuQ29udHJhY3RBZGRyZXNzOiBhZGRIZXhQcmVmaXgodG9rZW5Db250cmFjdEFkZHJlc3MgYXMgc3RyaW5nKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUVSQzcyMVRyYW5zZmVyRGF0YShkYXRhOiBzdHJpbmcpOiBFUkM3MjFUcmFuc2ZlckRhdGEge1xuICBpZiAoIWRhdGEuc3RhcnRzV2l0aChzZW5kTXVsdGlzaWdNZXRob2RJZCkpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBjb25zdCBbdG8sIGFtb3VudCwgaW50ZXJuYWxEYXRhLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCBzaWduYXR1cmVdID0gZ2V0UmF3RGVjb2RlZChcbiAgICBzZW5kTXVsdGlTaWdUeXBlcyxcbiAgICBnZXRCdWZmZXJlZEJ5dGVDb2RlKHNlbmRNdWx0aXNpZ01ldGhvZElkLCBkYXRhKVxuICApO1xuXG4gIGNvbnN0IGludGVybmFsRGF0YUhleCA9IGJ1ZmZlclRvSGV4KGludGVybmFsRGF0YSBhcyBCdWZmZXIpO1xuICBpZiAoIWludGVybmFsRGF0YUhleC5zdGFydHNXaXRoKEVSQzcyMVNhZmVUcmFuc2ZlclR5cGVNZXRob2RJZCkpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBjb25zdCBbZnJvbSwgcmVjZWl2ZXIsIHRva2VuSWQsIHVzZXJTZW50RGF0YV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgIEVSQzcyMVNhZmVUcmFuc2ZlclR5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoRVJDNzIxU2FmZVRyYW5zZmVyVHlwZU1ldGhvZElkLCBpbnRlcm5hbERhdGFIZXgpXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICB0bzogYWRkSGV4UHJlZml4KHJlY2VpdmVyIGFzIHN0cmluZyksXG4gICAgZnJvbTogYWRkSGV4UHJlZml4KGZyb20gYXMgc3RyaW5nKSxcbiAgICBleHBpcmVUaW1lOiBidWZmZXJUb0ludChleHBpcmVUaW1lIGFzIEJ1ZmZlciksXG4gICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KGFtb3VudCBhcyBCdWZmZXIpKS50b0ZpeGVkKCksXG4gICAgdG9rZW5JZDogbmV3IEJpZ051bWJlcihidWZmZXJUb0hleCh0b2tlbklkIGFzIEJ1ZmZlcikpLnRvRml4ZWQoKSxcbiAgICBzZXF1ZW5jZUlkOiBidWZmZXJUb0ludChzZXF1ZW5jZUlkIGFzIEJ1ZmZlciksXG4gICAgc2lnbmF0dXJlOiBidWZmZXJUb0hleChzaWduYXR1cmUgYXMgQnVmZmVyKSxcbiAgICB0b2tlbkNvbnRyYWN0QWRkcmVzczogYWRkSGV4UHJlZml4KHRvIGFzIHN0cmluZyksXG4gICAgdXNlckRhdGE6IGJ1ZmZlclRvSGV4KHVzZXJTZW50RGF0YSBhcyBCdWZmZXIpLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRVJDMTE1NVRyYW5zZmVyRGF0YShkYXRhOiBzdHJpbmcpOiBFUkMxMTU1VHJhbnNmZXJEYXRhIHtcbiAgbGV0IGZyb20sIHJlY2VpdmVyLCB1c2VyU2VudERhdGE7XG4gIGxldCB0b2tlbklkczogc3RyaW5nW107XG4gIGxldCB2YWx1ZXM6IHN0cmluZ1tdO1xuXG4gIGlmICghZGF0YS5zdGFydHNXaXRoKHNlbmRNdWx0aXNpZ01ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFt0bywgYW1vdW50LCBpbnRlcm5hbERhdGEsIGV4cGlyZVRpbWUsIHNlcXVlbmNlSWQsIHNpZ25hdHVyZV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgIHNlbmRNdWx0aVNpZ1R5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoc2VuZE11bHRpc2lnTWV0aG9kSWQsIGRhdGEpXG4gICk7XG5cbiAgY29uc3QgaW50ZXJuYWxEYXRhSGV4ID0gYnVmZmVyVG9IZXgoaW50ZXJuYWxEYXRhIGFzIEJ1ZmZlcik7XG4gIGlmIChpbnRlcm5hbERhdGFIZXguc3RhcnRzV2l0aChFUkMxMTU1U2FmZVRyYW5zZmVyVHlwZU1ldGhvZElkKSkge1xuICAgIGxldCB0b2tlbklkO1xuICAgIGxldCB2YWx1ZTtcblxuICAgIFtmcm9tLCByZWNlaXZlciwgdG9rZW5JZCwgdmFsdWUsIHVzZXJTZW50RGF0YV0gPSBnZXRSYXdEZWNvZGVkKFxuICAgICAgRVJDMTE1NVNhZmVUcmFuc2ZlclR5cGVzLFxuICAgICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShFUkMxMTU1U2FmZVRyYW5zZmVyVHlwZU1ldGhvZElkLCBpbnRlcm5hbERhdGFIZXgpXG4gICAgKTtcblxuICAgIHRva2VuSWRzID0gW25ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgodG9rZW5JZCkpLnRvRml4ZWQoKV07XG4gICAgdmFsdWVzID0gW25ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgodmFsdWUpKS50b0ZpeGVkKCldO1xuICB9IGVsc2UgaWYgKGJ1ZmZlclRvSGV4KGludGVybmFsRGF0YSBhcyBCdWZmZXIpLnN0YXJ0c1dpdGgoRVJDMTE1NUJhdGNoVHJhbnNmZXJUeXBlTWV0aG9kSWQpKSB7XG4gICAgbGV0IHRlbXBUb2tlbklkcywgdGVtcFZhbHVlcztcbiAgICBbZnJvbSwgcmVjZWl2ZXIsIHRlbXBUb2tlbklkcywgdGVtcFZhbHVlcywgdXNlclNlbnREYXRhXSA9IGdldFJhd0RlY29kZWQoXG4gICAgICBFUkMxMTU1QmF0Y2hUcmFuc2ZlclR5cGVzLFxuICAgICAgZ2V0QnVmZmVyZWRCeXRlQ29kZShFUkMxMTU1QmF0Y2hUcmFuc2ZlclR5cGVNZXRob2RJZCwgaW50ZXJuYWxEYXRhSGV4KVxuICAgICk7XG4gICAgdG9rZW5JZHMgPSB0ZW1wVG9rZW5JZHMubWFwKCh4KSA9PiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KHgpKS50b0ZpeGVkKCkpO1xuICAgIHZhbHVlcyA9IHRlbXBWYWx1ZXMubWFwKCh4KSA9PiBuZXcgQmlnTnVtYmVyKGJ1ZmZlclRvSGV4KHgpKS50b0ZpeGVkKCkpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG86IGFkZEhleFByZWZpeChyZWNlaXZlciksXG4gICAgZnJvbTogYWRkSGV4UHJlZml4KGZyb20pLFxuICAgIGV4cGlyZVRpbWU6IGJ1ZmZlclRvSW50KGV4cGlyZVRpbWUgYXMgQnVmZmVyKSxcbiAgICBhbW91bnQ6IG5ldyBCaWdOdW1iZXIoYnVmZmVyVG9IZXgoYW1vdW50IGFzIEJ1ZmZlcikpLnRvRml4ZWQoKSxcbiAgICB0b2tlbklkcyxcbiAgICB2YWx1ZXMsXG4gICAgc2VxdWVuY2VJZDogYnVmZmVyVG9JbnQoc2VxdWVuY2VJZCBhcyBCdWZmZXIpLFxuICAgIHNpZ25hdHVyZTogYnVmZmVyVG9IZXgoc2lnbmF0dXJlIGFzIEJ1ZmZlciksXG4gICAgdG9rZW5Db250cmFjdEFkZHJlc3M6IGFkZEhleFByZWZpeCh0byBhcyBzdHJpbmcpLFxuICAgIHVzZXJEYXRhOiB1c2VyU2VudERhdGEsXG4gIH07XG59XG5cbi8qKlxuICogRGVjb2RlIHRoZSBnaXZlbiBBQkktZW5jb2RlZCB0cmFuc2ZlciBkYXRhIGZvciB0aGUgc2VuZE11bHRpc2lnIGZ1bmN0aW9uIGFuZCByZXR1cm4gcGFyc2VkIGZpZWxkc1xuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29kZVxuICogQHJldHVybnMgcGFyc2VkIHRyYW5zZmVyIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5hdGl2ZVRyYW5zZmVyRGF0YShkYXRhOiBzdHJpbmcpOiBOYXRpdmVUcmFuc2ZlckRhdGEge1xuICBpZiAoIWRhdGEuc3RhcnRzV2l0aChzZW5kTXVsdGlzaWdNZXRob2RJZCkpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHRyYW5zZmVyIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBjb25zdCBbdG8sIGFtb3VudCwgaW50ZXJuYWxEYXRhLCBleHBpcmVUaW1lLCBzZXF1ZW5jZUlkLCBzaWduYXR1cmVdID0gZ2V0UmF3RGVjb2RlZChcbiAgICBzZW5kTXVsdGlTaWdUeXBlcyxcbiAgICBnZXRCdWZmZXJlZEJ5dGVDb2RlKHNlbmRNdWx0aXNpZ01ldGhvZElkLCBkYXRhKVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgdG86IGFkZEhleFByZWZpeCh0byBhcyBzdHJpbmcpLFxuICAgIGFtb3VudDogbmV3IEJpZ051bWJlcihidWZmZXJUb0hleChhbW91bnQgYXMgQnVmZmVyKSkudG9GaXhlZCgpLFxuICAgIGV4cGlyZVRpbWU6IGJ1ZmZlclRvSW50KGV4cGlyZVRpbWUgYXMgQnVmZmVyKSxcbiAgICBzZXF1ZW5jZUlkOiBidWZmZXJUb0ludChzZXF1ZW5jZUlkIGFzIEJ1ZmZlciksXG4gICAgc2lnbmF0dXJlOiBidWZmZXJUb0hleChzaWduYXR1cmUgYXMgQnVmZmVyKSxcbiAgICBkYXRhOiBidWZmZXJUb0hleChpbnRlcm5hbERhdGEgYXMgQnVmZmVyKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIEFCSS1lbmNvZGVkIGZsdXNoIHRva2VucyBkYXRhIGFuZCByZXR1cm4gcGFyc2VkIGZpZWxkc1xuICpcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29kZVxuICogQHJldHVybnMgcGFyc2VkIHRyYW5zZmVyIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUZsdXNoVG9rZW5zRGF0YShkYXRhOiBzdHJpbmcpOiBGbHVzaFRva2Vuc0RhdGEge1xuICBpZiAoIWRhdGEuc3RhcnRzV2l0aChmbHVzaEZvcndhcmRlclRva2Vuc01ldGhvZElkKSkge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgdHJhbnNmZXIgYnl0ZWNvZGU6ICR7ZGF0YX1gKTtcbiAgfVxuXG4gIGNvbnN0IFtmb3J3YXJkZXJBZGRyZXNzLCB0b2tlbkFkZHJlc3NdID0gZ2V0UmF3RGVjb2RlZChcbiAgICBmbHVzaFRva2Vuc1R5cGVzLFxuICAgIGdldEJ1ZmZlcmVkQnl0ZUNvZGUoZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZCwgZGF0YSlcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIGZvcndhcmRlckFkZHJlc3M6IGFkZEhleFByZWZpeChmb3J3YXJkZXJBZGRyZXNzIGFzIHN0cmluZyksXG4gICAgdG9rZW5BZGRyZXNzOiBhZGRIZXhQcmVmaXgodG9rZW5BZGRyZXNzIGFzIHN0cmluZyksXG4gIH07XG59XG5cbi8qKlxuICogQ2xhc3NpZnkgdGhlIGdpdmVuIHRyYW5zYWN0aW9uIGRhdGEgYmFzZWQgYXMgYSB0cmFuc2FjdGlvbiB0eXBlLlxuICogRVRIIHRyYW5zYWN0aW9ucyBhcmUgZGVmaW5lZCBieSB0aGUgZmlyc3QgOCBieXRlcyBvZiB0aGUgdHJhbnNhY3Rpb24gZGF0YSwgYWxzbyBrbm93biBhcyB0aGUgbWV0aG9kIGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gY2xhc3NpZnkgdGhlIHRyYW5zYWN0aW9uIHdpdGhcbiAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblR5cGV9IFRoZSBjbGFzc2lmaWVkIHRyYW5zYWN0aW9uIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWZ5VHJhbnNhY3Rpb24oZGF0YTogc3RyaW5nKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgaWYgKGRhdGEubGVuZ3RoIDwgMTApIHtcbiAgICAvLyBjb250cmFjdCBjYWxscyBtdXN0IGhhdmUgYXQgbGVhc3QgNCBieXRlcyAobWV0aG9kIGlkKSBhbmQgJzB4J1xuICAgIC8vIGlmIGl0IGRvZXNuJ3QgaGF2ZSBlbm91Z2ggZGF0YSB0byBiZSBhIGNvbnRyYWN0IGNhbGwgaXQgbXVzdCBiZSBhIHNpbmdsZSBzaWcgc2VuZFxuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU2luZ2xlU2lnU2VuZDtcbiAgfVxuXG4gIC8vIFRPRE8oU1RMWC0xOTcwKTogdmFsaWRhdGUgaWYgd2UgYXJlIGdvaW5nIHRvIGNvbnN0cmFpbnQgdG8gc29tZSBtZXRob2RzIGFsbG93ZWRcbiAgbGV0IHRyYW5zYWN0aW9uVHlwZSA9IHRyYW5zYWN0aW9uVHlwZXNNYXBbZGF0YS5zbGljZSgwLCAxMCkudG9Mb3dlckNhc2UoKV07XG4gIGlmICh0cmFuc2FjdGlvblR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRyYW5zYWN0aW9uVHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5Db250cmFjdENhbGw7XG4gIH1cblxuICByZXR1cm4gdHJhbnNhY3Rpb25UeXBlO1xufVxuXG4vKipcbiAqIEEgdHJhbnNhY3Rpb24gdHlwZXMgbWFwIGFjY29yZGluZyB0byB0aGUgc3RhcnRpbmcgcGFydCBvZiB0aGUgZW5jb2RlZCBkYXRhXG4gKi9cbmNvbnN0IHRyYW5zYWN0aW9uVHlwZXNNYXAgPSB7XG4gIFt3YWxsZXRJbml0aWFsaXphdGlvbkZpcnN0Qnl0ZXNdOiBUcmFuc2FjdGlvblR5cGUuV2FsbGV0SW5pdGlhbGl6YXRpb24sXG4gIFtyZWNvdmVyeVdhbGxldEluaXRpYWxpemF0aW9uRmlyc3RCeXRlc106IFRyYW5zYWN0aW9uVHlwZS5SZWNvdmVyeVdhbGxldERlcGxveW1lbnQsXG4gIFt2MUNyZWF0ZVdhbGxldE1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLldhbGxldEluaXRpYWxpemF0aW9uLFxuICBbY3JlYXRlRm9yd2FyZGVyTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuQWRkcmVzc0luaXRpYWxpemF0aW9uLFxuICBbdjFDcmVhdGVGb3J3YXJkZXJNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5BZGRyZXNzSW5pdGlhbGl6YXRpb24sXG4gIFtzZW5kTXVsdGlzaWdNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TZW5kLFxuICBbZmx1c2hGb3J3YXJkZXJUb2tlbnNNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5GbHVzaFRva2VucyxcbiAgW2ZsdXNoQ29pbnNNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5GbHVzaENvaW5zLFxuICBbc2VuZE11bHRpc2lnVG9rZW5NZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TZW5kLFxuICBbTG9ja01ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdMb2NrLFxuICBbVm90ZU1ldGhvZElkXTogVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdWb3RlLFxuICBbQWN0aXZhdGVNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nQWN0aXZhdGUsXG4gIFtVbnZvdGVNZXRob2RJZF06IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nVW52b3RlLFxuICBbVW5sb2NrTWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1VubG9jayxcbiAgW1dpdGhkcmF3TWV0aG9kSWRdOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1dpdGhkcmF3LFxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBudW1iZXIgdG8gYmUgY29udmVydGVkIHRvIGhleFxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGhleCBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4U3RyaW5nKG51bTogbnVtYmVyKTogc3RyaW5nIHtcbiAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggJSAyID09PSAwID8gJzB4JyArIGhleCA6ICcweDAnICsgaGV4O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGV4IFRoZSBoZXggc3RyaW5nIHRvIGJlIGNvbnZlcnRlZFxuICogQHJldHVybnMge251bWJlcn0gdGhlIHJlc3VsdGluZyBudW1iZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFN0cmluZ1RvTnVtYmVyKGhleDogc3RyaW5nKTogbnVtYmVyIHtcbiAgcmV0dXJuIHBhcnNlSW50KGhleC5zbGljZSgyKSwgMTYpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIHRoZSBmb3J3YXJkZXIgYWRkcmVzcyB0byBiZSBkZXBsb3llZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgdGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRyYWN0Q291bnRlciB0aGUgbm9uY2Ugb2YgdGhlIGNvbnRyYWN0IGFkZHJlc3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBjYWxjdWxhdGVkIGZvcndhcmRlciBjb250cmFjdCBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVGb3J3YXJkZXJBZGRyZXNzKGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLCBjb250cmFjdENvdW50ZXI6IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IGZvcndhcmRlckFkZHJlc3MgPSBnZW5lcmF0ZUFkZHJlc3MoXG4gICAgQnVmZmVyLmZyb20oc3RyaXBIZXhQcmVmaXgoY29udHJhY3RBZGRyZXNzKSwgJ2hleCcpLFxuICAgIEJ1ZmZlci5mcm9tKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChudW1iZXJUb0hleFN0cmluZyhjb250cmFjdENvdW50ZXIpKSksICdoZXgnKVxuICApO1xuICByZXR1cm4gYWRkSGV4UHJlZml4KGZvcndhcmRlckFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGZvcndhcmRlciB2MSBhZGRyZXNzIHRoYXQgd2lsbCBiZSBnZW5lcmF0ZWQgaWYgYGNyZWF0b3JBZGRyZXNzYCBjcmVhdGVzIGl0IHdpdGggc2FsdCBgc2FsdGBcbiAqIGFuZCBpbml0Y29kZSBgaW5pY29kZSB1c2luZyB0aGUgY3JlYXRlMiBvcGNvZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBjcmVhdG9yQWRkcmVzcyBUaGUgYWRkcmVzcyB0aGF0IGlzIHNlbmRpbmcgdGhlIHR4IHRvIGNyZWF0ZSBhIG5ldyBhZGRyZXNzLCBoZXggc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gc2FsdCBUaGUgc2FsdCB0byBjcmVhdGUgdGhlIGFkZHJlc3Mgd2l0aCB1c2luZyBjcmVhdGUyLCBoZXggc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5pdGNvZGUgVGhlIGluaXRjb2RlIHRoYXQgd2lsbCBiZSBkZXBsb3llZCB0byB0aGUgYWRkcmVzcywgaGV4IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfSBUaGUgY2FsY3VsYXRlZCBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVGb3J3YXJkZXJWMUFkZHJlc3MoY3JlYXRvckFkZHJlc3M6IHN0cmluZywgc2FsdDogc3RyaW5nLCBpbml0Y29kZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZm9yd2FyZGVyVjFBZGRyZXNzID0gZ2VuZXJhdGVBZGRyZXNzMihcbiAgICBCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChjcmVhdG9yQWRkcmVzcyksICdoZXgnKSxcbiAgICBCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChzYWx0KSwgJ2hleCcpLFxuICAgIEJ1ZmZlci5mcm9tKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChpbml0Y29kZSkpLCAnaGV4JylcbiAgKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChmb3J3YXJkZXJWMUFkZHJlc3MudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBUYWtlIHRoZSBpbXBsZW1lbnRhdGlvbiBhZGRyZXNzIGZvciB0aGUgcHJveHkgY29udHJhY3QsIGFuZCBnZXQgdGhlIGJpbmFyeSBpbml0Y29kZSBmb3IgdGhlIGFzc29jaWF0ZWQgcHJveHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbXBsZW1lbnRhdGlvbkFkZHJlc3MgVGhlIGFkZHJlc3Mgb2YgdGhlIGltcGxlbWVudGF0aW9uIGNvbnRyYWN0IGZvciB0aGUgcHJveHlcbiAqIEByZXR1cm4ge3N0cmluZ30gQmluYXJ5IGhleCBzdHJpbmcgb2YgdGhlIHByb3h5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm94eUluaXRjb2RlKGltcGxlbWVudGF0aW9uQWRkcmVzczogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgdGFyZ2V0ID0gc3RyaXBIZXhQcmVmaXgoaW1wbGVtZW50YXRpb25BZGRyZXNzLnRvTG93ZXJDYXNlKCkpLnBhZFN0YXJ0KDQwLCAnMCcpO1xuXG4gIC8vIGJ5dGVjb2RlIG9mIHRoZSBwcm94eSwgZnJvbTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0JpdEdvL2V0aC1tdWx0aXNpZy12NC9ibG9iL2Q1NDZhOTM3ZjkwZjkzZTgzYjM0MjNhNWJmOTMzZDFkNzdjNjc3YzMvY29udHJhY3RzL0Nsb25lRmFjdG9yeS5zb2wjTDQyLUw1NlxuICByZXR1cm4gYDB4M2Q2MDJkODA2MDBhM2QzOTgxZjMzNjNkM2QzNzNkM2QzZDM2M2Q3MyR7dGFyZ2V0fTVhZjQzZDgyODAzZTkwM2Q5MTYwMmI1N2ZkNWJmM2A7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gc2lnbmF0dXJlIHBhcnRzIHRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTaWduYXR1cmVQYXJ0c30gc2lnIFRoZSBzaWduYXR1cmUgdG8gY29udmVydCB0byBzdHJpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZ1NpZyhzaWc6IFNpZ25hdHVyZVBhcnRzKTogc3RyaW5nIHtcbiAgcmV0dXJuIGJ1ZmZlclRvSGV4KFxuICAgIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgc2V0TGVuZ3RoTGVmdChCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChzaWcuciksICdoZXgnKSwgMzIpLFxuICAgICAgc2V0TGVuZ3RoTGVmdChCdWZmZXIuZnJvbShzdHJpcEhleFByZWZpeChzaWcucyksICdoZXgnKSwgMzIpLFxuICAgICAgdG9CdWZmZXIoc2lnLnYpLFxuICAgIF0pXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB0eCBkYXRhIGhhcyBhIHNpZ25hdHVyZVxuICpcbiAqIEBwYXJhbSB7VHhEYXRhfSB0eERhdGEgVGhlIHRyYW5zYWN0aW9uIGRhdGEgdG8gY2hlY2sgZm9yIHNpZ25hdHVyZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHR4IGhhcyBhIHNpZ25hdHVyZSwgZWxzZSBmYWxzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzU2lnbmF0dXJlKHR4RGF0YTogVHhEYXRhKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgdHhEYXRhLnYgIT09IHVuZGVmaW5lZCAmJlxuICAgIHR4RGF0YS5yICE9PSB1bmRlZmluZWQgJiZcbiAgICB0eERhdGEucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgdHhEYXRhLnYubGVuZ3RoID4gMCAmJlxuICAgIHR4RGF0YS5yLmxlbmd0aCA+IDAgJiZcbiAgICB0eERhdGEucy5sZW5ndGggPiAwXG4gICk7XG59XG5cbnR5cGUgUmVjdXJzaXZlQnVmZmVyT3JTdHJpbmcgPSBzdHJpbmcgfCBCdWZmZXIgfCBCTiB8IFJlY3Vyc2l2ZUJ1ZmZlck9yU3RyaW5nW107XG5cbi8qKlxuICogR2V0IHRoZSByYXcgZGF0YSBkZWNvZGVkIGZvciBzb21lIHR5cGVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gdHlwZXMgQUJJIHR5cGVzIGRlZmluaXRpb25cbiAqIEBwYXJhbSB7QnVmZmVyfSBzZXJpYWxpemVkQXJncyBlbmNvZGVkIGFyZ3NcbiAqIEByZXR1cm5zIHtCdWZmZXJbXX0gdGhlIGRlY29kZWQgcmF3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYXdEZWNvZGVkKHR5cGVzOiBzdHJpbmdbXSwgc2VyaWFsaXplZEFyZ3M6IEJ1ZmZlcik6IFJlY3Vyc2l2ZUJ1ZmZlck9yU3RyaW5nW10ge1xuICBmdW5jdGlvbiBub3JtYWxpemUodjogdW5rbm93biwgaTogbnVtYmVyKTogdW5rbm93biB7XG4gICAgaWYgKEJOLmlzQk4odikpIHtcbiAgICAgIHJldHVybiB2O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IEJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICByZXR1cm4gdi5tYXAobm9ybWFsaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3IgJHt0eXBlc31bJHtpfV0gZ290ICR7dHlwZW9mIHZ9YCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEV0aGVyZXVtQWJpLnJhd0RlY29kZSh0eXBlcywgc2VyaWFsaXplZEFyZ3MpLm1hcChub3JtYWxpemUpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYnVmZmVyZWQgYnl0ZWNvZGUgZnJvbSByYXdEYXRhIHVzaW5nIGEgbWV0aG9kSWQgYXMgZGVsaW1pdGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZElkIHRoZSBoZXggZW5jb2RlZCBtZXRob2QgSWRcbiAqIEBwYXJhbSB7c3RyaW5nfSByYXdEYXRhIHRoZSBoZXggZW5jb2RlZCByYXcgZGF0YVxuICogQHJldHVybnMge0J1ZmZlcn0gZGF0YSBidWZmZXJlZCBieXRlY29kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnVmZmVyZWRCeXRlQ29kZShtZXRob2RJZDogc3RyaW5nLCByYXdEYXRhOiBzdHJpbmcpOiBCdWZmZXIge1xuICBjb25zdCBzcGxpdEJ5dGVjb2RlID0gcmF3RGF0YS5zcGxpdChtZXRob2RJZCk7XG4gIGlmIChzcGxpdEJ5dGVjb2RlLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgc2VuZCBieXRlY29kZTogJHtyYXdEYXRhfWApO1xuICB9XG4gIGlmIChzcGxpdEJ5dGVjb2RlWzFdLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKGBJbnZhbGlkIHNlbmQgYnl0ZWNvZGU6ICR7cmF3RGF0YX0gKHdyb25nIGxlbmdodClgKTtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmZyb20oc3BsaXRCeXRlY29kZVsxXSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3RhdGljcyBjb2luIG9iamVjdCBtYXRjaGluZyBhIGdpdmVuIGNvbnRyYWN0IGFkZHJlc3MgaWYgaXQgZXhpc3RzXG4gKlxuICogQHBhcmFtIHRva2VuQ29udHJhY3RBZGRyZXNzIFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIG1hdGNoIGFnYWluc3RcbiAqIEByZXR1cm5zIHN0YXRpY3MgQmFzZUNvaW4gb2JqZWN0IGZvciB0aGUgbWF0Y2hpbmcgdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRva2VuKHRva2VuQ29udHJhY3RBZGRyZXNzOiBzdHJpbmcsIG5ldHdvcms6IEJhc2VOZXR3b3JrKTogUmVhZG9ubHk8QmFzZUNvaW4+IHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdG9rZW5zID0gY29pbnMuZmlsdGVyKChjb2luKSA9PiB7XG4gICAgaWYgKGNvaW4gaW5zdGFuY2VvZiBDb250cmFjdEFkZHJlc3NEZWZpbmVkVG9rZW4pIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNvaW4ubmV0d29yay50eXBlID09PSBuZXR3b3JrLnR5cGUgJiYgY29pbi5jb250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5Db250cmFjdEFkZHJlc3MudG9Mb3dlckNhc2UoKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxuICAvLyBpZiBsZW5ndGggb2YgdG9rZW5zIGlzIDEsIHJldHVybiB0aGUgZmlyc3QsIGVsc2UgcmV0dXJuIHVuZGVmaW5lZFxuICAvLyBDYW4ndCBkaXJlY3RseSBpbmRleCBpbnRvIHRva2Vucywgb3IgY2FsbCBgbGVuZ3RoYCwgc28gd2UgdXNlIG1hcCB0byBnZXQgYW4gYXJyYXlcbiAgY29uc3QgdG9rZW5zQXJyYXkgPSB0b2tlbnMubWFwKCh0b2tlbikgPT4gdG9rZW4pO1xuICBpZiAodG9rZW5zQXJyYXkubGVuZ3RoID49IDEpIHtcbiAgICAvLyB0aGVyZSBzaG91bGQgbmV2ZXIgYmUgdHdvIHRva2VucyB3aXRoIHRoZSBzYW1lIGNvbnRyYWN0IGFkZHJlc3MsIHNvIHdlIGFzc2VydCB0aGF0IGhlcmVcbiAgICBhc3NlcnQodG9rZW5zQXJyYXkubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdG9rZW5zQXJyYXlbMF07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjcmVhdGUgd2FsbGV0IG1ldGhvZCBjYWxsaW5nIGRhdGEgZm9yIHYxIHdhbGxldHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSB3YWxsZXRPd25lcnMgLSB3YWxsZXQgb3duZXIgYWRkcmVzc2VzIGZvciB3YWxsZXQgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gc2FsdCAtIFRoZSBzYWx0IGZvciB3YWxsZXQgaW5pdGlhbGl6YXRpb24gdHJhbnNhY3Rpb25zXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBjcmVhdGVXYWxsZXQgbWV0aG9kIGVuY29kZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFYxV2FsbGV0SW5pdGlhbGl6YXRpb25EYXRhKHdhbGxldE93bmVyczogc3RyaW5nW10sIHNhbHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHNhbHRCdWZmZXIgPSBzZXRMZW5ndGhMZWZ0KHRvQnVmZmVyKHNhbHQpLCAzMik7XG4gIGNvbnN0IHBhcmFtcyA9IFt3YWxsZXRPd25lcnMsIHNhbHRCdWZmZXJdO1xuICBjb25zdCBtZXRob2QgPSBFdGhlcmV1bUFiaS5tZXRob2RJRCgnY3JlYXRlV2FsbGV0JywgY3JlYXRlVjFXYWxsZXRUeXBlcyk7XG4gIGNvbnN0IGFyZ3MgPSBFdGhlcmV1bUFiaS5yYXdFbmNvZGUoY3JlYXRlVjFXYWxsZXRUeXBlcywgcGFyYW1zKTtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChCdWZmZXIuY29uY2F0KFttZXRob2QsIGFyZ3NdKS50b1N0cmluZygnaGV4JykpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNyZWF0ZSBhZGRyZXNzIG1ldGhvZCBjYWxsaW5nIGRhdGEgZm9yIHYxIHdhbGxldHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZUFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgd2FsbGV0IGNvbnRyYWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2FsdCAtIFRoZSBzYWx0IGZvciBhZGRyZXNzIGluaXRpYWxpemF0aW9uIHRyYW5zYWN0aW9uc1xuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgY3JlYXRlRm9yd2FyZGVyIG1ldGhvZCBlbmNvZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWMUFkZHJlc3NJbml0aWFsaXphdGlvbkRhdGEoYmFzZUFkZHJlc3M6IHN0cmluZywgc2FsdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc2FsdEJ1ZmZlciA9IHNldExlbmd0aExlZnQodG9CdWZmZXIoc2FsdCksIDMyKTtcbiAgY29uc3QgcGFyYW1zID0gW2Jhc2VBZGRyZXNzLCBzYWx0QnVmZmVyXTtcbiAgY29uc3QgbWV0aG9kID0gRXRoZXJldW1BYmkubWV0aG9kSUQoJ2NyZWF0ZUZvcndhcmRlcicsIGNyZWF0ZVYxRm9yd2FyZGVyVHlwZXMpO1xuICBjb25zdCBhcmdzID0gRXRoZXJldW1BYmkucmF3RW5jb2RlKGNyZWF0ZVYxRm9yd2FyZGVyVHlwZXMsIHBhcmFtcyk7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoQnVmZmVyLmNvbmNhdChbbWV0aG9kLCBhcmdzXSkudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIGdpdmVuIEFCSS1lbmNvZGVkIGNyZWF0ZSBmb3J3YXJkZXIgZGF0YSBhbmQgcmV0dXJuIHBhcnNlZCBmaWVsZHNcbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvZGVcbiAqIEByZXR1cm5zIHBhcnNlZCB0cmFuc2ZlciBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVGb3J3YXJkZXJDcmVhdGlvbkRhdGEoZGF0YTogc3RyaW5nKTogRm9yd2FyZGVySW5pdGlhbGl6YXRpb25EYXRhIHtcbiAgaWYgKCEoZGF0YS5zdGFydHNXaXRoKHYxQ3JlYXRlRm9yd2FyZGVyTWV0aG9kSWQpIHx8IGRhdGEuc3RhcnRzV2l0aChjcmVhdGVGb3J3YXJkZXJNZXRob2RJZCkpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBhZGRyZXNzIGJ5dGVjb2RlOiAke2RhdGF9YCk7XG4gIH1cblxuICBpZiAoZGF0YS5zdGFydHNXaXRoKGNyZWF0ZUZvcndhcmRlck1ldGhvZElkKSkge1xuICAgIHJldHVybiB7XG4gICAgICBiYXNlQWRkcmVzczogdW5kZWZpbmVkLFxuICAgICAgYWRkcmVzc0NyZWF0aW9uU2FsdDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW2Jhc2VBZGRyZXNzLCBzYWx0QnVmZmVyXSA9IGdldFJhd0RlY29kZWQoXG4gICAgICBjcmVhdGVWMUZvcndhcmRlclR5cGVzLFxuICAgICAgZ2V0QnVmZmVyZWRCeXRlQ29kZSh2MUNyZWF0ZUZvcndhcmRlck1ldGhvZElkLCBkYXRhKVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZUFkZHJlc3M6IGFkZEhleFByZWZpeChiYXNlQWRkcmVzcyBhcyBzdHJpbmcpLFxuICAgICAgYWRkcmVzc0NyZWF0aW9uU2FsdDogYnVmZmVyVG9IZXgoc2FsdEJ1ZmZlciBhcyBCdWZmZXIpLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==