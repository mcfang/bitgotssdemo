"use strict";
/**
 * @hidden
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
/**
 */
const rippleKeypairs = __importStar(require("ripple-keypairs"));
const ripple = __importStar(require("ripple-lib"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const binary = __importStar(require("ripple-binary-codec"));
const hashes_1 = require("ripple-lib/dist/npm/common/hashes");
function computeSignature(tx, privateKey, signAs) {
    const signingData = signAs ? binary.encodeForMultisigning(tx, signAs) : binary.encodeForSigning(tx);
    return rippleKeypairs.sign(signingData, privateKey);
}
/**
 * Sign Ripple transaction with a secp256k1 private key
 * @param txHex
 * @param privateKey
 * @param options
 * @returns {{signedTransaction: *, id}}
 */
const signWithPrivateKey = function (txHex, privateKey, options) {
    let privateKeyBuffer = Buffer.from(privateKey, 'hex');
    if (privateKeyBuffer.length === 33 && privateKeyBuffer[0] === 0) {
        privateKeyBuffer = privateKeyBuffer.slice(1, 33);
    }
    const publicKey = utxo_lib_1.ECPair.fromPrivateKey(privateKeyBuffer).publicKey.toString('hex').toUpperCase();
    let tx;
    try {
        tx = binary.decode(txHex);
    }
    catch (e) {
        try {
            tx = JSON.parse(txHex);
        }
        catch (e) {
            throw new Error('txHex needs to be either hex or JSON string for XRP');
        }
    }
    tx.SigningPubKey = options && options.signAs ? '' : publicKey;
    if (options && options.signAs) {
        const expectedSigner = rippleKeypairs.deriveAddress(publicKey);
        if (options.signAs !== expectedSigner) {
            throw new Error('signAs does not match private key');
        }
        const signer = {
            Account: options.signAs,
            SigningPubKey: publicKey,
            TxnSignature: computeSignature(tx, privateKey, options.signAs),
        };
        // Ordering of private key signing matters, or the Ripple fullnode will throw an 'Unsorted Signers array' error.
        // Additional signers must be added to the front of the signers array list.
        if (tx.TxnSignature || tx.Signers) {
            tx.Signers.unshift({ Signer: signer });
        }
        else {
            tx.Signers = [{ Signer: signer }];
        }
    }
    else {
        tx.TxnSignature = computeSignature(tx, privateKey, undefined);
    }
    const serialized = binary.encode(tx);
    return {
        signedTransaction: serialized,
        id: hashes_1.computeBinaryTransactionHash(serialized),
    };
};
module.exports = (params) => {
    const rippleLib = new ripple.RippleAPI(params);
    rippleLib.signWithPrivateKey = signWithPrivateKey;
    return rippleLib;
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmlwcGxlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3JpcHBsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUg7R0FDRztBQUNILGdFQUFrRDtBQUNsRCxtREFBcUM7QUFDckMsOENBQXlDO0FBRXpDLDREQUE4QztBQUM5Qyw4REFBaUY7QUFFakYsU0FBUyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLE1BQU07SUFDOUMsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMscUJBQXFCLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDcEcsT0FBTyxjQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUN0RCxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxrQkFBa0IsR0FBRyxVQUFVLEtBQUssRUFBRSxVQUFVLEVBQUUsT0FBTztJQUM3RCxJQUFJLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3RELElBQUksZ0JBQWdCLENBQUMsTUFBTSxLQUFLLEVBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDL0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztLQUNsRDtJQUNELE1BQU0sU0FBUyxHQUFHLGlCQUFNLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUVsRyxJQUFJLEVBQUUsQ0FBQztJQUNQLElBQUk7UUFDRixFQUFFLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUMzQjtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsSUFBSTtZQUNGLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3hCO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7U0FDeEU7S0FDRjtJQUVELEVBQUUsQ0FBQyxhQUFhLEdBQUcsT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBRTlELElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7UUFDN0IsTUFBTSxjQUFjLEdBQUcsY0FBYyxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMvRCxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssY0FBYyxFQUFFO1lBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztTQUN0RDtRQUNELE1BQU0sTUFBTSxHQUFHO1lBQ2IsT0FBTyxFQUFFLE9BQU8sQ0FBQyxNQUFNO1lBQ3ZCLGFBQWEsRUFBRSxTQUFTO1lBQ3hCLFlBQVksRUFBRSxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUM7U0FDL0QsQ0FBQztRQUNGLGdIQUFnSDtRQUNoSCwyRUFBMkU7UUFDM0UsSUFBSSxFQUFFLENBQUMsWUFBWSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUU7WUFDakMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztTQUN4QzthQUFNO1lBQ0wsRUFBRSxDQUFDLE9BQU8sR0FBRyxDQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDbkM7S0FDRjtTQUFNO1FBQ0wsRUFBRSxDQUFDLFlBQVksR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0tBQy9EO0lBRUQsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNyQyxPQUFPO1FBQ0wsaUJBQWlCLEVBQUUsVUFBVTtRQUM3QixFQUFFLEVBQUUscUNBQTRCLENBQUMsVUFBVSxDQUFDO0tBQzdDLENBQUM7QUFDSixDQUFDLENBQUM7QUFFRixpQkFBUyxDQUFDLE1BQU0sRUFBb0IsRUFBRTtJQUNwQyxNQUFNLFNBQVMsR0FBRyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDOUMsU0FBaUIsQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQztJQUMzRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBoaWRkZW5cbiAqL1xuXG4vKipcbiAqL1xuaW1wb3J0ICogYXMgcmlwcGxlS2V5cGFpcnMgZnJvbSAncmlwcGxlLWtleXBhaXJzJztcbmltcG9ydCAqIGFzIHJpcHBsZSBmcm9tICdyaXBwbGUtbGliJztcbmltcG9ydCB7IEVDUGFpciB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5cbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICdyaXBwbGUtYmluYXJ5LWNvZGVjJztcbmltcG9ydCB7IGNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvbkhhc2ggfSBmcm9tICdyaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9oYXNoZXMnO1xuXG5mdW5jdGlvbiBjb21wdXRlU2lnbmF0dXJlKHR4LCBwcml2YXRlS2V5LCBzaWduQXMpIHtcbiAgY29uc3Qgc2lnbmluZ0RhdGEgPSBzaWduQXMgPyBiaW5hcnkuZW5jb2RlRm9yTXVsdGlzaWduaW5nKHR4LCBzaWduQXMpIDogYmluYXJ5LmVuY29kZUZvclNpZ25pbmcodHgpO1xuICByZXR1cm4gcmlwcGxlS2V5cGFpcnMuc2lnbihzaWduaW5nRGF0YSwgcHJpdmF0ZUtleSk7XG59XG5cbi8qKlxuICogU2lnbiBSaXBwbGUgdHJhbnNhY3Rpb24gd2l0aCBhIHNlY3AyNTZrMSBwcml2YXRlIGtleVxuICogQHBhcmFtIHR4SGV4XG4gKiBAcGFyYW0gcHJpdmF0ZUtleVxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zIHt7c2lnbmVkVHJhbnNhY3Rpb246ICosIGlkfX1cbiAqL1xuY29uc3Qgc2lnbldpdGhQcml2YXRlS2V5ID0gZnVuY3Rpb24gKHR4SGV4LCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gIGxldCBwcml2YXRlS2V5QnVmZmVyID0gQnVmZmVyLmZyb20ocHJpdmF0ZUtleSwgJ2hleCcpO1xuICBpZiAocHJpdmF0ZUtleUJ1ZmZlci5sZW5ndGggPT09IDMzICYmIHByaXZhdGVLZXlCdWZmZXJbMF0gPT09IDApIHtcbiAgICBwcml2YXRlS2V5QnVmZmVyID0gcHJpdmF0ZUtleUJ1ZmZlci5zbGljZSgxLCAzMyk7XG4gIH1cbiAgY29uc3QgcHVibGljS2V5ID0gRUNQYWlyLmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXlCdWZmZXIpLnB1YmxpY0tleS50b1N0cmluZygnaGV4JykudG9VcHBlckNhc2UoKTtcblxuICBsZXQgdHg7XG4gIHRyeSB7XG4gICAgdHggPSBiaW5hcnkuZGVjb2RlKHR4SGV4KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICB0eCA9IEpTT04ucGFyc2UodHhIZXgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHhIZXggbmVlZHMgdG8gYmUgZWl0aGVyIGhleCBvciBKU09OIHN0cmluZyBmb3IgWFJQJyk7XG4gICAgfVxuICB9XG5cbiAgdHguU2lnbmluZ1B1YktleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaWduQXMgPyAnJyA6IHB1YmxpY0tleTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNpZ25Bcykge1xuICAgIGNvbnN0IGV4cGVjdGVkU2lnbmVyID0gcmlwcGxlS2V5cGFpcnMuZGVyaXZlQWRkcmVzcyhwdWJsaWNLZXkpO1xuICAgIGlmIChvcHRpb25zLnNpZ25BcyAhPT0gZXhwZWN0ZWRTaWduZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbkFzIGRvZXMgbm90IG1hdGNoIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lciA9IHtcbiAgICAgIEFjY291bnQ6IG9wdGlvbnMuc2lnbkFzLFxuICAgICAgU2lnbmluZ1B1YktleTogcHVibGljS2V5LFxuICAgICAgVHhuU2lnbmF0dXJlOiBjb21wdXRlU2lnbmF0dXJlKHR4LCBwcml2YXRlS2V5LCBvcHRpb25zLnNpZ25BcyksXG4gICAgfTtcbiAgICAvLyBPcmRlcmluZyBvZiBwcml2YXRlIGtleSBzaWduaW5nIG1hdHRlcnMsIG9yIHRoZSBSaXBwbGUgZnVsbG5vZGUgd2lsbCB0aHJvdyBhbiAnVW5zb3J0ZWQgU2lnbmVycyBhcnJheScgZXJyb3IuXG4gICAgLy8gQWRkaXRpb25hbCBzaWduZXJzIG11c3QgYmUgYWRkZWQgdG8gdGhlIGZyb250IG9mIHRoZSBzaWduZXJzIGFycmF5IGxpc3QuXG4gICAgaWYgKHR4LlR4blNpZ25hdHVyZSB8fCB0eC5TaWduZXJzKSB7XG4gICAgICB0eC5TaWduZXJzLnVuc2hpZnQoeyBTaWduZXI6IHNpZ25lciB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHguU2lnbmVycyA9IFt7IFNpZ25lcjogc2lnbmVyIH1dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0eC5UeG5TaWduYXR1cmUgPSBjb21wdXRlU2lnbmF0dXJlKHR4LCBwcml2YXRlS2V5LCB1bmRlZmluZWQpO1xuICB9XG5cbiAgY29uc3Qgc2VyaWFsaXplZCA9IGJpbmFyeS5lbmNvZGUodHgpO1xuICByZXR1cm4ge1xuICAgIHNpZ25lZFRyYW5zYWN0aW9uOiBzZXJpYWxpemVkLFxuICAgIGlkOiBjb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoKHNlcmlhbGl6ZWQpLFxuICB9O1xufTtcblxuZXhwb3J0ID0gKHBhcmFtcyk6IHJpcHBsZS5SaXBwbGVBUEkgPT4ge1xuICBjb25zdCByaXBwbGVMaWIgPSBuZXcgcmlwcGxlLlJpcHBsZUFQSShwYXJhbXMpO1xuICAocmlwcGxlTGliIGFzIGFueSkuc2lnbldpdGhQcml2YXRlS2V5ID0gc2lnbldpdGhQcml2YXRlS2V5O1xuICByZXR1cm4gcmlwcGxlTGliO1xufTtcbiJdfQ==