"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xrp = void 0;
/**
 * @prettier
 */
const bignumber_js_1 = require("bignumber.js");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = require("crypto");
const _ = __importStar(require("lodash"));
const url = __importStar(require("url"));
const querystring = __importStar(require("querystring"));
const rippleAddressCodec = __importStar(require("ripple-address-codec"));
const rippleBinaryCodec = __importStar(require("ripple-binary-codec"));
const hashes_1 = require("ripple-lib/dist/npm/common/hashes");
const rippleKeypairs = __importStar(require("ripple-keypairs"));
const sdk_core_1 = require("@bitgo/sdk-core");
const ripple = require('./ripple');
class Xrp extends sdk_core_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
    }
    static createInstance(bitgo) {
        return new Xrp(bitgo);
    }
    /**
     * Factor between the coin's base unit and its smallest subdivison
     */
    getBaseFactor() {
        return 1e6;
    }
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain() {
        return 'xrp';
    }
    /**
     * Identifier for the coin family
     */
    getFamily() {
        return 'xrp';
    }
    /**
     * Complete human-readable name of this coin
     */
    getFullName() {
        return 'Ripple';
    }
    /**
     * Parse an address string into address and destination tag
     */
    getAddressDetails(address) {
        const destinationDetails = url.parse(address);
        const destinationAddress = destinationDetails.pathname;
        if (!destinationAddress || !rippleAddressCodec.isValidClassicAddress(destinationAddress)) {
            throw new sdk_core_1.InvalidAddressError(`destination address "${destinationAddress}" is not valid`);
        }
        // there are no other properties like destination tags
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                destinationTag: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new sdk_core_1.InvalidAddressError('no query params present');
        }
        const queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.dt) {
            // if there are more properties, the query details need to contain the destination tag property.
            throw new sdk_core_1.InvalidAddressError('destination tag missing');
        }
        if (Array.isArray(queryDetails.dt)) {
            // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
            throw new sdk_core_1.InvalidAddressError(`destination tag can appear at most once, but ${queryDetails.dt.length} destination tags were found`);
        }
        const parsedTag = parseInt(queryDetails.dt, 10);
        if (!Number.isSafeInteger(parsedTag)) {
            throw new sdk_core_1.InvalidAddressError('invalid destination tag');
        }
        if (parsedTag > 0xffffffff || parsedTag < 0) {
            throw new sdk_core_1.InvalidAddressError('destination tag out of range');
        }
        return {
            address: destinationAddress,
            destinationTag: parsedTag,
        };
    }
    /**
     * Construct a full, normalized address from an address and destination tag
     */
    normalizeAddress({ address, destinationTag }) {
        if (!_.isString(address)) {
            throw new sdk_core_1.InvalidAddressError('invalid address details');
        }
        if (_.isInteger(destinationTag)) {
            return `${address}?dt=${destinationTag}`;
        }
        return address;
    }
    /**
     * Evaluates whether an address string is valid for this coin
     * @param address
     */
    isValidAddress(address) {
        try {
            const addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        try {
            return utxo_lib_1.bip32.fromBase58(pub).isNeutered();
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Get fee info from server
     */
    async getFeeInfo() {
        return this.bitgo.get(this.url('/public/feeinfo')).result();
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns Bluebird<HalfSignedTransaction>
     */
    async signTransaction({ txPrebuild, prv, isLastSignature, }) {
        if (_.isUndefined(txPrebuild) || !_.isObject(txPrebuild)) {
            if (!_.isUndefined(txPrebuild) && !_.isObject(txPrebuild)) {
                throw new Error(`txPrebuild must be an object, got type ${typeof txPrebuild}`);
            }
            throw new Error('missing txPrebuild parameter');
        }
        if (_.isUndefined(prv) || !_.isString(prv)) {
            if (!_.isUndefined(prv) && !_.isString(prv)) {
                throw new Error(`prv must be a string, got type ${typeof prv}`);
            }
            throw new Error('missing prv parameter to sign transaction');
        }
        const userKey = utxo_lib_1.bip32.fromBase58(prv);
        const userPrivateKey = userKey.privateKey;
        if (!userPrivateKey) {
            throw new Error(`no privateKey`);
        }
        const userAddress = rippleKeypairs.deriveAddress(userKey.publicKey.toString('hex'));
        const rippleLib = ripple();
        const tx = rippleLib.signWithPrivateKey(txPrebuild.txHex, userPrivateKey.toString('hex'), {
            signAs: userAddress,
        });
        // Normally the SDK provides the first signature for an XRP tx, but occasionally it provides the final one as well
        // (recoveries)
        if (isLastSignature) {
            return { txHex: tx.signedTransaction };
        }
        return { halfSigned: { txHex: tx.signedTransaction } };
    }
    /**
     * Ripple requires additional parameters for wallet generation to be sent to the server. The additional parameters are
     * the root public key, which is the basis of the root address, two signed, and one half-signed initialization txs
     * @param walletParams
     * - rootPrivateKey: optional hex-encoded Ripple private key
     */
    async supplementGenerateWallet(walletParams) {
        if (walletParams.rootPrivateKey) {
            if (walletParams.rootPrivateKey.length !== 64) {
                throw new Error('rootPrivateKey needs to be a hexadecimal private key string');
            }
        }
        else {
            const keyPair = utxo_lib_1.ECPair.makeRandom();
            if (!keyPair.privateKey) {
                throw new Error('no privateKey');
            }
            walletParams.rootPrivateKey = keyPair.privateKey.toString('hex');
        }
        return walletParams;
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params = {}) {
        let transaction;
        let txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex) {
            throw new Error('missing required param txHex');
        }
        try {
            transaction = rippleBinaryCodec.decode(txHex);
        }
        catch (e) {
            try {
                transaction = JSON.parse(txHex);
                txHex = rippleBinaryCodec.encode(transaction);
            }
            catch (e) {
                throw new Error('txHex needs to be either hex or JSON string for XRP');
            }
        }
        const id = hashes_1.computeBinaryTransactionHash(txHex);
        if (transaction.TransactionType == 'AccountSet') {
            return {
                displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee', 'accountSet'],
                id: id,
                changeOutputs: [],
                outputAmount: 0,
                changeAmount: 0,
                outputs: [],
                fee: {
                    fee: transaction.Fee,
                    feeRate: null,
                    size: txHex.length / 2,
                },
                accountSet: {
                    messageKey: transaction.MessageKey,
                },
            };
        }
        const address = transaction.Destination + (transaction.DestinationTag >= 0 ? '?dt=' + transaction.DestinationTag : '');
        return {
            displayOrder: ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'],
            id: id,
            changeOutputs: [],
            outputAmount: transaction.Amount,
            changeAmount: 0,
            outputs: [
                {
                    address,
                    amount: transaction.Amount,
                },
            ],
            fee: {
                fee: transaction.Fee,
                feeRate: null,
                size: txHex.length / 2,
            },
        };
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     * @param txParams params object passed to send
     * @param txPrebuild prebuild object returned by server
     * @param wallet
     * @returns {boolean}
     */
    async verifyTransaction({ txParams, txPrebuild }) {
        const explanation = await this.explainTransaction({
            txHex: txPrebuild.txHex,
        });
        const output = [...explanation.outputs, ...explanation.changeOutputs][0];
        const expectedOutput = txParams.recipients && txParams.recipients[0];
        const comparator = (recipient1, recipient2) => {
            if (recipient1.address !== recipient2.address) {
                return false;
            }
            const amount1 = new bignumber_js_1.BigNumber(recipient1.amount);
            const amount2 = new bignumber_js_1.BigNumber(recipient2.amount);
            return amount1.toFixed() === amount2.toFixed();
        };
        if (!comparator(output, expectedOutput)) {
            throw new Error('transaction prebuild does not match expected output');
        }
        return true;
    }
    /**
     * Check if address is a valid XRP address, and then make sure the root addresses match.
     * This prevents attacks where an attack may switch out the new address for one of their own
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     * @return true iff address is a wallet address (based on rootAddress)
     */
    async isWalletAddress({ address, rootAddress }) {
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`address verification failure: address "${address}" is not valid`);
        }
        const addressDetails = this.getAddressDetails(address);
        const rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.address !== rootAddressDetails.address) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${addressDetails.address} vs. ${rootAddressDetails.address}`);
        }
        return true;
    }
    /**
     * URL of a well-known, public facing (non-bitgo) rippled instance which can be used for recovery
     */
    getRippledUrl() {
        return 'https://s1.ripple.com:51234';
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - rootAddress: root XRP wallet address to recover funds from
     * - userKey: [encrypted] xprv
     * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
     * - walletPassphrase: necessary if one of the xprvs is encrypted
     * - bitgoKey: xpub
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     */
    async recover(params) {
        const rippledUrl = this.getRippledUrl();
        const isKrsRecovery = params.backupKey.startsWith('xpub') && !params.userKey.startsWith('xpub');
        const isUnsignedSweep = params.backupKey.startsWith('xpub') && params.userKey.startsWith('xpub');
        const accountInfoParams = {
            method: 'account_info',
            params: [
                {
                    account: params.rootAddress,
                    strict: true,
                    ledger_index: 'current',
                    queue: true,
                    signer_lists: true,
                },
            ],
        };
        if (isKrsRecovery) {
            sdk_core_1.checkKrsProvider(this, params.krsProvider);
        }
        // Validate the destination address
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new Error('Invalid destination address!');
        }
        const keys = sdk_core_1.getBip32Keys(this.bitgo, params, { requireBitGoXpub: false });
        const { addressDetails, feeDetails, serverDetails } = await sdk_core_1.promiseProps({
            addressDetails: this.bitgo.post(rippledUrl).send(accountInfoParams),
            feeDetails: this.bitgo.post(rippledUrl).send({ method: 'fee' }),
            serverDetails: this.bitgo.post(rippledUrl).send({ method: 'server_info' }),
        });
        const openLedgerFee = new bignumber_js_1.BigNumber(feeDetails.body.result.drops.open_ledger_fee);
        const baseReserve = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_base_xrp).times(this.getBaseFactor());
        const reserveDelta = new bignumber_js_1.BigNumber(serverDetails.body.result.info.validated_ledger.reserve_inc_xrp).times(this.getBaseFactor());
        const currentLedger = serverDetails.body.result.info.validated_ledger.seq;
        const sequenceId = addressDetails.body.result.account_data.Sequence;
        const balance = new bignumber_js_1.BigNumber(addressDetails.body.result.account_data.Balance);
        const signerLists = addressDetails.body.result.account_data.signer_lists;
        const accountFlags = addressDetails.body.result.account_data.Flags;
        // make sure there is only one signer list set
        if (signerLists.length !== 1) {
            throw new Error('unexpected set of signer lists');
        }
        // make sure the signers are user, backup, bitgo
        const userAddress = rippleKeypairs.deriveAddress(keys[0].publicKey.toString('hex'));
        const backupAddress = rippleKeypairs.deriveAddress(keys[1].publicKey.toString('hex'));
        const signerList = signerLists[0];
        if (signerList.SignerQuorum !== 2) {
            throw new Error('invalid minimum signature count');
        }
        const foundAddresses = {};
        const signerEntries = signerList.SignerEntries;
        if (signerEntries.length !== 3) {
            throw new Error('invalid signer list length');
        }
        for (const { SignerEntry } of signerEntries) {
            const weight = SignerEntry.SignerWeight;
            const address = SignerEntry.Account;
            if (weight !== 1) {
                throw new Error('invalid signer weight');
            }
            // if it's a dupe of an address we already know, block
            if (foundAddresses[address] >= 1) {
                throw new Error('duplicate signer address');
            }
            foundAddresses[address] = (foundAddresses[address] || 0) + 1;
        }
        if (foundAddresses[userAddress] !== 1) {
            throw new Error('unexpected incidence frequency of user signer address');
        }
        if (foundAddresses[backupAddress] !== 1) {
            throw new Error('unexpected incidence frequency of user signer address');
        }
        // make sure the flags disable the master key and enforce destination tags
        const USER_KEY_SETTING_FLAG = 65536;
        const MASTER_KEY_DEACTIVATION_FLAG = 1048576;
        const REQUIRE_DESTINATION_TAG_FLAG = 131072;
        if ((accountFlags & USER_KEY_SETTING_FLAG) !== 0) {
            throw new Error('a custom user key has been set');
        }
        if ((accountFlags & MASTER_KEY_DEACTIVATION_FLAG) !== MASTER_KEY_DEACTIVATION_FLAG) {
            throw new Error('the master key has not been deactivated');
        }
        if ((accountFlags & REQUIRE_DESTINATION_TAG_FLAG) !== REQUIRE_DESTINATION_TAG_FLAG) {
            throw new Error('the destination flag requirement has not been activated');
        }
        // recover the funds
        const reserve = baseReserve.plus(reserveDelta.times(5));
        const recoverableBalance = balance.minus(reserve);
        const rawDestination = params.recoveryDestination;
        const destinationDetails = url.parse(rawDestination);
        const destinationAddress = destinationDetails.pathname;
        // parse destination tag from query
        let destinationTag;
        if (destinationDetails.query) {
            const queryDetails = querystring.parse(destinationDetails.query);
            if (Array.isArray(queryDetails.dt)) {
                // if queryDetails.dt is an array, that means dt was given multiple times, which is not valid
                throw new sdk_core_1.InvalidAddressError(`destination tag can appear at most once, but ${queryDetails.dt.length} destination tags were found`);
            }
            const parsedTag = parseInt(queryDetails.dt, 10);
            if (Number.isInteger(parsedTag)) {
                destinationTag = parsedTag;
            }
        }
        const transaction = {
            TransactionType: 'Payment',
            Account: params.rootAddress,
            Destination: destinationAddress,
            DestinationTag: destinationTag,
            Amount: recoverableBalance.toFixed(0),
            Flags: 2147483648,
            LastLedgerSequence: currentLedger + 1000000,
            Fee: openLedgerFee.times(3).toFixed(0),
            Sequence: sequenceId,
        };
        const txJSON = JSON.stringify(transaction);
        if (isUnsignedSweep) {
            return {
                txHex: txJSON,
                coin: this.getChain(),
            };
        }
        const rippleLib = ripple();
        if (!keys[0].privateKey) {
            throw new Error(`userKey is not a private key`);
        }
        const userKey = keys[0].privateKey.toString('hex');
        const userSignature = rippleLib.signWithPrivateKey(txJSON, userKey, { signAs: userAddress });
        let signedTransaction;
        if (isKrsRecovery) {
            signedTransaction = userSignature;
        }
        else {
            if (!keys[1].privateKey) {
                throw new Error(`backupKey is not a private key`);
            }
            const backupKey = keys[1].privateKey.toString('hex');
            const backupSignature = rippleLib.signWithPrivateKey(txJSON, backupKey, { signAs: backupAddress });
            signedTransaction = rippleLib.combine([userSignature.signedTransaction, backupSignature.signedTransaction]);
        }
        const transactionExplanation = (await this.explainTransaction({
            txHex: signedTransaction.signedTransaction,
        }));
        transactionExplanation.txHex = signedTransaction.signedTransaction;
        if (isKrsRecovery) {
            transactionExplanation.backupKey = params.backupKey;
            transactionExplanation.coin = this.getChain();
        }
        return transactionExplanation;
    }
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Generate a new keypair for this coin.
     * @param seed Seed from which the new keypair should be generated, otherwise a random seed is used
     */
    generateKeyPair(seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        const extendedKey = utxo_lib_1.bip32.fromSeed(seed);
        const xpub = extendedKey.neutered().toBase58();
        return {
            pub: xpub,
            prv: extendedKey.toBase58(),
        };
    }
    async parseTransaction(params) {
        return {};
    }
}
exports.Xrp = Xrp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieHJwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3hycC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCwrQ0FBeUM7QUFDekMsOENBQWdEO0FBQ2hELG1DQUFxQztBQUNyQywwQ0FBNEI7QUFDNUIseUNBQTJCO0FBQzNCLHlEQUEyQztBQUUzQyx5RUFBMkQ7QUFDM0QsdUVBQXlEO0FBQ3pELDhEQUFpRjtBQUNqRixnRUFBa0Q7QUFDbEQsOENBaUJ5QjtBQUV6QixNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFpRW5DLE1BQWEsR0FBSSxTQUFRLG1CQUFRO0lBQy9CLFlBQXNCLEtBQWdCO1FBQ3BDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNmLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCO1FBQ3BDLE9BQU8sSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksYUFBYTtRQUNsQixPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNJLFFBQVE7UUFDYixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLFNBQVM7UUFDZCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7T0FFRztJQUNJLFdBQVc7UUFDaEIsT0FBTyxRQUFRLENBQUM7SUFDbEIsQ0FBQztJQUVEOztPQUVHO0lBQ0ksaUJBQWlCLENBQUMsT0FBZTtRQUN0QyxNQUFNLGtCQUFrQixHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUMsTUFBTSxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQyxRQUFRLENBQUM7UUFDdkQsSUFBSSxDQUFDLGtCQUFrQixJQUFJLENBQUMsa0JBQWtCLENBQUMscUJBQXFCLENBQUMsa0JBQWtCLENBQUMsRUFBRTtZQUN4RixNQUFNLElBQUksOEJBQW1CLENBQUMsd0JBQXdCLGtCQUFrQixnQkFBZ0IsQ0FBQyxDQUFDO1NBQzNGO1FBQ0Qsc0RBQXNEO1FBQ3RELElBQUksa0JBQWtCLENBQUMsUUFBUSxLQUFLLE9BQU8sRUFBRTtZQUMzQyxPQUFPO2dCQUNMLE9BQU8sRUFBRSxPQUFPO2dCQUNoQixjQUFjLEVBQUUsU0FBUzthQUMxQixDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFO1lBQzdCLE1BQU0sSUFBSSw4QkFBbUIsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQzFEO1FBRUQsTUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRTtZQUNwQixnR0FBZ0c7WUFDaEcsTUFBTSxJQUFJLDhCQUFtQixDQUFDLHlCQUF5QixDQUFDLENBQUM7U0FDMUQ7UUFFRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFO1lBQ2xDLDZGQUE2RjtZQUM3RixNQUFNLElBQUksOEJBQW1CLENBQzNCLGdEQUFnRCxZQUFZLENBQUMsRUFBRSxDQUFDLE1BQU0sOEJBQThCLENBQ3JHLENBQUM7U0FDSDtRQUVELE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3BDLE1BQU0sSUFBSSw4QkFBbUIsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQzFEO1FBRUQsSUFBSSxTQUFTLEdBQUcsVUFBVSxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDM0MsTUFBTSxJQUFJLDhCQUFtQixDQUFDLDhCQUE4QixDQUFDLENBQUM7U0FDL0Q7UUFFRCxPQUFPO1lBQ0wsT0FBTyxFQUFFLGtCQUFrQjtZQUMzQixjQUFjLEVBQUUsU0FBUztTQUMxQixDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0ksZ0JBQWdCLENBQUMsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFXO1FBQzFELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3hCLE1BQU0sSUFBSSw4QkFBbUIsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1NBQzFEO1FBQ0QsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxFQUFFO1lBQy9CLE9BQU8sR0FBRyxPQUFPLE9BQU8sY0FBYyxFQUFFLENBQUM7U0FDMUM7UUFDRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksY0FBYyxDQUFDLE9BQWU7UUFDbkMsSUFBSTtZQUNGLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN2RCxPQUFPLE9BQU8sS0FBSyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLENBQUM7U0FDMUQ7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxVQUFVLENBQUMsR0FBVztRQUMzQixJQUFJO1lBQ0YsT0FBTyxnQkFBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUMzQztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxLQUFLLENBQUM7U0FDZDtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyxVQUFVO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDOUQsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLEtBQUssQ0FBQyxlQUFlLENBQUMsRUFDM0IsVUFBVSxFQUNWLEdBQUcsRUFDSCxlQUFlLEdBQ1E7UUFDdkIsSUFBSSxDQUFDLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN4RCxJQUFJLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQ3pELE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLE9BQU8sVUFBVSxFQUFFLENBQUMsQ0FBQzthQUNoRjtZQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztTQUNqRDtRQUVELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDMUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUMzQyxNQUFNLElBQUksS0FBSyxDQUFDLGtDQUFrQyxPQUFPLEdBQUcsRUFBRSxDQUFDLENBQUM7YUFDakU7WUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7U0FDOUQ7UUFFRCxNQUFNLE9BQU8sR0FBRyxnQkFBSyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QyxNQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO1FBQzFDLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDbkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztTQUNsQztRQUNELE1BQU0sV0FBVyxHQUFHLGNBQWMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUVwRixNQUFNLFNBQVMsR0FBRyxNQUFNLEVBQUUsQ0FBQztRQUUzQixNQUFNLEVBQUUsR0FBRyxTQUFTLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLEtBQUssRUFBRSxjQUFjLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3hGLE1BQU0sRUFBRSxXQUFXO1NBQ3BCLENBQUMsQ0FBQztRQUVILGtIQUFrSDtRQUNsSCxlQUFlO1FBQ2YsSUFBSSxlQUFlLEVBQUU7WUFDbkIsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztTQUN4QztRQUNELE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixFQUFFLEVBQUUsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsd0JBQXdCLENBQzVCLFlBQTZDO1FBRTdDLElBQUksWUFBWSxDQUFDLGNBQWMsRUFBRTtZQUMvQixJQUFJLFlBQVksQ0FBQyxjQUFjLENBQUMsTUFBTSxLQUFLLEVBQUUsRUFBRTtnQkFDN0MsTUFBTSxJQUFJLEtBQUssQ0FBQyw2REFBNkQsQ0FBQyxDQUFDO2FBQ2hGO1NBQ0Y7YUFBTTtZQUNMLE1BQU0sT0FBTyxHQUFHLGlCQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDcEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUU7Z0JBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7YUFDbEM7WUFDRCxZQUFZLENBQUMsY0FBYyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ2xFO1FBQ0QsT0FBTyxZQUFZLENBQUM7SUFDdEIsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxTQUFvQyxFQUFFO1FBQzdELElBQUksV0FBVyxDQUFDO1FBQ2hCLElBQUksS0FBSyxHQUFXLE1BQU0sQ0FBQyxLQUFLLElBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFZLENBQUM7UUFDL0YsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztTQUNqRDtRQUNELElBQUk7WUFDRixXQUFXLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQy9DO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixJQUFJO2dCQUNGLFdBQVcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNoQyxLQUFLLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2FBQy9DO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO2FBQ3hFO1NBQ0Y7UUFDRCxNQUFNLEVBQUUsR0FBRyxxQ0FBNEIsQ0FBQyxLQUFlLENBQUMsQ0FBQztRQUV6RCxJQUFJLFdBQVcsQ0FBQyxlQUFlLElBQUksWUFBWSxFQUFFO1lBQy9DLE9BQU87Z0JBQ0wsWUFBWSxFQUFFLENBQUMsSUFBSSxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsWUFBWSxDQUFDO2dCQUNyRyxFQUFFLEVBQUUsRUFBRTtnQkFDTixhQUFhLEVBQUUsRUFBRTtnQkFDakIsWUFBWSxFQUFFLENBQUM7Z0JBQ2YsWUFBWSxFQUFFLENBQUM7Z0JBQ2YsT0FBTyxFQUFFLEVBQUU7Z0JBQ1gsR0FBRyxFQUFFO29CQUNILEdBQUcsRUFBRSxXQUFXLENBQUMsR0FBRztvQkFDcEIsT0FBTyxFQUFFLElBQUk7b0JBQ2IsSUFBSSxFQUFFLEtBQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQztpQkFDeEI7Z0JBQ0QsVUFBVSxFQUFFO29CQUNWLFVBQVUsRUFBRSxXQUFXLENBQUMsVUFBVTtpQkFDbkM7YUFDSyxDQUFDO1NBQ1Y7UUFFRCxNQUFNLE9BQU8sR0FDWCxXQUFXLENBQUMsV0FBVyxHQUFHLENBQUMsV0FBVyxDQUFDLGNBQWMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN6RyxPQUFPO1lBQ0wsWUFBWSxFQUFFLENBQUMsSUFBSSxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxLQUFLLENBQUM7WUFDdkYsRUFBRSxFQUFFLEVBQUU7WUFDTixhQUFhLEVBQUUsRUFBRTtZQUNqQixZQUFZLEVBQUUsV0FBVyxDQUFDLE1BQU07WUFDaEMsWUFBWSxFQUFFLENBQUM7WUFDZixPQUFPLEVBQUU7Z0JBQ1A7b0JBQ0UsT0FBTztvQkFDUCxNQUFNLEVBQUUsV0FBVyxDQUFDLE1BQU07aUJBQzNCO2FBQ0Y7WUFDRCxHQUFHLEVBQUU7Z0JBQ0gsR0FBRyxFQUFFLFdBQVcsQ0FBQyxHQUFHO2dCQUNwQixPQUFPLEVBQUUsSUFBSTtnQkFDYixJQUFJLEVBQUUsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDO2FBQ3ZCO1NBQ0ssQ0FBQztJQUNYLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUE0QjtRQUMvRSxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztZQUNoRCxLQUFLLEVBQUUsVUFBVSxDQUFDLEtBQUs7U0FDeEIsQ0FBQyxDQUFDO1FBRUgsTUFBTSxNQUFNLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxPQUFPLEVBQUUsR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDekUsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLFVBQVUsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXJFLE1BQU0sVUFBVSxHQUFHLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxFQUFFO1lBQzVDLElBQUksVUFBVSxDQUFDLE9BQU8sS0FBSyxVQUFVLENBQUMsT0FBTyxFQUFFO2dCQUM3QyxPQUFPLEtBQUssQ0FBQzthQUNkO1lBQ0QsTUFBTSxPQUFPLEdBQUcsSUFBSSx3QkFBUyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNqRCxNQUFNLE9BQU8sR0FBRyxJQUFJLHdCQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2pELE9BQU8sT0FBTyxDQUFDLE9BQU8sRUFBRSxLQUFLLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqRCxDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxjQUFjLENBQUMsRUFBRTtZQUN2QyxNQUFNLElBQUksS0FBSyxDQUFDLHFEQUFxRCxDQUFDLENBQUM7U0FDeEU7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxLQUFLLENBQUMsZUFBZSxDQUFDLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBd0I7UUFDekUsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDakMsTUFBTSxJQUFJLDhCQUFtQixDQUFDLDBDQUEwQyxPQUFPLGdCQUFnQixDQUFDLENBQUM7U0FDbEc7UUFFRCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdkQsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFL0QsSUFBSSxjQUFjLENBQUMsT0FBTyxLQUFLLGtCQUFrQixDQUFDLE9BQU8sRUFBRTtZQUN6RCxNQUFNLElBQUksaUNBQXNCLENBQzlCLCtCQUErQixjQUFjLENBQUMsT0FBTyxRQUFRLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxDQUMxRixDQUFDO1NBQ0g7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7T0FFRztJQUNJLGFBQWE7UUFDbEIsT0FBTyw2QkFBNkIsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBdUI7UUFDMUMsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3hDLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDaEcsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFakcsTUFBTSxpQkFBaUIsR0FBRztZQUN4QixNQUFNLEVBQUUsY0FBYztZQUN0QixNQUFNLEVBQUU7Z0JBQ047b0JBQ0UsT0FBTyxFQUFFLE1BQU0sQ0FBQyxXQUFXO29CQUMzQixNQUFNLEVBQUUsSUFBSTtvQkFDWixZQUFZLEVBQUUsU0FBUztvQkFDdkIsS0FBSyxFQUFFLElBQUk7b0JBQ1gsWUFBWSxFQUFFLElBQUk7aUJBQ25CO2FBQ0Y7U0FDRixDQUFDO1FBRUYsSUFBSSxhQUFhLEVBQUU7WUFDakIsMkJBQWdCLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUM1QztRQUVELG1DQUFtQztRQUNuQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsRUFBRTtZQUNwRCxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixDQUFDLENBQUM7U0FDakQ7UUFFRCxNQUFNLElBQUksR0FBRyx1QkFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUUzRSxNQUFNLEVBQUUsY0FBYyxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUUsR0FBRyxNQUFNLHVCQUFZLENBQUM7WUFDdkUsY0FBYyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztZQUNuRSxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDO1lBQy9ELGFBQWEsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsYUFBYSxFQUFFLENBQUM7U0FDM0UsQ0FBQyxDQUFDO1FBRUgsTUFBTSxhQUFhLEdBQUcsSUFBSSx3QkFBUyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNsRixNQUFNLFdBQVcsR0FBRyxJQUFJLHdCQUFTLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixDQUFDLENBQUMsS0FBSyxDQUN2RyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQ3JCLENBQUM7UUFDRixNQUFNLFlBQVksR0FBRyxJQUFJLHdCQUFTLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxDQUFDLEtBQUssQ0FDdkcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUNyQixDQUFDO1FBQ0YsTUFBTSxhQUFhLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQztRQUMxRSxNQUFNLFVBQVUsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDO1FBQ3BFLE1BQU0sT0FBTyxHQUFHLElBQUksd0JBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDL0UsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQztRQUN6RSxNQUFNLFlBQVksR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDO1FBRW5FLDhDQUE4QztRQUM5QyxJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztTQUNuRDtRQUVELGdEQUFnRDtRQUNoRCxNQUFNLFdBQVcsR0FBRyxjQUFjLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDcEYsTUFBTSxhQUFhLEdBQUcsY0FBYyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBRXRGLE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNsQyxJQUFJLFVBQVUsQ0FBQyxZQUFZLEtBQUssQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNwRDtRQUNELE1BQU0sY0FBYyxHQUFHLEVBQUUsQ0FBQztRQUUxQixNQUFNLGFBQWEsR0FBRyxVQUFVLENBQUMsYUFBYSxDQUFDO1FBQy9DLElBQUksYUFBYSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1NBQy9DO1FBQ0QsS0FBSyxNQUFNLEVBQUUsV0FBVyxFQUFFLElBQUksYUFBYSxFQUFFO1lBQzNDLE1BQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxZQUFZLENBQUM7WUFDeEMsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQztZQUNwQyxJQUFJLE1BQU0sS0FBSyxDQUFDLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLENBQUMsQ0FBQzthQUMxQztZQUVELHNEQUFzRDtZQUN0RCxJQUFJLGNBQWMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQzthQUM3QztZQUNELGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDOUQ7UUFFRCxJQUFJLGNBQWMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyx1REFBdUQsQ0FBQyxDQUFDO1NBQzFFO1FBQ0QsSUFBSSxjQUFjLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMsdURBQXVELENBQUMsQ0FBQztTQUMxRTtRQUVELDBFQUEwRTtRQUMxRSxNQUFNLHFCQUFxQixHQUFHLEtBQUssQ0FBQztRQUNwQyxNQUFNLDRCQUE0QixHQUFHLE9BQU8sQ0FBQztRQUM3QyxNQUFNLDRCQUE0QixHQUFHLE1BQU0sQ0FBQztRQUM1QyxJQUFJLENBQUMsWUFBWSxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztTQUNuRDtRQUNELElBQUksQ0FBQyxZQUFZLEdBQUcsNEJBQTRCLENBQUMsS0FBSyw0QkFBNEIsRUFBRTtZQUNsRixNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7U0FDNUQ7UUFDRCxJQUFJLENBQUMsWUFBWSxHQUFHLDRCQUE0QixDQUFDLEtBQUssNEJBQTRCLEVBQUU7WUFDbEYsTUFBTSxJQUFJLEtBQUssQ0FBQyx5REFBeUQsQ0FBQyxDQUFDO1NBQzVFO1FBRUQsb0JBQW9CO1FBQ3BCLE1BQU0sT0FBTyxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hELE1BQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVsRCxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsbUJBQW1CLENBQUM7UUFDbEQsTUFBTSxrQkFBa0IsR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3JELE1BQU0sa0JBQWtCLEdBQUcsa0JBQWtCLENBQUMsUUFBUSxDQUFDO1FBRXZELG1DQUFtQztRQUNuQyxJQUFJLGNBQWtDLENBQUM7UUFDdkMsSUFBSSxrQkFBa0IsQ0FBQyxLQUFLLEVBQUU7WUFDNUIsTUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNqRSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxFQUFFO2dCQUNsQyw2RkFBNkY7Z0JBQzdGLE1BQU0sSUFBSSw4QkFBbUIsQ0FDM0IsZ0RBQWdELFlBQVksQ0FBQyxFQUFFLENBQUMsTUFBTSw4QkFBOEIsQ0FDckcsQ0FBQzthQUNIO1lBRUQsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxFQUFZLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDMUQsSUFBSSxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFFO2dCQUMvQixjQUFjLEdBQUcsU0FBUyxDQUFDO2FBQzVCO1NBQ0Y7UUFFRCxNQUFNLFdBQVcsR0FBRztZQUNsQixlQUFlLEVBQUUsU0FBUztZQUMxQixPQUFPLEVBQUUsTUFBTSxDQUFDLFdBQVc7WUFDM0IsV0FBVyxFQUFFLGtCQUFrQjtZQUMvQixjQUFjLEVBQUUsY0FBYztZQUM5QixNQUFNLEVBQUUsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztZQUNyQyxLQUFLLEVBQUUsVUFBVTtZQUNqQixrQkFBa0IsRUFBRSxhQUFhLEdBQUcsT0FBTztZQUMzQyxHQUFHLEVBQUUsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3RDLFFBQVEsRUFBRSxVQUFVO1NBQ3JCLENBQUM7UUFDRixNQUFNLE1BQU0sR0FBVyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRW5ELElBQUksZUFBZSxFQUFFO1lBQ25CLE9BQU87Z0JBQ0wsS0FBSyxFQUFFLE1BQU07Z0JBQ2IsSUFBSSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUU7YUFDdEIsQ0FBQztTQUNIO1FBQ0QsTUFBTSxTQUFTLEdBQUcsTUFBTSxFQUFFLENBQUM7UUFDM0IsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUU7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1NBQ2pEO1FBQ0QsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbkQsTUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUU3RixJQUFJLGlCQUFpQixDQUFDO1FBRXRCLElBQUksYUFBYSxFQUFFO1lBQ2pCLGlCQUFpQixHQUFHLGFBQWEsQ0FBQztTQUNuQzthQUFNO1lBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUU7Z0JBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQzthQUNuRDtZQUNELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JELE1BQU0sZUFBZSxHQUFHLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLEVBQUUsTUFBTSxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUM7WUFDbkcsaUJBQWlCLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsRUFBRSxlQUFlLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1NBQzdHO1FBRUQsTUFBTSxzQkFBc0IsR0FBaUIsQ0FBQyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztZQUMxRSxLQUFLLEVBQUUsaUJBQWlCLENBQUMsaUJBQWlCO1NBQzNDLENBQUMsQ0FBUSxDQUFDO1FBQ1gsc0JBQXNCLENBQUMsS0FBSyxHQUFHLGlCQUFpQixDQUFDLGlCQUFpQixDQUFDO1FBRW5FLElBQUksYUFBYSxFQUFFO1lBQ2pCLHNCQUFzQixDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO1lBQ3BELHNCQUFzQixDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDL0M7UUFDRCxPQUFPLHNCQUFzQixDQUFDO0lBQ2hDLENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxNQUErQjtRQUM5QyxNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGVBQWUsQ0FBQyxJQUFhO1FBQ2xDLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDVCwwRUFBMEU7WUFDMUUsMEVBQTBFO1lBQzFFLGtFQUFrRTtZQUNsRSxJQUFJLEdBQUcsb0JBQVcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDN0I7UUFDRCxNQUFNLFdBQVcsR0FBRyxnQkFBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QyxNQUFNLElBQUksR0FBRyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDL0MsT0FBTztZQUNMLEdBQUcsRUFBRSxJQUFJO1lBQ1QsR0FBRyxFQUFFLFdBQVcsQ0FBQyxRQUFRLEVBQUU7U0FDNUIsQ0FBQztJQUNKLENBQUM7SUFFRCxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBK0I7UUFDcEQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0NBQ0Y7QUEvaEJELGtCQStoQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgYmlwMzIsIEVDUGFpciB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJ3F1ZXJ5c3RyaW5nJztcblxuaW1wb3J0ICogYXMgcmlwcGxlQWRkcmVzc0NvZGVjIGZyb20gJ3JpcHBsZS1hZGRyZXNzLWNvZGVjJztcbmltcG9ydCAqIGFzIHJpcHBsZUJpbmFyeUNvZGVjIGZyb20gJ3JpcHBsZS1iaW5hcnktY29kZWMnO1xuaW1wb3J0IHsgY29tcHV0ZUJpbmFyeVRyYW5zYWN0aW9uSGFzaCB9IGZyb20gJ3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL2hhc2hlcyc7XG5pbXBvcnQgKiBhcyByaXBwbGVLZXlwYWlycyBmcm9tICdyaXBwbGUta2V5cGFpcnMnO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgY2hlY2tLcnNQcm92aWRlcixcbiAgZ2V0QmlwMzJLZXlzLFxuICBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyBhcyBCYXNlSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMsXG4gIEludmFsaWRBZGRyZXNzRXJyb3IsXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgcHJvbWlzZVByb3BzLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyBhcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcblxuY29uc3QgcmlwcGxlID0gcmVxdWlyZSgnLi9yaXBwbGUnKTtcblxuaW50ZXJmYWNlIEFkZHJlc3Mge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGRlc3RpbmF0aW9uVGFnPzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRmVlSW5mbyB7XG4gIGRhdGU6IHN0cmluZztcbiAgaGVpZ2h0OiBudW1iZXI7XG4gIGJhc2VSZXNlcnZlOiBzdHJpbmc7XG4gIGJhc2VGZWU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xuICBpc0xhc3RTaWduYXR1cmU/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7IC8vIHR4SGV4IGlzIHBvb3JseSBuYW1lZCBoZXJlOyBpdCBpcyBqdXN0IGEgd3JhcHBlZCBKU09OIG9iamVjdFxuICB9O1xufVxuXG5pbnRlcmZhY2UgVmVyaWZ5QWRkcmVzc09wdGlvbnMgZXh0ZW5kcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMge1xuICByb290QWRkcmVzczogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlcnlJbmZvIGV4dGVuZHMgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIGJhY2t1cEtleT86IHN0cmluZztcbiAgY29pbj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyeVRyYW5zYWN0aW9uIHtcbiAgdHhIZXg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyBleHRlbmRzIEJhc2VJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyB7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5T3B0aW9ucyB7XG4gIGJhY2t1cEtleTogc3RyaW5nO1xuICB1c2VyS2V5OiBzdHJpbmc7XG4gIHJvb3RBZGRyZXNzOiBzdHJpbmc7XG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZztcbiAgYml0Z29LZXk/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBIYWxmU2lnbmVkVHJhbnNhY3Rpb24ge1xuICBoYWxmU2lnbmVkOiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbn1cblxuaW50ZXJmYWNlIFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMge1xuICByb290UHJpdmF0ZUtleT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFhycCBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UpIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IFhycChiaXRnbyk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yIGJldHdlZW4gdGhlIGNvaW4ncyBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqL1xuICBwdWJsaWMgZ2V0QmFzZUZhY3RvcigpOiBudW1iZXIge1xuICAgIHJldHVybiAxZTY7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGJsb2NrY2hhaW4gd2hpY2ggc3VwcG9ydHMgdGhpcyBjb2luXG4gICAqL1xuICBwdWJsaWMgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3hycCc7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGNvaW4gZmFtaWx5XG4gICAqL1xuICBwdWJsaWMgZ2V0RmFtaWx5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICd4cnAnO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIGh1bWFuLXJlYWRhYmxlIG5hbWUgb2YgdGhpcyBjb2luXG4gICAqL1xuICBwdWJsaWMgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1JpcHBsZSc7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYW4gYWRkcmVzcyBzdHJpbmcgaW50byBhZGRyZXNzIGFuZCBkZXN0aW5hdGlvbiB0YWdcbiAgICovXG4gIHB1YmxpYyBnZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzOiBzdHJpbmcpOiBBZGRyZXNzIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSB1cmwucGFyc2UoYWRkcmVzcyk7XG4gICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lO1xuICAgIGlmICghZGVzdGluYXRpb25BZGRyZXNzIHx8ICFyaXBwbGVBZGRyZXNzQ29kZWMuaXNWYWxpZENsYXNzaWNBZGRyZXNzKGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBkZXN0aW5hdGlvbiBhZGRyZXNzIFwiJHtkZXN0aW5hdGlvbkFkZHJlc3N9XCIgaXMgbm90IHZhbGlkYCk7XG4gICAgfVxuICAgIC8vIHRoZXJlIGFyZSBubyBvdGhlciBwcm9wZXJ0aWVzIGxpa2UgZGVzdGluYXRpb24gdGFnc1xuICAgIGlmIChkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWUgPT09IGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIGRlc3RpbmF0aW9uVGFnOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignbm8gcXVlcnkgcGFyYW1zIHByZXNlbnQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeURldGFpbHMgPSBxdWVyeXN0cmluZy5wYXJzZShkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpO1xuICAgIGlmICghcXVlcnlEZXRhaWxzLmR0KSB7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBwcm9wZXJ0aWVzLCB0aGUgcXVlcnkgZGV0YWlscyBuZWVkIHRvIGNvbnRhaW4gdGhlIGRlc3RpbmF0aW9uIHRhZyBwcm9wZXJ0eS5cbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdkZXN0aW5hdGlvbiB0YWcgbWlzc2luZycpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5kdCkpIHtcbiAgICAgIC8vIGlmIHF1ZXJ5RGV0YWlscy5kdCBpcyBhbiBhcnJheSwgdGhhdCBtZWFucyBkdCB3YXMgZ2l2ZW4gbXVsdGlwbGUgdGltZXMsIHdoaWNoIGlzIG5vdCB2YWxpZFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoXG4gICAgICAgIGBkZXN0aW5hdGlvbiB0YWcgY2FuIGFwcGVhciBhdCBtb3N0IG9uY2UsIGJ1dCAke3F1ZXJ5RGV0YWlscy5kdC5sZW5ndGh9IGRlc3RpbmF0aW9uIHRhZ3Mgd2VyZSBmb3VuZGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkVGFnID0gcGFyc2VJbnQocXVlcnlEZXRhaWxzLmR0LCAxMCk7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihwYXJzZWRUYWcpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignaW52YWxpZCBkZXN0aW5hdGlvbiB0YWcnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyc2VkVGFnID4gMHhmZmZmZmZmZiB8fCBwYXJzZWRUYWcgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcignZGVzdGluYXRpb24gdGFnIG91dCBvZiByYW5nZScpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhZGRyZXNzOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBkZXN0aW5hdGlvblRhZzogcGFyc2VkVGFnLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgZnVsbCwgbm9ybWFsaXplZCBhZGRyZXNzIGZyb20gYW4gYWRkcmVzcyBhbmQgZGVzdGluYXRpb24gdGFnXG4gICAqL1xuICBwdWJsaWMgbm9ybWFsaXplQWRkcmVzcyh7IGFkZHJlc3MsIGRlc3RpbmF0aW9uVGFnIH06IEFkZHJlc3MpOiBzdHJpbmcge1xuICAgIGlmICghXy5pc1N0cmluZyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoJ2ludmFsaWQgYWRkcmVzcyBkZXRhaWxzJyk7XG4gICAgfVxuICAgIGlmIChfLmlzSW50ZWdlcihkZXN0aW5hdGlvblRhZykpIHtcbiAgICAgIHJldHVybiBgJHthZGRyZXNzfT9kdD0ke2Rlc3RpbmF0aW9uVGFnfWA7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyB3aGV0aGVyIGFuIGFkZHJlc3Mgc3RyaW5nIGlzIHZhbGlkIGZvciB0aGlzIGNvaW5cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIHB1YmxpYyBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3MpO1xuICAgICAgcmV0dXJuIGFkZHJlc3MgPT09IHRoaXMubm9ybWFsaXplQWRkcmVzcyhhZGRyZXNzRGV0YWlscyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIHB1YmxpYyBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBiaXAzMi5mcm9tQmFzZTU4KHB1YikuaXNOZXV0ZXJlZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGZlZSBpbmZvIGZyb20gc2VydmVyXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgZ2V0RmVlSW5mbygpOiBQcm9taXNlPEZlZUluZm8+IHtcbiAgICByZXR1cm4gdGhpcy5iaXRnby5nZXQodGhpcy51cmwoJy9wdWJsaWMvZmVlaW5mbycpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB0eFByZWJ1aWxkXG4gICAqIC0gcHJ2XG4gICAqIEByZXR1cm5zIEJsdWViaXJkPEhhbGZTaWduZWRUcmFuc2FjdGlvbj5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBzaWduVHJhbnNhY3Rpb24oe1xuICAgIHR4UHJlYnVpbGQsXG4gICAgcHJ2LFxuICAgIGlzTGFzdFNpZ25hdHVyZSxcbiAgfTogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8SGFsZlNpZ25lZFRyYW5zYWN0aW9uIHwgUmVjb3ZlcnlUcmFuc2FjdGlvbj4ge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHR4UHJlYnVpbGQpIHx8ICFfLmlzT2JqZWN0KHR4UHJlYnVpbGQpKSB7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkgJiYgIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB0eFByZWJ1aWxkIG11c3QgYmUgYW4gb2JqZWN0LCBnb3QgdHlwZSAke3R5cGVvZiB0eFByZWJ1aWxkfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4UHJlYnVpbGQgcGFyYW1ldGVyJyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocHJ2KSB8fCAhXy5pc1N0cmluZyhwcnYpKSB7XG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQocHJ2KSAmJiAhXy5pc1N0cmluZyhwcnYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHBydn1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwcnYgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyS2V5ID0gYmlwMzIuZnJvbUJhc2U1OChwcnYpO1xuICAgIGNvbnN0IHVzZXJQcml2YXRlS2V5ID0gdXNlcktleS5wcml2YXRlS2V5O1xuICAgIGlmICghdXNlclByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gcHJpdmF0ZUtleWApO1xuICAgIH1cbiAgICBjb25zdCB1c2VyQWRkcmVzcyA9IHJpcHBsZUtleXBhaXJzLmRlcml2ZUFkZHJlc3ModXNlcktleS5wdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpKTtcblxuICAgIGNvbnN0IHJpcHBsZUxpYiA9IHJpcHBsZSgpO1xuXG4gICAgY29uc3QgdHggPSByaXBwbGVMaWIuc2lnbldpdGhQcml2YXRlS2V5KHR4UHJlYnVpbGQudHhIZXgsIHVzZXJQcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKSwge1xuICAgICAgc2lnbkFzOiB1c2VyQWRkcmVzcyxcbiAgICB9KTtcblxuICAgIC8vIE5vcm1hbGx5IHRoZSBTREsgcHJvdmlkZXMgdGhlIGZpcnN0IHNpZ25hdHVyZSBmb3IgYW4gWFJQIHR4LCBidXQgb2NjYXNpb25hbGx5IGl0IHByb3ZpZGVzIHRoZSBmaW5hbCBvbmUgYXMgd2VsbFxuICAgIC8vIChyZWNvdmVyaWVzKVxuICAgIGlmIChpc0xhc3RTaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiB7IHR4SGV4OiB0eC5zaWduZWRUcmFuc2FjdGlvbiB9O1xuICAgIH1cbiAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHR4SGV4OiB0eC5zaWduZWRUcmFuc2FjdGlvbiB9IH07XG4gIH1cblxuICAvKipcbiAgICogUmlwcGxlIHJlcXVpcmVzIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3Igd2FsbGV0IGdlbmVyYXRpb24gdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLiBUaGUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGFyZVxuICAgKiB0aGUgcm9vdCBwdWJsaWMga2V5LCB3aGljaCBpcyB0aGUgYmFzaXMgb2YgdGhlIHJvb3QgYWRkcmVzcywgdHdvIHNpZ25lZCwgYW5kIG9uZSBoYWxmLXNpZ25lZCBpbml0aWFsaXphdGlvbiB0eHNcbiAgICogQHBhcmFtIHdhbGxldFBhcmFtc1xuICAgKiAtIHJvb3RQcml2YXRlS2V5OiBvcHRpb25hbCBoZXgtZW5jb2RlZCBSaXBwbGUgcHJpdmF0ZSBrZXlcbiAgICovXG4gIGFzeW5jIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldChcbiAgICB3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnNcbiAgKTogUHJvbWlzZTxTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zPiB7XG4gICAgaWYgKHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSkge1xuICAgICAgaWYgKHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm9vdFByaXZhdGVLZXkgbmVlZHMgdG8gYmUgYSBoZXhhZGVjaW1hbCBwcml2YXRlIGtleSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5UGFpciA9IEVDUGFpci5tYWtlUmFuZG9tKCk7XG4gICAgICBpZiAoIWtleVBhaXIucHJpdmF0ZUtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByaXZhdGVLZXknKTtcbiAgICAgIH1cbiAgICAgIHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSA9IGtleVBhaXIucHJpdmF0ZUtleS50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXRQYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbi9wYXJzZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zID0ge30pOiBQcm9taXNlPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICBsZXQgdHJhbnNhY3Rpb247XG4gICAgbGV0IHR4SGV4OiBzdHJpbmcgPSBwYXJhbXMudHhIZXggfHwgKChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCkgYXMgc3RyaW5nKTtcbiAgICBpZiAoIXR4SGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gdHhIZXgnKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHRyYW5zYWN0aW9uID0gcmlwcGxlQmluYXJ5Q29kZWMuZGVjb2RlKHR4SGV4KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IEpTT04ucGFyc2UodHhIZXgpO1xuICAgICAgICB0eEhleCA9IHJpcHBsZUJpbmFyeUNvZGVjLmVuY29kZSh0cmFuc2FjdGlvbik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHhIZXggbmVlZHMgdG8gYmUgZWl0aGVyIGhleCBvciBKU09OIHN0cmluZyBmb3IgWFJQJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlkID0gY29tcHV0ZUJpbmFyeVRyYW5zYWN0aW9uSGFzaCh0eEhleCBhcyBzdHJpbmcpO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLlRyYW5zYWN0aW9uVHlwZSA9PSAnQWNjb3VudFNldCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXlPcmRlcjogWydpZCcsICdvdXRwdXRBbW91bnQnLCAnY2hhbmdlQW1vdW50JywgJ291dHB1dHMnLCAnY2hhbmdlT3V0cHV0cycsICdmZWUnLCAnYWNjb3VudFNldCddLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRBbW91bnQ6IDAsXG4gICAgICAgIGNoYW5nZUFtb3VudDogMCxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICAgIGZlZToge1xuICAgICAgICAgIGZlZTogdHJhbnNhY3Rpb24uRmVlLFxuICAgICAgICAgIGZlZVJhdGU6IG51bGwsXG4gICAgICAgICAgc2l6ZTogdHhIZXghLmxlbmd0aCAvIDIsXG4gICAgICAgIH0sXG4gICAgICAgIGFjY291bnRTZXQ6IHtcbiAgICAgICAgICBtZXNzYWdlS2V5OiB0cmFuc2FjdGlvbi5NZXNzYWdlS2V5LFxuICAgICAgICB9LFxuICAgICAgfSBhcyBhbnk7XG4gICAgfVxuXG4gICAgY29uc3QgYWRkcmVzcyA9XG4gICAgICB0cmFuc2FjdGlvbi5EZXN0aW5hdGlvbiArICh0cmFuc2FjdGlvbi5EZXN0aW5hdGlvblRhZyA+PSAwID8gJz9kdD0nICsgdHJhbnNhY3Rpb24uRGVzdGluYXRpb25UYWcgOiAnJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BsYXlPcmRlcjogWydpZCcsICdvdXRwdXRBbW91bnQnLCAnY2hhbmdlQW1vdW50JywgJ291dHB1dHMnLCAnY2hhbmdlT3V0cHV0cycsICdmZWUnXSxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgb3V0cHV0QW1vdW50OiB0cmFuc2FjdGlvbi5BbW91bnQsXG4gICAgICBjaGFuZ2VBbW91bnQ6IDAsXG4gICAgICBvdXRwdXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGFtb3VudDogdHJhbnNhY3Rpb24uQW1vdW50LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICAgIGZlZToge1xuICAgICAgICBmZWU6IHRyYW5zYWN0aW9uLkZlZSxcbiAgICAgICAgZmVlUmF0ZTogbnVsbCxcbiAgICAgICAgc2l6ZTogdHhIZXgubGVuZ3RoIC8gMixcbiAgICAgIH0sXG4gICAgfSBhcyBhbnk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBjb21wbGllcyB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICogQHBhcmFtIHR4UGFyYW1zIHBhcmFtcyBvYmplY3QgcGFzc2VkIHRvIHNlbmRcbiAgICogQHBhcmFtIHR4UHJlYnVpbGQgcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHNlcnZlclxuICAgKiBAcGFyYW0gd2FsbGV0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHZlcmlmeVRyYW5zYWN0aW9uKHsgdHhQYXJhbXMsIHR4UHJlYnVpbGQgfTogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZXhwbGFuYXRpb24gPSBhd2FpdCB0aGlzLmV4cGxhaW5UcmFuc2FjdGlvbih7XG4gICAgICB0eEhleDogdHhQcmVidWlsZC50eEhleCxcbiAgICB9KTtcblxuICAgIGNvbnN0IG91dHB1dCA9IFsuLi5leHBsYW5hdGlvbi5vdXRwdXRzLCAuLi5leHBsYW5hdGlvbi5jaGFuZ2VPdXRwdXRzXVswXTtcbiAgICBjb25zdCBleHBlY3RlZE91dHB1dCA9IHR4UGFyYW1zLnJlY2lwaWVudHMgJiYgdHhQYXJhbXMucmVjaXBpZW50c1swXTtcblxuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSAocmVjaXBpZW50MSwgcmVjaXBpZW50MikgPT4ge1xuICAgICAgaWYgKHJlY2lwaWVudDEuYWRkcmVzcyAhPT0gcmVjaXBpZW50Mi5hZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFtb3VudDEgPSBuZXcgQmlnTnVtYmVyKHJlY2lwaWVudDEuYW1vdW50KTtcbiAgICAgIGNvbnN0IGFtb3VudDIgPSBuZXcgQmlnTnVtYmVyKHJlY2lwaWVudDIuYW1vdW50KTtcbiAgICAgIHJldHVybiBhbW91bnQxLnRvRml4ZWQoKSA9PT0gYW1vdW50Mi50b0ZpeGVkKCk7XG4gICAgfTtcblxuICAgIGlmICghY29tcGFyYXRvcihvdXRwdXQsIGV4cGVjdGVkT3V0cHV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBvdXRwdXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhZGRyZXNzIGlzIGEgdmFsaWQgWFJQIGFkZHJlc3MsIGFuZCB0aGVuIG1ha2Ugc3VyZSB0aGUgcm9vdCBhZGRyZXNzZXMgbWF0Y2guXG4gICAqIFRoaXMgcHJldmVudHMgYXR0YWNrcyB3aGVyZSBhbiBhdHRhY2sgbWF5IHN3aXRjaCBvdXQgdGhlIG5ldyBhZGRyZXNzIGZvciBvbmUgb2YgdGhlaXIgb3duXG4gICAqIEBwYXJhbSBhZGRyZXNzIHtTdHJpbmd9IHRoZSBhZGRyZXNzIHRvIHZlcmlmeVxuICAgKiBAcGFyYW0gcm9vdEFkZHJlc3Mge1N0cmluZ30gdGhlIHdhbGxldCdzIHJvb3QgYWRkcmVzc1xuICAgKiBAcmV0dXJuIHRydWUgaWZmIGFkZHJlc3MgaXMgYSB3YWxsZXQgYWRkcmVzcyAoYmFzZWQgb24gcm9vdEFkZHJlc3MpXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaXNXYWxsZXRBZGRyZXNzKHsgYWRkcmVzcywgcm9vdEFkZHJlc3MgfTogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBhZGRyZXNzIHZlcmlmaWNhdGlvbiBmYWlsdXJlOiBhZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIG5vdCB2YWxpZGApO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICBjb25zdCByb290QWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKHJvb3RBZGRyZXNzKTtcblxuICAgIGlmIChhZGRyZXNzRGV0YWlscy5hZGRyZXNzICE9PSByb290QWRkcmVzc0RldGFpbHMuYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoXG4gICAgICAgIGBhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogJHthZGRyZXNzRGV0YWlscy5hZGRyZXNzfSB2cy4gJHtyb290QWRkcmVzc0RldGFpbHMuYWRkcmVzc31gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVSTCBvZiBhIHdlbGwta25vd24sIHB1YmxpYyBmYWNpbmcgKG5vbi1iaXRnbykgcmlwcGxlZCBpbnN0YW5jZSB3aGljaCBjYW4gYmUgdXNlZCBmb3IgcmVjb3ZlcnlcbiAgICovXG4gIHB1YmxpYyBnZXRSaXBwbGVkVXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdodHRwczovL3MxLnJpcHBsZS5jb206NTEyMzQnO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHJvb3RBZGRyZXNzOiByb290IFhSUCB3YWxsZXQgYWRkcmVzcyB0byByZWNvdmVyIGZ1bmRzIGZyb21cbiAgICogLSB1c2VyS2V5OiBbZW5jcnlwdGVkXSB4cHJ2XG4gICAqIC0gYmFja3VwS2V5OiBbZW5jcnlwdGVkXSB4cHJ2LCBvciB4cHViIGlmIHRoZSB4cHJ2IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAgICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSB4cHJ2cyBpcyBlbmNyeXB0ZWRcbiAgICogLSBiaXRnb0tleTogeHB1YlxuICAgKiAtIGtyc1Byb3ZpZGVyOiBuZWNlc3NhcnkgaWYgYmFja3VwIGtleSBpcyBoZWxkIGJ5IEtSU1xuICAgKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcmVjb3ZlcihwYXJhbXM6IFJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8UmVjb3ZlcnlJbmZvIHwgUmVjb3ZlcnlUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHJpcHBsZWRVcmwgPSB0aGlzLmdldFJpcHBsZWRVcmwoKTtcbiAgICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCd4cHViJykgJiYgIXBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ3hwdWInKSAmJiBwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJyk7XG5cbiAgICBjb25zdCBhY2NvdW50SW5mb1BhcmFtcyA9IHtcbiAgICAgIG1ldGhvZDogJ2FjY291bnRfaW5mbycsXG4gICAgICBwYXJhbXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGFjY291bnQ6IHBhcmFtcy5yb290QWRkcmVzcyxcbiAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgbGVkZ2VyX2luZGV4OiAnY3VycmVudCcsXG4gICAgICAgICAgcXVldWU6IHRydWUsXG4gICAgICAgICAgc2lnbmVyX2xpc3RzOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuXG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIGNoZWNrS3JzUHJvdmlkZXIodGhpcywgcGFyYW1zLmtyc1Byb3ZpZGVyKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGUgZGVzdGluYXRpb24gYWRkcmVzc1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXN0aW5hdGlvbiBhZGRyZXNzIScpO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBnZXRCaXAzMktleXModGhpcy5iaXRnbywgcGFyYW1zLCB7IHJlcXVpcmVCaXRHb1hwdWI6IGZhbHNlIH0pO1xuXG4gICAgY29uc3QgeyBhZGRyZXNzRGV0YWlscywgZmVlRGV0YWlscywgc2VydmVyRGV0YWlscyB9ID0gYXdhaXQgcHJvbWlzZVByb3BzKHtcbiAgICAgIGFkZHJlc3NEZXRhaWxzOiB0aGlzLmJpdGdvLnBvc3QocmlwcGxlZFVybCkuc2VuZChhY2NvdW50SW5mb1BhcmFtcyksXG4gICAgICBmZWVEZXRhaWxzOiB0aGlzLmJpdGdvLnBvc3QocmlwcGxlZFVybCkuc2VuZCh7IG1ldGhvZDogJ2ZlZScgfSksXG4gICAgICBzZXJ2ZXJEZXRhaWxzOiB0aGlzLmJpdGdvLnBvc3QocmlwcGxlZFVybCkuc2VuZCh7IG1ldGhvZDogJ3NlcnZlcl9pbmZvJyB9KSxcbiAgICB9KTtcblxuICAgIGNvbnN0IG9wZW5MZWRnZXJGZWUgPSBuZXcgQmlnTnVtYmVyKGZlZURldGFpbHMuYm9keS5yZXN1bHQuZHJvcHMub3Blbl9sZWRnZXJfZmVlKTtcbiAgICBjb25zdCBiYXNlUmVzZXJ2ZSA9IG5ldyBCaWdOdW1iZXIoc2VydmVyRGV0YWlscy5ib2R5LnJlc3VsdC5pbmZvLnZhbGlkYXRlZF9sZWRnZXIucmVzZXJ2ZV9iYXNlX3hycCkudGltZXMoXG4gICAgICB0aGlzLmdldEJhc2VGYWN0b3IoKVxuICAgICk7XG4gICAgY29uc3QgcmVzZXJ2ZURlbHRhID0gbmV3IEJpZ051bWJlcihzZXJ2ZXJEZXRhaWxzLmJvZHkucmVzdWx0LmluZm8udmFsaWRhdGVkX2xlZGdlci5yZXNlcnZlX2luY194cnApLnRpbWVzKFxuICAgICAgdGhpcy5nZXRCYXNlRmFjdG9yKClcbiAgICApO1xuICAgIGNvbnN0IGN1cnJlbnRMZWRnZXIgPSBzZXJ2ZXJEZXRhaWxzLmJvZHkucmVzdWx0LmluZm8udmFsaWRhdGVkX2xlZGdlci5zZXE7XG4gICAgY29uc3Qgc2VxdWVuY2VJZCA9IGFkZHJlc3NEZXRhaWxzLmJvZHkucmVzdWx0LmFjY291bnRfZGF0YS5TZXF1ZW5jZTtcbiAgICBjb25zdCBiYWxhbmNlID0gbmV3IEJpZ051bWJlcihhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuQmFsYW5jZSk7XG4gICAgY29uc3Qgc2lnbmVyTGlzdHMgPSBhZGRyZXNzRGV0YWlscy5ib2R5LnJlc3VsdC5hY2NvdW50X2RhdGEuc2lnbmVyX2xpc3RzO1xuICAgIGNvbnN0IGFjY291bnRGbGFncyA9IGFkZHJlc3NEZXRhaWxzLmJvZHkucmVzdWx0LmFjY291bnRfZGF0YS5GbGFncztcblxuICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBvbmx5IG9uZSBzaWduZXIgbGlzdCBzZXRcbiAgICBpZiAoc2lnbmVyTGlzdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgc2V0IG9mIHNpZ25lciBsaXN0cycpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgc2lnbmVycyBhcmUgdXNlciwgYmFja3VwLCBiaXRnb1xuICAgIGNvbnN0IHVzZXJBZGRyZXNzID0gcmlwcGxlS2V5cGFpcnMuZGVyaXZlQWRkcmVzcyhrZXlzWzBdLnB1YmxpY0tleS50b1N0cmluZygnaGV4JykpO1xuICAgIGNvbnN0IGJhY2t1cEFkZHJlc3MgPSByaXBwbGVLZXlwYWlycy5kZXJpdmVBZGRyZXNzKGtleXNbMV0ucHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKSk7XG5cbiAgICBjb25zdCBzaWduZXJMaXN0ID0gc2lnbmVyTGlzdHNbMF07XG4gICAgaWYgKHNpZ25lckxpc3QuU2lnbmVyUXVvcnVtICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWluaW11bSBzaWduYXR1cmUgY291bnQnKTtcbiAgICB9XG4gICAgY29uc3QgZm91bmRBZGRyZXNzZXMgPSB7fTtcblxuICAgIGNvbnN0IHNpZ25lckVudHJpZXMgPSBzaWduZXJMaXN0LlNpZ25lckVudHJpZXM7XG4gICAgaWYgKHNpZ25lckVudHJpZXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmVyIGxpc3QgbGVuZ3RoJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyBTaWduZXJFbnRyeSB9IG9mIHNpZ25lckVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IFNpZ25lckVudHJ5LlNpZ25lcldlaWdodDtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBTaWduZXJFbnRyeS5BY2NvdW50O1xuICAgICAgaWYgKHdlaWdodCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmVyIHdlaWdodCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBpdCdzIGEgZHVwZSBvZiBhbiBhZGRyZXNzIHdlIGFscmVhZHkga25vdywgYmxvY2tcbiAgICAgIGlmIChmb3VuZEFkZHJlc3Nlc1thZGRyZXNzXSA+PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZHVwbGljYXRlIHNpZ25lciBhZGRyZXNzJyk7XG4gICAgICB9XG4gICAgICBmb3VuZEFkZHJlc3Nlc1thZGRyZXNzXSA9IChmb3VuZEFkZHJlc3Nlc1thZGRyZXNzXSB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kQWRkcmVzc2VzW3VzZXJBZGRyZXNzXSAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGluY2lkZW5jZSBmcmVxdWVuY3kgb2YgdXNlciBzaWduZXIgYWRkcmVzcycpO1xuICAgIH1cbiAgICBpZiAoZm91bmRBZGRyZXNzZXNbYmFja3VwQWRkcmVzc10gIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBpbmNpZGVuY2UgZnJlcXVlbmN5IG9mIHVzZXIgc2lnbmVyIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIGZsYWdzIGRpc2FibGUgdGhlIG1hc3RlciBrZXkgYW5kIGVuZm9yY2UgZGVzdGluYXRpb24gdGFnc1xuICAgIGNvbnN0IFVTRVJfS0VZX1NFVFRJTkdfRkxBRyA9IDY1NTM2O1xuICAgIGNvbnN0IE1BU1RFUl9LRVlfREVBQ1RJVkFUSU9OX0ZMQUcgPSAxMDQ4NTc2O1xuICAgIGNvbnN0IFJFUVVJUkVfREVTVElOQVRJT05fVEFHX0ZMQUcgPSAxMzEwNzI7XG4gICAgaWYgKChhY2NvdW50RmxhZ3MgJiBVU0VSX0tFWV9TRVRUSU5HX0ZMQUcpICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2EgY3VzdG9tIHVzZXIga2V5IGhhcyBiZWVuIHNldCcpO1xuICAgIH1cbiAgICBpZiAoKGFjY291bnRGbGFncyAmIE1BU1RFUl9LRVlfREVBQ1RJVkFUSU9OX0ZMQUcpICE9PSBNQVNURVJfS0VZX0RFQUNUSVZBVElPTl9GTEFHKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBtYXN0ZXIga2V5IGhhcyBub3QgYmVlbiBkZWFjdGl2YXRlZCcpO1xuICAgIH1cbiAgICBpZiAoKGFjY291bnRGbGFncyAmIFJFUVVJUkVfREVTVElOQVRJT05fVEFHX0ZMQUcpICE9PSBSRVFVSVJFX0RFU1RJTkFUSU9OX1RBR19GTEFHKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoZSBkZXN0aW5hdGlvbiBmbGFnIHJlcXVpcmVtZW50IGhhcyBub3QgYmVlbiBhY3RpdmF0ZWQnKTtcbiAgICB9XG5cbiAgICAvLyByZWNvdmVyIHRoZSBmdW5kc1xuICAgIGNvbnN0IHJlc2VydmUgPSBiYXNlUmVzZXJ2ZS5wbHVzKHJlc2VydmVEZWx0YS50aW1lcyg1KSk7XG4gICAgY29uc3QgcmVjb3ZlcmFibGVCYWxhbmNlID0gYmFsYW5jZS5taW51cyhyZXNlcnZlKTtcblxuICAgIGNvbnN0IHJhd0Rlc3RpbmF0aW9uID0gcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb247XG4gICAgY29uc3QgZGVzdGluYXRpb25EZXRhaWxzID0gdXJsLnBhcnNlKHJhd0Rlc3RpbmF0aW9uKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3MgPSBkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWU7XG5cbiAgICAvLyBwYXJzZSBkZXN0aW5hdGlvbiB0YWcgZnJvbSBxdWVyeVxuICAgIGxldCBkZXN0aW5hdGlvblRhZzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGlmIChkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpIHtcbiAgICAgIGNvbnN0IHF1ZXJ5RGV0YWlscyA9IHF1ZXJ5c3RyaW5nLnBhcnNlKGRlc3RpbmF0aW9uRGV0YWlscy5xdWVyeSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMuZHQpKSB7XG4gICAgICAgIC8vIGlmIHF1ZXJ5RGV0YWlscy5kdCBpcyBhbiBhcnJheSwgdGhhdCBtZWFucyBkdCB3YXMgZ2l2ZW4gbXVsdGlwbGUgdGltZXMsIHdoaWNoIGlzIG5vdCB2YWxpZFxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihcbiAgICAgICAgICBgZGVzdGluYXRpb24gdGFnIGNhbiBhcHBlYXIgYXQgbW9zdCBvbmNlLCBidXQgJHtxdWVyeURldGFpbHMuZHQubGVuZ3RofSBkZXN0aW5hdGlvbiB0YWdzIHdlcmUgZm91bmRgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZFRhZyA9IHBhcnNlSW50KHF1ZXJ5RGV0YWlscy5kdCBhcyBzdHJpbmcsIDEwKTtcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHBhcnNlZFRhZykpIHtcbiAgICAgICAgZGVzdGluYXRpb25UYWcgPSBwYXJzZWRUYWc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgICBUcmFuc2FjdGlvblR5cGU6ICdQYXltZW50JyxcbiAgICAgIEFjY291bnQ6IHBhcmFtcy5yb290QWRkcmVzcywgLy8gc291cmNlIGFkZHJlc3NcbiAgICAgIERlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbkFkZHJlc3MsXG4gICAgICBEZXN0aW5hdGlvblRhZzogZGVzdGluYXRpb25UYWcsXG4gICAgICBBbW91bnQ6IHJlY292ZXJhYmxlQmFsYW5jZS50b0ZpeGVkKDApLFxuICAgICAgRmxhZ3M6IDIxNDc0ODM2NDgsXG4gICAgICBMYXN0TGVkZ2VyU2VxdWVuY2U6IGN1cnJlbnRMZWRnZXIgKyAxMDAwMDAwLCAvLyBnaXZlIGl0IDEgbWlsbGlvbiBsZWRnZXJzJyB0aW1lICh+MSBtb250aCwgc3VpdGFibGUgZm9yIEtSUylcbiAgICAgIEZlZTogb3BlbkxlZGdlckZlZS50aW1lcygzKS50b0ZpeGVkKDApLCAvLyB0aGUgZmFjdG9yIHRocmVlIGlzIGZvciB0aGUgbXVsdGlzaWduaW5nXG4gICAgICBTZXF1ZW5jZTogc2VxdWVuY2VJZCxcbiAgICB9O1xuICAgIGNvbnN0IHR4SlNPTjogc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb24pO1xuXG4gICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHhIZXg6IHR4SlNPTixcbiAgICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmlwcGxlTGliID0gcmlwcGxlKCk7XG4gICAgaWYgKCFrZXlzWzBdLnByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXNlcktleSBpcyBub3QgYSBwcml2YXRlIGtleWApO1xuICAgIH1cbiAgICBjb25zdCB1c2VyS2V5ID0ga2V5c1swXS5wcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCB1c2VyU2lnbmF0dXJlID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eEpTT04sIHVzZXJLZXksIHsgc2lnbkFzOiB1c2VyQWRkcmVzcyB9KTtcblxuICAgIGxldCBzaWduZWRUcmFuc2FjdGlvbjtcblxuICAgIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IHVzZXJTaWduYXR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgha2V5c1sxXS5wcml2YXRlS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFja3VwS2V5IGlzIG5vdCBhIHByaXZhdGUga2V5YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBiYWNrdXBLZXkgPSBrZXlzWzFdLnByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgY29uc3QgYmFja3VwU2lnbmF0dXJlID0gcmlwcGxlTGliLnNpZ25XaXRoUHJpdmF0ZUtleSh0eEpTT04sIGJhY2t1cEtleSwgeyBzaWduQXM6IGJhY2t1cEFkZHJlc3MgfSk7XG4gICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IHJpcHBsZUxpYi5jb21iaW5lKFt1c2VyU2lnbmF0dXJlLnNpZ25lZFRyYW5zYWN0aW9uLCBiYWNrdXBTaWduYXR1cmUuc2lnbmVkVHJhbnNhY3Rpb25dKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2FjdGlvbkV4cGxhbmF0aW9uOiBSZWNvdmVyeUluZm8gPSAoYXdhaXQgdGhpcy5leHBsYWluVHJhbnNhY3Rpb24oe1xuICAgICAgdHhIZXg6IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25lZFRyYW5zYWN0aW9uLFxuICAgIH0pKSBhcyBhbnk7XG4gICAgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbi50eEhleCA9IHNpZ25lZFRyYW5zYWN0aW9uLnNpZ25lZFRyYW5zYWN0aW9uO1xuXG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICAgIHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uY29pbiA9IHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uRXhwbGFuYXRpb247XG4gIH1cblxuICBpbml0aWF0ZVJlY292ZXJ5KHBhcmFtczogSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZXByZWNhdGVkIG1ldGhvZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IGtleXBhaXIgZm9yIHRoaXMgY29pbi5cbiAgICogQHBhcmFtIHNlZWQgU2VlZCBmcm9tIHdoaWNoIHRoZSBuZXcga2V5cGFpciBzaG91bGQgYmUgZ2VuZXJhdGVkLCBvdGhlcndpc2UgYSByYW5kb20gc2VlZCBpcyB1c2VkXG4gICAqL1xuICBwdWJsaWMgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2XG4gICAgICAvLyBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZVxuICAgICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgY29uc3QgeHB1YiA9IGV4dGVuZGVkS2V5Lm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiB4cHViLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleS50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG4iXX0=