"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = exports.addressFormat = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const create_hash_1 = __importDefault(require("create-hash"));
const safe_buffer_1 = require("safe-buffer");
const avalanche_1 = require("avalanche");
const common_1 = require("avalanche/dist/common");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = require("crypto");
const utils_1 = __importDefault(require("./utils"));
const DEFAULT_SEED_SIZE_BYTES = 16;
var addressFormat;
(function (addressFormat) {
    addressFormat["testnet"] = "fuji";
    addressFormat["mainnet"] = "avax";
})(addressFormat = exports.addressFormat || (exports.addressFormat = {}));
class KeyPair extends sdk_core_1.Secp256k1ExtendedKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    constructor(source) {
        super(source);
        if (!source) {
            const seed = crypto_1.randomBytes(DEFAULT_SEED_SIZE_BYTES);
            this.hdNode = utxo_lib_1.bip32.fromSeed(seed);
        }
        else if (sdk_core_1.isSeed(source)) {
            this.hdNode = utxo_lib_1.bip32.fromSeed(source.seed);
        }
        else if (sdk_core_1.isPrivateKey(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if (sdk_core_1.isPublicKey(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (this.hdNode) {
            this.keyPair = sdk_core_1.Secp256k1ExtendedKeyPair.toKeyPair(this.hdNode);
        }
    }
    /**
     * Build a keypair from a protocol private key or extended private key.
     *
     * @param {string} prv A raw private key
     */
    recordKeysFromPrivateKey(prv) {
        if (prv.startsWith('PrivateKey-')) {
            this.keyPair = utxo_lib_1.ECPair.fromPrivateKey(Buffer.from(utils_1.default.cb58Decode(prv.split('-')[1])));
            return;
        }
        if (!utils_1.default.isValidPrivateKey(prv)) {
            throw new Error('Unsupported private key');
        }
        if (sdk_core_1.isValidXprv(prv)) {
            this.hdNode = utxo_lib_1.bip32.fromBase58(prv);
        }
        else {
            this.keyPair = utxo_lib_1.ECPair.fromPrivateKey(Buffer.from(prv.slice(0, 64), 'hex'));
        }
    }
    /**
     * Build an ECPair from a protocol public key or extended public key.
     *
     * @param {string} pub A raw public key
     */
    recordKeysFromPublicKey(pub) {
        try {
            if (sdk_core_1.isValidXpub(pub)) {
                this.hdNode = utxo_lib_1.bip32.fromBase58(pub);
            }
            else {
                this.keyPair = utxo_lib_1.ECPair.fromPublicKey(Buffer.from(pub, 'hex'));
            }
            return;
        }
        catch (e) {
            try {
                this.keyPair = utxo_lib_1.ECPair.fromPublicKey(Buffer.from(utils_1.default.cb58Decode(pub)));
                return;
            }
            catch (e) {
                throw new Error('Unsupported public key');
            }
        }
    }
    /**
     * Default keys format is a pair of Uint8Array keys
     *
     * @returns { DefaultKeys } The keys in the defined format
     */
    getKeys() {
        var _a;
        return {
            pub: this.getPublicKey({ compressed: true }).toString('hex'),
            prv: (_a = this.getPrivateKey()) === null || _a === void 0 ? void 0 : _a.toString('hex'),
        };
    }
    /**
     * Get an Avalanche P-Chain public mainnet address
     *
     * @param {string} format - avalanche hrp - select Mainnet(avax) or Testnet(fuji) for the address
     * @returns {string} The mainnet address derived from the public key
     */
    getAddress(format = 'mainnet') {
        return this.getAvaxPAddress(addressFormat[format]);
    }
    /**
     * Get a public address of public key.
     *
     * @param {string} hrp - select Mainnet(avax) or Testnet(fuji) for the address
     * @returns {string} The address derived from the public key and hrp
     */
    getAvaxPAddress(hrp) {
        const addressBuffer = avalanche_1.Buffer.from(this.getAddressBuffer());
        return utils_1.default.addressToString(hrp, 'P', addressBuffer);
    }
    /**
     * Get an Avalanche P-Chain public mainnet address
     *
     * @returns {Buffer} The address buffer derived from the public key
     */
    getAddressBuffer() {
        const publicKey = avalanche_1.Buffer.from(this.keyPair.publicKey);
        try {
            return Buffer.from(common_1.SECP256k1KeyPair.addressFromPublicKey(publicKey));
        }
        catch (error) {
            return this.getAddressSafeBuffer();
        }
    }
    /**
     * Use the safe Buffer instead of the regular buffer to derive the address buffer. Used in the OVC.
     *
     * @returns {Buffer}
     */
    getAddressSafeBuffer() {
        const publicKeySafe = safe_buffer_1.Buffer.from(this.keyPair.publicKey);
        const sha256 = safe_buffer_1.Buffer.from(create_hash_1.default('sha256').update(publicKeySafe).digest());
        return Buffer.from(create_hash_1.default('ripemd160').update(sha256).digest());
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw4Q0FTeUI7QUFDekIsOERBQXFDO0FBQ3JDLDZDQUFtRDtBQUNuRCx5Q0FBaUQ7QUFDakQsa0RBQXlEO0FBQ3pELDhDQUFnRDtBQUNoRCxtQ0FBcUM7QUFDckMsb0RBQTRCO0FBRTVCLE1BQU0sdUJBQXVCLEdBQUcsRUFBRSxDQUFDO0FBQ25DLElBQVksYUFHWDtBQUhELFdBQVksYUFBYTtJQUN2QixpQ0FBZ0IsQ0FBQTtJQUNoQixpQ0FBZ0IsQ0FBQTtBQUNsQixDQUFDLEVBSFcsYUFBYSxHQUFiLHFCQUFhLEtBQWIscUJBQWEsUUFHeEI7QUFFRCxNQUFhLE9BQVEsU0FBUSxtQ0FBd0I7SUFDbkQ7Ozs7T0FJRztJQUNILFlBQVksTUFBdUI7UUFDakMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sSUFBSSxHQUFHLG9CQUFXLENBQUMsdUJBQXVCLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BDO2FBQU0sSUFBSSxpQkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxNQUFNLEdBQUcsZ0JBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzNDO2FBQU0sSUFBSSx1QkFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0M7YUFBTSxJQUFJLHNCQUFXLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDOUIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztT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QztJQUN4RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILGdCQUFnQjtRQUNkLE1BQU0sU0FBUyxHQUFHLGtCQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDMUQsSUFBSTtZQUNGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyx5QkFBZ0IsQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBQ3RFO1FBQUMsT0FBTyxLQUFLLEVBQUU7WUFDZCxPQUFPLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxvQkFBb0I7UUFDbEIsTUFBTSxhQUFhLEdBQUcsb0JBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM5RCxNQUFNLE1BQU0sR0FBRyxvQkFBVSxDQUFDLElBQUksQ0FBQyxxQkFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQ3BGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxxQkFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7Q0FDRjtBQTdIRCwwQkE2SEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEZWZhdWx0S2V5cyxcbiAgaXNQcml2YXRlS2V5LFxuICBpc1B1YmxpY0tleSxcbiAgaXNTZWVkLFxuICBpc1ZhbGlkWHBydixcbiAgaXNWYWxpZFhwdWIsXG4gIEtleVBhaXJPcHRpb25zLFxuICBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgY3JlYXRlSGFzaCBmcm9tICdjcmVhdGUtaGFzaCc7XG5pbXBvcnQgeyBCdWZmZXIgYXMgU2FmZUJ1ZmZlciB9IGZyb20gJ3NhZmUtYnVmZmVyJztcbmltcG9ydCB7IEJ1ZmZlciBhcyBCdWZmZXJBdmF4IH0gZnJvbSAnYXZhbGFuY2hlJztcbmltcG9ydCB7IFNFQ1AyNTZrMUtleVBhaXIgfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9jb21tb24nO1xuaW1wb3J0IHsgYmlwMzIsIEVDUGFpciB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IERFRkFVTFRfU0VFRF9TSVpFX0JZVEVTID0gMTY7XG5leHBvcnQgZW51bSBhZGRyZXNzRm9ybWF0IHtcbiAgdGVzdG5ldCA9ICdmdWppJyxcbiAgbWFpbm5ldCA9ICdhdmF4Jyxcbn1cblxuZXhwb3J0IGNsYXNzIEtleVBhaXIgZXh0ZW5kcyBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIge1xuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLiBCeSBkZWZhdWx0LCBjcmVhdGVzIGEga2V5IHBhaXIgd2l0aCBhIHJhbmRvbSBtYXN0ZXIgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHsgS2V5UGFpck9wdGlvbnMgfSBzb3VyY2UgRWl0aGVyIGEgbWFzdGVyIHNlZWQsIGEgcHJpdmF0ZSBrZXksIG9yIGEgcHVibGljIGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICBjb25zdCBzZWVkID0gcmFuZG9tQnl0ZXMoREVGQVVMVF9TRUVEX1NJWkVfQllURVMpO1xuICAgICAgdGhpcy5oZE5vZGUgPSBiaXAzMi5mcm9tU2VlZChzZWVkKTtcbiAgICB9IGVsc2UgaWYgKGlzU2VlZChzb3VyY2UpKSB7XG4gICAgICB0aGlzLmhkTm9kZSA9IGJpcDMyLmZyb21TZWVkKHNvdXJjZS5zZWVkKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpdmF0ZUtleShzb3VyY2UpKSB7XG4gICAgICB0aGlzLnJlY29yZEtleXNGcm9tUHJpdmF0ZUtleShzb3VyY2UucHJ2KTtcbiAgICB9IGVsc2UgaWYgKGlzUHVibGljS2V5KHNvdXJjZSkpIHtcbiAgICAgIHRoaXMucmVjb3JkS2V5c0Zyb21QdWJsaWNLZXkoc291cmNlLnB1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgcGFpciBvcHRpb25zJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGROb2RlKSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSBTZWNwMjU2azFFeHRlbmRlZEtleVBhaXIudG9LZXlQYWlyKHRoaXMuaGROb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYSBrZXlwYWlyIGZyb20gYSBwcm90b2NvbCBwcml2YXRlIGtleSBvciBleHRlbmRlZCBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBydiBBIHJhdyBwcml2YXRlIGtleVxuICAgKi9cbiAgcmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5KHBydjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHBydi5zdGFydHNXaXRoKCdQcml2YXRlS2V5LScpKSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSBFQ1BhaXIuZnJvbVByaXZhdGVLZXkoQnVmZmVyLmZyb20odXRpbHMuY2I1OERlY29kZShwcnYuc3BsaXQoJy0nKVsxXSkpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF1dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIGlmIChpc1ZhbGlkWHBydihwcnYpKSB7XG4gICAgICB0aGlzLmhkTm9kZSA9IGJpcDMyLmZyb21CYXNlNTgocHJ2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXlQYWlyID0gRUNQYWlyLmZyb21Qcml2YXRlS2V5KEJ1ZmZlci5mcm9tKHBydi5zbGljZSgwLCA2NCksICdoZXgnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGFuIEVDUGFpciBmcm9tIGEgcHJvdG9jb2wgcHVibGljIGtleSBvciBleHRlbmRlZCBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHViIEEgcmF3IHB1YmxpYyBrZXlcbiAgICovXG4gIHJlY29yZEtleXNGcm9tUHVibGljS2V5KHB1Yjogc3RyaW5nKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc1ZhbGlkWHB1YihwdWIpKSB7XG4gICAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChwdWIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5rZXlQYWlyID0gRUNQYWlyLmZyb21QdWJsaWNLZXkoQnVmZmVyLmZyb20ocHViLCAnaGV4JykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMua2V5UGFpciA9IEVDUGFpci5mcm9tUHVibGljS2V5KEJ1ZmZlci5mcm9tKHV0aWxzLmNiNThEZWNvZGUocHViKSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHVibGljIGtleScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGtleXMgZm9ybWF0IGlzIGEgcGFpciBvZiBVaW50OEFycmF5IGtleXNcbiAgICpcbiAgICogQHJldHVybnMgeyBEZWZhdWx0S2V5cyB9IFRoZSBrZXlzIGluIHRoZSBkZWZpbmVkIGZvcm1hdFxuICAgKi9cbiAgZ2V0S2V5cygpOiBEZWZhdWx0S2V5cyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogdGhpcy5nZXRQdWJsaWNLZXkoeyBjb21wcmVzc2VkOiB0cnVlIH0pLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHBydjogdGhpcy5nZXRQcml2YXRlS2V5KCk/LnRvU3RyaW5nKCdoZXgnKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBBdmFsYW5jaGUgUC1DaGFpbiBwdWJsaWMgbWFpbm5ldCBhZGRyZXNzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSBhdmFsYW5jaGUgaHJwIC0gc2VsZWN0IE1haW5uZXQoYXZheCkgb3IgVGVzdG5ldChmdWppKSBmb3IgdGhlIGFkZHJlc3NcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG1haW5uZXQgYWRkcmVzcyBkZXJpdmVkIGZyb20gdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIGdldEFkZHJlc3MoZm9ybWF0ID0gJ21haW5uZXQnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdmF4UEFkZHJlc3MoYWRkcmVzc0Zvcm1hdFtmb3JtYXRdKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcHVibGljIGFkZHJlc3Mgb2YgcHVibGljIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhycCAtIHNlbGVjdCBNYWlubmV0KGF2YXgpIG9yIFRlc3RuZXQoZnVqaSkgZm9yIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhZGRyZXNzIGRlcml2ZWQgZnJvbSB0aGUgcHVibGljIGtleSBhbmQgaHJwXG4gICAqL1xuICBnZXRBdmF4UEFkZHJlc3MoaHJwOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGFkZHJlc3NCdWZmZXI6IEJ1ZmZlckF2YXggPSBCdWZmZXJBdmF4LmZyb20odGhpcy5nZXRBZGRyZXNzQnVmZmVyKCkpO1xuICAgIHJldHVybiB1dGlscy5hZGRyZXNzVG9TdHJpbmcoaHJwLCAnUCcsIGFkZHJlc3NCdWZmZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBBdmFsYW5jaGUgUC1DaGFpbiBwdWJsaWMgbWFpbm5ldCBhZGRyZXNzXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IFRoZSBhZGRyZXNzIGJ1ZmZlciBkZXJpdmVkIGZyb20gdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIGdldEFkZHJlc3NCdWZmZXIoKTogQnVmZmVyIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBCdWZmZXJBdmF4LmZyb20odGhpcy5rZXlQYWlyLnB1YmxpY0tleSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShTRUNQMjU2azFLZXlQYWlyLmFkZHJlc3NGcm9tUHVibGljS2V5KHB1YmxpY0tleSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBZGRyZXNzU2FmZUJ1ZmZlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhlIHNhZmUgQnVmZmVyIGluc3RlYWQgb2YgdGhlIHJlZ3VsYXIgYnVmZmVyIHRvIGRlcml2ZSB0aGUgYWRkcmVzcyBidWZmZXIuIFVzZWQgaW4gdGhlIE9WQy5cbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICovXG4gIGdldEFkZHJlc3NTYWZlQnVmZmVyKCk6IEJ1ZmZlciB7XG4gICAgY29uc3QgcHVibGljS2V5U2FmZSA9IFNhZmVCdWZmZXIuZnJvbSh0aGlzLmtleVBhaXIucHVibGljS2V5KTtcbiAgICBjb25zdCBzaGEyNTYgPSBTYWZlQnVmZmVyLmZyb20oY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKHB1YmxpY0tleVNhZmUpLmRpZ2VzdCgpKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oY3JlYXRlSGFzaCgncmlwZW1kMTYwJykudXBkYXRlKHNoYTI1NikuZGlnZXN0KCkpO1xuICB9XG59XG4iXX0=