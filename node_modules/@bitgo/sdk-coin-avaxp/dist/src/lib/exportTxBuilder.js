"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExportTxBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const atomicTransactionBuilder_1 = require("./atomicTransactionBuilder");
const platformvm_1 = require("avalanche/dist/apis/platformvm");
const avalanche_1 = require("avalanche");
const utils_1 = __importDefault(require("./utils"));
const utxoEngine_1 = require("./utxoEngine");
class ExportTxBuilder extends atomicTransactionBuilder_1.AtomicTransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
        this._externalChainId = utils_1.default.cb58Decode(this.transaction._network.cChainBlockchainID);
    }
    get transactionType() {
        return sdk_core_1.TransactionType.Export;
    }
    /**
     * Amount is a long that specifies the quantity of the asset that this output owns. Must be positive.
     *
     * @param {BN | string} amount The withdrawal amount
     */
    amount(value) {
        const valueBN = avalanche_1.BN.isBN(value) ? value : new avalanche_1.BN(value);
        this.validateAmount(valueBN);
        this._amount = valueBN;
        return this;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        const baseTx = tx.getUnsignedTx().getTransaction();
        if (!this.verifyTxType(baseTx)) {
            throw new sdk_core_1.NotSupported('Transaction cannot be parsed or has an unsupported transaction type');
        }
        // The ExportOutputs is a {@link exportedOutputs} result.
        // It's expected to have only one outputs with the addresses of the sender.
        const outputs = baseTx.getExportOutputs();
        if (outputs.length != 1) {
            throw new sdk_core_1.BuildTransactionError('Transaction can have one external output');
        }
        const output = outputs[0];
        if (!output.getAssetID().equals(this.transaction._assetId)) {
            throw new Error('The Asset ID of the output does not match the transaction');
        }
        const secpOut = output.getOutput();
        this.transaction._locktime = secpOut.getLocktime();
        this.transaction._threshold = secpOut.getThreshold();
        // output addresses are the sender addresses
        this.transaction._fromAddresses = secpOut.getAddresses();
        this._externalChainId = baseTx.getDestinationChain();
        this._amount = secpOut.getAmount();
        this.transaction._utxos = utxoEngine_1.recoverUtxos(baseTx.getIns());
        return this;
    }
    static verifyTxType(baseTx) {
        return baseTx.getTypeID() === platformvm_1.PlatformVMConstants.EXPORTTX;
    }
    verifyTxType(baseTx) {
        return ExportTxBuilder.verifyTxType(baseTx);
    }
    /**
     * Create the internal avalanche transaction.
     * @protected
     */
    buildAvaxTransaction() {
        // if tx has credentials, tx shouldn't change
        if (this.transaction.hasCredentials)
            return;
        const { inputs, outputs, credentials } = this.createInputOutput(this._amount.add(new avalanche_1.BN(this.transaction.fee.fee)));
        this.transaction.setTransaction(new platformvm_1.Tx(new platformvm_1.UnsignedTx(new platformvm_1.ExportTx(this.transaction._networkID, this.transaction._blockchainID, outputs, inputs, this.transaction._memo, this._externalChainId, this.exportedOutputs())), credentials));
    }
    /**
     * Create the ExportedOut where the recipient address are the sender.
     * Later a importTx should complete the operations signing with the same keys.
     * @protected
     */
    exportedOutputs() {
        return [
            new platformvm_1.TransferableOutput(this.transaction._assetId, new platformvm_1.SECPTransferOutput(this._amount, this.transaction._fromAddresses, this.transaction._locktime, this.transaction._threshold)),
        ];
    }
}
exports.ExportTxBuilder = ExportTxBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwb3J0VHhCdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9leHBvcnRUeEJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsOENBQXVGO0FBQ3ZGLHlFQUFzRTtBQUN0RSwrREFPd0M7QUFDeEMseUNBQStCO0FBRS9CLG9EQUE0QjtBQUM1Qiw2Q0FBNEM7QUFHNUMsTUFBYSxlQUFnQixTQUFRLG1EQUF3QjtJQUczRCxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsZUFBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7SUFFRCxJQUFjLGVBQWU7UUFDM0IsT0FBTywwQkFBZSxDQUFDLE1BQU0sQ0FBQztJQUNoQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILE1BQU0sQ0FBQyxLQUFrQjtRQUN2QixNQUFNLE9BQU8sR0FBRyxjQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksY0FBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7UUFDdkIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFdBQVcsQ0FBQyxFQUFNO1FBQ2hCLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEIsTUFBTSxNQUFNLEdBQVcsRUFBRSxDQUFDLGFBQWEsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQzNELElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lB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O0lBQ0osQ0FBQztDQUNGO0FBeEdELDBDQXdHQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIE5vdFN1cHBvcnRlZCwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEF0b21pY1RyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4vYXRvbWljVHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7XG4gIEV4cG9ydFR4LFxuICBQbGF0Zm9ybVZNQ29uc3RhbnRzLFxuICBTRUNQVHJhbnNmZXJPdXRwdXQsXG4gIFRyYW5zZmVyYWJsZU91dHB1dCxcbiAgVHggYXMgUFZNVHgsXG4gIFVuc2lnbmVkVHgsXG59IGZyb20gJ2F2YWxhbmNoZS9kaXN0L2FwaXMvcGxhdGZvcm12bSc7XG5pbXBvcnQgeyBCTiB9IGZyb20gJ2F2YWxhbmNoZSc7XG5pbXBvcnQgeyBBbW91bnRPdXRwdXQgfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9hcGlzL2V2bS9vdXRwdXRzJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IHJlY292ZXJVdHhvcyB9IGZyb20gJy4vdXR4b0VuZ2luZSc7XG5pbXBvcnQgeyBUeCwgQmFzZVR4IH0gZnJvbSAnLi9pZmFjZSc7XG5cbmV4cG9ydCBjbGFzcyBFeHBvcnRUeEJ1aWxkZXIgZXh0ZW5kcyBBdG9taWNUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBwcml2YXRlIF9hbW91bnQ6IEJOO1xuXG4gIGNvbnN0cnVjdG9yKF9jb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKF9jb2luQ29uZmlnKTtcbiAgICB0aGlzLl9leHRlcm5hbENoYWluSWQgPSB1dGlscy5jYjU4RGVjb2RlKHRoaXMudHJhbnNhY3Rpb24uX25ldHdvcmsuY0NoYWluQmxvY2tjaGFpbklEKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgdHJhbnNhY3Rpb25UeXBlKCk6IFRyYW5zYWN0aW9uVHlwZSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5FeHBvcnQ7XG4gIH1cblxuICAvKipcbiAgICogQW1vdW50IGlzIGEgbG9uZyB0aGF0IHNwZWNpZmllcyB0aGUgcXVhbnRpdHkgb2YgdGhlIGFzc2V0IHRoYXQgdGhpcyBvdXRwdXQgb3ducy4gTXVzdCBiZSBwb3NpdGl2ZS5cbiAgICpcbiAgICogQHBhcmFtIHtCTiB8IHN0cmluZ30gYW1vdW50IFRoZSB3aXRoZHJhd2FsIGFtb3VudFxuICAgKi9cbiAgYW1vdW50KHZhbHVlOiBCTiB8IHN0cmluZyk6IHRoaXMge1xuICAgIGNvbnN0IHZhbHVlQk4gPSBCTi5pc0JOKHZhbHVlKSA/IHZhbHVlIDogbmV3IEJOKHZhbHVlKTtcbiAgICB0aGlzLnZhbGlkYXRlQW1vdW50KHZhbHVlQk4pO1xuICAgIHRoaXMuX2Ftb3VudCA9IHZhbHVlQk47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaW5pdEJ1aWxkZXIodHg6IFR4KTogdGhpcyB7XG4gICAgc3VwZXIuaW5pdEJ1aWxkZXIodHgpO1xuICAgIGNvbnN0IGJhc2VUeDogQmFzZVR4ID0gdHguZ2V0VW5zaWduZWRUeCgpLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKCF0aGlzLnZlcmlmeVR4VHlwZShiYXNlVHgpKSB7XG4gICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkKCdUcmFuc2FjdGlvbiBjYW5ub3QgYmUgcGFyc2VkIG9yIGhhcyBhbiB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlJyk7XG4gICAgfVxuICAgIC8vIFRoZSBFeHBvcnRPdXRwdXRzIGlzIGEge0BsaW5rIGV4cG9ydGVkT3V0cHV0c30gcmVzdWx0LlxuICAgIC8vIEl0J3MgZXhwZWN0ZWQgdG8gaGF2ZSBvbmx5IG9uZSBvdXRwdXRzIHdpdGggdGhlIGFkZHJlc3NlcyBvZiB0aGUgc2VuZGVyLlxuICAgIGNvbnN0IG91dHB1dHMgPSBiYXNlVHguZ2V0RXhwb3J0T3V0cHV0cygpO1xuICAgIGlmIChvdXRwdXRzLmxlbmd0aCAhPSAxKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBjYW4gaGF2ZSBvbmUgZXh0ZXJuYWwgb3V0cHV0Jyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dHNbMF07XG4gICAgaWYgKCFvdXRwdXQuZ2V0QXNzZXRJRCgpLmVxdWFscyh0aGlzLnRyYW5zYWN0aW9uLl9hc3NldElkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQXNzZXQgSUQgb2YgdGhlIG91dHB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3Qgc2VjcE91dCA9IG91dHB1dC5nZXRPdXRwdXQoKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLl9sb2NrdGltZSA9IHNlY3BPdXQuZ2V0TG9ja3RpbWUoKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLl90aHJlc2hvbGQgPSBzZWNwT3V0LmdldFRocmVzaG9sZCgpO1xuICAgIC8vIG91dHB1dCBhZGRyZXNzZXMgYXJlIHRoZSBzZW5kZXIgYWRkcmVzc2VzXG4gICAgdGhpcy50cmFuc2FjdGlvbi5fZnJvbUFkZHJlc3NlcyA9IHNlY3BPdXQuZ2V0QWRkcmVzc2VzKCk7XG4gICAgdGhpcy5fZXh0ZXJuYWxDaGFpbklkID0gYmFzZVR4LmdldERlc3RpbmF0aW9uQ2hhaW4oKTtcbiAgICB0aGlzLl9hbW91bnQgPSAoc2VjcE91dCBhcyBBbW91bnRPdXRwdXQpLmdldEFtb3VudCgpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24uX3V0eG9zID0gcmVjb3ZlclV0eG9zKGJhc2VUeC5nZXRJbnMoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdGF0aWMgdmVyaWZ5VHhUeXBlKGJhc2VUeDogQmFzZVR4KTogYmFzZVR4IGlzIEV4cG9ydFR4IHtcbiAgICByZXR1cm4gYmFzZVR4LmdldFR5cGVJRCgpID09PSBQbGF0Zm9ybVZNQ29uc3RhbnRzLkVYUE9SVFRYO1xuICB9XG5cbiAgdmVyaWZ5VHhUeXBlKGJhc2VUeDogQmFzZVR4KTogYmFzZVR4IGlzIEV4cG9ydFR4IHtcbiAgICByZXR1cm4gRXhwb3J0VHhCdWlsZGVyLnZlcmlmeVR4VHlwZShiYXNlVHgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgaW50ZXJuYWwgYXZhbGFuY2hlIHRyYW5zYWN0aW9uLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRBdmF4VHJhbnNhY3Rpb24oKTogdm9pZCB7XG4gICAgLy8gaWYgdHggaGFzIGNyZWRlbnRpYWxzLCB0eCBzaG91bGRuJ3QgY2hhbmdlXG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaGFzQ3JlZGVudGlhbHMpIHJldHVybjtcbiAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgY3JlZGVudGlhbHMgfSA9IHRoaXMuY3JlYXRlSW5wdXRPdXRwdXQodGhpcy5fYW1vdW50LmFkZChuZXcgQk4odGhpcy50cmFuc2FjdGlvbi5mZWUuZmVlKSkpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24uc2V0VHJhbnNhY3Rpb24oXG4gICAgICBuZXcgUFZNVHgoXG4gICAgICAgIG5ldyBVbnNpZ25lZFR4KFxuICAgICAgICAgIG5ldyBFeHBvcnRUeChcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uX25ldHdvcmtJRCxcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uX2Jsb2NrY2hhaW5JRCxcbiAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICBpbnB1dHMsXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLl9tZW1vLFxuICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxDaGFpbklkLFxuICAgICAgICAgICAgdGhpcy5leHBvcnRlZE91dHB1dHMoKVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgY3JlZGVudGlhbHNcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgRXhwb3J0ZWRPdXQgd2hlcmUgdGhlIHJlY2lwaWVudCBhZGRyZXNzIGFyZSB0aGUgc2VuZGVyLlxuICAgKiBMYXRlciBhIGltcG9ydFR4IHNob3VsZCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9ucyBzaWduaW5nIHdpdGggdGhlIHNhbWUga2V5cy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcHJvdGVjdGVkIGV4cG9ydGVkT3V0cHV0cygpOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBUcmFuc2ZlcmFibGVPdXRwdXQoXG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24uX2Fzc2V0SWQsXG4gICAgICAgIG5ldyBTRUNQVHJhbnNmZXJPdXRwdXQoXG4gICAgICAgICAgdGhpcy5fYW1vdW50LFxuICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb24uX2Zyb21BZGRyZXNzZXMsXG4gICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fbG9ja3RpbWUsXG4gICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fdGhyZXNob2xkXG4gICAgICAgIClcbiAgICAgICksXG4gICAgXTtcbiAgfVxufVxuIl19