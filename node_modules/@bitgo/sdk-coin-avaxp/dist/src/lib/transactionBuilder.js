"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const transaction_1 = require("./transaction");
const keyPair_1 = require("./keyPair");
const avalanche_1 = require("avalanche");
const utils_1 = __importDefault(require("./utils"));
const platformvm_1 = require("avalanche/dist/apis/platformvm");
class TransactionBuilder extends sdk_core_1.BaseTransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
        this._signer = [];
        this.recoverSigner = false;
        this._transaction = new transaction_1.Transaction(_coinConfig);
    }
    /**
     * Initialize the transaction builder fields using the decoded transaction data
     *
     * @param {Transaction} tx the transaction data
     * @returns itself
     */
    initBuilder(tx) {
        const baseTx = tx.getUnsignedTx().getTransaction();
        if (baseTx.getNetworkID() !== this._transaction._networkID ||
            !baseTx.getBlockchainID().equals(this._transaction._blockchainID)) {
            throw new Error('Network or blockchain is not equals');
        }
        // EVMBaseTx has not memo.
        if ('getMemo' in baseTx) {
            this._transaction._memo = baseTx.getMemo();
        }
        this._transaction.setTransaction(tx);
        return this;
    }
    /** @inheritdoc */
    fromImplementation(rawTransaction) {
        const tx = new platformvm_1.Tx();
        tx.fromBuffer(avalanche_1.Buffer.from(rawTransaction, 'hex'));
        this.initBuilder(tx);
        return this.transaction;
    }
    /** @inheritdoc */
    async buildImplementation() {
        this.buildAvaxTransaction();
        this.transaction.setTransactionType(this.transactionType);
        if (this.hasSigner) {
            this._signer.forEach((keyPair) => this.transaction.sign(keyPair));
        }
        return this.transaction;
    }
    // region Getters and Setters
    /**
     * When using recovery key must be set here
     * TODO: STLX-17317 recovery key signing
     * @param {boolean} true if it's recovery signer, default true.
     */
    recoverMode(recoverSigner = true) {
        this.recoverSigner = recoverSigner;
        return this;
    }
    /**
     * Threshold is an int that names the number of unique signatures required to spend the output.
     * Must be less than or equal to the length of Addresses.
     * @param {number}
     */
    threshold(value) {
        this.validateThreshold(value);
        this._transaction._threshold = value;
        return this;
    }
    /**
     * Locktime is a long that contains the unix timestamp that this output can be spent after.
     * The unix timestamp is specific to the second.
     * @param value
     */
    locktime(value) {
        this.validateLocktime(new avalanche_1.BN(value));
        this._transaction._locktime = new avalanche_1.BN(value);
        return this;
    }
    /**
     * fromPubKey is a list of unique addresses that correspond to the private keys that can be used to spend this output.
     * @param {string | stirng[]} senderPubKey
     */
    fromPubKey(senderPubKey) {
        const pubKeys = senderPubKey instanceof Array ? senderPubKey : [senderPubKey];
        this._transaction._fromAddresses = pubKeys.map(utils_1.default.parseAddress);
        return this;
    }
    /**
     * List of UTXO required as inputs.
     * A UTXO is a standalone representation of a transaction output.
     *
     * @param {DecodedUtxoObj[]} list of UTXOS
     */
    utxos(value) {
        this.validateUtxos(value);
        this._transaction._utxos = value;
        return this;
    }
    /**
     *
     * @param value Optional Buffer for the memo
     * @returns value Buffer for the memo
     * set using Buffer.from("message")
     */
    memo(value) {
        this._transaction._memo = utils_1.default.stringToBuffer(value);
        return this;
    }
    /**
     * Getter for know if build should sign
     */
    get hasSigner() {
        return this._signer !== undefined && this._signer.length > 0;
    }
    /** @inheritdoc */
    get transaction() {
        return this._transaction;
    }
    set transaction(transaction) {
        this._transaction = transaction;
    }
    /** @inheritdoc */
    signImplementation({ key }) {
        this._signer.push(new keyPair_1.KeyPair({ prv: key }));
        return this.transaction;
    }
    // endregion
    // region Validators
    /**
     * Validates the threshold
     * @param threshold
     */
    validateThreshold(threshold) {
        if (!threshold || threshold !== 2) {
            throw new sdk_core_1.BuildTransactionError('Invalid transaction: threshold must be set to 2');
        }
    }
    /**
     * Validates locktime
     * @param locktime
     */
    validateLocktime(locktime) {
        if (!locktime || locktime.lt(new avalanche_1.BN(0))) {
            throw new sdk_core_1.BuildTransactionError('Invalid transaction: locktime must be 0 or higher');
        }
    }
    /** @inheritdoc */
    validateAddress(address, addressFormat) {
        if (!utils_1.default.isValidAddress(address.address)) {
            throw new sdk_core_1.BuildTransactionError('Invalid address');
        }
    }
    /** @inheritdoc */
    validateKey({ key }) {
        if (!new keyPair_1.KeyPair({ prv: key })) {
            throw new sdk_core_1.BuildTransactionError('Invalid key');
        }
    }
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     * It overrides abstract method from BaseTransactionBuilder
     *
     * @param rawTransaction Transaction in any format
     */
    validateRawTransaction(rawTransaction) {
        utils_1.default.validateRawTransaction(rawTransaction);
    }
    /** @inheritdoc */
    validateTransaction(transaction) {
        // throw new NotImplementedError('validateTransaction not implemented');
    }
    /** @inheritdoc */
    validateValue(value) {
        if (value.isLessThan(0)) {
            throw new sdk_core_1.BuildTransactionError('Value cannot be less than zero');
        }
    }
    /**
     * Check the list of UTXOS is empty and check each UTXO.
     * @param values
     */
    validateUtxos(values) {
        if (values.length === 0) {
            throw new sdk_core_1.BuildTransactionError("Utxos can't be empty array");
        }
        values.forEach(this.validateUtxo);
    }
    /**
     * Check the UTXO has expected fields.
     * @param UTXO
     */
    validateUtxo(value) {
        ['outputID', 'amount', 'txid', 'outputidx'].forEach((field) => {
            if (!value.hasOwnProperty(field))
                throw new sdk_core_1.BuildTransactionError(`Utxos required ${field}`);
        });
    }
    /**
     * Check the amount is positive.
     * @param amount
     */
    validateAmount(amount) {
        if (amount.lten(0)) {
            throw new sdk_core_1.BuildTransactionError('Amount must be greater than 0');
        }
    }
    /**
     * Check the buffer has 32 byte long.
     * @param chainID
     */
    validateChainId(chainID) {
        if (chainID.length !== 32) {
            throw new sdk_core_1.BuildTransactionError('Chain id are 32 byte size');
        }
    }
}
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi90cmFuc2FjdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUEsOENBT3lCO0FBQ3pCLCtDQUE0QztBQUM1Qyx1Q0FBb0M7QUFDcEMseUNBQXFEO0FBQ3JELG9EQUE0QjtBQUU1QiwrREFBNkQ7QUFFN0QsTUFBc0Isa0JBQW1CLFNBQVEsaUNBQXNCO0lBS3JFLFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBSmQsWUFBTyxHQUFjLEVBQUUsQ0FBQztRQUNyQixrQkFBYSxHQUFHLEtBQUssQ0FBQztRQUk5QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUkseUJBQVcsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxXQUFXLENBQUMsRUFBTTtRQUNoQixNQUFNLE1BQU0sR0FBRyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDbkQsSUFDRSxNQUFNLENBQUMsWUFBWSxFQUFFLEtBQUssSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVO1lBQ3RELENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxFQUNqRTtZQUNBLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLENBQUMsQ0FBQztTQUN4RDtRQUNELDBCQUEwQjtRQUMxQixJQUFJLFNBQVMsSUFBSSxNQUFNLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQzVDO1FBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDckMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQs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RTtZQUN6QixNQUFNLElBQUksZ0NBQXFCLENBQUMsMkJBQTJCLENBQUMsQ0FBQztTQUM5RDtJQUNILENBQUM7Q0FHRjtBQXJQRCxnREFxUEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHtcbiAgQmFzZUFkZHJlc3MsXG4gIEJhc2VLZXksXG4gIEJhc2VUcmFuc2FjdGlvbkJ1aWxkZXIsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgQnVpbGRUcmFuc2FjdGlvbkVycm9yLFxuICBCYXNlVHJhbnNhY3Rpb24sXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQgeyBCTiwgQnVmZmVyIGFzIEJ1ZmZlckF2YXggfSBmcm9tICdhdmFsYW5jaGUnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgRGVjb2RlZFV0eG9PYmosIFR4IH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBUeCBhcyBQVk1UeCB9IGZyb20gJ2F2YWxhbmNoZS9kaXN0L2FwaXMvcGxhdGZvcm12bSc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBUcmFuc2FjdGlvbkJ1aWxkZXIgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJpdmF0ZSBfdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uO1xuICBwdWJsaWMgX3NpZ25lcjogS2V5UGFpcltdID0gW107XG4gIHByb3RlY3RlZCByZWNvdmVyU2lnbmVyID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKF9jb2luQ29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBidWlsZGVyIGZpZWxkcyB1c2luZyB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvbiBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHR4IHRoZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAqIEByZXR1cm5zIGl0c2VsZlxuICAgKi9cbiAgaW5pdEJ1aWxkZXIodHg6IFR4KTogdGhpcyB7XG4gICAgY29uc3QgYmFzZVR4ID0gdHguZ2V0VW5zaWduZWRUeCgpLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKFxuICAgICAgYmFzZVR4LmdldE5ldHdvcmtJRCgpICE9PSB0aGlzLl90cmFuc2FjdGlvbi5fbmV0d29ya0lEIHx8XG4gICAgICAhYmFzZVR4LmdldEJsb2NrY2hhaW5JRCgpLmVxdWFscyh0aGlzLl90cmFuc2FjdGlvbi5fYmxvY2tjaGFpbklEKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZXR3b3JrIG9yIGJsb2NrY2hhaW4gaXMgbm90IGVxdWFscycpO1xuICAgIH1cbiAgICAvLyBFVk1CYXNlVHggaGFzIG5vdCBtZW1vLlxuICAgIGlmICgnZ2V0TWVtbycgaW4gYmFzZVR4KSB7XG4gICAgICB0aGlzLl90cmFuc2FjdGlvbi5fbWVtbyA9IGJhc2VUeC5nZXRNZW1vKCk7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zYWN0aW9uLnNldFRyYW5zYWN0aW9uKHR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgZnJvbUltcGxlbWVudGF0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiBUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgdHggPSBuZXcgUFZNVHgoKTtcbiAgICB0eC5mcm9tQnVmZmVyKEJ1ZmZlckF2YXguZnJvbShyYXdUcmFuc2FjdGlvbiwgJ2hleCcpKTtcbiAgICB0aGlzLmluaXRCdWlsZGVyKHR4KTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgdGhpcy5idWlsZEF2YXhUcmFuc2FjdGlvbigpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24uc2V0VHJhbnNhY3Rpb25UeXBlKHRoaXMudHJhbnNhY3Rpb25UeXBlKTtcbiAgICBpZiAodGhpcy5oYXNTaWduZXIpIHtcbiAgICAgIHRoaXMuX3NpZ25lci5mb3JFYWNoKChrZXlQYWlyKSA9PiB0aGlzLnRyYW5zYWN0aW9uLnNpZ24oa2V5UGFpcikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgdGhlIGF2YXggdHJhbnNhY3Rpb24uIHRyYW5zYWN0aW9uIGZpZWxkIGlzIGNoYW5nZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgYnVpbGRBdmF4VHJhbnNhY3Rpb24oKTogdm9pZDtcblxuICAvLyByZWdpb24gR2V0dGVycyBhbmQgU2V0dGVyc1xuICAvKipcbiAgICogV2hlbiB1c2luZyByZWNvdmVyeSBrZXkgbXVzdCBiZSBzZXQgaGVyZVxuICAgKiBUT0RPOiBTVExYLTE3MzE3IHJlY292ZXJ5IGtleSBzaWduaW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJ1ZSBpZiBpdCdzIHJlY292ZXJ5IHNpZ25lciwgZGVmYXVsdCB0cnVlLlxuICAgKi9cbiAgcHVibGljIHJlY292ZXJNb2RlKHJlY292ZXJTaWduZXIgPSB0cnVlKTogdGhpcyB7XG4gICAgdGhpcy5yZWNvdmVyU2lnbmVyID0gcmVjb3ZlclNpZ25lcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJlc2hvbGQgaXMgYW4gaW50IHRoYXQgbmFtZXMgdGhlIG51bWJlciBvZiB1bmlxdWUgc2lnbmF0dXJlcyByZXF1aXJlZCB0byBzcGVuZCB0aGUgb3V0cHV0LlxuICAgKiBNdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mIEFkZHJlc3Nlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9XG4gICAqL1xuICB0aHJlc2hvbGQodmFsdWU6IG51bWJlcik6IHRoaXMge1xuICAgIHRoaXMudmFsaWRhdGVUaHJlc2hvbGQodmFsdWUpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uLl90aHJlc2hvbGQgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrdGltZSBpcyBhIGxvbmcgdGhhdCBjb250YWlucyB0aGUgdW5peCB0aW1lc3RhbXAgdGhhdCB0aGlzIG91dHB1dCBjYW4gYmUgc3BlbnQgYWZ0ZXIuXG4gICAqIFRoZSB1bml4IHRpbWVzdGFtcCBpcyBzcGVjaWZpYyB0byB0aGUgc2Vjb25kLlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIGxvY2t0aW1lKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiB0aGlzIHtcbiAgICB0aGlzLnZhbGlkYXRlTG9ja3RpbWUobmV3IEJOKHZhbHVlKSk7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24uX2xvY2t0aW1lID0gbmV3IEJOKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBmcm9tUHViS2V5IGlzIGEgbGlzdCBvZiB1bmlxdWUgYWRkcmVzc2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgcHJpdmF0ZSBrZXlzIHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlbmQgdGhpcyBvdXRwdXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3Rpcm5nW119IHNlbmRlclB1YktleVxuICAgKi9cbiAgZnJvbVB1YktleShzZW5kZXJQdWJLZXk6IHN0cmluZyB8IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgY29uc3QgcHViS2V5cyA9IHNlbmRlclB1YktleSBpbnN0YW5jZW9mIEFycmF5ID8gc2VuZGVyUHViS2V5IDogW3NlbmRlclB1YktleV07XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24uX2Zyb21BZGRyZXNzZXMgPSBwdWJLZXlzLm1hcCh1dGlscy5wYXJzZUFkZHJlc3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgVVRYTyByZXF1aXJlZCBhcyBpbnB1dHMuXG4gICAqIEEgVVRYTyBpcyBhIHN0YW5kYWxvbmUgcmVwcmVzZW50YXRpb24gb2YgYSB0cmFuc2FjdGlvbiBvdXRwdXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RGVjb2RlZFV0eG9PYmpbXX0gbGlzdCBvZiBVVFhPU1xuICAgKi9cbiAgdXR4b3ModmFsdWU6IERlY29kZWRVdHhvT2JqW10pOiB0aGlzIHtcbiAgICB0aGlzLnZhbGlkYXRlVXR4b3ModmFsdWUpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uLl91dHhvcyA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgT3B0aW9uYWwgQnVmZmVyIGZvciB0aGUgbWVtb1xuICAgKiBAcmV0dXJucyB2YWx1ZSBCdWZmZXIgZm9yIHRoZSBtZW1vXG4gICAqIHNldCB1c2luZyBCdWZmZXIuZnJvbShcIm1lc3NhZ2VcIilcbiAgICovXG4gIG1lbW8odmFsdWU6IHN0cmluZyk6IHRoaXMge1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uLl9tZW1vID0gdXRpbHMuc3RyaW5nVG9CdWZmZXIodmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3Iga25vdyBpZiBidWlsZCBzaG91bGQgc2lnblxuICAgKi9cbiAgZ2V0IGhhc1NpZ25lcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmVyICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fc2lnbmVyLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvbigpOiBUcmFuc2FjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNldCB0cmFuc2FjdGlvbih0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBzaWduSW1wbGVtZW50YXRpb24oeyBrZXkgfTogQmFzZUtleSk6IEJhc2VUcmFuc2FjdGlvbiB7XG4gICAgdGhpcy5fc2lnbmVyLnB1c2gobmV3IEtleVBhaXIoeyBwcnY6IGtleSB9KSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb247XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0IHRyYW5zYWN0aW9uVHlwZSgpOiBUcmFuc2FjdGlvblR5cGU7XG5cbiAgLy8gZW5kcmVnaW9uXG4gIC8vIHJlZ2lvbiBWYWxpZGF0b3JzXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgdGhyZXNob2xkXG4gICAqIEBwYXJhbSB0aHJlc2hvbGRcbiAgICovXG4gIHZhbGlkYXRlVGhyZXNob2xkKHRocmVzaG9sZDogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCF0aHJlc2hvbGQgfHwgdGhyZXNob2xkICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiB0aHJlc2hvbGQgbXVzdCBiZSBzZXQgdG8gMicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgbG9ja3RpbWVcbiAgICogQHBhcmFtIGxvY2t0aW1lXG4gICAqL1xuICB2YWxpZGF0ZUxvY2t0aW1lKGxvY2t0aW1lOiBCTik6IHZvaWQge1xuICAgIGlmICghbG9ja3RpbWUgfHwgbG9ja3RpbWUubHQobmV3IEJOKDApKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogbG9ja3RpbWUgbXVzdCBiZSAwIG9yIGhpZ2hlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzczogQmFzZUFkZHJlc3MsIGFkZHJlc3NGb3JtYXQ/OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIXV0aWxzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MuYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZUtleSh7IGtleSB9OiBCYXNlS2V5KTogdm9pZCB7XG4gICAgaWYgKCFuZXcgS2V5UGFpcih7IHBydjoga2V5IH0pKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgcmF3IHRyYW5zYWN0aW9uIGhhcyBhIHZhbGlkIGZvcm1hdCBpbiB0aGUgYmxvY2tjaGFpbiBjb250ZXh0LCB0aHJvdyBvdGhlcndpc2UuXG4gICAqIEl0IG92ZXJyaWRlcyBhYnN0cmFjdCBtZXRob2QgZnJvbSBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyXG4gICAqXG4gICAqIEBwYXJhbSByYXdUcmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBpbiBhbnkgZm9ybWF0XG4gICAqL1xuICB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB1dGlscy52YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICAvLyB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigndmFsaWRhdGVUcmFuc2FjdGlvbiBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZVZhbHVlKHZhbHVlOiBCaWdOdW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodmFsdWUuaXNMZXNzVGhhbigwKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVmFsdWUgY2Fubm90IGJlIGxlc3MgdGhhbiB6ZXJvJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBsaXN0IG9mIFVUWE9TIGlzIGVtcHR5IGFuZCBjaGVjayBlYWNoIFVUWE8uXG4gICAqIEBwYXJhbSB2YWx1ZXNcbiAgICovXG4gIHZhbGlkYXRlVXR4b3ModmFsdWVzOiBEZWNvZGVkVXR4b09ialtdKTogdm9pZCB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoXCJVdHhvcyBjYW4ndCBiZSBlbXB0eSBhcnJheVwiKTtcbiAgICB9XG4gICAgdmFsdWVzLmZvckVhY2godGhpcy52YWxpZGF0ZVV0eG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoZSBVVFhPIGhhcyBleHBlY3RlZCBmaWVsZHMuXG4gICAqIEBwYXJhbSBVVFhPXG4gICAqL1xuICB2YWxpZGF0ZVV0eG8odmFsdWU6IERlY29kZWRVdHhvT2JqKTogdm9pZCB7XG4gICAgWydvdXRwdXRJRCcsICdhbW91bnQnLCAndHhpZCcsICdvdXRwdXRpZHgnXS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgaWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoYFV0eG9zIHJlcXVpcmVkICR7ZmllbGR9YCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGFtb3VudCBpcyBwb3NpdGl2ZS5cbiAgICogQHBhcmFtIGFtb3VudFxuICAgKi9cbiAgdmFsaWRhdGVBbW91bnQoYW1vdW50OiBCTik6IHZvaWQge1xuICAgIGlmIChhbW91bnQubHRlbigwKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignQW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGJ1ZmZlciBoYXMgMzIgYnl0ZSBsb25nLlxuICAgKiBAcGFyYW0gY2hhaW5JRFxuICAgKi9cbiAgdmFsaWRhdGVDaGFpbklkKGNoYWluSUQ6IEJ1ZmZlckF2YXgpOiB2b2lkIHtcbiAgICBpZiAoY2hhaW5JRC5sZW5ndGggIT09IDMyKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdDaGFpbiBpZCBhcmUgMzIgYnl0ZSBzaXplJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5kcmVnaW9uXG59XG4iXX0=