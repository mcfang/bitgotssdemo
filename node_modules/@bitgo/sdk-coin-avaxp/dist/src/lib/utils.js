"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const avalanche_1 = require("avalanche");
const utils_1 = require("avalanche/dist/utils");
const elliptic_1 = require("elliptic");
const platformvm_1 = require("avalanche/dist/apis/platformvm");
const keychain_1 = require("avalanche/dist/apis/platformvm/keychain");
const common_1 = require("avalanche/dist/common");
const createHash = __importStar(require("create-hash"));
const iface_1 = require("./iface");
class Utils {
    constructor() {
        this.binTools = avalanche_1.BinTools.getInstance();
        this.cb58Decode = this.binTools.cb58Decode;
        this.cb58Encode = this.binTools.cb58Encode;
        this.stringToBuffer = this.binTools.stringToBuffer;
        this.bufferToString = this.binTools.bufferToString;
        this.NodeIDStringToBuffer = utils_1.NodeIDStringToBuffer;
        this.addressToString = this.binTools.addressToString;
        this.parseAddress = (pub) => this.binTools.stringToAddress(pub);
    }
    includeIn(walletAddresses, otxoOutputAddresses) {
        return walletAddresses.map((a) => otxoOutputAddresses.includes(a)).reduce((a, b) => a && b, true);
    }
    /**
     * Checks if it is a valid address no illegal characters
     *
     * @param {string} address - address to be validated
     * @returns {boolean} - the validation result
     */
    /** @inheritdoc */
    isValidAddress(address) {
        const addressArr = Array.isArray(address) ? address : address.split('~');
        for (const address of addressArr) {
            if (!this.isValidAddressRegex(address)) {
                return false;
            }
        }
        return true;
    }
    isValidAddressRegex(address) {
        return /^(^P||NodeID)-[a-zA-Z0-9]+$/.test(address);
    }
    /**
     * Checks if it is a valid blockId with length 66 including 0x
     *
     * @param {string} hash - blockId to be validated
     * @returns {boolean} - the validation result
     */
    /** @inheritdoc */
    isValidBlockId(hash) {
        return this.binTools.isCB58(hash) && this.binTools.b58ToBuffer(hash).length === 36;
    }
    /**
     * Checks if the string is a valid protocol public key or
     * extended public key.
     *
     * @param {string} pub - the  public key to be validated
     * @returns {boolean} - the validation result
     */
    isValidPublicKey(pub) {
        if (sdk_core_1.isValidXpub(pub))
            return true;
        let pubBuf;
        if (pub.length === 50) {
            try {
                pubBuf = utils.cb58Decode(pub);
            }
            catch {
                return false;
            }
        }
        else {
            if (pub.length !== 66 && pub.length !== 130)
                return false;
            const firstByte = pub.slice(0, 2);
            // uncompressed public key
            if (pub.length === 130 && firstByte !== '04')
                return false;
            // compressed public key
            if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')
                return false;
            if (!this.allHexChars(pub))
                return false;
            pubBuf = avalanche_1.Buffer.from(pub, 'hex');
        }
        // validate the public key
        const secp256k1 = new elliptic_1.ec('secp256k1');
        try {
            const keyPair = secp256k1.keyFromPublic(pubBuf);
            const { result } = keyPair.validate();
            return result;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Returns whether or not the string is a valid protocol private key, or extended
     * private key.
     *
     * The protocol key format is described in the @stacks/transactions npm package, in the
     * createStacksPrivateKey function:
     * https://github.com/blockstack/stacks.js/blob/master/packages/transactions/src/keys.ts#L125
     *
     * @param {string} prv - the private key (or extended private key) to be validated
     * @returns {boolean} - the validation result
     */
    isValidPrivateKey(prv) {
        if (sdk_core_1.isValidXprv(prv))
            return true;
        if (prv.length !== 64 && prv.length !== 66)
            return false;
        if (prv.length === 66 && prv.slice(64) !== '01')
            return false;
        return this.allHexChars(prv);
    }
    /**
     * Returns whether or not the string is a composed of hex chars only
     *
     * @param {string} maybe - the  string to be validated
     * @returns {boolean} - the validation result
     */
    allHexChars(maybe) {
        return /^(0x){0,1}([0-9a-f])+$/i.test(maybe);
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        throw new sdk_core_1.NotImplementedError('isValidSignature not implemented');
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        throw new sdk_core_1.NotImplementedError('isValidTransactionId not implemented');
    }
    getCredentials(tx) {
        return tx.getIns().map((ins) => platformvm_1.SelectCredentialClass(ins.getInput().getCredentialID()));
    }
    /**
     * Avaxp wrapper to create signature and return it for credentials using Avalanche's buffer
     * @param network
     * @param message
     * @param prv
     * @return signature
     */
    createSignatureAvaxBuffer(network, message, prv) {
        const ky = new keychain_1.KeyPair(network.hrp, network.networkID.toString());
        ky.importKey(prv);
        return ky.sign(message);
    }
    /**
     * Avaxp wrapper to create signature and return it for credentials
     * @param network
     * @param message
     * @param prv
     * @return signature
     */
    createSignature(network, message, prv) {
        return Buffer.from(this.createSignatureAvaxBuffer(network, avalanche_1.Buffer.from(message), avalanche_1.Buffer.from(prv)));
    }
    /**
     * Avaxp wrapper to verify signature using Avalanche's buffer
     * @param network
     * @param message
     * @param signature
     * @param prv
     * @return true if it's verify successful
     */
    verifySignatureAvaxBuffer(network, message, signature, prv) {
        const ky = new keychain_1.KeyPair(network.hrp, network.networkID.toString());
        ky.importKey(prv);
        return ky.verify(message, signature);
    }
    /**
     * Avaxp wrapper to verify signature
     * @param network
     * @param message
     * @param signature
     * @param prv
     * @return true if it's verify successful
     */
    verifySignature(network, message, signature, prv) {
        return this.verifySignatureAvaxBuffer(network, avalanche_1.Buffer.from(message), avalanche_1.Buffer.from(signature), avalanche_1.Buffer.from(prv));
    }
    createSig(sigHex) {
        const sig = new common_1.Signature();
        sig.fromBuffer(avalanche_1.Buffer.from(sigHex.padStart(130, '0'), 'hex'));
        return sig;
    }
    /**
     * Avaxp wrapper to recovery signature using Avalanche's buffer
     * @param network
     * @param message
     * @param signature
     * @return
     */
    recoverySignatureAvaxBuffer(network, message, signature) {
        const ky = new keychain_1.KeyPair(network.hrp, network.networkID.toString());
        return ky.recover(message, signature);
    }
    /**
     * Avaxp wrapper to verify signature
     * @param network
     * @param message
     * @param signature
     * @return true if it's verify successful
     */
    recoverySignature(network, message, signature) {
        return Buffer.from(this.recoverySignatureAvaxBuffer(network, avalanche_1.Buffer.from(message), avalanche_1.Buffer.from(signature)));
    }
    sha256(buf) {
        return createHash.default('sha256').update(buf).digest();
    }
    /**
     * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
     * It's to reuse in TransactionBuilder and TransactionBuilderFactory
     *
     * @param rawTransaction Transaction as hex string
     */
    validateRawTransaction(rawTransaction) {
        if (!rawTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Raw transaction is empty');
        }
        if (!utils.allHexChars(rawTransaction)) {
            throw new sdk_core_1.ParseTransactionError('Raw transaction is not hex string');
        }
    }
    /**
     * Check if tx is for the blockchainId
     *
     * @param {Tx} tx
     * @param {string} blockchainId
     * @returns true if tx is for blockchainId
     */
    isTransactionOf(tx, blockchainId) {
        return utils.cb58Encode(tx.getUnsignedTx().getTransaction().getBlockchainID()) === blockchainId;
    }
    /**
     * Check if Output is from PVM.
     * Output could be EVM or PVM output.
     * @param {Output} output
     * @returns {boolean} output is TransferableOutput
     */
    isTransferableOutput(output) {
        return 'getOutput' in output;
    }
    /**
     * Return a mapper function to that network address representation.
     * @param network required to stringify addresses
     * @return mapper function
     */
    mapOutputToEntry(network) {
        return (output) => {
            if (this.isTransferableOutput(output)) {
                const amountOutput = output.getOutput();
                const address = amountOutput
                    .getAddresses()
                    .map((a) => this.addressToString(network.hrp, network.alias, a))
                    .sort()
                    .join(iface_1.ADDRESS_SEPARATOR);
                return {
                    value: amountOutput.getAmount().toString(),
                    address,
                };
            }
            else {
                const evmOutput = output;
                return {
                    // it should be evmOuput.getAmount(), but it returns a 0.
                    value: new avalanche_1.BN(evmOutput.amount).toString(),
                    // C-Chain address.
                    address: '0x' + evmOutput.getAddressString(),
                };
            }
        };
    }
    /**
     * remove hex prefix (0x)
     * @param hex string
     * @returns hex without 0x
     */
    removeHexPrefix(hex) {
        if (hex.startsWith('0x')) {
            return hex.substring(2);
        }
        return hex;
    }
    /**
     * Outputidx convert from number (as string) to buffer.
     * @param {string} outputidx number
     * @return {BufferAvax} buffer of size 4 with that number value
     */
    outputidxNumberToBuffer(outputidx) {
        return avalanche_1.Buffer.from(Number(outputidx).toString(16).padStart(8, '0'), 'hex');
    }
    /**
     * Outputidx buffer to number (as string)
     * @param {BufferAvax} outputidx
     * @return {string} outputidx number
     */
    outputidxBufferToNumber(outputidx) {
        return parseInt(outputidx.toString('hex'), 16).toString();
    }
}
exports.Utils = Utils;
const utils = new Utils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw4Q0FReUI7QUFDekIseUNBQStEO0FBQy9ELGdEQUE0RDtBQUM1RCx1Q0FBOEI7QUFDOUIsK0RBQWlIO0FBRWpILHNFQUFpRjtBQUVqRixrREFBa0Q7QUFDbEQsd0RBQTBDO0FBRTFDLG1DQUF3RDtBQUV4RCxNQUFhLEtBQUs7SUFBbEI7UUFDVSxhQUFRLEdBQUcsb0JBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNuQyxlQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7UUFDdEMsZUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDO1FBQ3RDLG1CQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUM7UUFDOUMsbUJBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQztRQUM5Qyx5QkFBb0IsR0FBRyw0QkFBb0IsQ0FBQztRQUM1QyxvQkFBZSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDO1FBbUZoRCxpQkFBWSxHQUFHLENBQUMsR0FBVyxFQUFjLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQTJPeEYsQ0FBQztJQTVUUSxTQUFTLENBQUMsZUFBeUIsRUFBRSxtQkFBNkI7UUFDdkUsT0FBTyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3BHLENBQUM7SUFF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O1NBQ3pCO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILHVCQUF1QixDQUFDLFNBQWlCO1FBQ3ZDLE9BQU8sa0JBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsdUJBQXVCLENBQUMsU0FBcUI7UUFDM0MsT0FBTyxRQUFRLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM1RCxDQUFDO0NBQ0Y7QUFyVUQsc0JBcVVDO0FBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztBQUUxQixrQkFBZSxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBpc1ZhbGlkWHB1YixcbiAgaXNWYWxpZFhwcnYsXG4gIE5vdEltcGxlbWVudGVkRXJyb3IsXG4gIEJhc2VVdGlscyxcbiAgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IsXG4gIFBhcnNlVHJhbnNhY3Rpb25FcnJvcixcbiAgRW50cnksXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBCaW5Ub29scywgQk4sIEJ1ZmZlciBhcyBCdWZmZXJBdmF4IH0gZnJvbSAnYXZhbGFuY2hlJztcbmltcG9ydCB7IE5vZGVJRFN0cmluZ1RvQnVmZmVyIH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvdXRpbHMnO1xuaW1wb3J0IHsgZWMgfSBmcm9tICdlbGxpcHRpYyc7XG5pbXBvcnQgeyBBbW91bnRPdXRwdXQsIEJhc2VUeCwgU2VsZWN0Q3JlZGVudGlhbENsYXNzLCBUcmFuc2ZlcmFibGVPdXRwdXQgfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9hcGlzL3BsYXRmb3Jtdm0nO1xuaW1wb3J0IHsgQ3JlZGVudGlhbCB9IGZyb20gJ2F2YWxhbmNoZS9kaXN0L2NvbW1vbi9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBLZXlQYWlyIGFzIEtleVBhaXJBdmF4IH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvYXBpcy9wbGF0Zm9ybXZtL2tleWNoYWluJztcbmltcG9ydCB7IEF2YWxhbmNoZU5ldHdvcmsgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9jb21tb24nO1xuaW1wb3J0ICogYXMgY3JlYXRlSGFzaCBmcm9tICdjcmVhdGUtaGFzaCc7XG5pbXBvcnQgeyBFVk1PdXRwdXQgfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9hcGlzL2V2bSc7XG5pbXBvcnQgeyBBRERSRVNTX1NFUEFSQVRPUiwgT3V0cHV0LCBUeCB9IGZyb20gJy4vaWZhY2UnO1xuXG5leHBvcnQgY2xhc3MgVXRpbHMgaW1wbGVtZW50cyBCYXNlVXRpbHMge1xuICBwcml2YXRlIGJpblRvb2xzID0gQmluVG9vbHMuZ2V0SW5zdGFuY2UoKTtcbiAgcHVibGljIGNiNThEZWNvZGUgPSB0aGlzLmJpblRvb2xzLmNiNThEZWNvZGU7XG4gIHB1YmxpYyBjYjU4RW5jb2RlID0gdGhpcy5iaW5Ub29scy5jYjU4RW5jb2RlO1xuICBwdWJsaWMgc3RyaW5nVG9CdWZmZXIgPSB0aGlzLmJpblRvb2xzLnN0cmluZ1RvQnVmZmVyO1xuICBwdWJsaWMgYnVmZmVyVG9TdHJpbmcgPSB0aGlzLmJpblRvb2xzLmJ1ZmZlclRvU3RyaW5nO1xuICBwdWJsaWMgTm9kZUlEU3RyaW5nVG9CdWZmZXIgPSBOb2RlSURTdHJpbmdUb0J1ZmZlcjtcbiAgcHVibGljIGFkZHJlc3NUb1N0cmluZyA9IHRoaXMuYmluVG9vbHMuYWRkcmVzc1RvU3RyaW5nO1xuXG4gIHB1YmxpYyBpbmNsdWRlSW4od2FsbGV0QWRkcmVzc2VzOiBzdHJpbmdbXSwgb3R4b091dHB1dEFkZHJlc3Nlczogc3RyaW5nW10pOiBib29sZWFuIHtcbiAgICByZXR1cm4gd2FsbGV0QWRkcmVzc2VzLm1hcCgoYSkgPT4gb3R4b091dHB1dEFkZHJlc3Nlcy5pbmNsdWRlcyhhKSkucmVkdWNlKChhLCBiKSA9PiBhICYmIGIsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBpdCBpcyBhIHZhbGlkIGFkZHJlc3Mgbm8gaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gYWRkcmVzcyB0byBiZSB2YWxpZGF0ZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nIHwgc3RyaW5nW10pOiBib29sZWFuIHtcbiAgICBjb25zdCBhZGRyZXNzQXJyOiBzdHJpbmdbXSA9IEFycmF5LmlzQXJyYXkoYWRkcmVzcykgPyBhZGRyZXNzIDogYWRkcmVzcy5zcGxpdCgnficpO1xuXG4gICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFkZHJlc3NBcnIpIHtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzc1JlZ2V4KGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgaXNWYWxpZEFkZHJlc3NSZWdleChhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gL14oXlB8fE5vZGVJRCktW2EtekEtWjAtOV0rJC8udGVzdChhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgaXQgaXMgYSB2YWxpZCBibG9ja0lkIHdpdGggbGVuZ3RoIDY2IGluY2x1ZGluZyAweFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIGJsb2NrSWQgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRCbG9ja0lkKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmJpblRvb2xzLmlzQ0I1OChoYXNoKSAmJiB0aGlzLmJpblRvb2xzLmI1OFRvQnVmZmVyKGhhc2gpLmxlbmd0aCA9PT0gMzY7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBwcm90b2NvbCBwdWJsaWMga2V5IG9yXG4gICAqIGV4dGVuZGVkIHB1YmxpYyBrZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWIgLSB0aGUgIHB1YmxpYyBrZXkgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgaXNWYWxpZFB1YmxpY0tleShwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmIChpc1ZhbGlkWHB1YihwdWIpKSByZXR1cm4gdHJ1ZTtcblxuICAgIGxldCBwdWJCdWY7XG4gICAgaWYgKHB1Yi5sZW5ndGggPT09IDUwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwdWJCdWYgPSB1dGlscy5jYjU4RGVjb2RlKHB1Yik7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHViLmxlbmd0aCAhPT0gNjYgJiYgcHViLmxlbmd0aCAhPT0gMTMwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IHB1Yi5zbGljZSgwLCAyKTtcblxuICAgICAgLy8gdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICAgIGlmIChwdWIubGVuZ3RoID09PSAxMzAgJiYgZmlyc3RCeXRlICE9PSAnMDQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIGNvbXByZXNzZWQgcHVibGljIGtleVxuICAgICAgaWYgKHB1Yi5sZW5ndGggPT09IDY2ICYmIGZpcnN0Qnl0ZSAhPT0gJzAyJyAmJiBmaXJzdEJ5dGUgIT09ICcwMycpIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKCF0aGlzLmFsbEhleENoYXJzKHB1YikpIHJldHVybiBmYWxzZTtcblxuICAgICAgcHViQnVmID0gQnVmZmVyQXZheC5mcm9tKHB1YiwgJ2hleCcpO1xuICAgIH1cbiAgICAvLyB2YWxpZGF0ZSB0aGUgcHVibGljIGtleVxuICAgIGNvbnN0IHNlY3AyNTZrMSA9IG5ldyBlYygnc2VjcDI1NmsxJyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGtleVBhaXIgPSBzZWNwMjU2azEua2V5RnJvbVB1YmxpYyhwdWJCdWYpO1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGtleVBhaXIudmFsaWRhdGUoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBwYXJzZUFkZHJlc3MgPSAocHViOiBzdHJpbmcpOiBCdWZmZXJBdmF4ID0+IHRoaXMuYmluVG9vbHMuc3RyaW5nVG9BZGRyZXNzKHB1Yik7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIHByb3RvY29sIHByaXZhdGUga2V5LCBvciBleHRlbmRlZFxuICAgKiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogVGhlIHByb3RvY29sIGtleSBmb3JtYXQgaXMgZGVzY3JpYmVkIGluIHRoZSBAc3RhY2tzL3RyYW5zYWN0aW9ucyBucG0gcGFja2FnZSwgaW4gdGhlXG4gICAqIGNyZWF0ZVN0YWNrc1ByaXZhdGVLZXkgZnVuY3Rpb246XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibG9ja3N0YWNrL3N0YWNrcy5qcy9ibG9iL21hc3Rlci9wYWNrYWdlcy90cmFuc2FjdGlvbnMvc3JjL2tleXMudHMjTDEyNVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJ2IC0gdGhlIHByaXZhdGUga2V5IChvciBleHRlbmRlZCBwcml2YXRlIGtleSkgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgaXNWYWxpZFByaXZhdGVLZXkocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoaXNWYWxpZFhwcnYocHJ2KSkgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAocHJ2Lmxlbmd0aCAhPT0gNjQgJiYgcHJ2Lmxlbmd0aCAhPT0gNjYpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChwcnYubGVuZ3RoID09PSA2NiAmJiBwcnYuc2xpY2UoNjQpICE9PSAnMDEnKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5hbGxIZXhDaGFycyhwcnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIGNvbXBvc2VkIG9mIGhleCBjaGFycyBvbmx5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXliZSAtIHRoZSAgc3RyaW5nIHRvIGJlIHZhbGlkYXRlZFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAgICovXG4gIGFsbEhleENoYXJzKG1heWJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gL14oMHgpezAsMX0oWzAtOWEtZl0pKyQvaS50ZXN0KG1heWJlKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkU2lnbmF0dXJlKHNpZ25hdHVyZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2lzVmFsaWRTaWduYXR1cmUgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFRyYW5zYWN0aW9uSWQodHhJZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2lzVmFsaWRUcmFuc2FjdGlvbklkIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgZ2V0Q3JlZGVudGlhbHModHg6IEJhc2VUeCk6IENyZWRlbnRpYWxbXSB7XG4gICAgcmV0dXJuIHR4LmdldElucygpLm1hcCgoaW5zKSA9PiBTZWxlY3RDcmVkZW50aWFsQ2xhc3MoaW5zLmdldElucHV0KCkuZ2V0Q3JlZGVudGlhbElEKCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdmF4cCB3cmFwcGVyIHRvIGNyZWF0ZSBzaWduYXR1cmUgYW5kIHJldHVybiBpdCBmb3IgY3JlZGVudGlhbHMgdXNpbmcgQXZhbGFuY2hlJ3MgYnVmZmVyXG4gICAqIEBwYXJhbSBuZXR3b3JrXG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqIEBwYXJhbSBwcnZcbiAgICogQHJldHVybiBzaWduYXR1cmVcbiAgICovXG4gIGNyZWF0ZVNpZ25hdHVyZUF2YXhCdWZmZXIobmV0d29yazogQXZhbGFuY2hlTmV0d29yaywgbWVzc2FnZTogQnVmZmVyQXZheCwgcHJ2OiBCdWZmZXJBdmF4KTogQnVmZmVyQXZheCB7XG4gICAgY29uc3Qga3kgPSBuZXcgS2V5UGFpckF2YXgobmV0d29yay5ocnAsIG5ldHdvcmsubmV0d29ya0lELnRvU3RyaW5nKCkpO1xuICAgIGt5LmltcG9ydEtleShwcnYpO1xuICAgIHJldHVybiBreS5zaWduKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF2YXhwIHdyYXBwZXIgdG8gY3JlYXRlIHNpZ25hdHVyZSBhbmQgcmV0dXJuIGl0IGZvciBjcmVkZW50aWFsc1xuICAgKiBAcGFyYW0gbmV0d29ya1xuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKiBAcGFyYW0gcHJ2XG4gICAqIEByZXR1cm4gc2lnbmF0dXJlXG4gICAqL1xuICBjcmVhdGVTaWduYXR1cmUobmV0d29yazogQXZhbGFuY2hlTmV0d29yaywgbWVzc2FnZTogQnVmZmVyLCBwcnY6IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuY3JlYXRlU2lnbmF0dXJlQXZheEJ1ZmZlcihuZXR3b3JrLCBCdWZmZXJBdmF4LmZyb20obWVzc2FnZSksIEJ1ZmZlckF2YXguZnJvbShwcnYpKSk7XG4gIH1cblxuICAvKipcbiAgICogQXZheHAgd3JhcHBlciB0byB2ZXJpZnkgc2lnbmF0dXJlIHVzaW5nIEF2YWxhbmNoZSdzIGJ1ZmZlclxuICAgKiBAcGFyYW0gbmV0d29ya1xuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlXG4gICAqIEBwYXJhbSBwcnZcbiAgICogQHJldHVybiB0cnVlIGlmIGl0J3MgdmVyaWZ5IHN1Y2Nlc3NmdWxcbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZUF2YXhCdWZmZXIoXG4gICAgbmV0d29yazogQXZhbGFuY2hlTmV0d29yayxcbiAgICBtZXNzYWdlOiBCdWZmZXJBdmF4LFxuICAgIHNpZ25hdHVyZTogQnVmZmVyQXZheCxcbiAgICBwcnY6IEJ1ZmZlckF2YXhcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3Qga3kgPSBuZXcgS2V5UGFpckF2YXgobmV0d29yay5ocnAsIG5ldHdvcmsubmV0d29ya0lELnRvU3RyaW5nKCkpO1xuICAgIGt5LmltcG9ydEtleShwcnYpO1xuICAgIHJldHVybiBreS52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdmF4cCB3cmFwcGVyIHRvIHZlcmlmeSBzaWduYXR1cmVcbiAgICogQHBhcmFtIG5ldHdvcmtcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICogQHBhcmFtIHNpZ25hdHVyZVxuICAgKiBAcGFyYW0gcHJ2XG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBpdCdzIHZlcmlmeSBzdWNjZXNzZnVsXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmUobmV0d29yazogQXZhbGFuY2hlTmV0d29yaywgbWVzc2FnZTogQnVmZmVyLCBzaWduYXR1cmU6IEJ1ZmZlciwgcHJ2OiBCdWZmZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52ZXJpZnlTaWduYXR1cmVBdmF4QnVmZmVyKFxuICAgICAgbmV0d29yayxcbiAgICAgIEJ1ZmZlckF2YXguZnJvbShtZXNzYWdlKSxcbiAgICAgIEJ1ZmZlckF2YXguZnJvbShzaWduYXR1cmUpLFxuICAgICAgQnVmZmVyQXZheC5mcm9tKHBydilcbiAgICApO1xuICB9XG5cbiAgY3JlYXRlU2lnKHNpZ0hleDogc3RyaW5nKTogU2lnbmF0dXJlIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgU2lnbmF0dXJlKCk7XG4gICAgc2lnLmZyb21CdWZmZXIoQnVmZmVyQXZheC5mcm9tKHNpZ0hleC5wYWRTdGFydCgxMzAsICcwJyksICdoZXgnKSk7XG4gICAgcmV0dXJuIHNpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBBdmF4cCB3cmFwcGVyIHRvIHJlY292ZXJ5IHNpZ25hdHVyZSB1c2luZyBBdmFsYW5jaGUncyBidWZmZXJcbiAgICogQHBhcmFtIG5ldHdvcmtcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICogQHBhcmFtIHNpZ25hdHVyZVxuICAgKiBAcmV0dXJuXG4gICAqL1xuICByZWNvdmVyeVNpZ25hdHVyZUF2YXhCdWZmZXIobmV0d29yazogQXZhbGFuY2hlTmV0d29yaywgbWVzc2FnZTogQnVmZmVyQXZheCwgc2lnbmF0dXJlOiBCdWZmZXJBdmF4KTogQnVmZmVyQXZheCB7XG4gICAgY29uc3Qga3kgPSBuZXcgS2V5UGFpckF2YXgobmV0d29yay5ocnAsIG5ldHdvcmsubmV0d29ya0lELnRvU3RyaW5nKCkpO1xuICAgIHJldHVybiBreS5yZWNvdmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQXZheHAgd3JhcHBlciB0byB2ZXJpZnkgc2lnbmF0dXJlXG4gICAqIEBwYXJhbSBuZXR3b3JrXG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqIEBwYXJhbSBzaWduYXR1cmVcbiAgICogQHJldHVybiB0cnVlIGlmIGl0J3MgdmVyaWZ5IHN1Y2Nlc3NmdWxcbiAgICovXG4gIHJlY292ZXJ5U2lnbmF0dXJlKG5ldHdvcms6IEF2YWxhbmNoZU5ldHdvcmssIG1lc3NhZ2U6IEJ1ZmZlciwgc2lnbmF0dXJlOiBCdWZmZXIpOiBCdWZmZXIge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLnJlY292ZXJ5U2lnbmF0dXJlQXZheEJ1ZmZlcihuZXR3b3JrLCBCdWZmZXJBdmF4LmZyb20obWVzc2FnZSksIEJ1ZmZlckF2YXguZnJvbShzaWduYXR1cmUpKSk7XG4gIH1cblxuICBzaGEyNTYoYnVmOiBVaW50OEFycmF5KTogQnVmZmVyIHtcbiAgICByZXR1cm4gY3JlYXRlSGFzaC5kZWZhdWx0KCdzaGEyNTYnKS51cGRhdGUoYnVmKS5kaWdlc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgcmF3IHRyYW5zYWN0aW9uIGhhcyBhIHZhbGlkIGZvcm1hdCBpbiB0aGUgYmxvY2tjaGFpbiBjb250ZXh0LCB0aHJvdyBvdGhlcndpc2UuXG4gICAqIEl0J3MgdG8gcmV1c2UgaW4gVHJhbnNhY3Rpb25CdWlsZGVyIGFuZCBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5XG4gICAqXG4gICAqIEBwYXJhbSByYXdUcmFuc2FjdGlvbiBUcmFuc2FjdGlvbiBhcyBoZXggc3RyaW5nXG4gICAqL1xuICB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIXJhd1RyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1JhdyB0cmFuc2FjdGlvbiBpcyBlbXB0eScpO1xuICAgIH1cbiAgICBpZiAoIXV0aWxzLmFsbEhleENoYXJzKHJhd1RyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignUmF3IHRyYW5zYWN0aW9uIGlzIG5vdCBoZXggc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR4IGlzIGZvciB0aGUgYmxvY2tjaGFpbklkXG4gICAqXG4gICAqIEBwYXJhbSB7VHh9IHR4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibG9ja2NoYWluSWRcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0eCBpcyBmb3IgYmxvY2tjaGFpbklkXG4gICAqL1xuICBpc1RyYW5zYWN0aW9uT2YodHg6IFR4LCBibG9ja2NoYWluSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB1dGlscy5jYjU4RW5jb2RlKHR4LmdldFVuc2lnbmVkVHgoKS5nZXRUcmFuc2FjdGlvbigpLmdldEJsb2NrY2hhaW5JRCgpKSA9PT0gYmxvY2tjaGFpbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIE91dHB1dCBpcyBmcm9tIFBWTS5cbiAgICogT3V0cHV0IGNvdWxkIGJlIEVWTSBvciBQVk0gb3V0cHV0LlxuICAgKiBAcGFyYW0ge091dHB1dH0gb3V0cHV0XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBvdXRwdXQgaXMgVHJhbnNmZXJhYmxlT3V0cHV0XG4gICAqL1xuICBpc1RyYW5zZmVyYWJsZU91dHB1dChvdXRwdXQ6IE91dHB1dCk6IG91dHB1dCBpcyBUcmFuc2ZlcmFibGVPdXRwdXQge1xuICAgIHJldHVybiAnZ2V0T3V0cHV0JyBpbiBvdXRwdXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgbWFwcGVyIGZ1bmN0aW9uIHRvIHRoYXQgbmV0d29yayBhZGRyZXNzIHJlcHJlc2VudGF0aW9uLlxuICAgKiBAcGFyYW0gbmV0d29yayByZXF1aXJlZCB0byBzdHJpbmdpZnkgYWRkcmVzc2VzXG4gICAqIEByZXR1cm4gbWFwcGVyIGZ1bmN0aW9uXG4gICAqL1xuICBtYXBPdXRwdXRUb0VudHJ5KG5ldHdvcms6IEF2YWxhbmNoZU5ldHdvcmspOiAoT3V0cHV0KSA9PiBFbnRyeSB7XG4gICAgcmV0dXJuIChvdXRwdXQ6IE91dHB1dCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNUcmFuc2ZlcmFibGVPdXRwdXQob3V0cHV0KSkge1xuICAgICAgICBjb25zdCBhbW91bnRPdXRwdXQgPSBvdXRwdXQuZ2V0T3V0cHV0KCkgYXMgQW1vdW50T3V0cHV0O1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYW1vdW50T3V0cHV0XG4gICAgICAgICAgLmdldEFkZHJlc3NlcygpXG4gICAgICAgICAgLm1hcCgoYSkgPT4gdGhpcy5hZGRyZXNzVG9TdHJpbmcobmV0d29yay5ocnAsIG5ldHdvcmsuYWxpYXMsIGEpKVxuICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAuam9pbihBRERSRVNTX1NFUEFSQVRPUik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGFtb3VudE91dHB1dC5nZXRBbW91bnQoKS50b1N0cmluZygpLFxuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBldm1PdXRwdXQgPSBvdXRwdXQgYXMgRVZNT3V0cHV0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBldm1PdXB1dC5nZXRBbW91bnQoKSwgYnV0IGl0IHJldHVybnMgYSAwLlxuICAgICAgICAgIHZhbHVlOiBuZXcgQk4oKGV2bU91dHB1dCBhcyBhbnkpLmFtb3VudCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAvLyBDLUNoYWluIGFkZHJlc3MuXG4gICAgICAgICAgYWRkcmVzczogJzB4JyArIGV2bU91dHB1dC5nZXRBZGRyZXNzU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgaGV4IHByZWZpeCAoMHgpXG4gICAqIEBwYXJhbSBoZXggc3RyaW5nXG4gICAqIEByZXR1cm5zIGhleCB3aXRob3V0IDB4XG4gICAqL1xuICByZW1vdmVIZXhQcmVmaXgoaGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChoZXguc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgcmV0dXJuIGhleC5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH1cblxuICAvKipcbiAgICogT3V0cHV0aWR4IGNvbnZlcnQgZnJvbSBudW1iZXIgKGFzIHN0cmluZykgdG8gYnVmZmVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3V0cHV0aWR4IG51bWJlclxuICAgKiBAcmV0dXJuIHtCdWZmZXJBdmF4fSBidWZmZXIgb2Ygc2l6ZSA0IHdpdGggdGhhdCBudW1iZXIgdmFsdWVcbiAgICovXG4gIG91dHB1dGlkeE51bWJlclRvQnVmZmVyKG91dHB1dGlkeDogc3RyaW5nKTogQnVmZmVyQXZheCB7XG4gICAgcmV0dXJuIEJ1ZmZlckF2YXguZnJvbShOdW1iZXIob3V0cHV0aWR4KS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgJzAnKSwgJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE91dHB1dGlkeCBidWZmZXIgdG8gbnVtYmVyIChhcyBzdHJpbmcpXG4gICAqIEBwYXJhbSB7QnVmZmVyQXZheH0gb3V0cHV0aWR4XG4gICAqIEByZXR1cm4ge3N0cmluZ30gb3V0cHV0aWR4IG51bWJlclxuICAgKi9cbiAgb3V0cHV0aWR4QnVmZmVyVG9OdW1iZXIob3V0cHV0aWR4OiBCdWZmZXJBdmF4KTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGFyc2VJbnQob3V0cHV0aWR4LnRvU3RyaW5nKCdoZXgnKSwgMTYpLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuY29uc3QgdXRpbHMgPSBuZXcgVXRpbHMoKTtcblxuZXhwb3J0IGRlZmF1bHQgdXRpbHM7XG4iXX0=