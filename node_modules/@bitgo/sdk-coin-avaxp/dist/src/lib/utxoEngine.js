"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.utxoToInput = exports.recoverUtxos = void 0;
const iface_1 = require("./iface");
const avalanche_1 = require("avalanche");
const utils_1 = __importDefault(require("./utils"));
const sdk_core_1 = require("@bitgo/sdk-core");
/**
 * Inputs can be controlled but outputs get reordered in transactions
 * In order to make sure that the mapping is always correct we create an addressIndex which matches to the appropriate
 * signatureIdx
 * @param {StandardTransferableInput[]} utxos as transaction ins.
 * @returns the list of UTXOs
 */
function recoverUtxos(utxos) {
    return utxos.map((utxo) => {
        const secpInput = utxo.getInput();
        // use the same addressesIndex as existing ones in the inputs
        const addressesIndex = secpInput.getSigIdxs().map((s) => s.toBuffer().readUInt32BE(0));
        return {
            outputID: iface_1.SECP256K1_Transfer_Output,
            outputidx: utils_1.default.outputidxBufferToNumber(utxo.getOutputIdx()),
            txid: utils_1.default.cb58Encode(utxo.getTxID()),
            amount: secpInput.getAmount().toString(),
            threshold: addressesIndex.length,
            addresses: [],
            addressesIndex,
        };
    });
}
exports.recoverUtxos = recoverUtxos;
/**
 * Convert Utxos into inputs data. Input Objects changes regarding chains. This method return a plain object to be mapped late in chain input.
 * Sender is a list of owners address and utxo address must contains all of them.
 * Signers is a list of sender cut it in threshold size. Firsts senders are the signers.
 *
 * Output always get reordered we want to make sure we can always add signatures in the correct location.
 * Signatures array store signers address of the expected signature. Tx sign replace the address for the signature.
 * So the location of the signatures is guaranteed.
 *
 * To find the correct location for the signature, we use the output's addresses to create the signatureIdx in the order that we desire
 * 0: user key, 1: hsm key, 2: recovery key
 *
 * @param utxos
 * @param sender array of addresses
 * @param threshold number of signatures required
 * @return {
 *   inputs: InputData[];
 *   amount: BN;
 * } as total amount and inputs with signatures as signers address to be replaced.
 */
function utxoToInput(utxos, sender, threshold = 2) {
    // amount spent so far
    let currentTotal = new avalanche_1.BN(0);
    const inputs = utxos
        .filter((utxo) => utxo && utxo.outputID === iface_1.SECP256K1_Transfer_Output)
        .map((utxo) => {
        // validate the utxos
        const utxoAddresses = utxo.addresses.map((a) => utils_1.default.parseAddress(a));
        const addressesIndex = sender.map((a) => utxoAddresses.findIndex((u) => a.equals(u)));
        // addressesIndex should never have a mismatch
        if (addressesIndex.includes(-1)) {
            throw new sdk_core_1.BuildTransactionError('Addresses are inconsistent: ' + utxo.txid);
        }
        if (utxo.threshold !== threshold) {
            throw new sdk_core_1.BuildTransactionError('Threshold is inconsistent');
        }
        const txidBuf = utils_1.default.cb58Decode(utxo.txid);
        const amount = new avalanche_1.BN(utxo.amount);
        const outputIdx = utils_1.default.outputidxNumberToBuffer(utxo.outputidx);
        currentTotal = currentTotal.add(amount);
        const signers = addressesIndex
            .slice(0, threshold)
            .map((utxoIndex, senderIndex) => ({ utxoIndex, senderIndex }))
            .sort((a, b) => a.utxoIndex - b.utxoIndex);
        const signatures = signers.map(({ senderIndex }) => 
        // TODO(BG-56700):  Improve canSign by check in addresses in empty credentials match signer
        // HSM require empty signature.
        utils_1.default.createSig(senderIndex == 1 ? '' : sender[senderIndex].toString('hex')));
        const signaturesIdx = signers.map(({ utxoIndex }) => utxoIndex);
        return { amount, txidBuf, outputIdx, signaturesIdx, signatures };
    });
    return { inputs, amount: currentTotal };
}
exports.utxoToInput = utxoToInput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXR4b0VuZ2luZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXR4b0VuZ2luZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxtQ0FBb0U7QUFDcEUseUNBQXFEO0FBRXJELG9EQUE0QjtBQUM1Qiw4Q0FBd0Q7QUFXeEQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLEtBQWtDO0lBQzdELE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ3hCLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLEVBQXlCLENBQUM7UUFFekQsNkRBQTZEO1FBQzdELE1BQU0sY0FBYyxHQUFhLFNBQVMsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVqRyxPQUFPO1lBQ0wsUUFBUSxFQUFFLGlDQUF5QjtZQUNuQyxTQUFTLEVBQUUsZUFBSyxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztZQUM3RCxJQUFJLEVBQUUsZUFBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDdEMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLEVBQUU7WUFDeEMsU0FBUyxFQUFFLGNBQWMsQ0FBQyxNQUFNO1lBQ2hDLFNBQVMsRUFBRSxFQUFFO1lBQ2IsY0FBYztTQUNmLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFqQkQsb0NBaUJDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FtQkc7QUFDSCxTQUFnQixXQUFXLENBQ3pCLEtBQXVCLEVBQ3ZCLE1BQW9CLEVBQ3BCLFNBQVMsR0FBRyxDQUFDO0lBS2Isc0JBQXNCO0lBQ3RCLElBQUksWUFBWSxHQUFPLElBQUksY0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRWpDLE1BQU0sTUFBTSxHQUFHLEtBQUs7U0FDakIsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxpQ0FBeUIsQ0FBQztTQUNyRSxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNaLHFCQUFxQjtRQUNyQixNQUFNLGFBQWEsR0FBaUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLGVBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyRixNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN0Riw4Q0FBOEM7UUFDOUMsSUFBSSxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7WUFDL0IsTUFBTSxJQUFJLGdDQUFxQixDQUFDLDhCQUE4QixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM3RTtRQUNELElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDaEMsTUFBTSxJQUFJLGdDQUFxQixDQUFDLDJCQUEyQixDQUFDLENBQUM7U0FDOUQ7UUFFRCxNQUFNLE9BQU8sR0FBZSxlQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN4RCxNQUFNLE1BQU0sR0FBTyxJQUFJLGNBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkMsTUFBTSxTQUFTLEdBQWUsZUFBSyxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUU1RSxZQUFZLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV4QyxNQUFNLE9BQU8sR0FBRyxjQUFjO2FBQzNCLEtBQUssQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDO2FBQ25CLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQzthQUM3RCxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM3QyxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFO1FBQ2pELDJGQUEyRjtRQUMzRiwrQkFBK0I7UUFDL0IsZUFBSyxDQUFDLFNBQVMsQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FDN0UsQ0FBQztRQUNGLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUVoRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxDQUFDO0lBQ25FLENBQUMsQ0FBQyxDQUFDO0lBRUwsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLENBQUM7QUFDMUMsQ0FBQztBQTlDRCxrQ0E4Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEZWNvZGVkVXR4b09iaiwgU0VDUDI1NksxX1RyYW5zZmVyX091dHB1dCB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgQk4sIEJ1ZmZlciBhcyBCdWZmZXJBdmF4IH0gZnJvbSAnYXZhbGFuY2hlJztcbmltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ2F2YWxhbmNoZS9kaXN0L2NvbW1vbic7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgU3RhbmRhcmRBbW91bnRJbnB1dCwgU3RhbmRhcmRUcmFuc2ZlcmFibGVJbnB1dCB9IGZyb20gJ2F2YWxhbmNoZS9kaXN0L2NvbW1vbi9pbnB1dCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5wdXREYXRhIHtcbiAgYW1vdW50OiBCTjtcbiAgdHhpZEJ1ZjogQnVmZmVyQXZheDtcbiAgb3V0cHV0SWR4OiBCdWZmZXJBdmF4O1xuICBzaWduYXR1cmVzSWR4OiBudW1iZXJbXTtcbiAgc2lnbmF0dXJlczogU2lnbmF0dXJlW107XG59XG5cbi8qKlxuICogSW5wdXRzIGNhbiBiZSBjb250cm9sbGVkIGJ1dCBvdXRwdXRzIGdldCByZW9yZGVyZWQgaW4gdHJhbnNhY3Rpb25zXG4gKiBJbiBvcmRlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgbWFwcGluZyBpcyBhbHdheXMgY29ycmVjdCB3ZSBjcmVhdGUgYW4gYWRkcmVzc0luZGV4IHdoaWNoIG1hdGNoZXMgdG8gdGhlIGFwcHJvcHJpYXRlXG4gKiBzaWduYXR1cmVJZHhcbiAqIEBwYXJhbSB7U3RhbmRhcmRUcmFuc2ZlcmFibGVJbnB1dFtdfSB1dHhvcyBhcyB0cmFuc2FjdGlvbiBpbnMuXG4gKiBAcmV0dXJucyB0aGUgbGlzdCBvZiBVVFhPc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVjb3ZlclV0eG9zKHV0eG9zOiBTdGFuZGFyZFRyYW5zZmVyYWJsZUlucHV0W10pOiBEZWNvZGVkVXR4b09ialtdIHtcbiAgcmV0dXJuIHV0eG9zLm1hcCgodXR4bykgPT4ge1xuICAgIGNvbnN0IHNlY3BJbnB1dCA9IHV0eG8uZ2V0SW5wdXQoKSBhcyBTdGFuZGFyZEFtb3VudElucHV0O1xuXG4gICAgLy8gdXNlIHRoZSBzYW1lIGFkZHJlc3Nlc0luZGV4IGFzIGV4aXN0aW5nIG9uZXMgaW4gdGhlIGlucHV0c1xuICAgIGNvbnN0IGFkZHJlc3Nlc0luZGV4OiBudW1iZXJbXSA9IHNlY3BJbnB1dC5nZXRTaWdJZHhzKCkubWFwKChzKSA9PiBzLnRvQnVmZmVyKCkucmVhZFVJbnQzMkJFKDApKTtcblxuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXRJRDogU0VDUDI1NksxX1RyYW5zZmVyX091dHB1dCxcbiAgICAgIG91dHB1dGlkeDogdXRpbHMub3V0cHV0aWR4QnVmZmVyVG9OdW1iZXIodXR4by5nZXRPdXRwdXRJZHgoKSksXG4gICAgICB0eGlkOiB1dGlscy5jYjU4RW5jb2RlKHV0eG8uZ2V0VHhJRCgpKSxcbiAgICAgIGFtb3VudDogc2VjcElucHV0LmdldEFtb3VudCgpLnRvU3RyaW5nKCksXG4gICAgICB0aHJlc2hvbGQ6IGFkZHJlc3Nlc0luZGV4Lmxlbmd0aCxcbiAgICAgIGFkZHJlc3NlczogW10sIC8vIHRoaXMgaXMgZW1wdHkgc2luY2UgdGhlIGlucHV0cyBmcm9tIGRlc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBkb24ndCBjb250YWluIGFkZHJlc3Nlc1xuICAgICAgYWRkcmVzc2VzSW5kZXgsXG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29udmVydCBVdHhvcyBpbnRvIGlucHV0cyBkYXRhLiBJbnB1dCBPYmplY3RzIGNoYW5nZXMgcmVnYXJkaW5nIGNoYWlucy4gVGhpcyBtZXRob2QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0IHRvIGJlIG1hcHBlZCBsYXRlIGluIGNoYWluIGlucHV0LlxuICogU2VuZGVyIGlzIGEgbGlzdCBvZiBvd25lcnMgYWRkcmVzcyBhbmQgdXR4byBhZGRyZXNzIG11c3QgY29udGFpbnMgYWxsIG9mIHRoZW0uXG4gKiBTaWduZXJzIGlzIGEgbGlzdCBvZiBzZW5kZXIgY3V0IGl0IGluIHRocmVzaG9sZCBzaXplLiBGaXJzdHMgc2VuZGVycyBhcmUgdGhlIHNpZ25lcnMuXG4gKlxuICogT3V0cHV0IGFsd2F5cyBnZXQgcmVvcmRlcmVkIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGNhbiBhbHdheXMgYWRkIHNpZ25hdHVyZXMgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb24uXG4gKiBTaWduYXR1cmVzIGFycmF5IHN0b3JlIHNpZ25lcnMgYWRkcmVzcyBvZiB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlLiBUeCBzaWduIHJlcGxhY2UgdGhlIGFkZHJlc3MgZm9yIHRoZSBzaWduYXR1cmUuXG4gKiBTbyB0aGUgbG9jYXRpb24gb2YgdGhlIHNpZ25hdHVyZXMgaXMgZ3VhcmFudGVlZC5cbiAqXG4gKiBUbyBmaW5kIHRoZSBjb3JyZWN0IGxvY2F0aW9uIGZvciB0aGUgc2lnbmF0dXJlLCB3ZSB1c2UgdGhlIG91dHB1dCdzIGFkZHJlc3NlcyB0byBjcmVhdGUgdGhlIHNpZ25hdHVyZUlkeCBpbiB0aGUgb3JkZXIgdGhhdCB3ZSBkZXNpcmVcbiAqIDA6IHVzZXIga2V5LCAxOiBoc20ga2V5LCAyOiByZWNvdmVyeSBrZXlcbiAqXG4gKiBAcGFyYW0gdXR4b3NcbiAqIEBwYXJhbSBzZW5kZXIgYXJyYXkgb2YgYWRkcmVzc2VzXG4gKiBAcGFyYW0gdGhyZXNob2xkIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkXG4gKiBAcmV0dXJuIHtcbiAqICAgaW5wdXRzOiBJbnB1dERhdGFbXTtcbiAqICAgYW1vdW50OiBCTjtcbiAqIH0gYXMgdG90YWwgYW1vdW50IGFuZCBpbnB1dHMgd2l0aCBzaWduYXR1cmVzIGFzIHNpZ25lcnMgYWRkcmVzcyB0byBiZSByZXBsYWNlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0eG9Ub0lucHV0KFxuICB1dHhvczogRGVjb2RlZFV0eG9PYmpbXSxcbiAgc2VuZGVyOiBCdWZmZXJBdmF4W10sXG4gIHRocmVzaG9sZCA9IDJcbik6IHtcbiAgaW5wdXRzOiBJbnB1dERhdGFbXTtcbiAgYW1vdW50OiBCTjtcbn0ge1xuICAvLyBhbW91bnQgc3BlbnQgc28gZmFyXG4gIGxldCBjdXJyZW50VG90YWw6IEJOID0gbmV3IEJOKDApO1xuXG4gIGNvbnN0IGlucHV0cyA9IHV0eG9zXG4gICAgLmZpbHRlcigodXR4bykgPT4gdXR4byAmJiB1dHhvLm91dHB1dElEID09PSBTRUNQMjU2SzFfVHJhbnNmZXJfT3V0cHV0KVxuICAgIC5tYXAoKHV0eG8pID0+IHtcbiAgICAgIC8vIHZhbGlkYXRlIHRoZSB1dHhvc1xuICAgICAgY29uc3QgdXR4b0FkZHJlc3NlczogQnVmZmVyQXZheFtdID0gdXR4by5hZGRyZXNzZXMubWFwKChhKSA9PiB1dGlscy5wYXJzZUFkZHJlc3MoYSkpO1xuICAgICAgY29uc3QgYWRkcmVzc2VzSW5kZXggPSBzZW5kZXIubWFwKChhKSA9PiB1dHhvQWRkcmVzc2VzLmZpbmRJbmRleCgodSkgPT4gYS5lcXVhbHModSkpKTtcbiAgICAgIC8vIGFkZHJlc3Nlc0luZGV4IHNob3VsZCBuZXZlciBoYXZlIGEgbWlzbWF0Y2hcbiAgICAgIGlmIChhZGRyZXNzZXNJbmRleC5pbmNsdWRlcygtMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignQWRkcmVzc2VzIGFyZSBpbmNvbnNpc3RlbnQ6ICcgKyB1dHhvLnR4aWQpO1xuICAgICAgfVxuICAgICAgaWYgKHV0eG8udGhyZXNob2xkICE9PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVGhyZXNob2xkIGlzIGluY29uc2lzdGVudCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0eGlkQnVmOiBCdWZmZXJBdmF4ID0gdXRpbHMuY2I1OERlY29kZSh1dHhvLnR4aWQpO1xuICAgICAgY29uc3QgYW1vdW50OiBCTiA9IG5ldyBCTih1dHhvLmFtb3VudCk7XG4gICAgICBjb25zdCBvdXRwdXRJZHg6IEJ1ZmZlckF2YXggPSB1dGlscy5vdXRwdXRpZHhOdW1iZXJUb0J1ZmZlcih1dHhvLm91dHB1dGlkeCk7XG5cbiAgICAgIGN1cnJlbnRUb3RhbCA9IGN1cnJlbnRUb3RhbC5hZGQoYW1vdW50KTtcblxuICAgICAgY29uc3Qgc2lnbmVycyA9IGFkZHJlc3Nlc0luZGV4XG4gICAgICAgIC5zbGljZSgwLCB0aHJlc2hvbGQpXG4gICAgICAgIC5tYXAoKHV0eG9JbmRleCwgc2VuZGVySW5kZXgpID0+ICh7IHV0eG9JbmRleCwgc2VuZGVySW5kZXggfSkpXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnV0eG9JbmRleCAtIGIudXR4b0luZGV4KTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSBzaWduZXJzLm1hcCgoeyBzZW5kZXJJbmRleCB9KSA9PlxuICAgICAgICAvLyBUT0RPKEJHLTU2NzAwKTogIEltcHJvdmUgY2FuU2lnbiBieSBjaGVjayBpbiBhZGRyZXNzZXMgaW4gZW1wdHkgY3JlZGVudGlhbHMgbWF0Y2ggc2lnbmVyXG4gICAgICAgIC8vIEhTTSByZXF1aXJlIGVtcHR5IHNpZ25hdHVyZS5cbiAgICAgICAgdXRpbHMuY3JlYXRlU2lnKHNlbmRlckluZGV4ID09IDEgPyAnJyA6IHNlbmRlcltzZW5kZXJJbmRleF0udG9TdHJpbmcoJ2hleCcpKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZXNJZHggPSBzaWduZXJzLm1hcCgoeyB1dHhvSW5kZXggfSkgPT4gdXR4b0luZGV4KTtcblxuICAgICAgcmV0dXJuIHsgYW1vdW50LCB0eGlkQnVmLCBvdXRwdXRJZHgsIHNpZ25hdHVyZXNJZHgsIHNpZ25hdHVyZXMgfTtcbiAgICB9KTtcblxuICByZXR1cm4geyBpbnB1dHMsIGFtb3VudDogY3VycmVudFRvdGFsIH07XG59XG4iXX0=