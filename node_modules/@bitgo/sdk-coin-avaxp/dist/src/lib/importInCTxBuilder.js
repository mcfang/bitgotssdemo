"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportInCTxBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const evm_1 = require("avalanche/dist/apis/evm");
const utils_1 = require("avalanche/dist/utils");
const avalanche_1 = require("avalanche");
const utxoEngine_1 = require("./utxoEngine");
const atomicInCTransactionBuilder_1 = require("./atomicInCTransactionBuilder");
const utils_2 = __importDefault(require("./utils"));
class ImportInCTxBuilder extends atomicInCTransactionBuilder_1.AtomicInCTransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    /**
     * C-chain address who is target of the import.
     * Address format is eth like
     * @param {string} cAddress
     */
    to(cAddress) {
        this.transaction._to = [utils_2.default.parseAddress(cAddress)];
        return this;
    }
    get transactionType() {
        return sdk_core_1.TransactionType.Import;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        const baseTx = tx.getUnsignedTx().getTransaction();
        if (baseTx.getNetworkID() !== this.transaction._networkID ||
            !baseTx.getBlockchainID().equals(this.transaction._blockchainID)) {
            throw new Error('Network or blockchain is not equals');
        }
        if (!this.verifyTxType(baseTx)) {
            throw new sdk_core_1.NotSupported('Transaction cannot be parsed or has an unsupported transaction type');
        }
        // The outputs is a signler C-Chain address result.
        // It's expected to have only one outputs to the destination C-Chain address.
        const outputs = baseTx.getOuts();
        if (outputs.length !== 1) {
            throw new sdk_core_1.BuildTransactionError('Transaction can have one output');
        }
        const output = outputs[0];
        if (!output.getAssetID().equals(this.transaction._assetId)) {
            throw new Error('AssetID are not equals');
        }
        this.transaction._to = [output.getAddress()];
        const input = baseTx.getImportInputs();
        this.transaction._utxos = utxoEngine_1.recoverUtxos(input);
        const totalInputAmount = input.reduce((t, i) => t.add(i.getInput().getAmount()), new avalanche_1.BN(0));
        // it should be (output as AmountOutput).getAmount(), but it's not working.
        const totalOutputAmount = new avalanche_1.BN(output.amount);
        const feeSize = utils_1.costImportTx(tx.getUnsignedTx());
        const fee = totalInputAmount.sub(totalOutputAmount);
        const feeRate = fee.divn(feeSize);
        this.transaction._fee = {
            fee: fee.toString(),
            feeRate: feeRate.toNumber(),
            size: feeSize,
        };
        this.transaction.setTransaction(tx);
        return this;
    }
    static verifyTxType(baseTx) {
        return baseTx.getTypeID() === evm_1.EVMConstants.IMPORTTX;
    }
    verifyTxType(baseTx) {
        return ImportInCTxBuilder.verifyTxType(baseTx);
    }
    /**
     * Build the import in C-chain transaction
     * @protected
     */
    buildAvaxTransaction() {
        // if tx has credentials, tx shouldn't change
        if (this.transaction.hasCredentials)
            return;
        if (this.transaction._to.length !== 1) {
            throw new Error('to is required');
        }
        if (!this.transaction._fee.feeRate) {
            throw new Error('fee rate is required');
        }
        const { inputs, amount, credentials } = this.createInputs();
        const feeRate = new avalanche_1.BN(this.transaction._fee.feeRate);
        const feeSize = utils_1.costImportTx(new evm_1.UnsignedTx(new evm_1.ImportTx(this.transaction._networkID, this.transaction._blockchainID, this._externalChainId, inputs, [
            new evm_1.EVMOutput(this.transaction._to[0], amount, this.transaction._assetId),
        ])));
        const fee = feeRate.muln(feeSize);
        this.transaction._fee.fee = fee.toString();
        this.transaction._fee.size = feeSize;
        this.transaction.setTransaction(new evm_1.Tx(new evm_1.UnsignedTx(new evm_1.ImportTx(this.transaction._networkID, this.transaction._blockchainID, this._externalChainId, inputs, [new evm_1.EVMOutput(this.transaction._to[0], amount.sub(fee), this.transaction._assetId)], fee)), credentials));
    }
    /**
     * Create inputs by mapping {@see utxoEngine.utxoToInput} result.
     * Reorder sender to handle recover signer.
     * TransferableInput is a EVM Tx.
     * @return {
     *     inputs: TransferableInput[];
     *     credentials: Credential[];
     *     amount: BN;
     *   } where amount is the sum of inputs amount and credentials has signer address to be replaced with correct signature.
     * @protected
     *
     */
    createInputs() {
        const sender = this.transaction._fromAddresses.slice();
        if (this.recoverSigner) {
            // switch first and last signer.
            const tmp = sender.pop();
            sender.push(sender[0]);
            if (tmp) {
                sender[0] = tmp;
            }
        }
        const { inputs, amount } = utxoEngine_1.utxoToInput(this.transaction._utxos, sender);
        const result = { inputs: [], credentials: [] };
        inputs.forEach((input) => {
            const secpTransferInput = new evm_1.SECPTransferInput(input.amount);
            input.signaturesIdx.forEach((signatureIdx, arrayIndex) => secpTransferInput.addSignatureIdx(signatureIdx, sender[arrayIndex]));
            result.inputs.push(new evm_1.TransferableInput(input.txidBuf, input.outputIdx, this.transaction._assetId, secpTransferInput));
            result.credentials.push(evm_1.SelectCredentialClass(secpTransferInput.getCredentialID(), input.signatures));
        });
        return { ...result, amount };
    }
}
exports.ImportInCTxBuilder = ImportInCTxBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1wb3J0SW5DVHhCdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9pbXBvcnRJbkNUeEJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsOENBQXVGO0FBQ3ZGLGlEQVVpQztBQUNqQyxnREFBb0Q7QUFDcEQseUNBQStCO0FBRS9CLDZDQUF5RDtBQUV6RCwrRUFBNEU7QUFDNUUsb0RBQTRCO0FBRTVCLE1BQWEsa0JBQW1CLFNBQVEseURBQTJCO0lBQ2pFLFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsRUFBRSxDQUFDLFFBQWdCO1FBQ2pCLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxHQUFHLENBQUMsZUFBSyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ3RELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELElBQWMsZUFBZTtRQUMzQixPQUFPLDBCQUFlLENBQUMsTUFBTSxDQUFDO0lBQ2hDLENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsV0FBVyxDQUFDLEVBQU07UUFDaEIsTUFBTSxNQUFNLEdBQVcsRUFBRSxDQUFDLGFBQWEsRUFBRSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQzNELElBQ0UsTUFBTSxDQUFDLFlBQVksRUFBRSxLQUFLLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVTtZQUNyRCxDQUFDLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsRUFDaEU7WUFDQSxNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUM7U0FDeEQ7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM5QixNQUFNLElBQUksdUJBQVksQ0FBQyxxRUFBcUUsQ0FBQyxDQUFDO1NBQy9GO1FBRUQsbURBQW1EO1FBQ25ELDZFQUE2RTtRQUM3RSxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDakMsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN4QixNQUFNLElBQUksZ0NBQXFCLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNwRTtRQUNELE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUUxQixJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzFELE1BQU0sSUFBSSxLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztTQUMzQztRQUNELElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUM7UUFFN0MsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRXZDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLHlCQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFOUMsTUFBTSxnQkFBZ0IsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBRSxDQUFDLENBQUMsUUFBUSxFQUFrQixDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsSUFBSSxjQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3RywyRUFBMkU7UUFDM0UsTUFBTSxpQkFBaUIsR0FBRyxJQUFJLGNBQUUsQ0FBRSxNQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDekQsTUFBTSxPQUFPLEdBQUcsb0JBQVksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFnQixDQUFDLENBQUM7UUFDL0QsTUFBTSxHQUFHLEdBQUcsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDcEQsTUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRztZQUN0QixHQUFHLEVBQUUsR0FBRyxDQUFDLFFBQVEsRUFBRTtZQUNuQixPQUFPLEVBQUUsT0FBTyxDQUFDLFFBQVEsRUFBRTtZQUMzQixJQUFJLEVBQUUsT0FBTztTQUNkLENBQUM7UUFDRixJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNwQyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQWM7UUFDaEMsT0FBTyxNQUFNLENBQUMsU0FBUyxFQUFFLEtBQUssa0JBQVksQ0FBQyxRQUFRLENBQUM7SUFDdEQsQ0FBQztJQUVELFlBQVksQ0FBQyxNQUFjO1FBQ3pCLE9BQU8sa0JBQWtCLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7O09BR0c7SUFDTyxvQkFBb0I7UUFDNUIsNkNBQTZDO1FBQzdDLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjO1lBQUUsT0FBTztRQUM1QyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQ25DO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7U0FDekM7UUFDRCxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFFNUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxjQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEQsTUFBTSxPQUFPLEdBQUcsb0JBQVksQ0FDMUIsSUFBSSxnQkFBVSxDQUNaLElBQUksY0FBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxNQUFNLEVBQUU7WUFDdkcsSUFBSSxlQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDO1NBQzFFLENBQUMsQ0FDSCxDQUNGLENBQUM7UUFDRixNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDM0MsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztRQUNyQyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FDN0IsSUFBSSxRQUFLLENBQ1AsSUFBSSxnQkFBVSxDQUNaLElBQUksY0FBUSxDQUNWLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUMzQixJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFDOUIsSUFBSSxDQUFDLGdCQUFnQixFQUNyQixNQUFNLEVBQ04sQ0FBQyxJQUFJLGVBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsRUFDcEYsR0FBRyxDQUNKLENBQ0YsRUFDRCxXQUFXLENBQ1osQ0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7OztPQVdHO0lBQ08sWUFBWTtRQUtwQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN2RCxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdEIsZ0NBQWdDO1lBQ2hDLE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUN6QixNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLElBQUksR0FBRyxFQUFFO2dCQUNQLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7YUFDakI7U0FDRjtRQUNELE1BQU0sRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsd0JBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUN4RSxNQUFNLE1BQU0sR0FHUixFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBRXBDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUN2QixNQUFNLGlCQUFpQixHQUFHLElBQUksdUJBQWlCLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzlELEtBQUssQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsWUFBWSxFQUFFLFVBQVUsRUFBRSxFQUFFLENBQ3ZELGlCQUFpQixDQUFDLGVBQWUsQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQ3BFLENBQUM7WUFDRixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDaEIsSUFBSSx1QkFBaUIsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsaUJBQWlCLENBQUMsQ0FDcEcsQ0FBQztZQUVGLE1BQU0sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLDJCQUFxQixDQUFDLGlCQUFpQixDQUFDLGVBQWUsRUFBRSxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQ3hHLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxFQUFFLEdBQUcsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDO0lBQy9CLENBQUM7Q0FDRjtBQWxLRCxnREFrS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgQnVpbGRUcmFuc2FjdGlvbkVycm9yLCBOb3RTdXBwb3J0ZWQsIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQge1xuICBFVk1Db25zdGFudHMsXG4gIFR4IGFzIEVWTVR4LFxuICBJbXBvcnRUeCxcbiAgVW5zaWduZWRUeCxcbiAgU0VDUFRyYW5zZmVySW5wdXQsXG4gIFNlbGVjdENyZWRlbnRpYWxDbGFzcyxcbiAgVHJhbnNmZXJhYmxlSW5wdXQsXG4gIEVWTU91dHB1dCxcbiAgQW1vdW50SW5wdXQsXG59IGZyb20gJ2F2YWxhbmNoZS9kaXN0L2FwaXMvZXZtJztcbmltcG9ydCB7IGNvc3RJbXBvcnRUeCB9IGZyb20gJ2F2YWxhbmNoZS9kaXN0L3V0aWxzJztcbmltcG9ydCB7IEJOIH0gZnJvbSAnYXZhbGFuY2hlJztcbmltcG9ydCB7IENyZWRlbnRpYWwgfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9jb21tb24nO1xuaW1wb3J0IHsgcmVjb3ZlclV0eG9zLCB1dHhvVG9JbnB1dCB9IGZyb20gJy4vdXR4b0VuZ2luZSc7XG5pbXBvcnQgeyBCYXNlVHgsIFR4IH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBBdG9taWNJbkNUcmFuc2FjdGlvbkJ1aWxkZXIgfSBmcm9tICcuL2F0b21pY0luQ1RyYW5zYWN0aW9uQnVpbGRlcic7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBjbGFzcyBJbXBvcnRJbkNUeEJ1aWxkZXIgZXh0ZW5kcyBBdG9taWNJbkNUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogQy1jaGFpbiBhZGRyZXNzIHdobyBpcyB0YXJnZXQgb2YgdGhlIGltcG9ydC5cbiAgICogQWRkcmVzcyBmb3JtYXQgaXMgZXRoIGxpa2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNBZGRyZXNzXG4gICAqL1xuICB0byhjQWRkcmVzczogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5fdG8gPSBbdXRpbHMucGFyc2VBZGRyZXNzKGNBZGRyZXNzKV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IHRyYW5zYWN0aW9uVHlwZSgpOiBUcmFuc2FjdGlvblR5cGUge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuSW1wb3J0O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGluaXRCdWlsZGVyKHR4OiBUeCk6IHRoaXMge1xuICAgIGNvbnN0IGJhc2VUeDogQmFzZVR4ID0gdHguZ2V0VW5zaWduZWRUeCgpLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgaWYgKFxuICAgICAgYmFzZVR4LmdldE5ldHdvcmtJRCgpICE9PSB0aGlzLnRyYW5zYWN0aW9uLl9uZXR3b3JrSUQgfHxcbiAgICAgICFiYXNlVHguZ2V0QmxvY2tjaGFpbklEKCkuZXF1YWxzKHRoaXMudHJhbnNhY3Rpb24uX2Jsb2NrY2hhaW5JRClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmV0d29yayBvciBibG9ja2NoYWluIGlzIG5vdCBlcXVhbHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudmVyaWZ5VHhUeXBlKGJhc2VUeCkpIHtcbiAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQoJ1RyYW5zYWN0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgaGFzIGFuIHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUnKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgb3V0cHV0cyBpcyBhIHNpZ25sZXIgQy1DaGFpbiBhZGRyZXNzIHJlc3VsdC5cbiAgICAvLyBJdCdzIGV4cGVjdGVkIHRvIGhhdmUgb25seSBvbmUgb3V0cHV0cyB0byB0aGUgZGVzdGluYXRpb24gQy1DaGFpbiBhZGRyZXNzLlxuICAgIGNvbnN0IG91dHB1dHMgPSBiYXNlVHguZ2V0T3V0cygpO1xuICAgIGlmIChvdXRwdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gY2FuIGhhdmUgb25lIG91dHB1dCcpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzWzBdO1xuXG4gICAgaWYgKCFvdXRwdXQuZ2V0QXNzZXRJRCgpLmVxdWFscyh0aGlzLnRyYW5zYWN0aW9uLl9hc3NldElkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBc3NldElEIGFyZSBub3QgZXF1YWxzJyk7XG4gICAgfVxuICAgIHRoaXMudHJhbnNhY3Rpb24uX3RvID0gW291dHB1dC5nZXRBZGRyZXNzKCldO1xuXG4gICAgY29uc3QgaW5wdXQgPSBiYXNlVHguZ2V0SW1wb3J0SW5wdXRzKCk7XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9uLl91dHhvcyA9IHJlY292ZXJVdHhvcyhpbnB1dCk7XG5cbiAgICBjb25zdCB0b3RhbElucHV0QW1vdW50ID0gaW5wdXQucmVkdWNlKCh0LCBpKSA9PiB0LmFkZCgoaS5nZXRJbnB1dCgpIGFzIEFtb3VudElucHV0KS5nZXRBbW91bnQoKSksIG5ldyBCTigwKSk7XG4gICAgLy8gaXQgc2hvdWxkIGJlIChvdXRwdXQgYXMgQW1vdW50T3V0cHV0KS5nZXRBbW91bnQoKSwgYnV0IGl0J3Mgbm90IHdvcmtpbmcuXG4gICAgY29uc3QgdG90YWxPdXRwdXRBbW91bnQgPSBuZXcgQk4oKG91dHB1dCBhcyBhbnkpLmFtb3VudCk7XG4gICAgY29uc3QgZmVlU2l6ZSA9IGNvc3RJbXBvcnRUeCh0eC5nZXRVbnNpZ25lZFR4KCkgYXMgVW5zaWduZWRUeCk7XG4gICAgY29uc3QgZmVlID0gdG90YWxJbnB1dEFtb3VudC5zdWIodG90YWxPdXRwdXRBbW91bnQpO1xuICAgIGNvbnN0IGZlZVJhdGUgPSBmZWUuZGl2bihmZWVTaXplKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLl9mZWUgPSB7XG4gICAgICBmZWU6IGZlZS50b1N0cmluZygpLFxuICAgICAgZmVlUmF0ZTogZmVlUmF0ZS50b051bWJlcigpLFxuICAgICAgc2l6ZTogZmVlU2l6ZSxcbiAgICB9O1xuICAgIHRoaXMudHJhbnNhY3Rpb24uc2V0VHJhbnNhY3Rpb24odHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIHZlcmlmeVR4VHlwZShiYXNlVHg6IEJhc2VUeCk6IGJhc2VUeCBpcyBJbXBvcnRUeCB7XG4gICAgcmV0dXJuIGJhc2VUeC5nZXRUeXBlSUQoKSA9PT0gRVZNQ29uc3RhbnRzLklNUE9SVFRYO1xuICB9XG5cbiAgdmVyaWZ5VHhUeXBlKGJhc2VUeDogQmFzZVR4KTogYmFzZVR4IGlzIEltcG9ydFR4IHtcbiAgICByZXR1cm4gSW1wb3J0SW5DVHhCdWlsZGVyLnZlcmlmeVR4VHlwZShiYXNlVHgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBpbXBvcnQgaW4gQy1jaGFpbiB0cmFuc2FjdGlvblxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRBdmF4VHJhbnNhY3Rpb24oKTogdm9pZCB7XG4gICAgLy8gaWYgdHggaGFzIGNyZWRlbnRpYWxzLCB0eCBzaG91bGRuJ3QgY2hhbmdlXG4gICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uaGFzQ3JlZGVudGlhbHMpIHJldHVybjtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5fdG8ubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghdGhpcy50cmFuc2FjdGlvbi5fZmVlLmZlZVJhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmVlIHJhdGUgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBpbnB1dHMsIGFtb3VudCwgY3JlZGVudGlhbHMgfSA9IHRoaXMuY3JlYXRlSW5wdXRzKCk7XG5cbiAgICBjb25zdCBmZWVSYXRlID0gbmV3IEJOKHRoaXMudHJhbnNhY3Rpb24uX2ZlZS5mZWVSYXRlKTtcbiAgICBjb25zdCBmZWVTaXplID0gY29zdEltcG9ydFR4KFxuICAgICAgbmV3IFVuc2lnbmVkVHgoXG4gICAgICAgIG5ldyBJbXBvcnRUeCh0aGlzLnRyYW5zYWN0aW9uLl9uZXR3b3JrSUQsIHRoaXMudHJhbnNhY3Rpb24uX2Jsb2NrY2hhaW5JRCwgdGhpcy5fZXh0ZXJuYWxDaGFpbklkLCBpbnB1dHMsIFtcbiAgICAgICAgICBuZXcgRVZNT3V0cHV0KHRoaXMudHJhbnNhY3Rpb24uX3RvWzBdLCBhbW91bnQsIHRoaXMudHJhbnNhY3Rpb24uX2Fzc2V0SWQpLFxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gICAgY29uc3QgZmVlID0gZmVlUmF0ZS5tdWxuKGZlZVNpemUpO1xuICAgIHRoaXMudHJhbnNhY3Rpb24uX2ZlZS5mZWUgPSBmZWUudG9TdHJpbmcoKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLl9mZWUuc2l6ZSA9IGZlZVNpemU7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5zZXRUcmFuc2FjdGlvbihcbiAgICAgIG5ldyBFVk1UeChcbiAgICAgICAgbmV3IFVuc2lnbmVkVHgoXG4gICAgICAgICAgbmV3IEltcG9ydFR4KFxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fbmV0d29ya0lELFxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fYmxvY2tjaGFpbklELFxuICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxDaGFpbklkLFxuICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgW25ldyBFVk1PdXRwdXQodGhpcy50cmFuc2FjdGlvbi5fdG9bMF0sIGFtb3VudC5zdWIoZmVlKSwgdGhpcy50cmFuc2FjdGlvbi5fYXNzZXRJZCldLFxuICAgICAgICAgICAgZmVlXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICBjcmVkZW50aWFsc1xuICAgICAgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGlucHV0cyBieSBtYXBwaW5nIHtAc2VlIHV0eG9FbmdpbmUudXR4b1RvSW5wdXR9IHJlc3VsdC5cbiAgICogUmVvcmRlciBzZW5kZXIgdG8gaGFuZGxlIHJlY292ZXIgc2lnbmVyLlxuICAgKiBUcmFuc2ZlcmFibGVJbnB1dCBpcyBhIEVWTSBUeC5cbiAgICogQHJldHVybiB7XG4gICAqICAgICBpbnB1dHM6IFRyYW5zZmVyYWJsZUlucHV0W107XG4gICAqICAgICBjcmVkZW50aWFsczogQ3JlZGVudGlhbFtdO1xuICAgKiAgICAgYW1vdW50OiBCTjtcbiAgICogICB9IHdoZXJlIGFtb3VudCBpcyB0aGUgc3VtIG9mIGlucHV0cyBhbW91bnQgYW5kIGNyZWRlbnRpYWxzIGhhcyBzaWduZXIgYWRkcmVzcyB0byBiZSByZXBsYWNlZCB3aXRoIGNvcnJlY3Qgc2lnbmF0dXJlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqXG4gICAqL1xuICBwcm90ZWN0ZWQgY3JlYXRlSW5wdXRzKCk6IHtcbiAgICBpbnB1dHM6IFRyYW5zZmVyYWJsZUlucHV0W107XG4gICAgY3JlZGVudGlhbHM6IENyZWRlbnRpYWxbXTtcbiAgICBhbW91bnQ6IEJOO1xuICB9IHtcbiAgICBjb25zdCBzZW5kZXIgPSB0aGlzLnRyYW5zYWN0aW9uLl9mcm9tQWRkcmVzc2VzLnNsaWNlKCk7XG4gICAgaWYgKHRoaXMucmVjb3ZlclNpZ25lcikge1xuICAgICAgLy8gc3dpdGNoIGZpcnN0IGFuZCBsYXN0IHNpZ25lci5cbiAgICAgIGNvbnN0IHRtcCA9IHNlbmRlci5wb3AoKTtcbiAgICAgIHNlbmRlci5wdXNoKHNlbmRlclswXSk7XG4gICAgICBpZiAodG1wKSB7XG4gICAgICAgIHNlbmRlclswXSA9IHRtcDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeyBpbnB1dHMsIGFtb3VudCB9ID0gdXR4b1RvSW5wdXQodGhpcy50cmFuc2FjdGlvbi5fdXR4b3MsIHNlbmRlcik7XG4gICAgY29uc3QgcmVzdWx0OiB7XG4gICAgICBpbnB1dHM6IFRyYW5zZmVyYWJsZUlucHV0W107XG4gICAgICBjcmVkZW50aWFsczogQ3JlZGVudGlhbFtdO1xuICAgIH0gPSB7IGlucHV0czogW10sIGNyZWRlbnRpYWxzOiBbXSB9O1xuXG4gICAgaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBjb25zdCBzZWNwVHJhbnNmZXJJbnB1dCA9IG5ldyBTRUNQVHJhbnNmZXJJbnB1dChpbnB1dC5hbW91bnQpO1xuICAgICAgaW5wdXQuc2lnbmF0dXJlc0lkeC5mb3JFYWNoKChzaWduYXR1cmVJZHgsIGFycmF5SW5kZXgpID0+XG4gICAgICAgIHNlY3BUcmFuc2ZlcklucHV0LmFkZFNpZ25hdHVyZUlkeChzaWduYXR1cmVJZHgsIHNlbmRlclthcnJheUluZGV4XSlcbiAgICAgICk7XG4gICAgICByZXN1bHQuaW5wdXRzLnB1c2goXG4gICAgICAgIG5ldyBUcmFuc2ZlcmFibGVJbnB1dChpbnB1dC50eGlkQnVmLCBpbnB1dC5vdXRwdXRJZHgsIHRoaXMudHJhbnNhY3Rpb24uX2Fzc2V0SWQsIHNlY3BUcmFuc2ZlcklucHV0KVxuICAgICAgKTtcblxuICAgICAgcmVzdWx0LmNyZWRlbnRpYWxzLnB1c2goU2VsZWN0Q3JlZGVudGlhbENsYXNzKHNlY3BUcmFuc2ZlcklucHV0LmdldENyZWRlbnRpYWxJRCgpLCBpbnB1dC5zaWduYXR1cmVzKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyAuLi5yZXN1bHQsIGFtb3VudCB9O1xuICB9XG59XG4iXX0=