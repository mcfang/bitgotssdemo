"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DelegatorTxBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const transactionBuilder_1 = require("./transactionBuilder");
const platformvm_1 = require("avalanche/dist/apis/platformvm");
const avalanche_1 = require("avalanche");
const iface_1 = require("./iface");
const utils_1 = __importDefault(require("./utils"));
const utxoEngine_1 = require("./utxoEngine");
class DelegatorTxBuilder extends transactionBuilder_1.TransactionBuilder {
    /**
     *
     * @param coinConfig
     */
    constructor(coinConfig) {
        super(coinConfig);
        const network = coinConfig.network;
        this._stakeAmount = new avalanche_1.BN(network.minStake);
    }
    /**
     * get transaction type
     * @protected
     */
    get transactionType() {
        return sdk_core_1.TransactionType.AddDelegator;
    }
    /**
     * Addresses where reward should be deposit
     * @param {string | string[]} address - single address or array of addresses to receive rewards
     */
    rewardAddresses(address) {
        const rewardAddresses = address instanceof Array ? address : [address];
        this.transaction._rewardAddresses = rewardAddresses.map(utils_1.default.parseAddress);
        return this;
    }
    /**
     *
     * @param nodeID
     */
    nodeID(value) {
        this.validateNodeID(value);
        this._nodeID = value;
        return this;
    }
    /**
     * start time of staking period
     * @param value
     */
    startTime(value) {
        this._startTime = new avalanche_1.BN(value);
        return this;
    }
    /**
     * end time of staking period
     * @param value
     */
    endTime(value) {
        this._endTime = new avalanche_1.BN(value);
        return this;
    }
    /**
     *
     * @param value
     */
    stakeAmount(value) {
        const valueBN = avalanche_1.BN.isBN(value) ? value : new avalanche_1.BN(value);
        this.validateStakeAmount(valueBN);
        this._stakeAmount = valueBN;
        return this;
    }
    // region Validators
    /**
     * validates a correct NodeID is used
     * @param nodeID
     */
    validateNodeID(nodeID) {
        if (!nodeID) {
            throw new sdk_core_1.BuildTransactionError('Invalid transaction: missing nodeID');
        }
        if (nodeID.slice(0, 6) !== 'NodeID') {
            throw new sdk_core_1.BuildTransactionError('Invalid transaction: invalid NodeID tag');
        }
        const bintools = avalanche_1.BinTools.getInstance();
        if (!(bintools.b58ToBuffer(nodeID.slice(7)).length === 24)) {
            throw new sdk_core_1.BuildTransactionError('Invalid transaction: NodeID is not in cb58 format');
        }
    }
    /**
     *
     *   protected _startTime: Date;
     *   protected _endTime: Date;
     *   2 weeks = 1209600
     *   1 year = 31556926
     *   unix time stamp based off seconds
     */
    validateStakeDuration(startTime, endTime) {
        const oneDayLater = new avalanche_1.BN(Date.now()).add(new avalanche_1.BN(86400));
        if (!startTime.gt(oneDayLater)) {
            throw new sdk_core_1.BuildTransactionError('Start time needs to be one day greater than current time');
        }
        if (endTime < startTime) {
            throw new sdk_core_1.BuildTransactionError('End date cannot be less than start date');
        }
        if (startTime.add(new avalanche_1.BN(this.transaction._network.minStakeDuration)).gt(endTime)) {
            throw new sdk_core_1.BuildTransactionError('End date must be greater than or equal to two weeks');
        }
        if (endTime.gt(startTime.add(new avalanche_1.BN(this.transaction._network.maxStakeDuration)))) {
            throw new sdk_core_1.BuildTransactionError('End date must be less than or equal to one year');
        }
    }
    /**
     *
     * @param amount
     */
    validateStakeAmount(amount) {
        const minStake = new avalanche_1.BN(this.transaction._network.minStake);
        if (amount.lt(minStake)) {
            throw new sdk_core_1.BuildTransactionError('Minimum staking amount is ' + Number(minStake) / 1000000000 + ' AVAX.');
        }
    }
    // endregion
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        const baseTx = tx.getUnsignedTx().getTransaction();
        if (!this.verifyTxType(baseTx)) {
            throw new sdk_core_1.NotSupported('Transaction cannot be parsed or has an unsupported transaction type');
        }
        // The StakeOuts is a {@link stakeTransferOut} result.
        // It's expected to have only one outputs with the addresses of the sender.
        const outputs = baseTx.getStakeOuts();
        if (outputs.length != 1) {
            throw new sdk_core_1.BuildTransactionError('Transaction can have one external output');
        }
        const output = outputs[0];
        if (!output.getAssetID().equals(this.transaction._assetId)) {
            throw new Error('The Asset ID of the output does not match the transaction');
        }
        const secpOut = output.getOutput();
        this.transaction._locktime = secpOut.getLocktime();
        this.transaction._threshold = secpOut.getThreshold();
        // output addresses are the sender addresses
        this.transaction._fromAddresses = secpOut.getAddresses();
        this._nodeID = baseTx.getNodeIDString();
        this._startTime = baseTx.getStartTime();
        this._endTime = baseTx.getEndTime();
        this._stakeAmount = baseTx.getStakeAmount();
        this.transaction._utxos = utxoEngine_1.recoverUtxos(baseTx.getIns());
        return this;
    }
    static verifyTxType(baseTx) {
        return baseTx.getTypeID() === platformvm_1.PlatformVMConstants.ADDVALIDATORTX;
    }
    verifyTxType(baseTx) {
        return DelegatorTxBuilder.verifyTxType(baseTx);
    }
    /**
     *
     * @protected
     */
    buildAvaxTransaction() {
        this.validateStakeDuration(this._startTime, this._endTime);
        const { inputs, outputs, credentials } = this.createInputOutput();
        this.transaction.setTransaction(new platformvm_1.Tx(new platformvm_1.UnsignedTx(new platformvm_1.AddDelegatorTx(this.transaction._networkID, this.transaction._blockchainID, outputs, inputs, this.transaction._memo, utils_1.default.NodeIDStringToBuffer(this._nodeID), this._startTime, this._endTime, this._stakeAmount, [this.stakeTransferOut()], this.rewardOwnersOutput())), credentials));
    }
    /**
     * Create the StakeOut where the recipient address are the sender.
     * @protected
     *
     */
    stakeTransferOut() {
        return new platformvm_1.TransferableOutput(this.transaction._assetId, new platformvm_1.SECPTransferOutput(this._stakeAmount, this.transaction._fromAddresses, this.transaction._locktime, this.transaction._threshold));
    }
    rewardOwnersOutput() {
        // if there are no reward addresses, the sender gets the rewards
        if (!this.transaction._rewardAddresses || this.transaction._rewardAddresses.length === 0) {
            this.transaction._rewardAddresses = this.transaction._fromAddresses;
        }
        return new platformvm_1.ParseableOutput(new platformvm_1.SECPOwnerOutput(this.transaction._rewardAddresses, this.transaction._locktime, this.transaction._threshold));
    }
    /**
     * Threshold must be 2 and since output always get reordered we want to make sure we can always add signatures in the correct location
     * To find the correct location for the signature, we use the ouput's addresses to create the signatureIdx in the order that we desire
     * 0: user key, 1: hsm key, 2: recovery key
     * @protected
     */
    createInputOutput() {
        const inputs = [];
        const outputs = [];
        // amount spent so far
        let currentTotal = new avalanche_1.BN(0);
        // delegating and validating have no fees
        const totalTarget = this._stakeAmount.clone();
        const credentials = [];
        // convert fromAddresses to string
        // fromAddresses = bitgo order if we are in WP
        // fromAddresses = onchain order if we are in from
        const bitgoAddresses = this.transaction._fromAddresses.map((b) => utils_1.default.addressToString(this.transaction._network.hrp, this.transaction._network.alias, b));
        /*
        A = user key
        B = hsm key
        C = backup key
        bitgoAddresses = bitgo addresses [ A, B, C ]
        utxo.addresses = IMS addresses [ B, C, A ]
        utxo.addressesIndex = [ 2, 0, 1 ]
        we pick 0, 1 for non-recovery
        we pick 1, 2 for recovery
        */
        this.transaction._utxos.forEach((utxo) => {
            // in WP, output.addressesIndex is empty, so fill it
            if (!utxo.addressesIndex || utxo.addressesIndex.length === 0) {
                utxo.addressesIndex = bitgoAddresses.map((a) => utxo.addresses.indexOf(a));
            }
            // in OVC, output.addressesIndex is defined correctly from the previous iteration
        });
        // validate the utxos
        this.transaction._utxos.forEach((utxo) => {
            var _a;
            if (!utxo) {
                throw new sdk_core_1.BuildTransactionError('Utxo is undefined');
            }
            // addressesIndex should neve have a mismatch
            if ((_a = utxo.addressesIndex) === null || _a === void 0 ? void 0 : _a.includes(-1)) {
                throw new sdk_core_1.BuildTransactionError('Addresses are inconsistent');
            }
            if (utxo.threshold !== this.transaction._threshold) {
                throw new sdk_core_1.BuildTransactionError('Threshold is inconsistent');
            }
        });
        // if we are in OVC, none of the utxos will have addresses since they come from
        // deserialized inputs (which don't have addresses), not the IMS
        const buildOutputs = this.transaction._utxos[0].addresses.length !== 0;
        this.transaction._utxos.forEach((utxo, i) => {
            var _a;
            if (utxo.outputID === iface_1.SECP256K1_Transfer_Output) {
                const txidBuf = utils_1.default.cb58Decode(utxo.txid);
                const amt = new avalanche_1.BN(utxo.amount);
                const outputidx = utils_1.default.outputidxNumberToBuffer(utxo.outputidx);
                const addressesIndex = (_a = utxo.addressesIndex) !== null && _a !== void 0 ? _a : [];
                // either user (0) or recovery (2)
                const firstIndex = this.recoverSigner ? 2 : 0;
                const bitgoIndex = 1;
                currentTotal = currentTotal.add(amt);
                const secpTransferInput = new platformvm_1.SECPTransferInput(amt);
                if (!buildOutputs) {
                    addressesIndex.forEach((i) => secpTransferInput.addSignatureIdx(i, this.transaction._fromAddresses[i]));
                }
                else {
                    // if user/backup > bitgo
                    if (addressesIndex[bitgoIndex] < addressesIndex[firstIndex]) {
                        secpTransferInput.addSignatureIdx(addressesIndex[bitgoIndex], this.transaction._fromAddresses[bitgoIndex]);
                        secpTransferInput.addSignatureIdx(addressesIndex[firstIndex], this.transaction._fromAddresses[firstIndex]);
                        credentials.push(platformvm_1.SelectCredentialClass(secpTransferInput.getCredentialID(), // 9
                        ['', this.transaction._fromAddresses[firstIndex].toString('hex')].map(utils_1.default.createSig)));
                    }
                    else {
                        secpTransferInput.addSignatureIdx(addressesIndex[firstIndex], this.transaction._fromAddresses[firstIndex]);
                        secpTransferInput.addSignatureIdx(addressesIndex[bitgoIndex], this.transaction._fromAddresses[bitgoIndex]);
                        credentials.push(platformvm_1.SelectCredentialClass(secpTransferInput.getCredentialID(), [this.transaction._fromAddresses[firstIndex].toString('hex'), ''].map(utils_1.default.createSig)));
                    }
                }
                const input = new platformvm_1.TransferableInput(txidBuf, outputidx, this.transaction._assetId, secpTransferInput);
                inputs.push(input);
            }
        });
        if (buildOutputs) {
            if (currentTotal.lt(totalTarget)) {
                throw new sdk_core_1.BuildTransactionError(`Utxo outputs get ${currentTotal.toString()} and ${totalTarget.toString()} is required`);
            }
            else if (currentTotal.gt(totalTarget)) {
                outputs.push(new platformvm_1.TransferableOutput(this.transaction._assetId, new platformvm_1.SECPTransferOutput(currentTotal.sub(totalTarget), this.transaction._fromAddresses, this.transaction._locktime, this.transaction._threshold)));
            }
        }
        // get outputs and credentials from the deserialized transaction if we are in OVC
        return {
            inputs,
            outputs: !buildOutputs ? this.transaction.avaxPTransaction.getOuts() : outputs,
            credentials: credentials.length === 0 ? this.transaction.credentials : credentials,
        };
    }
}
exports.DelegatorTxBuilder = DelegatorTxBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVsZWdhdG9yVHhCdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9kZWxlZ2F0b3JUeEJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsOENBQXVGO0FBRXZGLDZEQUEwRDtBQUMxRCwrREFhd0M7QUFDeEMseUNBQXlDO0FBQ3pDLG1DQUFnRTtBQUNoRSxvREFBNEI7QUFFNUIsNkNBQTRDO0FBRTVDLE1BQWEsa0JBQW1CLFNBQVEsdUNBQWtCO0lBTXhEOzs7T0FHRztJQUNILFlBQVksVUFBZ0M7UUFDMUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xCLE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxPQUEyQixDQUFDO1FBQ3ZELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxjQUFFLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFjLGVBQWU7UUFDM0IsT0FBTywwQkFBZSxDQUFDLFlBQVksQ0FBQztJQUN0QyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsZUFBZSxDQUFDLE9BQTBCO1FBQ3hDLE1BQU0sZUFBZSxHQUFHLE9BQU8sWUFBWSxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN2RSxJQUFJLENBQUMsV0FBVyxDQUFDLGdCQUFnQixHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsZUFBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzVFLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7T0FHRztJQUNILE1BQU0sQ0FBQyxLQUFhO1FBQ2xCLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDckIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7OztPQUdH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Q0FBQyxVQUFVLENBQzVCLENBQ0YsQ0FDRixDQUFDO2FBQ0g7U0FDRjtRQUNELGlGQUFpRjtRQUNqRixPQUFPO1lBQ0wsTUFBTTtZQUNOLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxnQkFBOEIsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTztZQUM3RixXQUFXLEVBQUUsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxXQUFXO1NBQ25GLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUExV0QsZ0RBMFdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVpbGRUcmFuc2FjdGlvbkVycm9yLCBOb3RTdXBwb3J0ZWQsIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBBdmFsYW5jaGVOZXR3b3JrLCBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi90cmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHtcbiAgQWRkRGVsZWdhdG9yVHgsXG4gIEJhc2VUeCBhcyBQVk1CYXNlVHgsXG4gIFBhcnNlYWJsZU91dHB1dCxcbiAgUGxhdGZvcm1WTUNvbnN0YW50cyxcbiAgU0VDUE93bmVyT3V0cHV0LFxuICBTRUNQVHJhbnNmZXJJbnB1dCxcbiAgU0VDUFRyYW5zZmVyT3V0cHV0LFxuICBTZWxlY3RDcmVkZW50aWFsQ2xhc3MsXG4gIFRyYW5zZmVyYWJsZUlucHV0LFxuICBUcmFuc2ZlcmFibGVPdXRwdXQsXG4gIFR4IGFzIFBWTVR4LFxuICBVbnNpZ25lZFR4LFxufSBmcm9tICdhdmFsYW5jaGUvZGlzdC9hcGlzL3BsYXRmb3Jtdm0nO1xuaW1wb3J0IHsgQmluVG9vbHMsIEJOIH0gZnJvbSAnYXZhbGFuY2hlJztcbmltcG9ydCB7IFNFQ1AyNTZLMV9UcmFuc2Zlcl9PdXRwdXQsIFR4LCBCYXNlVHggfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IENyZWRlbnRpYWwgfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9jb21tb24nO1xuaW1wb3J0IHsgcmVjb3ZlclV0eG9zIH0gZnJvbSAnLi91dHhvRW5naW5lJztcblxuZXhwb3J0IGNsYXNzIERlbGVnYXRvclR4QnVpbGRlciBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIHByb3RlY3RlZCBfbm9kZUlEOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBfc3RhcnRUaW1lOiBCTjtcbiAgcHJvdGVjdGVkIF9lbmRUaW1lOiBCTjtcbiAgcHJvdGVjdGVkIF9zdGFrZUFtb3VudDogQk47XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBjb2luQ29uZmlnXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2luQ29uZmlnOiBSZWFkb25seTxDb2luQ29uZmlnPikge1xuICAgIHN1cGVyKGNvaW5Db25maWcpO1xuICAgIGNvbnN0IG5ldHdvcmsgPSBjb2luQ29uZmlnLm5ldHdvcmsgYXMgQXZhbGFuY2hlTmV0d29yaztcbiAgICB0aGlzLl9zdGFrZUFtb3VudCA9IG5ldyBCTihuZXR3b3JrLm1pblN0YWtlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgdHJhbnNhY3Rpb24gdHlwZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0IHRyYW5zYWN0aW9uVHlwZSgpOiBUcmFuc2FjdGlvblR5cGUge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuQWRkRGVsZWdhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHJlc3NlcyB3aGVyZSByZXdhcmQgc2hvdWxkIGJlIGRlcG9zaXRcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gYWRkcmVzcyAtIHNpbmdsZSBhZGRyZXNzIG9yIGFycmF5IG9mIGFkZHJlc3NlcyB0byByZWNlaXZlIHJld2FyZHNcbiAgICovXG4gIHJld2FyZEFkZHJlc3NlcyhhZGRyZXNzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IHRoaXMge1xuICAgIGNvbnN0IHJld2FyZEFkZHJlc3NlcyA9IGFkZHJlc3MgaW5zdGFuY2VvZiBBcnJheSA/IGFkZHJlc3MgOiBbYWRkcmVzc107XG4gICAgdGhpcy50cmFuc2FjdGlvbi5fcmV3YXJkQWRkcmVzc2VzID0gcmV3YXJkQWRkcmVzc2VzLm1hcCh1dGlscy5wYXJzZUFkZHJlc3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBub2RlSURcbiAgICovXG4gIG5vZGVJRCh2YWx1ZTogc3RyaW5nKTogdGhpcyB7XG4gICAgdGhpcy52YWxpZGF0ZU5vZGVJRCh2YWx1ZSk7XG4gICAgdGhpcy5fbm9kZUlEID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogc3RhcnQgdGltZSBvZiBzdGFraW5nIHBlcmlvZFxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHN0YXJ0VGltZSh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogdGhpcyB7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gbmV3IEJOKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBlbmQgdGltZSBvZiBzdGFraW5nIHBlcmlvZFxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIGVuZFRpbWUodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IHRoaXMge1xuICAgIHRoaXMuX2VuZFRpbWUgPSBuZXcgQk4odmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgc3Rha2VBbW91bnQodmFsdWU6IEJOIHwgc3RyaW5nKTogdGhpcyB7XG4gICAgY29uc3QgdmFsdWVCTiA9IEJOLmlzQk4odmFsdWUpID8gdmFsdWUgOiBuZXcgQk4odmFsdWUpO1xuICAgIHRoaXMudmFsaWRhdGVTdGFrZUFtb3VudCh2YWx1ZUJOKTtcbiAgICB0aGlzLl9zdGFrZUFtb3VudCA9IHZhbHVlQk47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZWdpb24gVmFsaWRhdG9yc1xuICAvKipcbiAgICogdmFsaWRhdGVzIGEgY29ycmVjdCBOb2RlSUQgaXMgdXNlZFxuICAgKiBAcGFyYW0gbm9kZUlEXG4gICAqL1xuICB2YWxpZGF0ZU5vZGVJRChub2RlSUQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghbm9kZUlEKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBtaXNzaW5nIG5vZGVJRCcpO1xuICAgIH1cbiAgICBpZiAobm9kZUlELnNsaWNlKDAsIDYpICE9PSAnTm9kZUlEJykge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbjogaW52YWxpZCBOb2RlSUQgdGFnJyk7XG4gICAgfVxuICAgIGNvbnN0IGJpbnRvb2xzID0gQmluVG9vbHMuZ2V0SW5zdGFuY2UoKTtcbiAgICBpZiAoIShiaW50b29scy5iNThUb0J1ZmZlcihub2RlSUQuc2xpY2UoNykpLmxlbmd0aCA9PT0gMjQpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiBOb2RlSUQgaXMgbm90IGluIGNiNTggZm9ybWF0Jyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKlxuICAgKiAgIHByb3RlY3RlZCBfc3RhcnRUaW1lOiBEYXRlO1xuICAgKiAgIHByb3RlY3RlZCBfZW5kVGltZTogRGF0ZTtcbiAgICogICAyIHdlZWtzID0gMTIwOTYwMFxuICAgKiAgIDEgeWVhciA9IDMxNTU2OTI2XG4gICAqICAgdW5peCB0aW1lIHN0YW1wIGJhc2VkIG9mZiBzZWNvbmRzXG4gICAqL1xuICB2YWxpZGF0ZVN0YWtlRHVyYXRpb24oc3RhcnRUaW1lOiBCTiwgZW5kVGltZTogQk4pOiB2b2lkIHtcbiAgICBjb25zdCBvbmVEYXlMYXRlciA9IG5ldyBCTihEYXRlLm5vdygpKS5hZGQobmV3IEJOKDg2NDAwKSk7XG4gICAgaWYgKCFzdGFydFRpbWUuZ3Qob25lRGF5TGF0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdTdGFydCB0aW1lIG5lZWRzIHRvIGJlIG9uZSBkYXkgZ3JlYXRlciB0aGFuIGN1cnJlbnQgdGltZScpO1xuICAgIH1cbiAgICBpZiAoZW5kVGltZSA8IHN0YXJ0VGltZSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignRW5kIGRhdGUgY2Fubm90IGJlIGxlc3MgdGhhbiBzdGFydCBkYXRlJyk7XG4gICAgfVxuICAgIGlmIChzdGFydFRpbWUuYWRkKG5ldyBCTih0aGlzLnRyYW5zYWN0aW9uLl9uZXR3b3JrLm1pblN0YWtlRHVyYXRpb24pKS5ndChlbmRUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignRW5kIGRhdGUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdHdvIHdlZWtzJyk7XG4gICAgfVxuICAgIGlmIChlbmRUaW1lLmd0KHN0YXJ0VGltZS5hZGQobmV3IEJOKHRoaXMudHJhbnNhY3Rpb24uX25ldHdvcmsubWF4U3Rha2VEdXJhdGlvbikpKSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignRW5kIGRhdGUgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gb25lIHllYXInKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGFtb3VudFxuICAgKi9cbiAgdmFsaWRhdGVTdGFrZUFtb3VudChhbW91bnQ6IEJOKTogdm9pZCB7XG4gICAgY29uc3QgbWluU3Rha2UgPSBuZXcgQk4odGhpcy50cmFuc2FjdGlvbi5fbmV0d29yay5taW5TdGFrZSk7XG4gICAgaWYgKGFtb3VudC5sdChtaW5TdGFrZSkpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ01pbmltdW0gc3Rha2luZyBhbW91bnQgaXMgJyArIE51bWJlcihtaW5TdGFrZSkgLyAxMDAwMDAwMDAwICsgJyBBVkFYLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuZHJlZ2lvblxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpbml0QnVpbGRlcih0eDogVHgpOiB0aGlzIHtcbiAgICBzdXBlci5pbml0QnVpbGRlcih0eCk7XG4gICAgY29uc3QgYmFzZVR4OiBCYXNlVHggPSB0eC5nZXRVbnNpZ25lZFR4KCkuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICBpZiAoIXRoaXMudmVyaWZ5VHhUeXBlKGJhc2VUeCkpIHtcbiAgICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWQoJ1RyYW5zYWN0aW9uIGNhbm5vdCBiZSBwYXJzZWQgb3IgaGFzIGFuIHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGUnKTtcbiAgICB9XG4gICAgLy8gVGhlIFN0YWtlT3V0cyBpcyBhIHtAbGluayBzdGFrZVRyYW5zZmVyT3V0fSByZXN1bHQuXG4gICAgLy8gSXQncyBleHBlY3RlZCB0byBoYXZlIG9ubHkgb25lIG91dHB1dHMgd2l0aCB0aGUgYWRkcmVzc2VzIG9mIHRoZSBzZW5kZXIuXG4gICAgY29uc3Qgb3V0cHV0cyA9IGJhc2VUeC5nZXRTdGFrZU91dHMoKTtcbiAgICBpZiAob3V0cHV0cy5sZW5ndGggIT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gY2FuIGhhdmUgb25lIGV4dGVybmFsIG91dHB1dCcpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBvdXRwdXRzWzBdO1xuICAgIGlmICghb3V0cHV0LmdldEFzc2V0SUQoKS5lcXVhbHModGhpcy50cmFuc2FjdGlvbi5fYXNzZXRJZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIEFzc2V0IElEIG9mIHRoZSBvdXRwdXQgZG9lcyBub3QgbWF0Y2ggdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlY3BPdXQgPSBvdXRwdXQuZ2V0T3V0cHV0KCk7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5fbG9ja3RpbWUgPSBzZWNwT3V0LmdldExvY2t0aW1lKCk7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5fdGhyZXNob2xkID0gc2VjcE91dC5nZXRUaHJlc2hvbGQoKTtcbiAgICAvLyBvdXRwdXQgYWRkcmVzc2VzIGFyZSB0aGUgc2VuZGVyIGFkZHJlc3Nlc1xuICAgIHRoaXMudHJhbnNhY3Rpb24uX2Zyb21BZGRyZXNzZXMgPSBzZWNwT3V0LmdldEFkZHJlc3NlcygpO1xuICAgIHRoaXMuX25vZGVJRCA9IGJhc2VUeC5nZXROb2RlSURTdHJpbmcoKTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBiYXNlVHguZ2V0U3RhcnRUaW1lKCk7XG4gICAgdGhpcy5fZW5kVGltZSA9IGJhc2VUeC5nZXRFbmRUaW1lKCk7XG4gICAgdGhpcy5fc3Rha2VBbW91bnQgPSBiYXNlVHguZ2V0U3Rha2VBbW91bnQoKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLl91dHhvcyA9IHJlY292ZXJVdHhvcyhiYXNlVHguZ2V0SW5zKCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc3RhdGljIHZlcmlmeVR4VHlwZShiYXNlVHg6IEJhc2VUeCk6IGJhc2VUeCBpcyBBZGREZWxlZ2F0b3JUeCB7XG4gICAgcmV0dXJuIGJhc2VUeC5nZXRUeXBlSUQoKSA9PT0gUGxhdGZvcm1WTUNvbnN0YW50cy5BRERWQUxJREFUT1JUWDtcbiAgfVxuXG4gIHZlcmlmeVR4VHlwZShiYXNlVHg6IEJhc2VUeCk6IGJhc2VUeCBpcyBBZGREZWxlZ2F0b3JUeCB7XG4gICAgcmV0dXJuIERlbGVnYXRvclR4QnVpbGRlci52ZXJpZnlUeFR5cGUoYmFzZVR4KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgYnVpbGRBdmF4VHJhbnNhY3Rpb24oKTogdm9pZCB7XG4gICAgdGhpcy52YWxpZGF0ZVN0YWtlRHVyYXRpb24odGhpcy5fc3RhcnRUaW1lLCB0aGlzLl9lbmRUaW1lKTtcbiAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgY3JlZGVudGlhbHMgfSA9IHRoaXMuY3JlYXRlSW5wdXRPdXRwdXQoKTtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLnNldFRyYW5zYWN0aW9uKFxuICAgICAgbmV3IFBWTVR4KFxuICAgICAgICBuZXcgVW5zaWduZWRUeChcbiAgICAgICAgICBuZXcgQWRkRGVsZWdhdG9yVHgoXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLl9uZXR3b3JrSUQsXG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLl9ibG9ja2NoYWluSUQsXG4gICAgICAgICAgICBvdXRwdXRzLFxuICAgICAgICAgICAgaW5wdXRzLFxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fbWVtbyxcbiAgICAgICAgICAgIHV0aWxzLk5vZGVJRFN0cmluZ1RvQnVmZmVyKHRoaXMuX25vZGVJRCksXG4gICAgICAgICAgICB0aGlzLl9zdGFydFRpbWUsXG4gICAgICAgICAgICB0aGlzLl9lbmRUaW1lLFxuICAgICAgICAgICAgdGhpcy5fc3Rha2VBbW91bnQsXG4gICAgICAgICAgICBbdGhpcy5zdGFrZVRyYW5zZmVyT3V0KCldLFxuICAgICAgICAgICAgdGhpcy5yZXdhcmRPd25lcnNPdXRwdXQoKVxuICAgICAgICAgIClcbiAgICAgICAgKSxcbiAgICAgICAgY3JlZGVudGlhbHNcbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgU3Rha2VPdXQgd2hlcmUgdGhlIHJlY2lwaWVudCBhZGRyZXNzIGFyZSB0aGUgc2VuZGVyLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqXG4gICAqL1xuICBwcm90ZWN0ZWQgc3Rha2VUcmFuc2Zlck91dCgpOiBUcmFuc2ZlcmFibGVPdXRwdXQge1xuICAgIHJldHVybiBuZXcgVHJhbnNmZXJhYmxlT3V0cHV0KFxuICAgICAgdGhpcy50cmFuc2FjdGlvbi5fYXNzZXRJZCxcbiAgICAgIG5ldyBTRUNQVHJhbnNmZXJPdXRwdXQoXG4gICAgICAgIHRoaXMuX3N0YWtlQW1vdW50LFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLl9mcm9tQWRkcmVzc2VzLFxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLl9sb2NrdGltZSxcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fdGhyZXNob2xkXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXdhcmRPd25lcnNPdXRwdXQoKTogUGFyc2VhYmxlT3V0cHV0IHtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcmV3YXJkIGFkZHJlc3NlcywgdGhlIHNlbmRlciBnZXRzIHRoZSByZXdhcmRzXG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9uLl9yZXdhcmRBZGRyZXNzZXMgfHwgdGhpcy50cmFuc2FjdGlvbi5fcmV3YXJkQWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy50cmFuc2FjdGlvbi5fcmV3YXJkQWRkcmVzc2VzID0gdGhpcy50cmFuc2FjdGlvbi5fZnJvbUFkZHJlc3NlcztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBhcnNlYWJsZU91dHB1dChcbiAgICAgIG5ldyBTRUNQT3duZXJPdXRwdXQodGhpcy50cmFuc2FjdGlvbi5fcmV3YXJkQWRkcmVzc2VzLCB0aGlzLnRyYW5zYWN0aW9uLl9sb2NrdGltZSwgdGhpcy50cmFuc2FjdGlvbi5fdGhyZXNob2xkKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogVGhyZXNob2xkIG11c3QgYmUgMiBhbmQgc2luY2Ugb3V0cHV0IGFsd2F5cyBnZXQgcmVvcmRlcmVkIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGNhbiBhbHdheXMgYWRkIHNpZ25hdHVyZXMgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb25cbiAgICogVG8gZmluZCB0aGUgY29ycmVjdCBsb2NhdGlvbiBmb3IgdGhlIHNpZ25hdHVyZSwgd2UgdXNlIHRoZSBvdXB1dCdzIGFkZHJlc3NlcyB0byBjcmVhdGUgdGhlIHNpZ25hdHVyZUlkeCBpbiB0aGUgb3JkZXIgdGhhdCB3ZSBkZXNpcmVcbiAgICogMDogdXNlciBrZXksIDE6IGhzbSBrZXksIDI6IHJlY292ZXJ5IGtleVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBwcm90ZWN0ZWQgY3JlYXRlSW5wdXRPdXRwdXQoKToge1xuICAgIGlucHV0czogVHJhbnNmZXJhYmxlSW5wdXRbXTtcbiAgICBvdXRwdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXTtcbiAgICBjcmVkZW50aWFsczogQ3JlZGVudGlhbFtdO1xuICB9IHtcbiAgICBjb25zdCBpbnB1dHM6IFRyYW5zZmVyYWJsZUlucHV0W10gPSBbXTtcbiAgICBjb25zdCBvdXRwdXRzOiBUcmFuc2ZlcmFibGVPdXRwdXRbXSA9IFtdO1xuXG4gICAgLy8gYW1vdW50IHNwZW50IHNvIGZhclxuICAgIGxldCBjdXJyZW50VG90YWw6IEJOID0gbmV3IEJOKDApO1xuXG4gICAgLy8gZGVsZWdhdGluZyBhbmQgdmFsaWRhdGluZyBoYXZlIG5vIGZlZXNcbiAgICBjb25zdCB0b3RhbFRhcmdldCA9IHRoaXMuX3N0YWtlQW1vdW50LmNsb25lKCk7XG5cbiAgICBjb25zdCBjcmVkZW50aWFsczogQ3JlZGVudGlhbFtdID0gW107XG5cbiAgICAvLyBjb252ZXJ0IGZyb21BZGRyZXNzZXMgdG8gc3RyaW5nXG4gICAgLy8gZnJvbUFkZHJlc3NlcyA9IGJpdGdvIG9yZGVyIGlmIHdlIGFyZSBpbiBXUFxuICAgIC8vIGZyb21BZGRyZXNzZXMgPSBvbmNoYWluIG9yZGVyIGlmIHdlIGFyZSBpbiBmcm9tXG4gICAgY29uc3QgYml0Z29BZGRyZXNzZXMgPSB0aGlzLnRyYW5zYWN0aW9uLl9mcm9tQWRkcmVzc2VzLm1hcCgoYikgPT5cbiAgICAgIHV0aWxzLmFkZHJlc3NUb1N0cmluZyh0aGlzLnRyYW5zYWN0aW9uLl9uZXR3b3JrLmhycCwgdGhpcy50cmFuc2FjdGlvbi5fbmV0d29yay5hbGlhcywgYilcbiAgICApO1xuXG4gICAgLypcbiAgICBBID0gdXNlciBrZXlcbiAgICBCID0gaHNtIGtleVxuICAgIEMgPSBiYWNrdXAga2V5XG4gICAgYml0Z29BZGRyZXNzZXMgPSBiaXRnbyBhZGRyZXNzZXMgWyBBLCBCLCBDIF1cbiAgICB1dHhvLmFkZHJlc3NlcyA9IElNUyBhZGRyZXNzZXMgWyBCLCBDLCBBIF1cbiAgICB1dHhvLmFkZHJlc3Nlc0luZGV4ID0gWyAyLCAwLCAxIF1cbiAgICB3ZSBwaWNrIDAsIDEgZm9yIG5vbi1yZWNvdmVyeVxuICAgIHdlIHBpY2sgMSwgMiBmb3IgcmVjb3ZlcnlcbiAgICAqL1xuICAgIHRoaXMudHJhbnNhY3Rpb24uX3V0eG9zLmZvckVhY2goKHV0eG8pID0+IHtcbiAgICAgIC8vIGluIFdQLCBvdXRwdXQuYWRkcmVzc2VzSW5kZXggaXMgZW1wdHksIHNvIGZpbGwgaXRcbiAgICAgIGlmICghdXR4by5hZGRyZXNzZXNJbmRleCB8fCB1dHhvLmFkZHJlc3Nlc0luZGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB1dHhvLmFkZHJlc3Nlc0luZGV4ID0gYml0Z29BZGRyZXNzZXMubWFwKChhKSA9PiB1dHhvLmFkZHJlc3Nlcy5pbmRleE9mKGEpKTtcbiAgICAgIH1cbiAgICAgIC8vIGluIE9WQywgb3V0cHV0LmFkZHJlc3Nlc0luZGV4IGlzIGRlZmluZWQgY29ycmVjdGx5IGZyb20gdGhlIHByZXZpb3VzIGl0ZXJhdGlvblxuICAgIH0pO1xuXG4gICAgLy8gdmFsaWRhdGUgdGhlIHV0eG9zXG4gICAgdGhpcy50cmFuc2FjdGlvbi5fdXR4b3MuZm9yRWFjaCgodXR4bykgPT4ge1xuICAgICAgaWYgKCF1dHhvKSB7XG4gICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1V0eG8gaXMgdW5kZWZpbmVkJyk7XG4gICAgICB9XG4gICAgICAvLyBhZGRyZXNzZXNJbmRleCBzaG91bGQgbmV2ZSBoYXZlIGEgbWlzbWF0Y2hcbiAgICAgIGlmICh1dHhvLmFkZHJlc3Nlc0luZGV4Py5pbmNsdWRlcygtMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignQWRkcmVzc2VzIGFyZSBpbmNvbnNpc3RlbnQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh1dHhvLnRocmVzaG9sZCAhPT0gdGhpcy50cmFuc2FjdGlvbi5fdGhyZXNob2xkKSB7XG4gICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1RocmVzaG9sZCBpcyBpbmNvbnNpc3RlbnQnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGlmIHdlIGFyZSBpbiBPVkMsIG5vbmUgb2YgdGhlIHV0eG9zIHdpbGwgaGF2ZSBhZGRyZXNzZXMgc2luY2UgdGhleSBjb21lIGZyb21cbiAgICAvLyBkZXNlcmlhbGl6ZWQgaW5wdXRzICh3aGljaCBkb24ndCBoYXZlIGFkZHJlc3NlcyksIG5vdCB0aGUgSU1TXG4gICAgY29uc3QgYnVpbGRPdXRwdXRzID0gdGhpcy50cmFuc2FjdGlvbi5fdXR4b3NbMF0uYWRkcmVzc2VzLmxlbmd0aCAhPT0gMDtcblxuICAgIHRoaXMudHJhbnNhY3Rpb24uX3V0eG9zLmZvckVhY2goKHV0eG8sIGkpID0+IHtcbiAgICAgIGlmICh1dHhvLm91dHB1dElEID09PSBTRUNQMjU2SzFfVHJhbnNmZXJfT3V0cHV0KSB7XG4gICAgICAgIGNvbnN0IHR4aWRCdWYgPSB1dGlscy5jYjU4RGVjb2RlKHV0eG8udHhpZCk7XG4gICAgICAgIGNvbnN0IGFtdDogQk4gPSBuZXcgQk4odXR4by5hbW91bnQpO1xuICAgICAgICBjb25zdCBvdXRwdXRpZHggPSB1dGlscy5vdXRwdXRpZHhOdW1iZXJUb0J1ZmZlcih1dHhvLm91dHB1dGlkeCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3Nlc0luZGV4ID0gdXR4by5hZGRyZXNzZXNJbmRleCA/PyBbXTtcblxuICAgICAgICAvLyBlaXRoZXIgdXNlciAoMCkgb3IgcmVjb3ZlcnkgKDIpXG4gICAgICAgIGNvbnN0IGZpcnN0SW5kZXggPSB0aGlzLnJlY292ZXJTaWduZXIgPyAyIDogMDtcbiAgICAgICAgY29uc3QgYml0Z29JbmRleCA9IDE7XG4gICAgICAgIGN1cnJlbnRUb3RhbCA9IGN1cnJlbnRUb3RhbC5hZGQoYW10KTtcblxuICAgICAgICBjb25zdCBzZWNwVHJhbnNmZXJJbnB1dCA9IG5ldyBTRUNQVHJhbnNmZXJJbnB1dChhbXQpO1xuXG4gICAgICAgIGlmICghYnVpbGRPdXRwdXRzKSB7XG4gICAgICAgICAgYWRkcmVzc2VzSW5kZXguZm9yRWFjaCgoaSkgPT4gc2VjcFRyYW5zZmVySW5wdXQuYWRkU2lnbmF0dXJlSWR4KGksIHRoaXMudHJhbnNhY3Rpb24uX2Zyb21BZGRyZXNzZXNbaV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB1c2VyL2JhY2t1cCA+IGJpdGdvXG4gICAgICAgICAgaWYgKGFkZHJlc3Nlc0luZGV4W2JpdGdvSW5kZXhdIDwgYWRkcmVzc2VzSW5kZXhbZmlyc3RJbmRleF0pIHtcbiAgICAgICAgICAgIHNlY3BUcmFuc2ZlcklucHV0LmFkZFNpZ25hdHVyZUlkeChhZGRyZXNzZXNJbmRleFtiaXRnb0luZGV4XSwgdGhpcy50cmFuc2FjdGlvbi5fZnJvbUFkZHJlc3Nlc1tiaXRnb0luZGV4XSk7XG4gICAgICAgICAgICBzZWNwVHJhbnNmZXJJbnB1dC5hZGRTaWduYXR1cmVJZHgoYWRkcmVzc2VzSW5kZXhbZmlyc3RJbmRleF0sIHRoaXMudHJhbnNhY3Rpb24uX2Zyb21BZGRyZXNzZXNbZmlyc3RJbmRleF0pO1xuICAgICAgICAgICAgY3JlZGVudGlhbHMucHVzaChcbiAgICAgICAgICAgICAgU2VsZWN0Q3JlZGVudGlhbENsYXNzKFxuICAgICAgICAgICAgICAgIHNlY3BUcmFuc2ZlcklucHV0LmdldENyZWRlbnRpYWxJRCgpLCAvLyA5XG4gICAgICAgICAgICAgICAgWycnLCB0aGlzLnRyYW5zYWN0aW9uLl9mcm9tQWRkcmVzc2VzW2ZpcnN0SW5kZXhdLnRvU3RyaW5nKCdoZXgnKV0ubWFwKHV0aWxzLmNyZWF0ZVNpZylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VjcFRyYW5zZmVySW5wdXQuYWRkU2lnbmF0dXJlSWR4KGFkZHJlc3Nlc0luZGV4W2ZpcnN0SW5kZXhdLCB0aGlzLnRyYW5zYWN0aW9uLl9mcm9tQWRkcmVzc2VzW2ZpcnN0SW5kZXhdKTtcbiAgICAgICAgICAgIHNlY3BUcmFuc2ZlcklucHV0LmFkZFNpZ25hdHVyZUlkeChhZGRyZXNzZXNJbmRleFtiaXRnb0luZGV4XSwgdGhpcy50cmFuc2FjdGlvbi5fZnJvbUFkZHJlc3Nlc1tiaXRnb0luZGV4XSk7XG4gICAgICAgICAgICBjcmVkZW50aWFscy5wdXNoKFxuICAgICAgICAgICAgICBTZWxlY3RDcmVkZW50aWFsQ2xhc3MoXG4gICAgICAgICAgICAgICAgc2VjcFRyYW5zZmVySW5wdXQuZ2V0Q3JlZGVudGlhbElEKCksXG4gICAgICAgICAgICAgICAgW3RoaXMudHJhbnNhY3Rpb24uX2Zyb21BZGRyZXNzZXNbZmlyc3RJbmRleF0udG9TdHJpbmcoJ2hleCcpLCAnJ10ubWFwKHV0aWxzLmNyZWF0ZVNpZylcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbnB1dDogVHJhbnNmZXJhYmxlSW5wdXQgPSBuZXcgVHJhbnNmZXJhYmxlSW5wdXQoXG4gICAgICAgICAgdHhpZEJ1ZixcbiAgICAgICAgICBvdXRwdXRpZHgsXG4gICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fYXNzZXRJZCxcbiAgICAgICAgICBzZWNwVHJhbnNmZXJJbnB1dFxuICAgICAgICApO1xuICAgICAgICBpbnB1dHMucHVzaChpbnB1dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoYnVpbGRPdXRwdXRzKSB7XG4gICAgICBpZiAoY3VycmVudFRvdGFsLmx0KHRvdGFsVGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKFxuICAgICAgICAgIGBVdHhvIG91dHB1dHMgZ2V0ICR7Y3VycmVudFRvdGFsLnRvU3RyaW5nKCl9IGFuZCAke3RvdGFsVGFyZ2V0LnRvU3RyaW5nKCl9IGlzIHJlcXVpcmVkYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChjdXJyZW50VG90YWwuZ3QodG90YWxUYXJnZXQpKSB7XG4gICAgICAgIG91dHB1dHMucHVzaChcbiAgICAgICAgICBuZXcgVHJhbnNmZXJhYmxlT3V0cHV0KFxuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fYXNzZXRJZCxcbiAgICAgICAgICAgIG5ldyBTRUNQVHJhbnNmZXJPdXRwdXQoXG4gICAgICAgICAgICAgIGN1cnJlbnRUb3RhbC5zdWIodG90YWxUYXJnZXQpLFxuICAgICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLl9mcm9tQWRkcmVzc2VzLFxuICAgICAgICAgICAgICB0aGlzLnRyYW5zYWN0aW9uLl9sb2NrdGltZSxcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbi5fdGhyZXNob2xkXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBnZXQgb3V0cHV0cyBhbmQgY3JlZGVudGlhbHMgZnJvbSB0aGUgZGVzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGlmIHdlIGFyZSBpbiBPVkNcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRzLFxuICAgICAgb3V0cHV0czogIWJ1aWxkT3V0cHV0cyA/ICh0aGlzLnRyYW5zYWN0aW9uLmF2YXhQVHJhbnNhY3Rpb24gYXMgUFZNQmFzZVR4KS5nZXRPdXRzKCkgOiBvdXRwdXRzLFxuICAgICAgY3JlZGVudGlhbHM6IGNyZWRlbnRpYWxzLmxlbmd0aCA9PT0gMCA/IHRoaXMudHJhbnNhY3Rpb24uY3JlZGVudGlhbHMgOiBjcmVkZW50aWFscyxcbiAgICB9O1xuICB9XG59XG4iXX0=