"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const iface_1 = require("./iface");
const avalanche_1 = require("avalanche");
const utils_1 = __importDefault(require("./utils"));
function isEmptySignature(s) {
    return !!s && s.startsWith(''.padStart(90, '0'));
}
/**
 * Signatures are prestore as empty buffer for hsm and address of signar for first signature.
 * When sign is required, this method return the function that identify a signature to be replaced.
 * @param signatures any signatures as samples to identify which signature required replace.
 */
function generateSelectorSignature(signatures) {
    if (signatures.length > 1 && signatures.every((sig) => isEmptySignature(sig.bytes))) {
        // Look for address.
        return function (sig, address) {
            try {
                if (!isEmptySignature(sig.bytes)) {
                    return false;
                }
                const pub = sig.bytes.substring(90);
                return pub === address;
            }
            catch (e) {
                return false;
            }
        };
    }
    else {
        // Look for empty string
        return function (sig, address) {
            if (isEmptySignature(sig.bytes))
                return true;
            return false;
        };
    }
}
// end region utils for sign
class Transaction extends sdk_core_1.BaseTransaction {
    constructor(coinConfig) {
        super(coinConfig);
        this._threshold = 2;
        this._locktime = new avalanche_1.BN(0);
        this._fromAddresses = [];
        this._utxos = [];
        this._fee = {};
        this._network = coinConfig.network;
        this._assetId = utils_1.default.cb58Decode(this._network.avaxAssetID);
        this._blockchainID = utils_1.default.cb58Decode(this._network.blockchainID);
        this._networkID = this._network.networkID;
    }
    get avaxPTransaction() {
        return this._avaxTransaction.getUnsignedTx().getTransaction();
    }
    get signature() {
        if (this.credentials.length === 0) {
            return [];
        }
        const obj = this.credentials[0].serialize();
        return obj.sigArray.map((s) => s.bytes).filter((s) => !isEmptySignature(s));
    }
    get credentials() {
        var _a;
        // it should be this._avaxpTransaction?.getCredentials(), but EVMTx doesn't have it
        return (_a = this._avaxTransaction) === null || _a === void 0 ? void 0 : _a.credentials;
    }
    get hasCredentials() {
        return this.credentials !== undefined && this.credentials.length > 0;
    }
    /** @inheritdoc */
    canSign({ key }) {
        // TODO(BG-56700):  Improve canSign by check in addresses in empty credentials match signer
        return true;
    }
    /**
     * Sign a avaxp transaction and update the transaction hex
     * validator, delegator, import, exports extend baseTx
     * unsignedTx: UnsignedTx = new UnsignedTx(baseTx)  (baseTx = addValidatorTx)
     * const tx: Tx = unsignedTx.sign(keychain) (tx is type standard signed tx)
     * get baseTx then create new unsignedTx then sign
     *
     * @param {KeyPair} keyPair
     */
    sign(keyPair) {
        const prv = keyPair.getPrivateKey();
        const addressHex = keyPair.getAddressBuffer().toString('hex');
        if (!prv) {
            throw new sdk_core_1.SigningError('Missing private key');
        }
        if (!this.avaxPTransaction) {
            throw new sdk_core_1.InvalidTransactionError('empty transaction to sign');
        }
        if (!this.hasCredentials) {
            throw new sdk_core_1.InvalidTransactionError('empty credentials to sign');
        }
        const signature = this.createSignature(prv);
        let checkSign = undefined;
        this.credentials.forEach((c) => {
            const cs = c.serialize();
            if (checkSign === undefined) {
                checkSign = generateSelectorSignature(cs.sigArray);
            }
            let find = false;
            cs.sigArray.forEach((sig) => {
                if (checkSign && checkSign(sig, addressHex)) {
                    sig.bytes = signature;
                    find = true;
                }
            });
            if (!find)
                throw new sdk_core_1.SigningError('Private key cannot sign the transaction');
            c.deserialize(cs);
        });
    }
    /** @inheritdoc */
    /**
     * should be of signedTx doing this with baseTx
     */
    toBroadcastFormat() {
        if (!this.avaxPTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction data');
        }
        return this._avaxTransaction.toStringHex();
    }
    // types - stakingTransaction, import, export
    toJson() {
        if (!this.avaxPTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction data');
        }
        // EVMTx do not have memo.
        const memo = 'getMemo' in this.avaxPTransaction ? utils_1.default.bufferToString(this.avaxPTransaction.getMemo()) : undefined;
        return {
            id: this.id,
            inputs: this.inputs,
            fromAddresses: this.fromAddresses,
            threshold: this._threshold,
            locktime: this._locktime.toString(),
            type: this.type,
            memo,
            signatures: this.signature,
            outputs: this.outputs,
            changeOutputs: this.changeOutputs,
            sourceChain: this.sourceChain,
            destinationChain: this.destinationChain,
        };
    }
    setTransaction(tx) {
        this._avaxTransaction = tx;
    }
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType) {
        this._type = transactionType;
    }
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     */
    get signablePayload() {
        return utils_1.default.sha256(this._avaxTransaction.getUnsignedTx().toBuffer());
    }
    get id() {
        return utils_1.default.cb58Encode(avalanche_1.Buffer.from(utils_1.default.sha256(this._avaxTransaction.toBuffer())));
    }
    get fromAddresses() {
        return this._fromAddresses.map((a) => utils_1.default.addressToString(this._network.hrp, this._network.alias, a));
    }
    get rewardAddresses() {
        return this._rewardAddresses.map((a) => utils_1.default.addressToString(this._network.hrp, this._network.alias, a));
    }
    /**
     * Get the list of outputs. Amounts are expressed in absolute value.
     */
    get outputs() {
        switch (this.type) {
            case sdk_core_1.TransactionType.Import:
                return this.avaxPTransaction.getOuts().map(utils_1.default.mapOutputToEntry(this._network));
            case sdk_core_1.TransactionType.Export:
                if (utils_1.default.isTransactionOf(this._avaxTransaction, this._network.cChainBlockchainID)) {
                    return this.avaxPTransaction.getExportedOutputs().map(utils_1.default.mapOutputToEntry(this._network));
                }
                else {
                    return this.avaxPTransaction.getExportOutputs().map(utils_1.default.mapOutputToEntry(this._network));
                }
            case sdk_core_1.TransactionType.AddDelegator:
            case sdk_core_1.TransactionType.AddValidator:
                // Get staked outputs
                const addValidatorTx = this.avaxPTransaction;
                return [
                    {
                        address: addValidatorTx.getNodeIDString(),
                        value: addValidatorTx.getStakeAmount().toString(),
                    },
                ];
            default:
                return [];
        }
    }
    /**
     * Get a Transasction Fee.
     */
    get fee() {
        return { fee: '0', ...this._fee };
    }
    get changeOutputs() {
        // C-chain tx adn Import Txs don't have change outputs
        if (this.type === sdk_core_1.TransactionType.Import ||
            utils_1.default.isTransactionOf(this._avaxTransaction, this._network.cChainBlockchainID)) {
            return [];
        }
        // general support any transaction type, but it's scoped yet
        return this.avaxPTransaction.getOuts().map(utils_1.default.mapOutputToEntry(this._network));
    }
    get inputs() {
        let inputs;
        switch (this.type) {
            case sdk_core_1.TransactionType.Import:
                inputs = this.avaxPTransaction.getImportInputs();
                break;
            case sdk_core_1.TransactionType.Export:
                if (utils_1.default.isTransactionOf(this._avaxTransaction, this._network.cChainBlockchainID)) {
                    return this.avaxPTransaction.getInputs().map((evmInput) => ({
                        address: '0x' + evmInput.getAddressString(),
                        value: new avalanche_1.BN(evmInput.amount).toString(),
                        nonce: evmInput.getNonce().toNumber(),
                    }));
                }
                inputs = this.avaxPTransaction.getIns();
                break;
            default:
                inputs = this.avaxPTransaction.getIns();
        }
        return inputs.map((input) => {
            const amountInput = input.getInput();
            return {
                id: utils_1.default.cb58Encode(input.getTxID()) + iface_1.INPUT_SEPARATOR + utils_1.default.outputidxBufferToNumber(input.getOutputIdx()),
                address: this.fromAddresses.sort().join(iface_1.ADDRESS_SEPARATOR),
                value: amountInput.getAmount().toString(),
            };
        });
    }
    /**
     * Avax wrapper to create signature and return it for credentials
     * @param prv
     * @return hexstring
     */
    createSignature(prv) {
        const signval = utils_1.default.createSignatureAvaxBuffer(this._network, avalanche_1.Buffer.from(this.signablePayload), avalanche_1.Buffer.from(prv));
        return signval.toString('hex');
    }
    /** @inheritdoc */
    explainTransaction() {
        const txJson = this.toJson();
        const displayOrder = [
            'id',
            'inputs',
            'outputAmount',
            'changeAmount',
            'outputs',
            'changeOutputs',
            'fee',
            'type',
            'memo',
        ];
        const outputAmount = txJson.outputs.reduce((p, n) => p.add(new avalanche_1.BN(n.value)), new avalanche_1.BN(0)).toString();
        const changeAmount = txJson.changeOutputs.reduce((p, n) => p.add(new avalanche_1.BN(n.value)), new avalanche_1.BN(0)).toString();
        let rewardAddresses;
        if ([sdk_core_1.TransactionType.AddValidator, sdk_core_1.TransactionType.AddDelegator].includes(txJson.type)) {
            rewardAddresses = this.rewardAddresses;
            displayOrder.splice(6, 0, 'rewardAddresses');
        }
        return {
            displayOrder,
            id: txJson.id,
            inputs: txJson.inputs,
            outputs: txJson.outputs.map((o) => ({ address: o.address, amount: o.value })),
            outputAmount,
            changeOutputs: txJson.changeOutputs.map((o) => ({ address: o.address, amount: o.value })),
            changeAmount,
            rewardAddresses,
            fee: this.fee,
            type: txJson.type,
            memo: txJson.memo,
        };
    }
    /**
     * Check if this transaction is a P chain
     */
    get isTransactionForCChain() {
        return utils_1.default.isTransactionOf(this._avaxTransaction, this._network.cChainBlockchainID);
    }
    /**
     * get the source chain id or undefined if it's a cross chain transfer.
     */
    get sourceChain() {
        let blockchainID;
        switch (this.type) {
            case sdk_core_1.TransactionType.Import:
                blockchainID = this.avaxPTransaction.getSourceChain();
                break;
            case sdk_core_1.TransactionType.Export:
                blockchainID = this.avaxPTransaction.getBlockchainID();
                break;
            default:
                return undefined;
        }
        return this.blockchainIDtoAlias(blockchainID);
    }
    /**
     * get the destinationChain or undefined if it's a cross chain transfer.
     */
    get destinationChain() {
        let blockchainID;
        switch (this.type) {
            case sdk_core_1.TransactionType.Import:
                blockchainID = this.avaxPTransaction.getBlockchainID();
                break;
            case sdk_core_1.TransactionType.Export:
                blockchainID = this.avaxPTransaction.getDestinationChain();
                break;
            default:
                return undefined;
        }
        return this.blockchainIDtoAlias(blockchainID);
    }
    /**
     * Convert a blockchainId buffer to string and return P or C alias if match of any of that chains.
     * @param {BufferAvax} blockchainIDBuffer
     * @return {string} blocchainID or alias if exists.
     * @private
     */
    blockchainIDtoAlias(blockchainIDBuffer) {
        const blockchainId = utils_1.default.cb58Encode(blockchainIDBuffer);
        switch (blockchainId) {
            case this._network.cChainBlockchainID:
                return 'C';
            case this._network.blockchainID:
                return 'P';
            default:
                return blockchainId;
        }
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLDhDQVF5QjtBQUV6QixtQ0FRaUI7QUFHakIseUNBQXFEO0FBQ3JELG9EQUE0QjtBQVk1QixTQUFTLGdCQUFnQixDQUFDLENBQVM7SUFDakMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNuRCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMseUJBQXlCLENBQUMsVUFBaUM7SUFDbEUsSUFBSSxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtRQUNuRixvQkFBb0I7UUFDcEIsT0FBTyxVQUFVLEdBQUcsRUFBRSxPQUFPO1lBQzNCLElBQUk7Z0JBQ0YsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDaEMsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7Z0JBQ0QsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQ3BDLE9BQU8sR0FBRyxLQUFLLE9BQU8sQ0FBQzthQUN4QjtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE9BQU8sS0FBSyxDQUFDO2FBQ2Q7UUFDSCxDQUFDLENBQUM7S0FDSDtTQUFNO1FBQ0wsd0JBQXdCO1FBQ3hCLE9BQU8sVUFBVSxHQUFHLEVBQUUsT0FBTztZQUMzQixJQUFJLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7Z0JBQUUsT0FBTyxJQUFJ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O1lBQ2I7Z0JBQ0UsT0FBTyxZQUFZLENBQUM7U0FDdkI7SUFDSCxDQUFDO0NBQ0Y7QUEzVkQsa0NBMlZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXZhbGFuY2hlTmV0d29yaywgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7XG4gIEJhc2VLZXksXG4gIEJhc2VUcmFuc2FjdGlvbixcbiAgRW50cnksXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxuICBTaWduaW5nRXJyb3IsXG4gIFRyYW5zYWN0aW9uRmVlLFxuICBUcmFuc2FjdGlvblR5cGUsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcbmltcG9ydCB7XG4gIEJhc2VUeCxcbiAgRGVjb2RlZFV0eG9PYmosXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIFR4LFxuICBUeERhdGEsXG4gIElOUFVUX1NFUEFSQVRPUixcbiAgQUREUkVTU19TRVBBUkFUT1IsXG59IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgQWRkRGVsZWdhdG9yVHgsIEFtb3VudElucHV0LCBCYXNlVHggYXMgUFZNQmFzZVR4LCBFeHBvcnRUeCwgSW1wb3J0VHggfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9hcGlzL3BsYXRmb3Jtdm0nO1xuaW1wb3J0IHsgRXhwb3J0VHggYXMgRVZNRXhwb3J0VHgsIEltcG9ydFR4IGFzIEVWTUltcG9ydFR4IH0gZnJvbSAnYXZhbGFuY2hlL2Rpc3QvYXBpcy9ldm0nO1xuaW1wb3J0IHsgQk4sIEJ1ZmZlciBhcyBCdWZmZXJBdmF4IH0gZnJvbSAnYXZhbGFuY2hlJztcbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IENyZWRlbnRpYWwgfSBmcm9tICdhdmFsYW5jaGUvZGlzdC9jb21tb24nO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcblxuLy8gcmVnaW9uIHV0aWxzIHRvIHNpZ25cbmludGVyZmFjZSBzaWduYXR1cmVTZXJpYWxpemVkIHtcbiAgYnl0ZXM6IHN0cmluZztcbn1cbmludGVyZmFjZSBDaGVja1NpZ25hdHVyZSB7XG4gIChzaWdhdHVyZTogc2lnbmF0dXJlU2VyaWFsaXplZCwgYWRkcmVzc0hleDogc3RyaW5nKTogYm9vbGVhbjtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eVNpZ25hdHVyZShzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuICEhcyAmJiBzLnN0YXJ0c1dpdGgoJycucGFkU3RhcnQoOTAsICcwJykpO1xufVxuXG4vKipcbiAqIFNpZ25hdHVyZXMgYXJlIHByZXN0b3JlIGFzIGVtcHR5IGJ1ZmZlciBmb3IgaHNtIGFuZCBhZGRyZXNzIG9mIHNpZ25hciBmb3IgZmlyc3Qgc2lnbmF0dXJlLlxuICogV2hlbiBzaWduIGlzIHJlcXVpcmVkLCB0aGlzIG1ldGhvZCByZXR1cm4gdGhlIGZ1bmN0aW9uIHRoYXQgaWRlbnRpZnkgYSBzaWduYXR1cmUgdG8gYmUgcmVwbGFjZWQuXG4gKiBAcGFyYW0gc2lnbmF0dXJlcyBhbnkgc2lnbmF0dXJlcyBhcyBzYW1wbGVzIHRvIGlkZW50aWZ5IHdoaWNoIHNpZ25hdHVyZSByZXF1aXJlZCByZXBsYWNlLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNlbGVjdG9yU2lnbmF0dXJlKHNpZ25hdHVyZXM6IHNpZ25hdHVyZVNlcmlhbGl6ZWRbXSk6IENoZWNrU2lnbmF0dXJlIHtcbiAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID4gMSAmJiBzaWduYXR1cmVzLmV2ZXJ5KChzaWcpID0+IGlzRW1wdHlTaWduYXR1cmUoc2lnLmJ5dGVzKSkpIHtcbiAgICAvLyBMb29rIGZvciBhZGRyZXNzLlxuICAgIHJldHVybiBmdW5jdGlvbiAoc2lnLCBhZGRyZXNzKTogYm9vbGVhbiB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlzRW1wdHlTaWduYXR1cmUoc2lnLmJ5dGVzKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWIgPSBzaWcuYnl0ZXMuc3Vic3RyaW5nKDkwKTtcbiAgICAgICAgcmV0dXJuIHB1YiA9PT0gYWRkcmVzcztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gTG9vayBmb3IgZW1wdHkgc3RyaW5nXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzaWcsIGFkZHJlc3MpOiBib29sZWFuIHtcbiAgICAgIGlmIChpc0VtcHR5U2lnbmF0dXJlKHNpZy5ieXRlcykpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbi8vIGVuZCByZWdpb24gdXRpbHMgZm9yIHNpZ25cblxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uIHtcbiAgcHJvdGVjdGVkIF9hdmF4VHJhbnNhY3Rpb246IFR4O1xuICBwdWJsaWMgX3R5cGU6IFRyYW5zYWN0aW9uVHlwZTtcbiAgcHVibGljIF9uZXR3b3JrOiBBdmFsYW5jaGVOZXR3b3JrO1xuICBwdWJsaWMgX25ldHdvcmtJRDogbnVtYmVyO1xuICBwdWJsaWMgX2Fzc2V0SWQ6IEJ1ZmZlckF2YXg7XG4gIHB1YmxpYyBfYmxvY2tjaGFpbklEOiBCdWZmZXJBdmF4O1xuICBwdWJsaWMgX21lbW8/OiBCdWZmZXJBdmF4O1xuICBwdWJsaWMgX3RocmVzaG9sZCA9IDI7XG4gIHB1YmxpYyBfbG9ja3RpbWU6IEJOID0gbmV3IEJOKDApO1xuICBwdWJsaWMgX2Zyb21BZGRyZXNzZXM6IEJ1ZmZlckF2YXhbXSA9IFtdO1xuICBwdWJsaWMgX3Jld2FyZEFkZHJlc3NlczogQnVmZmVyQXZheFtdO1xuICBwdWJsaWMgX3V0eG9zOiBEZWNvZGVkVXR4b09ialtdID0gW107XG4gIHB1YmxpYyBfdG86IEJ1ZmZlckF2YXhbXTtcbiAgcHVibGljIF9mZWU6IFBhcnRpYWw8VHJhbnNhY3Rpb25GZWU+ID0ge307XG5cbiAgY29uc3RydWN0b3IoY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihjb2luQ29uZmlnKTtcbiAgICB0aGlzLl9uZXR3b3JrID0gY29pbkNvbmZpZy5uZXR3b3JrIGFzIEF2YWxhbmNoZU5ldHdvcms7XG4gICAgdGhpcy5fYXNzZXRJZCA9IHV0aWxzLmNiNThEZWNvZGUodGhpcy5fbmV0d29yay5hdmF4QXNzZXRJRCk7XG4gICAgdGhpcy5fYmxvY2tjaGFpbklEID0gdXRpbHMuY2I1OERlY29kZSh0aGlzLl9uZXR3b3JrLmJsb2NrY2hhaW5JRCk7XG4gICAgdGhpcy5fbmV0d29ya0lEID0gdGhpcy5fbmV0d29yay5uZXR3b3JrSUQ7XG4gIH1cblxuICBnZXQgYXZheFBUcmFuc2FjdGlvbigpOiBCYXNlVHgge1xuICAgIHJldHVybiB0aGlzLl9hdmF4VHJhbnNhY3Rpb24uZ2V0VW5zaWduZWRUeCgpLmdldFRyYW5zYWN0aW9uKCk7XG4gIH1cblxuICBnZXQgc2lnbmF0dXJlKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAodGhpcy5jcmVkZW50aWFscy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB0aGlzLmNyZWRlbnRpYWxzWzBdLnNlcmlhbGl6ZSgpO1xuICAgIHJldHVybiBvYmouc2lnQXJyYXkubWFwKChzKSA9PiBzLmJ5dGVzKS5maWx0ZXIoKHMpID0+ICFpc0VtcHR5U2lnbmF0dXJlKHMpKTtcbiAgfVxuXG4gIGdldCBjcmVkZW50aWFscygpOiBDcmVkZW50aWFsW10ge1xuICAgIC8vIGl0IHNob3VsZCBiZSB0aGlzLl9hdmF4cFRyYW5zYWN0aW9uPy5nZXRDcmVkZW50aWFscygpLCBidXQgRVZNVHggZG9lc24ndCBoYXZlIGl0XG4gICAgcmV0dXJuICh0aGlzLl9hdmF4VHJhbnNhY3Rpb24gYXMgYW55KT8uY3JlZGVudGlhbHM7XG4gIH1cblxuICBnZXQgaGFzQ3JlZGVudGlhbHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmNyZWRlbnRpYWxzLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgY2FuU2lnbih7IGtleSB9OiBCYXNlS2V5KTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETyhCRy01NjcwMCk6ICBJbXByb3ZlIGNhblNpZ24gYnkgY2hlY2sgaW4gYWRkcmVzc2VzIGluIGVtcHR5IGNyZWRlbnRpYWxzIG1hdGNoIHNpZ25lclxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gYSBhdmF4cCB0cmFuc2FjdGlvbiBhbmQgdXBkYXRlIHRoZSB0cmFuc2FjdGlvbiBoZXhcbiAgICogdmFsaWRhdG9yLCBkZWxlZ2F0b3IsIGltcG9ydCwgZXhwb3J0cyBleHRlbmQgYmFzZVR4XG4gICAqIHVuc2lnbmVkVHg6IFVuc2lnbmVkVHggPSBuZXcgVW5zaWduZWRUeChiYXNlVHgpICAoYmFzZVR4ID0gYWRkVmFsaWRhdG9yVHgpXG4gICAqIGNvbnN0IHR4OiBUeCA9IHVuc2lnbmVkVHguc2lnbihrZXljaGFpbikgKHR4IGlzIHR5cGUgc3RhbmRhcmQgc2lnbmVkIHR4KVxuICAgKiBnZXQgYmFzZVR4IHRoZW4gY3JlYXRlIG5ldyB1bnNpZ25lZFR4IHRoZW4gc2lnblxuICAgKlxuICAgKiBAcGFyYW0ge0tleVBhaXJ9IGtleVBhaXJcbiAgICovXG4gIHNpZ24oa2V5UGFpcjogS2V5UGFpcik6IHZvaWQge1xuICAgIGNvbnN0IHBydiA9IGtleVBhaXIuZ2V0UHJpdmF0ZUtleSgpO1xuICAgIGNvbnN0IGFkZHJlc3NIZXggPSBrZXlQYWlyLmdldEFkZHJlc3NCdWZmZXIoKS50b1N0cmluZygnaGV4Jyk7XG4gICAgaWYgKCFwcnYpIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmF2YXhQVHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignZW1wdHkgdHJhbnNhY3Rpb24gdG8gc2lnbicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzQ3JlZGVudGlhbHMpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignZW1wdHkgY3JlZGVudGlhbHMgdG8gc2lnbicpO1xuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLmNyZWF0ZVNpZ25hdHVyZShwcnYpO1xuICAgIGxldCBjaGVja1NpZ246IENoZWNrU2lnbmF0dXJlIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY3JlZGVudGlhbHMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgY29uc3QgY3M6IGFueSA9IGMuc2VyaWFsaXplKCk7XG4gICAgICBpZiAoY2hlY2tTaWduID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hlY2tTaWduID0gZ2VuZXJhdGVTZWxlY3RvclNpZ25hdHVyZShjcy5zaWdBcnJheSk7XG4gICAgICB9XG4gICAgICBsZXQgZmluZCA9IGZhbHNlO1xuICAgICAgY3Muc2lnQXJyYXkuZm9yRWFjaCgoc2lnKSA9PiB7XG4gICAgICAgIGlmIChjaGVja1NpZ24gJiYgY2hlY2tTaWduKHNpZywgYWRkcmVzc0hleCkpIHtcbiAgICAgICAgICBzaWcuYnl0ZXMgPSBzaWduYXR1cmU7XG4gICAgICAgICAgZmluZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFmaW5kKSB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdQcml2YXRlIGtleSBjYW5ub3Qgc2lnbiB0aGUgdHJhbnNhY3Rpb24nKTtcbiAgICAgIGMuZGVzZXJpYWxpemUoY3MpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIC8qKlxuICAgKiBzaG91bGQgYmUgb2Ygc2lnbmVkVHggZG9pbmcgdGhpcyB3aXRoIGJhc2VUeFxuICAgKi9cbiAgdG9Ccm9hZGNhc3RGb3JtYXQoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuYXZheFBUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbiBkYXRhJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hdmF4VHJhbnNhY3Rpb24udG9TdHJpbmdIZXgoKTtcbiAgfVxuXG4gIC8vIHR5cGVzIC0gc3Rha2luZ1RyYW5zYWN0aW9uLCBpbXBvcnQsIGV4cG9ydFxuICB0b0pzb24oKTogVHhEYXRhIHtcbiAgICBpZiAoIXRoaXMuYXZheFBUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbiBkYXRhJyk7XG4gICAgfVxuICAgIC8vIEVWTVR4IGRvIG5vdCBoYXZlIG1lbW8uXG4gICAgY29uc3QgbWVtbyA9ICdnZXRNZW1vJyBpbiB0aGlzLmF2YXhQVHJhbnNhY3Rpb24gPyB1dGlscy5idWZmZXJUb1N0cmluZyh0aGlzLmF2YXhQVHJhbnNhY3Rpb24uZ2V0TWVtbygpKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLFxuICAgICAgZnJvbUFkZHJlc3NlczogdGhpcy5mcm9tQWRkcmVzc2VzLFxuICAgICAgdGhyZXNob2xkOiB0aGlzLl90aHJlc2hvbGQsXG4gICAgICBsb2NrdGltZTogdGhpcy5fbG9ja3RpbWUudG9TdHJpbmcoKSxcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIG1lbW8sXG4gICAgICBzaWduYXR1cmVzOiB0aGlzLnNpZ25hdHVyZSxcbiAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0cyxcbiAgICAgIGNoYW5nZU91dHB1dHM6IHRoaXMuY2hhbmdlT3V0cHV0cyxcbiAgICAgIHNvdXJjZUNoYWluOiB0aGlzLnNvdXJjZUNoYWluLFxuICAgICAgZGVzdGluYXRpb25DaGFpbjogdGhpcy5kZXN0aW5hdGlvbkNoYWluLFxuICAgIH07XG4gIH1cblxuICBzZXRUcmFuc2FjdGlvbih0eDogVHgpOiB2b2lkIHtcbiAgICB0aGlzLl9hdmF4VHJhbnNhY3Rpb24gPSB0eDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHRyYW5zYWN0aW9uIHR5cGVcbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblR5cGV9IHRyYW5zYWN0aW9uVHlwZSBUaGUgdHJhbnNhY3Rpb24gdHlwZSB0byBiZSBzZXRcbiAgICovXG4gIHNldFRyYW5zYWN0aW9uVHlwZSh0cmFuc2FjdGlvblR5cGU6IFRyYW5zYWN0aW9uVHlwZSk6IHZvaWQge1xuICAgIHRoaXMuX3R5cGUgPSB0cmFuc2FjdGlvblR5cGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9ydGlvbiBvZiB0aGUgdHJhbnNhY3Rpb24gdGhhdCBuZWVkcyB0byBiZSBzaWduZWQgaW4gQnVmZmVyIGZvcm1hdC5cbiAgICogT25seSBuZWVkZWQgZm9yIGNvaW5zIHRoYXQgc3VwcG9ydCBhZGRpbmcgc2lnbmF0dXJlcyBkaXJlY3RseSAoZS5nLiBUU1MpLlxuICAgKi9cbiAgZ2V0IHNpZ25hYmxlUGF5bG9hZCgpOiBCdWZmZXIge1xuICAgIHJldHVybiB1dGlscy5zaGEyNTYodGhpcy5fYXZheFRyYW5zYWN0aW9uLmdldFVuc2lnbmVkVHgoKS50b0J1ZmZlcigpKTtcbiAgfVxuXG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB1dGlscy5jYjU4RW5jb2RlKEJ1ZmZlckF2YXguZnJvbSh1dGlscy5zaGEyNTYodGhpcy5fYXZheFRyYW5zYWN0aW9uLnRvQnVmZmVyKCkpKSk7XG4gIH1cblxuICBnZXQgZnJvbUFkZHJlc3NlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2Zyb21BZGRyZXNzZXMubWFwKChhKSA9PiB1dGlscy5hZGRyZXNzVG9TdHJpbmcodGhpcy5fbmV0d29yay5ocnAsIHRoaXMuX25ldHdvcmsuYWxpYXMsIGEpKTtcbiAgfVxuXG4gIGdldCByZXdhcmRBZGRyZXNzZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLl9yZXdhcmRBZGRyZXNzZXMubWFwKChhKSA9PiB1dGlscy5hZGRyZXNzVG9TdHJpbmcodGhpcy5fbmV0d29yay5ocnAsIHRoaXMuX25ldHdvcmsuYWxpYXMsIGEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2Ygb3V0cHV0cy4gQW1vdW50cyBhcmUgZXhwcmVzc2VkIGluIGFic29sdXRlIHZhbHVlLlxuICAgKi9cbiAgZ2V0IG91dHB1dHMoKTogRW50cnlbXSB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkltcG9ydDpcbiAgICAgICAgcmV0dXJuICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgSW1wb3J0VHggfCBFVk1JbXBvcnRUeCkuZ2V0T3V0cygpLm1hcCh1dGlscy5tYXBPdXRwdXRUb0VudHJ5KHRoaXMuX25ldHdvcmspKTtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkV4cG9ydDpcbiAgICAgICAgaWYgKHV0aWxzLmlzVHJhbnNhY3Rpb25PZih0aGlzLl9hdmF4VHJhbnNhY3Rpb24sIHRoaXMuX25ldHdvcmsuY0NoYWluQmxvY2tjaGFpbklEKSkge1xuICAgICAgICAgIHJldHVybiAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEVWTUV4cG9ydFR4KS5nZXRFeHBvcnRlZE91dHB1dHMoKS5tYXAodXRpbHMubWFwT3V0cHV0VG9FbnRyeSh0aGlzLl9uZXR3b3JrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgRXhwb3J0VHgpLmdldEV4cG9ydE91dHB1dHMoKS5tYXAodXRpbHMubWFwT3V0cHV0VG9FbnRyeSh0aGlzLl9uZXR3b3JrKSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZERlbGVnYXRvcjpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkFkZFZhbGlkYXRvcjpcbiAgICAgICAgLy8gR2V0IHN0YWtlZCBvdXRwdXRzXG4gICAgICAgIGNvbnN0IGFkZFZhbGlkYXRvclR4ID0gdGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEFkZERlbGVnYXRvclR4O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZFZhbGlkYXRvclR4LmdldE5vZGVJRFN0cmluZygpLFxuICAgICAgICAgICAgdmFsdWU6IGFkZFZhbGlkYXRvclR4LmdldFN0YWtlQW1vdW50KCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBUcmFuc2FzY3Rpb24gRmVlLlxuICAgKi9cbiAgZ2V0IGZlZSgpOiBUcmFuc2FjdGlvbkZlZSB7XG4gICAgcmV0dXJuIHsgZmVlOiAnMCcsIC4uLnRoaXMuX2ZlZSB9O1xuICB9XG5cbiAgZ2V0IGNoYW5nZU91dHB1dHMoKTogRW50cnlbXSB7XG4gICAgLy8gQy1jaGFpbiB0eCBhZG4gSW1wb3J0IFR4cyBkb24ndCBoYXZlIGNoYW5nZSBvdXRwdXRzXG4gICAgaWYgKFxuICAgICAgdGhpcy50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuSW1wb3J0IHx8XG4gICAgICB1dGlscy5pc1RyYW5zYWN0aW9uT2YodGhpcy5fYXZheFRyYW5zYWN0aW9uLCB0aGlzLl9uZXR3b3JrLmNDaGFpbkJsb2NrY2hhaW5JRClcbiAgICApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gZ2VuZXJhbCBzdXBwb3J0IGFueSB0cmFuc2FjdGlvbiB0eXBlLCBidXQgaXQncyBzY29wZWQgeWV0XG4gICAgcmV0dXJuICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgUFZNQmFzZVR4KS5nZXRPdXRzKCkubWFwKHV0aWxzLm1hcE91dHB1dFRvRW50cnkodGhpcy5fbmV0d29yaykpO1xuICB9XG5cbiAgZ2V0IGlucHV0cygpOiBFbnRyeVtdIHtcbiAgICBsZXQgaW5wdXRzO1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5JbXBvcnQ6XG4gICAgICAgIGlucHV0cyA9ICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgSW1wb3J0VHggfCBFVk1JbXBvcnRUeCkuZ2V0SW1wb3J0SW5wdXRzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuRXhwb3J0OlxuICAgICAgICBpZiAodXRpbHMuaXNUcmFuc2FjdGlvbk9mKHRoaXMuX2F2YXhUcmFuc2FjdGlvbiwgdGhpcy5fbmV0d29yay5jQ2hhaW5CbG9ja2NoYWluSUQpKSB7XG4gICAgICAgICAgcmV0dXJuICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgRVZNRXhwb3J0VHgpLmdldElucHV0cygpLm1hcCgoZXZtSW5wdXQpID0+ICh7XG4gICAgICAgICAgICBhZGRyZXNzOiAnMHgnICsgZXZtSW5wdXQuZ2V0QWRkcmVzc1N0cmluZygpLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBCTigoZXZtSW5wdXQgYXMgYW55KS5hbW91bnQpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBub25jZTogZXZtSW5wdXQuZ2V0Tm9uY2UoKS50b051bWJlcigpLFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dHMgPSAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIFBWTUJhc2VUeCkuZ2V0SW5zKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5wdXRzID0gKHRoaXMuYXZheFBUcmFuc2FjdGlvbiBhcyBQVk1CYXNlVHgpLmdldElucygpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRzLm1hcCgoaW5wdXQpID0+IHtcbiAgICAgIGNvbnN0IGFtb3VudElucHV0ID0gaW5wdXQuZ2V0SW5wdXQoKSBhcyBhbnkgYXMgQW1vdW50SW5wdXQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogdXRpbHMuY2I1OEVuY29kZShpbnB1dC5nZXRUeElEKCkpICsgSU5QVVRfU0VQQVJBVE9SICsgdXRpbHMub3V0cHV0aWR4QnVmZmVyVG9OdW1iZXIoaW5wdXQuZ2V0T3V0cHV0SWR4KCkpLFxuICAgICAgICBhZGRyZXNzOiB0aGlzLmZyb21BZGRyZXNzZXMuc29ydCgpLmpvaW4oQUREUkVTU19TRVBBUkFUT1IpLFxuICAgICAgICB2YWx1ZTogYW1vdW50SW5wdXQuZ2V0QW1vdW50KCkudG9TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXZheCB3cmFwcGVyIHRvIGNyZWF0ZSBzaWduYXR1cmUgYW5kIHJldHVybiBpdCBmb3IgY3JlZGVudGlhbHNcbiAgICogQHBhcmFtIHBydlxuICAgKiBAcmV0dXJuIGhleHN0cmluZ1xuICAgKi9cbiAgY3JlYXRlU2lnbmF0dXJlKHBydjogQnVmZmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBzaWdudmFsID0gdXRpbHMuY3JlYXRlU2lnbmF0dXJlQXZheEJ1ZmZlcihcbiAgICAgIHRoaXMuX25ldHdvcmssXG4gICAgICBCdWZmZXJBdmF4LmZyb20odGhpcy5zaWduYWJsZVBheWxvYWQpLFxuICAgICAgQnVmZmVyQXZheC5mcm9tKHBydilcbiAgICApO1xuICAgIHJldHVybiBzaWdudmFsLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBleHBsYWluVHJhbnNhY3Rpb24oKTogVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gICAgY29uc3QgdHhKc29uID0gdGhpcy50b0pzb24oKTtcbiAgICBjb25zdCBkaXNwbGF5T3JkZXIgPSBbXG4gICAgICAnaWQnLFxuICAgICAgJ2lucHV0cycsXG4gICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICdjaGFuZ2VBbW91bnQnLFxuICAgICAgJ291dHB1dHMnLFxuICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgJ2ZlZScsXG4gICAgICAndHlwZScsXG4gICAgICAnbWVtbycsXG4gICAgXTtcblxuICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IHR4SnNvbi5vdXRwdXRzLnJlZHVjZSgocCwgbikgPT4gcC5hZGQobmV3IEJOKG4udmFsdWUpKSwgbmV3IEJOKDApKS50b1N0cmluZygpO1xuICAgIGNvbnN0IGNoYW5nZUFtb3VudCA9IHR4SnNvbi5jaGFuZ2VPdXRwdXRzLnJlZHVjZSgocCwgbikgPT4gcC5hZGQobmV3IEJOKG4udmFsdWUpKSwgbmV3IEJOKDApKS50b1N0cmluZygpO1xuXG4gICAgbGV0IHJld2FyZEFkZHJlc3NlcztcbiAgICBpZiAoW1RyYW5zYWN0aW9uVHlwZS5BZGRWYWxpZGF0b3IsIFRyYW5zYWN0aW9uVHlwZS5BZGREZWxlZ2F0b3JdLmluY2x1ZGVzKHR4SnNvbi50eXBlKSkge1xuICAgICAgcmV3YXJkQWRkcmVzc2VzID0gdGhpcy5yZXdhcmRBZGRyZXNzZXM7XG4gICAgICBkaXNwbGF5T3JkZXIuc3BsaWNlKDYsIDAsICdyZXdhcmRBZGRyZXNzZXMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgaWQ6IHR4SnNvbi5pZCxcbiAgICAgIGlucHV0czogdHhKc29uLmlucHV0cyxcbiAgICAgIG91dHB1dHM6IHR4SnNvbi5vdXRwdXRzLm1hcCgobykgPT4gKHsgYWRkcmVzczogby5hZGRyZXNzLCBhbW91bnQ6IG8udmFsdWUgfSkpLFxuICAgICAgb3V0cHV0QW1vdW50LFxuICAgICAgY2hhbmdlT3V0cHV0czogdHhKc29uLmNoYW5nZU91dHB1dHMubWFwKChvKSA9PiAoeyBhZGRyZXNzOiBvLmFkZHJlc3MsIGFtb3VudDogby52YWx1ZSB9KSksXG4gICAgICBjaGFuZ2VBbW91bnQsXG4gICAgICByZXdhcmRBZGRyZXNzZXMsXG4gICAgICBmZWU6IHRoaXMuZmVlLFxuICAgICAgdHlwZTogdHhKc29uLnR5cGUsXG4gICAgICBtZW1vOiB0eEpzb24ubWVtbyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoaXMgdHJhbnNhY3Rpb24gaXMgYSBQIGNoYWluXG4gICAqL1xuICBnZXQgaXNUcmFuc2FjdGlvbkZvckNDaGFpbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdXRpbHMuaXNUcmFuc2FjdGlvbk9mKHRoaXMuX2F2YXhUcmFuc2FjdGlvbiwgdGhpcy5fbmV0d29yay5jQ2hhaW5CbG9ja2NoYWluSUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgc291cmNlIGNoYWluIGlkIG9yIHVuZGVmaW5lZCBpZiBpdCdzIGEgY3Jvc3MgY2hhaW4gdHJhbnNmZXIuXG4gICAqL1xuICBnZXQgc291cmNlQ2hhaW4oKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgYmxvY2tjaGFpbklEO1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5JbXBvcnQ6XG4gICAgICAgIGJsb2NrY2hhaW5JRCA9ICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgSW1wb3J0VHggfCBFVk1JbXBvcnRUeCkuZ2V0U291cmNlQ2hhaW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5FeHBvcnQ6XG4gICAgICAgIGJsb2NrY2hhaW5JRCA9ICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgRXhwb3J0VHggfCBFVk1FeHBvcnRUeCkuZ2V0QmxvY2tjaGFpbklEKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tjaGFpbklEdG9BbGlhcyhibG9ja2NoYWluSUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgZGVzdGluYXRpb25DaGFpbiBvciB1bmRlZmluZWQgaWYgaXQncyBhIGNyb3NzIGNoYWluIHRyYW5zZmVyLlxuICAgKi9cbiAgZ2V0IGRlc3RpbmF0aW9uQ2hhaW4oKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgYmxvY2tjaGFpbklEO1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5JbXBvcnQ6XG4gICAgICAgIGJsb2NrY2hhaW5JRCA9ICh0aGlzLmF2YXhQVHJhbnNhY3Rpb24gYXMgSW1wb3J0VHggfCBFVk1JbXBvcnRUeCkuZ2V0QmxvY2tjaGFpbklEKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuRXhwb3J0OlxuICAgICAgICBibG9ja2NoYWluSUQgPSAodGhpcy5hdmF4UFRyYW5zYWN0aW9uIGFzIEV4cG9ydFR4IHwgRVZNRXhwb3J0VHgpLmdldERlc3RpbmF0aW9uQ2hhaW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ibG9ja2NoYWluSUR0b0FsaWFzKGJsb2NrY2hhaW5JRCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIGJsb2NrY2hhaW5JZCBidWZmZXIgdG8gc3RyaW5nIGFuZCByZXR1cm4gUCBvciBDIGFsaWFzIGlmIG1hdGNoIG9mIGFueSBvZiB0aGF0IGNoYWlucy5cbiAgICogQHBhcmFtIHtCdWZmZXJBdmF4fSBibG9ja2NoYWluSURCdWZmZXJcbiAgICogQHJldHVybiB7c3RyaW5nfSBibG9jY2hhaW5JRCBvciBhbGlhcyBpZiBleGlzdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGJsb2NrY2hhaW5JRHRvQWxpYXMoYmxvY2tjaGFpbklEQnVmZmVyOiBCdWZmZXJBdmF4KTogc3RyaW5nIHtcbiAgICBjb25zdCBibG9ja2NoYWluSWQgPSB1dGlscy5jYjU4RW5jb2RlKGJsb2NrY2hhaW5JREJ1ZmZlcik7XG4gICAgc3dpdGNoIChibG9ja2NoYWluSWQpIHtcbiAgICAgIGNhc2UgdGhpcy5fbmV0d29yay5jQ2hhaW5CbG9ja2NoYWluSUQ6XG4gICAgICAgIHJldHVybiAnQyc7XG4gICAgICBjYXNlIHRoaXMuX25ldHdvcmsuYmxvY2tjaGFpbklEOlxuICAgICAgICByZXR1cm4gJ1AnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGJsb2NrY2hhaW5JZDtcbiAgICB9XG4gIH1cbn1cbiJdfQ==