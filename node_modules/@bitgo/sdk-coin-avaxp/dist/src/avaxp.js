"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvaxP = void 0;
const statics_1 = require("@bitgo/statics");
const sdk_core_1 = require("@bitgo/sdk-core");
const AvaxpLib = __importStar(require("./lib"));
const utils_1 = __importDefault(require("./lib/utils"));
const lodash_1 = __importDefault(require("lodash"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethereumjs_util_1 = require("ethereumjs-util");
class AvaxP extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new AvaxP(bitgo, staticsCoin);
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    /**
     * Check if staking txn is valid, based on expected tx params.
     *
     * @param {AvaxpTransactionStakingOptions} stakingOptions expected staking params to check against
     * @param {AvaxpLib.TransactionExplanation} explainedTx explained staking transaction
     */
    validateStakingTx(stakingOptions, explainedTx) {
        const filteredRecipients = [{ address: stakingOptions.nodeID, amount: stakingOptions.amount }];
        const filteredOutputs = explainedTx.outputs.map((output) => lodash_1.default.pick(output, ['address', 'amount']));
        if (!lodash_1.default.isEqual(filteredOutputs, filteredRecipients)) {
            throw new Error('Tx outputs does not match with expected txParams');
        }
        if ((stakingOptions === null || stakingOptions === void 0 ? void 0 : stakingOptions.amount) !== explainedTx.outputAmount) {
            throw new Error('Tx total amount does not match with expected total amount field');
        }
    }
    /**
     * Check if export txn is valid, based on expected tx params.
     *
     * @param {ITransactionRecipient[]} recipients expected recipients and info
     * @param {string} memo txn memo to verify
     * @param {AvaxpLib.TransactionExplanation} explainedTx explained export transaction
     */
    validateExportTx(recipients, memo, explainedTx) {
        if (recipients.length !== 1 || explainedTx.outputs.length !== 1) {
            throw new Error('Export Tx requires one recipient');
        }
        const recipientAmount = new bignumber_js_1.default(recipients[0].amount);
        if (recipientAmount.isGreaterThan(explainedTx.outputAmount) ||
            recipientAmount.plus(explainedTx.fee.fee).isLessThan(explainedTx.outputAmount)) {
            throw new Error(`Tx total amount ${explainedTx.outputAmount} does not match with expected total amount field ${recipientAmount} and fixed fee ${explainedTx.fee.fee}`);
        }
        if (explainedTx.outputs && !utils_1.default.isValidAddress(explainedTx.outputs[0].address)) {
            throw new Error(`Invalid P-chain address ${explainedTx.outputs[0].address}`);
        }
        const memoValue = memo.split('~');
        if (!ethereumjs_util_1.isValidAddress(memoValue[0])) {
            throw new Error(`Txn memo must contain valid C-chain address destination, received: ${memo}`);
        }
        else if (memoValue[0] !== recipients[0].address) {
            throw new Error(`Invalid C-chain receive address ${memoValue[0]}, does not match expected params address ${recipients[0].address}`);
        }
    }
    /**
     * Check if import txn into P is valid, based on expected tx params.
     *
     * @param {AvaxpLib.AvaxpEntry[]} explainedTxInputs tx inputs (unspents to be imported)
     * @param {AvaxpTransactionParams} txParams expected tx info to check against
     */
    validateImportTx(explainedTxInputs, txParams) {
        if (txParams.unspents) {
            if (explainedTxInputs.length !== txParams.unspents.length) {
                throw new Error(`Expected ${txParams.unspents.length} UTXOs, transaction had ${explainedTxInputs.length}`);
            }
            const unspents = new Set(txParams.unspents);
            for (const unspent of explainedTxInputs) {
                if (!unspents.has(unspent.id)) {
                    throw new Error(`Transaction should not contain the UTXO: ${unspent.id}`);
                }
            }
        }
    }
    async verifyTransaction(params) {
        const txHex = params.txPrebuild && params.txPrebuild.txHex;
        if (!txHex) {
            throw new Error('missing required tx prebuild property txHex');
        }
        let tx;
        try {
            const txBuilder = this.getBuilder().from(txHex);
            tx = await txBuilder.build();
        }
        catch (error) {
            throw new Error('Invalid transaction');
        }
        const explainedTx = tx.explainTransaction();
        const { type, stakingOptions } = params.txParams;
        // TODO(BG-62112): change ImportToC type to Import
        if (!type || (type !== 'ImportToC' && explainedTx.type !== sdk_core_1.TransactionType[type])) {
            throw new Error('Tx type does not match with expected txParams type');
        }
        switch (explainedTx.type) {
            case sdk_core_1.TransactionType.AddDelegator:
            case sdk_core_1.TransactionType.AddValidator:
                if (params.txParams.memo && explainedTx.memo !== params.txParams.memo.value) {
                    throw new Error('Tx memo does not match with expected txParams memo');
                }
                this.validateStakingTx(stakingOptions, explainedTx);
                break;
            case sdk_core_1.TransactionType.Export:
                if (!params.txParams.recipients) {
                    throw new Error('Export Tx requires a recipient');
                }
                else if (!explainedTx.memo) {
                    throw new Error('Export Tx requires a memo with c-chain address');
                }
                else {
                    this.validateExportTx(params.txParams.recipients, explainedTx.memo, explainedTx);
                }
                break;
            case sdk_core_1.TransactionType.Import:
                if (tx.isTransactionForCChain) {
                    // Import to C-chain
                    if ((params.txParams.recipients && params.txParams.recipients.length !== 0) ||
                        explainedTx.outputs.length !== 1) {
                        throw new Error('Expected 1 output in import txn and does not require recipients');
                    }
                }
                else {
                    // Import to P-chain
                    if (explainedTx.outputs.length !== 1) {
                        throw new Error('Expected 1 output in import txn');
                    }
                    this.validateImportTx(explainedTx.inputs, params.txParams);
                }
                break;
            default:
                throw new Error('Tx type is not supported yet');
        }
        return true;
    }
    /**
     * Check if address is valid, then make sure it matches the root address.
     *
     * @param params.address address to validate
     * @param params.keychains public keys to generate the wallet
     */
    async isWalletAddress(params) {
        const { address, keychains } = params;
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (!keychains || keychains.length !== 3) {
            throw new Error('Invalid keychains');
        }
        // multisig addresses are separated by ~
        const splitAddresses = address.split('~');
        // derive addresses from keychain
        const unlockAddresses = keychains.map((keychain) => new AvaxpLib.KeyPair({ pub: keychain.pub }).getAddress(this._staticsCoin.network.type));
        if (splitAddresses.length !== unlockAddresses.length) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: multisig address length does not match`);
        }
        if (!this.adressesArraysMatch(splitAddresses, unlockAddresses)) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${address} is not of this wallet`);
        }
        return true;
    }
    /**
     * Validate that two multisig address arrays have the same elements, order doesnt matter
     * @param addressArray1
     * @param addressArray2
     * @returns true if address arrays have the same addresses
     * @private
     */
    adressesArraysMatch(addressArray1, addressArray2) {
        return JSON.stringify(addressArray1.sort()) === JSON.stringify(addressArray2.sort());
    }
    /**
     * Generate Avaxp key pair
     *
     * @param {Buffer} seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? new AvaxpLib.KeyPair({ seed }) : new AvaxpLib.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {string} pub the prv to be checked
     * @returns is it valid?
     */
    isValidPub(pub) {
        try {
            new AvaxpLib.KeyPair({ pub });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param {string} prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        try {
            new AvaxpLib.KeyPair({ prv });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    isValidAddress(address) {
        if (address === undefined) {
            return false;
        }
        // validate eth address for cross-chain txs to c-chain
        if (typeof address === 'string' && ethereumjs_util_1.isValidAddress(address)) {
            return true;
        }
        return AvaxpLib.Utils.isValidAddress(address);
    }
    /**
     * Signs Avaxp transaction
     */
    async signTransaction(params) {
        // deserialize raw transaction (note: fromAddress has onchain order)
        const txBuilder = this.getBuilder().from(params.txPrebuild.txHex);
        const key = params.prv;
        // push the keypair to signer array
        txBuilder.sign({ key });
        // build the transaction
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new sdk_core_1.InvalidTransactionError('Error while trying to build transaction');
        }
        return transaction.signature.length >= 2
            ? { txHex: transaction.toBroadcastFormat() }
            : { halfSigned: { txHex: transaction.toBroadcastFormat() } };
    }
    async feeEstimate(params) {
        // staking transactions are fee-less
        return { fee: '0' };
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Explain a Avaxp transaction from txHex
     * @param params
     * @param callback
     */
    async explainTransaction(params) {
        var _a, _b;
        const txHex = (_a = params.txHex) !== null && _a !== void 0 ? _a : (_b = params === null || params === void 0 ? void 0 : params.halfSigned) === null || _b === void 0 ? void 0 : _b.txHex;
        if (!txHex) {
            throw new Error('missing transaction hex');
        }
        try {
            const txBuilder = this.getBuilder().from(txHex);
            const tx = await txBuilder.build();
            return tx.explainTransaction();
        }
        catch (e) {
            throw new Error(`Invalid transaction: ${e.message}`);
        }
    }
    recoverySignature(message, signature) {
        return AvaxpLib.Utils.recoverySignature(this._staticsCoin.network, message, signature);
    }
    async signMessage(key, message) {
        const prv = new AvaxpLib.KeyPair(key).getPrivateKey();
        if (!prv) {
            throw new sdk_core_1.SigningError('Invalid key pair options');
        }
        if (typeof message === 'string') {
            message = Buffer.from(message, 'hex');
        }
        return AvaxpLib.Utils.createSignature(this._staticsCoin.network, message, prv);
    }
    getBuilder() {
        return new AvaxpLib.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
}
exports.AvaxP = AvaxP;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZheHAuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXZheHAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDRDQUFrRztBQUNsRyw4Q0FnQnlCO0FBQ3pCLGdEQUFrQztBQVNsQyx3REFBZ0M7QUFDaEMsb0RBQXVCO0FBQ3ZCLGdFQUFxQztBQUNyQyxxREFBc0U7QUFFdEUsTUFBYSxLQUFNLFNBQVEsbUJBQVE7SUFHakMsWUFBWSxLQUFnQixFQUFFLFdBQXVDO1FBQ25FLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUViLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7SUFDbEMsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxPQUFPLElBQUksS0FBSyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUNELFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFDRCxXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0lBQ0QsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxpQkFBaUIsQ0FDZixjQUE4QyxFQUM5QyxXQUE0QztRQUU1QyxNQUFNLGtCQUFrQixHQUFHLENBQUMsRUFBRSxPQUFPLEVBQUUs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LFNBQWlCO1FBQ2xELE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQTJCLEVBQUUsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzdHLENBQUM7SUFFRCxLQUFLLENBQUMsV0FBVyxDQUFDLEdBQVksRUFBRSxPQUF3QjtRQUN0RCxNQUFNLEdBQUcsR0FBRyxJQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDdEQsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNSLE1BQU0sSUFBSSx1QkFBWSxDQUFDLDBCQUEwQixDQUFDLENBQUM7U0FDcEQ7UUFDRCxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRTtZQUMvQixPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDdkM7UUFDRCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBMkIsRUFBRSxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDckcsQ0FBQztJQUVPLFVBQVU7UUFDaEIsT0FBTyxJQUFJLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxlQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDNUUsQ0FBQztDQUNGO0FBL1ZELHNCQStWQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF2YWxhbmNoZU5ldHdvcmssIEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgQ29pbkZhbWlseSwgY29pbnMgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQml0R29CYXNlLFxuICBLZXlQYWlyLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxuICBGZWVFc3RpbWF0ZU9wdGlvbnMsXG4gIFNpZ25pbmdFcnJvcixcbiAgVHJhbnNhY3Rpb25UeXBlLFxuICBJbnZhbGlkQWRkcmVzc0Vycm9yLFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBJVHJhbnNhY3Rpb25SZWNpcGllbnQsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0ICogYXMgQXZheHBMaWIgZnJvbSAnLi9saWInO1xuaW1wb3J0IHtcbiAgQXZheHBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkZlZSxcbiAgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgQXZheHBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIEF2YXhwVHJhbnNhY3Rpb25TdGFraW5nT3B0aW9ucyxcbiAgQXZheHBUcmFuc2FjdGlvblBhcmFtcyxcbn0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi9saWIvdXRpbHMnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGlzVmFsaWRBZGRyZXNzIGFzIGlzVmFsaWRFdGhBZGRyZXNzIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcblxuZXhwb3J0IGNsYXNzIEF2YXhQIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcblxuICAgIGlmICghc3RhdGljc0NvaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc3RhdGljc0NvaW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0aWNzQ29pbiA9IHN0YXRpY3NDb2luO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IEF2YXhQKGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG4gIGdldEZhbWlseSgpOiBDb2luRmFtaWx5IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZmFtaWx5O1xuICB9XG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZ1bGxOYW1lO1xuICB9XG4gIGdldEJhc2VGYWN0b3IoKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXRpY3NDb2luLmRlY2ltYWxQbGFjZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHN0YWtpbmcgdHhuIGlzIHZhbGlkLCBiYXNlZCBvbiBleHBlY3RlZCB0eCBwYXJhbXMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXZheHBUcmFuc2FjdGlvblN0YWtpbmdPcHRpb25zfSBzdGFraW5nT3B0aW9ucyBleHBlY3RlZCBzdGFraW5nIHBhcmFtcyB0byBjaGVjayBhZ2FpbnN0XG4gICAqIEBwYXJhbSB7QXZheHBMaWIuVHJhbnNhY3Rpb25FeHBsYW5hdGlvbn0gZXhwbGFpbmVkVHggZXhwbGFpbmVkIHN0YWtpbmcgdHJhbnNhY3Rpb25cbiAgICovXG4gIHZhbGlkYXRlU3Rha2luZ1R4KFxuICAgIHN0YWtpbmdPcHRpb25zOiBBdmF4cFRyYW5zYWN0aW9uU3Rha2luZ09wdGlvbnMsXG4gICAgZXhwbGFpbmVkVHg6IEF2YXhwTGliLlRyYW5zYWN0aW9uRXhwbGFuYXRpb25cbiAgKTogdm9pZCB7XG4gICAgY29uc3QgZmlsdGVyZWRSZWNpcGllbnRzID0gW3sgYWRkcmVzczogc3Rha2luZ09wdGlvbnMubm9kZUlELCBhbW91bnQ6IHN0YWtpbmdPcHRpb25zLmFtb3VudCB9XTtcbiAgICBjb25zdCBmaWx0ZXJlZE91dHB1dHMgPSBleHBsYWluZWRUeC5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiBfLnBpY2sob3V0cHV0LCBbJ2FkZHJlc3MnLCAnYW1vdW50J10pKTtcblxuICAgIGlmICghXy5pc0VxdWFsKGZpbHRlcmVkT3V0cHV0cywgZmlsdGVyZWRSZWNpcGllbnRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBvdXRwdXRzIGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdHhQYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHN0YWtpbmdPcHRpb25zPy5hbW91bnQgIT09IGV4cGxhaW5lZFR4Lm91dHB1dEFtb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCB0b3RhbCBhbW91bnQgZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0b3RhbCBhbW91bnQgZmllbGQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgZXhwb3J0IHR4biBpcyB2YWxpZCwgYmFzZWQgb24gZXhwZWN0ZWQgdHggcGFyYW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0lUcmFuc2FjdGlvblJlY2lwaWVudFtdfSByZWNpcGllbnRzIGV4cGVjdGVkIHJlY2lwaWVudHMgYW5kIGluZm9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lbW8gdHhuIG1lbW8gdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSB7QXZheHBMaWIuVHJhbnNhY3Rpb25FeHBsYW5hdGlvbn0gZXhwbGFpbmVkVHggZXhwbGFpbmVkIGV4cG9ydCB0cmFuc2FjdGlvblxuICAgKi9cbiAgdmFsaWRhdGVFeHBvcnRUeChcbiAgICByZWNpcGllbnRzOiBJVHJhbnNhY3Rpb25SZWNpcGllbnRbXSxcbiAgICBtZW1vOiBzdHJpbmcsXG4gICAgZXhwbGFpbmVkVHg6IEF2YXhwTGliLlRyYW5zYWN0aW9uRXhwbGFuYXRpb25cbiAgKTogdm9pZCB7XG4gICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoICE9PSAxIHx8IGV4cGxhaW5lZFR4Lm91dHB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cG9ydCBUeCByZXF1aXJlcyBvbmUgcmVjaXBpZW50Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjaXBpZW50QW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnRzWzBdLmFtb3VudCk7XG5cbiAgICBpZiAoXG4gICAgICByZWNpcGllbnRBbW91bnQuaXNHcmVhdGVyVGhhbihleHBsYWluZWRUeC5vdXRwdXRBbW91bnQpIHx8XG4gICAgICByZWNpcGllbnRBbW91bnQucGx1cyhleHBsYWluZWRUeC5mZWUuZmVlKS5pc0xlc3NUaGFuKGV4cGxhaW5lZFR4Lm91dHB1dEFtb3VudClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFR4IHRvdGFsIGFtb3VudCAke2V4cGxhaW5lZFR4Lm91dHB1dEFtb3VudH0gZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0b3RhbCBhbW91bnQgZmllbGQgJHtyZWNpcGllbnRBbW91bnR9IGFuZCBmaXhlZCBmZWUgJHtleHBsYWluZWRUeC5mZWUuZmVlfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGV4cGxhaW5lZFR4Lm91dHB1dHMgJiYgIXV0aWxzLmlzVmFsaWRBZGRyZXNzKGV4cGxhaW5lZFR4Lm91dHB1dHNbMF0uYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBQLWNoYWluIGFkZHJlc3MgJHtleHBsYWluZWRUeC5vdXRwdXRzWzBdLmFkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVtb1ZhbHVlID0gbWVtby5zcGxpdCgnficpO1xuICAgIGlmICghaXNWYWxpZEV0aEFkZHJlc3MobWVtb1ZhbHVlWzBdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeG4gbWVtbyBtdXN0IGNvbnRhaW4gdmFsaWQgQy1jaGFpbiBhZGRyZXNzIGRlc3RpbmF0aW9uLCByZWNlaXZlZDogJHttZW1vfWApO1xuICAgIH0gZWxzZSBpZiAobWVtb1ZhbHVlWzBdICE9PSByZWNpcGllbnRzWzBdLmFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgQy1jaGFpbiByZWNlaXZlIGFkZHJlc3MgJHttZW1vVmFsdWVbMF19LCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBwYXJhbXMgYWRkcmVzcyAke3JlY2lwaWVudHNbMF0uYWRkcmVzc31gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBpbXBvcnQgdHhuIGludG8gUCBpcyB2YWxpZCwgYmFzZWQgb24gZXhwZWN0ZWQgdHggcGFyYW1zLlxuICAgKlxuICAgKiBAcGFyYW0ge0F2YXhwTGliLkF2YXhwRW50cnlbXX0gZXhwbGFpbmVkVHhJbnB1dHMgdHggaW5wdXRzICh1bnNwZW50cyB0byBiZSBpbXBvcnRlZClcbiAgICogQHBhcmFtIHtBdmF4cFRyYW5zYWN0aW9uUGFyYW1zfSB0eFBhcmFtcyBleHBlY3RlZCB0eCBpbmZvIHRvIGNoZWNrIGFnYWluc3RcbiAgICovXG4gIHZhbGlkYXRlSW1wb3J0VHgoZXhwbGFpbmVkVHhJbnB1dHM6IEF2YXhwTGliLkF2YXhwRW50cnlbXSwgdHhQYXJhbXM6IEF2YXhwVHJhbnNhY3Rpb25QYXJhbXMpOiB2b2lkIHtcbiAgICBpZiAodHhQYXJhbXMudW5zcGVudHMpIHtcbiAgICAgIGlmIChleHBsYWluZWRUeElucHV0cy5sZW5ndGggIT09IHR4UGFyYW1zLnVuc3BlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICR7dHhQYXJhbXMudW5zcGVudHMubGVuZ3RofSBVVFhPcywgdHJhbnNhY3Rpb24gaGFkICR7ZXhwbGFpbmVkVHhJbnB1dHMubGVuZ3RofWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1bnNwZW50cyA9IG5ldyBTZXQodHhQYXJhbXMudW5zcGVudHMpO1xuXG4gICAgICBmb3IgKGNvbnN0IHVuc3BlbnQgb2YgZXhwbGFpbmVkVHhJbnB1dHMpIHtcbiAgICAgICAgaWYgKCF1bnNwZW50cy5oYXModW5zcGVudC5pZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIHNob3VsZCBub3QgY29udGFpbiB0aGUgVVRYTzogJHt1bnNwZW50LmlkfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBBdmF4cFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4UHJlYnVpbGQgJiYgcGFyYW1zLnR4UHJlYnVpbGQudHhIZXg7XG4gICAgaWYgKCF0eEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4IHByZWJ1aWxkIHByb3BlcnR5IHR4SGV4Jyk7XG4gICAgfVxuICAgIGxldCB0eDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZnJvbSh0eEhleCk7XG4gICAgICB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgZXhwbGFpbmVkVHggPSB0eC5leHBsYWluVHJhbnNhY3Rpb24oKTtcblxuICAgIGNvbnN0IHsgdHlwZSwgc3Rha2luZ09wdGlvbnMgfSA9IHBhcmFtcy50eFBhcmFtcztcbiAgICAvLyBUT0RPKEJHLTYyMTEyKTogY2hhbmdlIEltcG9ydFRvQyB0eXBlIHRvIEltcG9ydFxuICAgIGlmICghdHlwZSB8fCAodHlwZSAhPT0gJ0ltcG9ydFRvQycgJiYgZXhwbGFpbmVkVHgudHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlW3R5cGVdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCB0eXBlIGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdHhQYXJhbXMgdHlwZScpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZXhwbGFpbmVkVHgudHlwZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQWRkRGVsZWdhdG9yOlxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQWRkVmFsaWRhdG9yOlxuICAgICAgICBpZiAocGFyYW1zLnR4UGFyYW1zLm1lbW8gJiYgZXhwbGFpbmVkVHgubWVtbyAhPT0gcGFyYW1zLnR4UGFyYW1zLm1lbW8udmFsdWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R4IG1lbW8gZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0eFBhcmFtcyBtZW1vJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbGlkYXRlU3Rha2luZ1R4KHN0YWtpbmdPcHRpb25zLCBleHBsYWluZWRUeCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuRXhwb3J0OlxuICAgICAgICBpZiAoIXBhcmFtcy50eFBhcmFtcy5yZWNpcGllbnRzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBvcnQgVHggcmVxdWlyZXMgYSByZWNpcGllbnQnKTtcbiAgICAgICAgfSBlbHNlIGlmICghZXhwbGFpbmVkVHgubWVtbykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwb3J0IFR4IHJlcXVpcmVzIGEgbWVtbyB3aXRoIGMtY2hhaW4gYWRkcmVzcycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudmFsaWRhdGVFeHBvcnRUeChwYXJhbXMudHhQYXJhbXMucmVjaXBpZW50cywgZXhwbGFpbmVkVHgubWVtbywgZXhwbGFpbmVkVHgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuSW1wb3J0OlxuICAgICAgICBpZiAodHguaXNUcmFuc2FjdGlvbkZvckNDaGFpbikge1xuICAgICAgICAgIC8vIEltcG9ydCB0byBDLWNoYWluXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHBhcmFtcy50eFBhcmFtcy5yZWNpcGllbnRzICYmIHBhcmFtcy50eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aCAhPT0gMCkgfHxcbiAgICAgICAgICAgIGV4cGxhaW5lZFR4Lm91dHB1dHMubGVuZ3RoICE9PSAxXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDEgb3V0cHV0IGluIGltcG9ydCB0eG4gYW5kIGRvZXMgbm90IHJlcXVpcmUgcmVjaXBpZW50cycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJbXBvcnQgdG8gUC1jaGFpblxuICAgICAgICAgIGlmIChleHBsYWluZWRUeC5vdXRwdXRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAxIG91dHB1dCBpbiBpbXBvcnQgdHhuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudmFsaWRhdGVJbXBvcnRUeChleHBsYWluZWRUeC5pbnB1dHMsIHBhcmFtcy50eFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R4IHR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYWRkcmVzcyBpcyB2YWxpZCwgdGhlbiBtYWtlIHN1cmUgaXQgbWF0Y2hlcyB0aGUgcm9vdCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLmFkZHJlc3MgYWRkcmVzcyB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0gcGFyYW1zLmtleWNoYWlucyBwdWJsaWMga2V5cyB0byBnZW5lcmF0ZSB0aGUgd2FsbGV0XG4gICAqL1xuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHsgYWRkcmVzcywga2V5Y2hhaW5zIH0gPSBwYXJhbXM7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gICAgaWYgKCFrZXljaGFpbnMgfHwga2V5Y2hhaW5zLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleWNoYWlucycpO1xuICAgIH1cblxuICAgIC8vIG11bHRpc2lnIGFkZHJlc3NlcyBhcmUgc2VwYXJhdGVkIGJ5IH5cbiAgICBjb25zdCBzcGxpdEFkZHJlc3NlcyA9IGFkZHJlc3Muc3BsaXQoJ34nKTtcblxuICAgIC8vIGRlcml2ZSBhZGRyZXNzZXMgZnJvbSBrZXljaGFpblxuICAgIGNvbnN0IHVubG9ja0FkZHJlc3NlcyA9IGtleWNoYWlucy5tYXAoKGtleWNoYWluKSA9PlxuICAgICAgbmV3IEF2YXhwTGliLktleVBhaXIoeyBwdWI6IGtleWNoYWluLnB1YiB9KS5nZXRBZGRyZXNzKHRoaXMuX3N0YXRpY3NDb2luLm5ldHdvcmsudHlwZSlcbiAgICApO1xuXG4gICAgaWYgKHNwbGl0QWRkcmVzc2VzLmxlbmd0aCAhPT0gdW5sb2NrQWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiBtdWx0aXNpZyBhZGRyZXNzIGxlbmd0aCBkb2VzIG5vdCBtYXRjaGApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hZHJlc3Nlc0FycmF5c01hdGNoKHNwbGl0QWRkcmVzc2VzLCB1bmxvY2tBZGRyZXNzZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6ICR7YWRkcmVzc30gaXMgbm90IG9mIHRoaXMgd2FsbGV0YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhhdCB0d28gbXVsdGlzaWcgYWRkcmVzcyBhcnJheXMgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cywgb3JkZXIgZG9lc250IG1hdHRlclxuICAgKiBAcGFyYW0gYWRkcmVzc0FycmF5MVxuICAgKiBAcGFyYW0gYWRkcmVzc0FycmF5MlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIGFkZHJlc3MgYXJyYXlzIGhhdmUgdGhlIHNhbWUgYWRkcmVzc2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFkcmVzc2VzQXJyYXlzTWF0Y2goYWRkcmVzc0FycmF5MTogc3RyaW5nW10sIGFkZHJlc3NBcnJheTI6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFkZHJlc3NBcnJheTEuc29ydCgpKSA9PT0gSlNPTi5zdHJpbmdpZnkoYWRkcmVzc0FycmF5Mi5zb3J0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIEF2YXhwIGtleSBwYWlyXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBzZWVkIC0gU2VlZCBmcm9tIHdoaWNoIHRoZSBuZXcga2V5cGFpciBzaG91bGQgYmUgZ2VuZXJhdGVkLCBvdGhlcndpc2UgYSByYW5kb20gc2VlZCBpcyB1c2VkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBrZXlQYWlyID0gc2VlZCA/IG5ldyBBdmF4cExpYi5LZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBBdmF4cExpYi5LZXlQYWlyKCk7XG4gICAgY29uc3Qga2V5cyA9IGtleVBhaXIuZ2V0S2V5cygpO1xuXG4gICAgaWYgKCFrZXlzLnBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBydiBpbiBrZXkgZ2VuZXJhdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBrZXlzLnB1YixcbiAgICAgIHBydjoga2V5cy5wcnYsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBBdmF4cExpYi5LZXlQYWlyKHsgcHViIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHJpdmF0ZSBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcnYgdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgQXZheHBMaWIuS2V5UGFpcih7IHBydiB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgIGlmIChhZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBldGggYWRkcmVzcyBmb3IgY3Jvc3MtY2hhaW4gdHhzIHRvIGMtY2hhaW5cbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICdzdHJpbmcnICYmIGlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXZheHBMaWIuVXRpbHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgQXZheHAgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IEF2YXhwU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICAvLyBkZXNlcmlhbGl6ZSByYXcgdHJhbnNhY3Rpb24gKG5vdGU6IGZyb21BZGRyZXNzIGhhcyBvbmNoYWluIG9yZGVyKVxuICAgIGNvbnN0IHR4QnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlcigpLmZyb20ocGFyYW1zLnR4UHJlYnVpbGQudHhIZXgpO1xuICAgIGNvbnN0IGtleSA9IHBhcmFtcy5wcnY7XG5cbiAgICAvLyBwdXNoIHRoZSBrZXlwYWlyIHRvIHNpZ25lciBhcnJheVxuICAgIHR4QnVpbGRlci5zaWduKHsga2V5IH0pO1xuXG4gICAgLy8gYnVpbGQgdGhlIHRyYW5zYWN0aW9uXG4gICAgY29uc3QgdHJhbnNhY3Rpb246IEJhc2VUcmFuc2FjdGlvbiA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGJ1aWxkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5zaWduYXR1cmUubGVuZ3RoID49IDJcbiAgICAgID8geyB0eEhleDogdHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKSB9XG4gICAgICA6IHsgaGFsZlNpZ25lZDogeyB0eEhleDogdHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKSB9IH07XG4gIH1cblxuICBhc3luYyBmZWVFc3RpbWF0ZShwYXJhbXM6IEZlZUVzdGltYXRlT3B0aW9ucyk6IFByb21pc2U8VHJhbnNhY3Rpb25GZWU+IHtcbiAgICAvLyBzdGFraW5nIHRyYW5zYWN0aW9ucyBhcmUgZmVlLWxlc3NcbiAgICByZXR1cm4geyBmZWU6ICcwJyB9O1xuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgQXZheHAgdHJhbnNhY3Rpb24gZnJvbSB0eEhleFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8QXZheHBMaWIuVHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4ID8/IHBhcmFtcz8uaGFsZlNpZ25lZD8udHhIZXg7XG4gICAgaWYgKCF0eEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHRyYW5zYWN0aW9uIGhleCcpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZnJvbSh0eEhleCk7XG4gICAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgICAgcmV0dXJuIHR4LmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0cmFuc2FjdGlvbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgcmVjb3ZlcnlTaWduYXR1cmUobWVzc2FnZTogQnVmZmVyLCBzaWduYXR1cmU6IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIEF2YXhwTGliLlV0aWxzLnJlY292ZXJ5U2lnbmF0dXJlKHRoaXMuX3N0YXRpY3NDb2luLm5ldHdvcmsgYXMgQXZhbGFuY2hlTmV0d29yaywgbWVzc2FnZSwgc2lnbmF0dXJlKTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBjb25zdCBwcnYgPSBuZXcgQXZheHBMaWIuS2V5UGFpcihrZXkpLmdldFByaXZhdGVLZXkoKTtcbiAgICBpZiAoIXBydikge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignSW52YWxpZCBrZXkgcGFpciBvcHRpb25zJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlLCAnaGV4Jyk7XG4gICAgfVxuICAgIHJldHVybiBBdmF4cExpYi5VdGlscy5jcmVhdGVTaWduYXR1cmUodGhpcy5fc3RhdGljc0NvaW4ubmV0d29yayBhcyBBdmFsYW5jaGVOZXR3b3JrLCBtZXNzYWdlLCBwcnYpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRCdWlsZGVyKCk6IEF2YXhwTGliLlRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICAgIHJldHVybiBuZXcgQXZheHBMaWIuVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRDaGFpbigpKSk7XG4gIH1cbn1cbiJdfQ==