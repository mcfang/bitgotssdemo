"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyCommitment = exports.createCommitment = void 0;
const crypto_1 = require("crypto");
const util_1 = require("./util");
const minRandomnessLength = 32;
/**
 * Create hash commitment and decommietment of a secret value.
 * @param secret The secret value/message.
 * @param r The randomness/nonce to be added to the commmitment.
 * @returns The created commitment and decommitment.
 */
function createCommitment(secret, r = crypto_1.randomBytes(minRandomnessLength)) {
    if (r.length < minRandomnessLength) {
        throw new Error(`randomness must be at least ${minRandomnessLength} bytes long`);
    }
    return {
        commitment: hash(secret, r),
        decommitment: {
            blindingFactor: r,
            secret: secret,
        },
    };
}
exports.createCommitment = createCommitment;
const bytesPerUint32 = 4;
function hash(secret, r) {
    return crypto_1.createHash('sha256')
        .update(util_1.bigIntToBufferBE(BigInt(secret.length), bytesPerUint32))
        .update(secret)
        .update(util_1.bigIntToBufferBE(BigInt(r.length), bytesPerUint32))
        .update(r)
        .digest();
}
/**
 * Verify hash commitment and decommietment of a secret value.
 * @param commitment The commitment.
 * @param decommietment The decommitment.
 * @returns True if verification succeeds.
 */
function verifyCommitment(commitment, decommietment) {
    return hash(decommietment.secret, decommietment.blindingFactor).compare(commitment) === 0;
}
exports.verifyCommitment = verifyCommitment;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaENvbW1pdG1lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaGFzaENvbW1pdG1lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQWlEO0FBRWpELGlDQUEwQztBQUUxQyxNQUFNLG1CQUFtQixHQUFHLEVBQUUsQ0FBQztBQUUvQjs7Ozs7R0FLRztBQUNILFNBQWdCLGdCQUFnQixDQUFDLE1BQWMsRUFBRSxJQUFZLG9CQUFXLENBQUMsbUJBQW1CLENBQUM7SUFDM0YsSUFBSSxDQUFDLENBQUMsTUFBTSxHQUFHLG1CQUFtQixFQUFFO1FBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLG1CQUFtQixhQUFhLENBQUMsQ0FBQztLQUNsRjtJQUNELE9BQU87UUFDTCxVQUFVLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDM0IsWUFBWSxFQUFFO1lBQ1osY0FBYyxFQUFFLENBQUM7WUFDakIsTUFBTSxFQUFFLE1BQU07U0FDZjtLQUNGLENBQUM7QUFDSixDQUFDO0FBWEQsNENBV0M7QUFFRCxNQUFNLGNBQWMsR0FBRyxDQUFDLENBQUM7QUFFekIsU0FBUyxJQUFJLENBQUMsTUFBYyxFQUFFLENBQVM7SUFDckMsT0FBTyxtQkFBVSxDQUFDLFFBQVEsQ0FBQztTQUN4QixNQUFNLENBQUMsdUJBQWdCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQztTQUMvRCxNQUFNLENBQUMsTUFBTSxDQUFDO1NBQ2QsTUFBTSxDQUFDLHVCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUM7U0FDMUQsTUFBTSxDQUFDLENBQUMsQ0FBQztTQUNULE1BQU0sRUFBRSxDQUFDO0FBQ2QsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsZ0JBQWdCLENBQUMsVUFBa0IsRUFBRSxhQUErQjtJQUNsRixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzVGLENBQUM7QUFGRCw0Q0FFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUhhc2gsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IEhhc2hDb21taXREZWNvbW1pdCwgSGFzaERlY29tbWl0bWVudCB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgYmlnSW50VG9CdWZmZXJCRSB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IG1pblJhbmRvbW5lc3NMZW5ndGggPSAzMjtcblxuLyoqXG4gKiBDcmVhdGUgaGFzaCBjb21taXRtZW50IGFuZCBkZWNvbW1pZXRtZW50IG9mIGEgc2VjcmV0IHZhbHVlLlxuICogQHBhcmFtIHNlY3JldCBUaGUgc2VjcmV0IHZhbHVlL21lc3NhZ2UuXG4gKiBAcGFyYW0gciBUaGUgcmFuZG9tbmVzcy9ub25jZSB0byBiZSBhZGRlZCB0byB0aGUgY29tbW1pdG1lbnQuXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBjb21taXRtZW50IGFuZCBkZWNvbW1pdG1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21taXRtZW50KHNlY3JldDogQnVmZmVyLCByOiBCdWZmZXIgPSByYW5kb21CeXRlcyhtaW5SYW5kb21uZXNzTGVuZ3RoKSk6IEhhc2hDb21taXREZWNvbW1pdCB7XG4gIGlmIChyLmxlbmd0aCA8IG1pblJhbmRvbW5lc3NMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHJhbmRvbW5lc3MgbXVzdCBiZSBhdCBsZWFzdCAke21pblJhbmRvbW5lc3NMZW5ndGh9IGJ5dGVzIGxvbmdgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1pdG1lbnQ6IGhhc2goc2VjcmV0LCByKSxcbiAgICBkZWNvbW1pdG1lbnQ6IHtcbiAgICAgIGJsaW5kaW5nRmFjdG9yOiByLFxuICAgICAgc2VjcmV0OiBzZWNyZXQsXG4gICAgfSxcbiAgfTtcbn1cblxuY29uc3QgYnl0ZXNQZXJVaW50MzIgPSA0O1xuXG5mdW5jdGlvbiBoYXNoKHNlY3JldDogQnVmZmVyLCByOiBCdWZmZXIpOiBCdWZmZXIge1xuICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoQmlnSW50KHNlY3JldC5sZW5ndGgpLCBieXRlc1BlclVpbnQzMikpXG4gICAgLnVwZGF0ZShzZWNyZXQpXG4gICAgLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKEJpZ0ludChyLmxlbmd0aCksIGJ5dGVzUGVyVWludDMyKSlcbiAgICAudXBkYXRlKHIpXG4gICAgLmRpZ2VzdCgpO1xufVxuXG4vKipcbiAqIFZlcmlmeSBoYXNoIGNvbW1pdG1lbnQgYW5kIGRlY29tbWlldG1lbnQgb2YgYSBzZWNyZXQgdmFsdWUuXG4gKiBAcGFyYW0gY29tbWl0bWVudCBUaGUgY29tbWl0bWVudC5cbiAqIEBwYXJhbSBkZWNvbW1pZXRtZW50IFRoZSBkZWNvbW1pdG1lbnQuXG4gKiBAcmV0dXJucyBUcnVlIGlmIHZlcmlmaWNhdGlvbiBzdWNjZWVkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeUNvbW1pdG1lbnQoY29tbWl0bWVudDogQnVmZmVyLCBkZWNvbW1pZXRtZW50OiBIYXNoRGVjb21taXRtZW50KTogYm9vbGVhbiB7XG4gIHJldHVybiBoYXNoKGRlY29tbWlldG1lbnQuc2VjcmV0LCBkZWNvbW1pZXRtZW50LmJsaW5kaW5nRmFjdG9yKS5jb21wYXJlKGNvbW1pdG1lbnQpID09PSAwO1xufVxuIl19