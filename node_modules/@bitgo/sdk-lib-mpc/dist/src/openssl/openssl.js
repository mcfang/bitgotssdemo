"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenSSL = void 0;
const wasi_1 = require("@wasmer/wasi");
const opensslbytes_1 = require("./opensslbytes");
class OpenSSL {
    constructor() {
        this.isInitialized = false;
    }
    async init() {
        await wasi_1.init();
        this.waModule = await WebAssembly.compile(await this.getWasmBytes());
        this.isInitialized = true;
    }
    async generateSafePrime(bitLength) {
        const bigIntString = await this.runCommand(`prime -bits ${bitLength} -generate -safe`);
        return BigInt(bigIntString);
    }
    async runCommand(openSslCommand) {
        if (!this.isInitialized) {
            throw new Error('The OpenSSl class is not initialized! Please call OpenSSL.init().');
        }
        const command = Array.isArray(openSslCommand) ? openSslCommand : openSslCommand.split(/[\s]{1,}/g).filter(Boolean);
        const wasi = new wasi_1.WASI({
            args: command,
        });
        // Instantiate the WASI module
        // cannot use wasi.instantiate(module, {}); due to the size of the module
        const instance = await WebAssembly.instantiate(this.waModule, {
            ...wasi.getImports(this.waModule),
        });
        // Run the start function
        wasi.start(instance);
        return wasi.getStdoutString();
    }
    async getWasmBytes() {
        const waBuffer = opensslbytes_1.loadWebAssembly();
        if (!waBuffer) {
            throw new Error('Cannot load openssl web-assembly!');
        }
        return waBuffer.buffer;
    }
}
exports.OpenSSL = OpenSSL;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3BlbnNzbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9vcGVuc3NsL29wZW5zc2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsdUNBQTBDO0FBQzFDLGlEQUFpRDtBQUVqRCxNQUFhLE9BQU87SUFBcEI7UUFFVSxrQkFBYSxHQUFHLEtBQUssQ0FBQztJQXNDaEMsQ0FBQztJQXBDQyxLQUFLLENBQUMsSUFBSTtRQUNSLE1BQU0sV0FBSSxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO1FBQ3JFLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO0lBQzVCLENBQUM7SUFFRCxLQUFLLENBQUMsaUJBQWlCLENBQUMsU0FBaUI7UUFDdkMsTUFBTSxZQUFZLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLGVBQWUsU0FBUyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3ZGLE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFDTyxLQUFLLENBQUMsVUFBVSxDQUFDLGNBQWlDO1FBQ3hELElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUVBQW1FLENBQUMsQ0FBQztTQUN0RjtRQUNELE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDbkgsTUFBTSxJQUFJLEdBQUcsSUFBSSxXQUFJLENBQUM7WUFDcEIsSUFBSSxFQUFFLE9BQU87U0FDZCxDQUFDLENBQUM7UUFFSCw4QkFBOEI7UUFDOUIseUVBQXlFO1FBQ3pFLE1BQU0sUUFBUSxHQUFHLE1BQU0sV0FBVyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQzVELEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1NBQ2xDLENBQUMsQ0FBQztRQUNILHlCQUF5QjtRQUN6QixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFFTyxLQUFLLENBQUMsWUFBWTtRQUN4QixNQUFNLFFBQVEsR0FBRyw4QkFBZSxFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNiLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztTQUN0RDtRQUNELE9BQU8sUUFBUSxDQUFDLE1BQU0sQ0FBQztJQUN6QixDQUFDO0NBQ0Y7QUF4Q0QsMEJBd0NDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5pdCwgV0FTSSB9IGZyb20gJ0B3YXNtZXIvd2FzaSc7XG5pbXBvcnQgeyBsb2FkV2ViQXNzZW1ibHkgfSBmcm9tICcuL29wZW5zc2xieXRlcyc7XG5cbmV4cG9ydCBjbGFzcyBPcGVuU1NMIHtcbiAgcHJpdmF0ZSB3YU1vZHVsZTogV2ViQXNzZW1ibHkuTW9kdWxlO1xuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICBhc3luYyBpbml0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IGluaXQoKTtcbiAgICB0aGlzLndhTW9kdWxlID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZShhd2FpdCB0aGlzLmdldFdhc21CeXRlcygpKTtcbiAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgYXN5bmMgZ2VuZXJhdGVTYWZlUHJpbWUoYml0TGVuZ3RoOiBudW1iZXIpOiBQcm9taXNlPGJpZ2ludD4ge1xuICAgIGNvbnN0IGJpZ0ludFN0cmluZyA9IGF3YWl0IHRoaXMucnVuQ29tbWFuZChgcHJpbWUgLWJpdHMgJHtiaXRMZW5ndGh9IC1nZW5lcmF0ZSAtc2FmZWApO1xuICAgIHJldHVybiBCaWdJbnQoYmlnSW50U3RyaW5nKTtcbiAgfVxuICBwcml2YXRlIGFzeW5jIHJ1bkNvbW1hbmQob3BlblNzbENvbW1hbmQ6IHN0cmluZyB8IHN0cmluZ1tdKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgT3BlblNTbCBjbGFzcyBpcyBub3QgaW5pdGlhbGl6ZWQhIFBsZWFzZSBjYWxsIE9wZW5TU0wuaW5pdCgpLicpO1xuICAgIH1cbiAgICBjb25zdCBjb21tYW5kID0gQXJyYXkuaXNBcnJheShvcGVuU3NsQ29tbWFuZCkgPyBvcGVuU3NsQ29tbWFuZCA6IG9wZW5Tc2xDb21tYW5kLnNwbGl0KC9bXFxzXXsxLH0vZykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICBhcmdzOiBjb21tYW5kLFxuICAgIH0pO1xuXG4gICAgLy8gSW5zdGFudGlhdGUgdGhlIFdBU0kgbW9kdWxlXG4gICAgLy8gY2Fubm90IHVzZSB3YXNpLmluc3RhbnRpYXRlKG1vZHVsZSwge30pOyBkdWUgdG8gdGhlIHNpemUgb2YgdGhlIG1vZHVsZVxuICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodGhpcy53YU1vZHVsZSwge1xuICAgICAgLi4ud2FzaS5nZXRJbXBvcnRzKHRoaXMud2FNb2R1bGUpLFxuICAgIH0pO1xuICAgIC8vIFJ1biB0aGUgc3RhcnQgZnVuY3Rpb25cbiAgICB3YXNpLnN0YXJ0KGluc3RhbmNlKTtcbiAgICByZXR1cm4gd2FzaS5nZXRTdGRvdXRTdHJpbmcoKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2V0V2FzbUJ5dGVzKCk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAgIGNvbnN0IHdhQnVmZmVyID0gbG9hZFdlYkFzc2VtYmx5KCk7XG4gICAgaWYgKCF3YUJ1ZmZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCBvcGVuc3NsIHdlYi1hc3NlbWJseSEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHdhQnVmZmVyLmJ1ZmZlcjtcbiAgfVxufVxuIl19