"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySchnorrProof = exports.createSchnorrProof = void 0;
/**
 * Implementation of Schnorr Non-interactive Zero-Knowledge Proof.
 * @see {@link https://datatracker.ietf.org/doc/rfc8235/}
 */
const crypto_1 = require("crypto");
const util_1 = require("./util");
/**
 * Create a Schnorr Proof of knowledge of the discrete log of an Elliptic-curve point.
 * @param A The curve point.
 * @param a The discrete log of the curve point.
 * @param curve The elliptic curve.
 * @param additionalCtx Additional contextual information to associate with the proof.
 * @returns The created proof.
 */
function createSchnorrProof(A, a, curve, additionalCtx = Buffer.from('')) {
    const v = curve.scalarRandom();
    const V = curve.basePointMult(v);
    const c = nonInteractiveChallenge(V, A, curve, additionalCtx);
    const r = curve.scalarSub(v, curve.scalarMult(a, c));
    return {
        vPoint: V,
        r: r,
    };
}
exports.createSchnorrProof = createSchnorrProof;
/**
 * Calculate challenge for NIZK schnorr proof using Fiat-Shamir transform.
 *
 * @param V The point/public value corresponding to the random scalar value v chosen by the prover.
 * @param A The point to be proved.
 * @param curve The elliptic curve.
 * @param additionalCtx Additional contextual information to associate with the proof.
 * @returns The calculated challenge.
 */
function nonInteractiveChallenge(V, A, curve, additionalCtx) {
    const G = curve.basePointMult(BigInt(1));
    const hash = crypto_1.createHash('sha256');
    hash.update(util_1.bigIntToBufferBE(G, 32));
    hash.update(util_1.bigIntToBufferBE(V, 32));
    hash.update(util_1.bigIntToBufferBE(A, 32));
    hash.update(additionalCtx);
    return util_1.bigIntFromBufferBE(hash.digest());
}
/**
 * Verify a Schnorr Proof of knowledge of the discrete log of an Elliptic-curve point.
 * @param A The curve point.
 * @param proof The schnorr proof.
 * @param curve The elliptic curve.
 * @param additionalCtx Additional contextual information that is supposed to associate with the proof.
 * @returns True if the proof checks out.
 */
function verifySchnorrProof(A, proof, curve, additionalCtx = Buffer.from('')) {
    const c = nonInteractiveChallenge(proof.vPoint, A, curve, additionalCtx);
    const rG = curve.basePointMult(proof.r);
    const cA = curve.pointMultiply(A, curve.scalarReduce(c));
    return proof.vPoint === curve.pointAdd(rG, cA);
}
exports.verifySchnorrProof = verifySchnorrProof;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nobm9yclByb29mLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NjaG5vcnJQcm9vZi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7O0dBR0c7QUFDSCxtQ0FBb0M7QUFHcEMsaUNBQThEO0FBRTlEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixrQkFBa0IsQ0FDaEMsQ0FBUyxFQUNULENBQVMsRUFDVCxLQUFZLEVBQ1osZ0JBQXdCLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBRXZDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUMvQixNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRWpDLE1BQU0sQ0FBQyxHQUFHLHVCQUF1QixDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLGFBQWEsQ0FBQyxDQUFDO0lBRTlELE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFckQsT0FBTztRQUNMLE1BQU0sRUFBRSxDQUFDO1FBQ1QsQ0FBQyxFQUFFLENBQUM7S0FDTCxDQUFDO0FBQ0osQ0FBQztBQWpCRCxnREFpQkM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILFNBQVMsdUJBQXVCLENBQUMsQ0FBUyxFQUFFLENBQVMsRUFBRSxLQUFZLEVBQUUsYUFBcUI7SUFDeEYsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV6QyxNQUFNLElBQUksR0FBRyxtQkFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2xDLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDckMsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNyQyxJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3JDLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7SUFFM0IsT0FBTyx5QkFBa0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztBQUMzQyxDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQWdCLGtCQUFrQixDQUNoQyxDQUFTLEVBQ1QsS0FBbUIsRUFDbkIsS0FBWSxFQUNaLGdCQUF3QixNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUV2QyxNQUFNLENBQUMsR0FBRyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsYUFBYSxDQUFDLENBQUM7SUFFekUsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFeEMsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXpELE9BQU8sS0FBSyxDQUFDLE1BQU0sS0FBSyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNqRCxDQUFDO0FBYkQsZ0RBYUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIFNjaG5vcnIgTm9uLWludGVyYWN0aXZlIFplcm8tS25vd2xlZGdlIFByb29mLlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvcmZjODIzNS99XG4gKi9cbmltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgQmFzZUN1cnZlIGFzIEN1cnZlIH0gZnJvbSAnLi9jdXJ2ZXMnO1xuaW1wb3J0IHsgU2Nobm9yclByb29mIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBiaWdJbnRGcm9tQnVmZmVyQkUsIGJpZ0ludFRvQnVmZmVyQkUgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENyZWF0ZSBhIFNjaG5vcnIgUHJvb2Ygb2Yga25vd2xlZGdlIG9mIHRoZSBkaXNjcmV0ZSBsb2cgb2YgYW4gRWxsaXB0aWMtY3VydmUgcG9pbnQuXG4gKiBAcGFyYW0gQSBUaGUgY3VydmUgcG9pbnQuXG4gKiBAcGFyYW0gYSBUaGUgZGlzY3JldGUgbG9nIG9mIHRoZSBjdXJ2ZSBwb2ludC5cbiAqIEBwYXJhbSBjdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUuXG4gKiBAcGFyYW0gYWRkaXRpb25hbEN0eCBBZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gdG8gYXNzb2NpYXRlIHdpdGggdGhlIHByb29mLlxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgcHJvb2YuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY2hub3JyUHJvb2YoXG4gIEE6IGJpZ2ludCxcbiAgYTogYmlnaW50LFxuICBjdXJ2ZTogQ3VydmUsXG4gIGFkZGl0aW9uYWxDdHg6IEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKCcnKVxuKTogU2Nobm9yclByb29mIHtcbiAgY29uc3QgdiA9IGN1cnZlLnNjYWxhclJhbmRvbSgpO1xuICBjb25zdCBWID0gY3VydmUuYmFzZVBvaW50TXVsdCh2KTtcblxuICBjb25zdCBjID0gbm9uSW50ZXJhY3RpdmVDaGFsbGVuZ2UoViwgQSwgY3VydmUsIGFkZGl0aW9uYWxDdHgpO1xuXG4gIGNvbnN0IHIgPSBjdXJ2ZS5zY2FsYXJTdWIodiwgY3VydmUuc2NhbGFyTXVsdChhLCBjKSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2UG9pbnQ6IFYsXG4gICAgcjogcixcbiAgfTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgY2hhbGxlbmdlIGZvciBOSVpLIHNjaG5vcnIgcHJvb2YgdXNpbmcgRmlhdC1TaGFtaXIgdHJhbnNmb3JtLlxuICpcbiAqIEBwYXJhbSBWIFRoZSBwb2ludC9wdWJsaWMgdmFsdWUgY29ycmVzcG9uZGluZyB0byB0aGUgcmFuZG9tIHNjYWxhciB2YWx1ZSB2IGNob3NlbiBieSB0aGUgcHJvdmVyLlxuICogQHBhcmFtIEEgVGhlIHBvaW50IHRvIGJlIHByb3ZlZC5cbiAqIEBwYXJhbSBjdXJ2ZSBUaGUgZWxsaXB0aWMgY3VydmUuXG4gKiBAcGFyYW0gYWRkaXRpb25hbEN0eCBBZGRpdGlvbmFsIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gdG8gYXNzb2NpYXRlIHdpdGggdGhlIHByb29mLlxuICogQHJldHVybnMgVGhlIGNhbGN1bGF0ZWQgY2hhbGxlbmdlLlxuICovXG5mdW5jdGlvbiBub25JbnRlcmFjdGl2ZUNoYWxsZW5nZShWOiBiaWdpbnQsIEE6IGJpZ2ludCwgY3VydmU6IEN1cnZlLCBhZGRpdGlvbmFsQ3R4OiBCdWZmZXIpOiBiaWdpbnQge1xuICBjb25zdCBHID0gY3VydmUuYmFzZVBvaW50TXVsdChCaWdJbnQoMSkpO1xuXG4gIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShHLCAzMikpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKFYsIDMyKSk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoQSwgMzIpKTtcbiAgaGFzaC51cGRhdGUoYWRkaXRpb25hbEN0eCk7XG5cbiAgcmV0dXJuIGJpZ0ludEZyb21CdWZmZXJCRShoYXNoLmRpZ2VzdCgpKTtcbn1cblxuLyoqXG4gKiBWZXJpZnkgYSBTY2hub3JyIFByb29mIG9mIGtub3dsZWRnZSBvZiB0aGUgZGlzY3JldGUgbG9nIG9mIGFuIEVsbGlwdGljLWN1cnZlIHBvaW50LlxuICogQHBhcmFtIEEgVGhlIGN1cnZlIHBvaW50LlxuICogQHBhcmFtIHByb29mIFRoZSBzY2hub3JyIHByb29mLlxuICogQHBhcmFtIGN1cnZlIFRoZSBlbGxpcHRpYyBjdXJ2ZS5cbiAqIEBwYXJhbSBhZGRpdGlvbmFsQ3R4IEFkZGl0aW9uYWwgY29udGV4dHVhbCBpbmZvcm1hdGlvbiB0aGF0IGlzIHN1cHBvc2VkIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBwcm9vZi5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHByb29mIGNoZWNrcyBvdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTY2hub3JyUHJvb2YoXG4gIEE6IGJpZ2ludCxcbiAgcHJvb2Y6IFNjaG5vcnJQcm9vZixcbiAgY3VydmU6IEN1cnZlLFxuICBhZGRpdGlvbmFsQ3R4OiBCdWZmZXIgPSBCdWZmZXIuZnJvbSgnJylcbik6IGJvb2xlYW4ge1xuICBjb25zdCBjID0gbm9uSW50ZXJhY3RpdmVDaGFsbGVuZ2UocHJvb2YudlBvaW50LCBBLCBjdXJ2ZSwgYWRkaXRpb25hbEN0eCk7XG5cbiAgY29uc3QgckcgPSBjdXJ2ZS5iYXNlUG9pbnRNdWx0KHByb29mLnIpO1xuXG4gIGNvbnN0IGNBID0gY3VydmUucG9pbnRNdWx0aXBseShBLCBjdXJ2ZS5zY2FsYXJSZWR1Y2UoYykpO1xuXG4gIHJldHVybiBwcm9vZi52UG9pbnQgPT09IGN1cnZlLnBvaW50QWRkKHJHLCBjQSk7XG59XG4iXX0=