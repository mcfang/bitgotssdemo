"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Secp256k1Curve = void 0;
const util_1 = require("../util");
const secp = __importStar(require("@noble/secp256k1"));
const order = secp.CURVE.n;
const privateKeySize = 32;
const publicKeySize = 33;
class Secp256k1Curve {
    constructor() {
        this.scalarBytes = privateKeySize;
        // Always use compressed points.
        this.pointBytes = publicKeySize;
    }
    scalarRandom() {
        return util_1.bigIntFromU8ABE(secp.utils.randomPrivateKey());
    }
    scalarAdd(x, y) {
        return util_1.bigIntFromU8ABE(secp.utils.privateAdd(x, util_1.bigIntToBufferBE(y, privateKeySize)));
    }
    scalarSub(x, y) {
        const negatedY = secp.utils.privateNegate(y);
        return util_1.bigIntFromU8ABE(secp.utils.privateAdd(x, negatedY));
    }
    scalarMult(x, y) {
        return secp.utils.mod(x * y, order);
    }
    scalarReduce(s) {
        return secp.utils.mod(s, order);
    }
    scalarNegate(s) {
        return util_1.bigIntFromU8ABE(secp.utils.privateNegate(s));
    }
    scalarInvert(s) {
        return secp.utils.invert(s, order);
    }
    pointAdd(a, b) {
        const pointA = secp.Point.fromHex(util_1.bigIntToBufferBE(a, privateKeySize));
        const pointB = secp.Point.fromHex(util_1.bigIntToBufferBE(b, privateKeySize));
        return util_1.bigIntFromU8ABE(pointA.add(pointB).toRawBytes(true));
    }
    pointMultiply(p, s) {
        const pointA = secp.Point.fromHex(util_1.bigIntToBufferBE(p, privateKeySize));
        return util_1.bigIntFromU8ABE(pointA.multiply(s).toRawBytes(true));
    }
    basePointMult(n) {
        const point = util_1.bigIntToBufferBE(n, privateKeySize);
        return util_1.bigIntFromU8ABE(secp.getPublicKey(point, true));
    }
    verify(message, signature, publicKey) {
        return Buffer.from(secp.recoverPublicKey(message, signature.subarray(1), signature[0], true)).equals(util_1.bigIntToBufferBE(publicKey, publicKeySize));
    }
    order() {
        return order;
    }
}
exports.Secp256k1Curve = Secp256k1Curve;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2N1cnZlcy9zZWNwMjU2azEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtDQUE0RDtBQUU1RCx1REFBeUM7QUFFekMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDM0IsTUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDO0FBQzFCLE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQztBQUV6QixNQUFhLGNBQWM7SUFBM0I7UUF3REUsZ0JBQVcsR0FBRyxjQUFjLENBQUM7UUFFN0IsZ0NBQWdDO1FBQ2hDLGVBQVUsR0FBRyxhQUFhLENBQUM7SUFDN0IsQ0FBQztJQTNEQyxZQUFZO1FBQ1YsT0FBTyxzQkFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO0lBQ3hELENBQUM7SUFFRCxTQUFTLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDNUIsT0FBTyxzQkFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSx1QkFBZ0IsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hGLENBQUM7SUFFRCxTQUFTLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDNUIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0MsT0FBTyxzQkFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRCxVQUFVLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDN0IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxZQUFZLENBQUMsQ0FBUztRQUNwQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNsQyxDQUFDO0lBRUQsWUFBWSxDQUFDLENBQVM7UUFDcEIsT0FBTyxzQkFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVELFlBQVksQ0FBQyxDQUFTO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3JDLENBQUM7SUFFRCxRQUFRLENBQUMsQ0FBUyxFQUFFLENBQVM7UUFDM0IsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFDdkUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFDdkUsT0FBTyxzQkFBZSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVELGFBQWEsQ0FBQyxDQUFTLEVBQUUsQ0FBUztRQUNoQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyx1QkFBZ0IsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQztRQUN2RSxPQUFPLHNCQUFlLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQsYUFBYSxDQUFDLENBQVM7UUFDckIsTUFBTSxLQUFLLEdBQUcsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ2xELE9BQU8sc0JBQWUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFRCxNQUFNLENBQUMsT0FBZSxFQUFFLFNBQWlCLEVBQUUsU0FBaUI7UUFDMUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQ2xHLHVCQUFnQixDQUFDLFNBQVMsRUFBRSxhQUFhLENBQUMsQ0FDM0MsQ0FBQztJQUNKLENBQUM7SUFFRCxLQUFLO1FBQ0gsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBTUY7QUE1REQsd0NBNERDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYmlnSW50RnJvbVU4QUJFLCBiaWdJbnRUb0J1ZmZlckJFIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyBCYXNlQ3VydmUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCAqIGFzIHNlY3AgZnJvbSAnQG5vYmxlL3NlY3AyNTZrMSc7XG5cbmNvbnN0IG9yZGVyID0gc2VjcC5DVVJWRS5uO1xuY29uc3QgcHJpdmF0ZUtleVNpemUgPSAzMjtcbmNvbnN0IHB1YmxpY0tleVNpemUgPSAzMztcblxuZXhwb3J0IGNsYXNzIFNlY3AyNTZrMUN1cnZlIGltcGxlbWVudHMgQmFzZUN1cnZlIHtcbiAgc2NhbGFyUmFuZG9tKCk6IGJpZ2ludCB7XG4gICAgcmV0dXJuIGJpZ0ludEZyb21VOEFCRShzZWNwLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSk7XG4gIH1cblxuICBzY2FsYXJBZGQoeDogYmlnaW50LCB5OiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIHJldHVybiBiaWdJbnRGcm9tVThBQkUoc2VjcC51dGlscy5wcml2YXRlQWRkKHgsIGJpZ0ludFRvQnVmZmVyQkUoeSwgcHJpdmF0ZUtleVNpemUpKSk7XG4gIH1cblxuICBzY2FsYXJTdWIoeDogYmlnaW50LCB5OiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIGNvbnN0IG5lZ2F0ZWRZID0gc2VjcC51dGlscy5wcml2YXRlTmVnYXRlKHkpO1xuICAgIHJldHVybiBiaWdJbnRGcm9tVThBQkUoc2VjcC51dGlscy5wcml2YXRlQWRkKHgsIG5lZ2F0ZWRZKSk7XG4gIH1cblxuICBzY2FsYXJNdWx0KHg6IGJpZ2ludCwgeTogYmlnaW50KTogYmlnaW50IHtcbiAgICByZXR1cm4gc2VjcC51dGlscy5tb2QoeCAqIHksIG9yZGVyKTtcbiAgfVxuXG4gIHNjYWxhclJlZHVjZShzOiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIHJldHVybiBzZWNwLnV0aWxzLm1vZChzLCBvcmRlcik7XG4gIH1cblxuICBzY2FsYXJOZWdhdGUoczogYmlnaW50KTogYmlnaW50IHtcbiAgICByZXR1cm4gYmlnSW50RnJvbVU4QUJFKHNlY3AudXRpbHMucHJpdmF0ZU5lZ2F0ZShzKSk7XG4gIH1cblxuICBzY2FsYXJJbnZlcnQoczogYmlnaW50KTogYmlnaW50IHtcbiAgICByZXR1cm4gc2VjcC51dGlscy5pbnZlcnQocywgb3JkZXIpO1xuICB9XG5cbiAgcG9pbnRBZGQoYTogYmlnaW50LCBiOiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIGNvbnN0IHBvaW50QSA9IHNlY3AuUG9pbnQuZnJvbUhleChiaWdJbnRUb0J1ZmZlckJFKGEsIHByaXZhdGVLZXlTaXplKSk7XG4gICAgY29uc3QgcG9pbnRCID0gc2VjcC5Qb2ludC5mcm9tSGV4KGJpZ0ludFRvQnVmZmVyQkUoYiwgcHJpdmF0ZUtleVNpemUpKTtcbiAgICByZXR1cm4gYmlnSW50RnJvbVU4QUJFKHBvaW50QS5hZGQocG9pbnRCKS50b1Jhd0J5dGVzKHRydWUpKTtcbiAgfVxuXG4gIHBvaW50TXVsdGlwbHkocDogYmlnaW50LCBzOiBiaWdpbnQpOiBiaWdpbnQge1xuICAgIGNvbnN0IHBvaW50QSA9IHNlY3AuUG9pbnQuZnJvbUhleChiaWdJbnRUb0J1ZmZlckJFKHAsIHByaXZhdGVLZXlTaXplKSk7XG4gICAgcmV0dXJuIGJpZ0ludEZyb21VOEFCRShwb2ludEEubXVsdGlwbHkocykudG9SYXdCeXRlcyh0cnVlKSk7XG4gIH1cblxuICBiYXNlUG9pbnRNdWx0KG46IGJpZ2ludCk6IGJpZ2ludCB7XG4gICAgY29uc3QgcG9pbnQgPSBiaWdJbnRUb0J1ZmZlckJFKG4sIHByaXZhdGVLZXlTaXplKTtcbiAgICByZXR1cm4gYmlnSW50RnJvbVU4QUJFKHNlY3AuZ2V0UHVibGljS2V5KHBvaW50LCB0cnVlKSk7XG4gIH1cblxuICB2ZXJpZnkobWVzc2FnZTogQnVmZmVyLCBzaWduYXR1cmU6IEJ1ZmZlciwgcHVibGljS2V5OiBiaWdpbnQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcC5yZWNvdmVyUHVibGljS2V5KG1lc3NhZ2UsIHNpZ25hdHVyZS5zdWJhcnJheSgxKSwgc2lnbmF0dXJlWzBdLCB0cnVlKSkuZXF1YWxzKFxuICAgICAgYmlnSW50VG9CdWZmZXJCRShwdWJsaWNLZXksIHB1YmxpY0tleVNpemUpXG4gICAgKTtcbiAgfVxuXG4gIG9yZGVyKCk6IGJpZ2ludCB7XG4gICAgcmV0dXJuIG9yZGVyO1xuICB9XG5cbiAgc2NhbGFyQnl0ZXMgPSBwcml2YXRlS2V5U2l6ZTtcblxuICAvLyBBbHdheXMgdXNlIGNvbXByZXNzZWQgcG9pbnRzLlxuICBwb2ludEJ5dGVzID0gcHVibGljS2V5U2l6ZTtcbn1cbiJdfQ==