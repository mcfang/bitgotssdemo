"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyWithCheck = exports.proveWithCheck = exports.verify = exports.prove = exports.verifyNtildeProof = exports.generateNtildeProof = exports.generateNtilde = exports.generateSafePrimes = void 0;
/**
 * Zero Knowledge Range Proofs as described in (Two-party generation of DSA signatures)[1].
 * [1]: https://reitermk.github.io/papers/2004/IJIS.pdf
 */
const crypto_1 = require("crypto");
const bigint_crypto_utils_1 = require("bigint-crypto-utils");
const bigint_mod_arith_1 = require("bigint-mod-arith");
const util_1 = require("../../util");
const openssl_1 = require("../../openssl");
const index_1 = require("./index");
// 128 as recommend by https://blog.verichains.io/p/vsa-2022-120-multichain-key-extraction.
const ITERATIONS = 128;
async function generateSafePrimes(bitLengths) {
    const openSSL = new openssl_1.OpenSSL();
    await openSSL.init();
    const promises = bitLengths.map((bitlength) => {
        return openSSL.generateSafePrime(bitlength);
    });
    return await Promise.all(promises);
}
exports.generateSafePrimes = generateSafePrimes;
async function generateModulus(bitlength = index_1.minModulusBitLength, retry = 10) {
    if (bitlength < index_1.minModulusBitLength) {
        // https://www.keylength.com/en/6/
        // eslint-disable-next-line no-console
        console.warn('Generating a modulus with less than 3072 is not recommended!');
    }
    const bitlengthP = Math.floor(bitlength / 2);
    const bitlengthQ = bitlength - bitlengthP;
    for (let i = 0; i < retry; i++) {
        const [p, q] = await generateSafePrimes([bitlengthP, bitlengthQ]);
        const n = p * q;
        // For large bit lengths, the probability of generating a modulus with the wrong bit length is very low.
        if (bigint_crypto_utils_1.bitLength(n) !== bitlength) {
            continue;
        }
        return { n, q1: (p - BigInt(1)) / BigInt(2), q2: (q - BigInt(1)) / BigInt(2) };
    }
    throw new Error(`Unable to generate modulus with bit length of ${bitlength} after ${retry} tries. Please try again or reach out to support@bitgo.com`);
}
/**
 * Generate "challenge" values for range proofs.
 * @param {number} bitlength The bit length of the modulus to generate. This should
 * be the same as the bit length of the paillier public keys used for MtA.
 * @returns {DeserializedNtilde} The generated Ntilde values.
 */
async function generateNtilde(bitlength = index_1.minModulusBitLength) {
    const { n: ntilde, q1, q2 } = await generateModulus(bitlength);
    const [f1, f2] = await Promise.all([util_1.randomPositiveCoPrimeTo(ntilde), util_1.randomPositiveCoPrimeTo(ntilde)]);
    const h1 = bigint_mod_arith_1.modPow(f1, BigInt(2), ntilde);
    const h2 = bigint_mod_arith_1.modPow(h1, f2, ntilde);
    const beta = bigint_mod_arith_1.modInv(f2, q1 * q2);
    const [h1wrtH2Proofs, h2wrtH1Proofs] = await Promise.all([
        generateNtildeProof({
            h1: h1,
            h2: h2,
            ntilde: ntilde,
        }, f2, q1, q2),
        generateNtildeProof({
            h1: h2,
            h2: h1,
            ntilde: ntilde,
        }, beta, q1, q2),
    ]);
    return {
        ntilde,
        h1,
        h2,
        ntildeProof: {
            h1WrtH2: {
                alpha: h1wrtH2Proofs.alpha,
                t: h1wrtH2Proofs.t,
            },
            h2WrtH1: {
                alpha: h2wrtH1Proofs.alpha,
                t: h2wrtH1Proofs.t,
            },
        },
    };
}
exports.generateNtilde = generateNtilde;
/**
 * Generate iterations of Ntilde, h1, h2 discrete log proofs.
 * @param {DeserializedNtilde} ntilde Ntilde, h1, h2 to generate the proofs for.
 * @param {bigint} x Either alpha or beta depending on whether it is a discrete log proof of
 * h1 w.r.t h2 or h2 w.r.t h1.
 * @param {bigint} q1 The Sophie Germain prime associated with the first safe prime p1 used to generate Ntilde.
 * @param {bigint} q2 The Sophie Germain prime associated with the second safe prime p2 used to generate Ntilde.
 * @returns {NtildeProof} The generated Ntilde Proofs.
 */
async function generateNtildeProof(ntilde, x, q1, q2) {
    const q1MulQ2 = q1 * q2;
    const a = [];
    const alpha = [];
    let msgToHash = Buffer.concat([
        util_1.bigIntToBufferBE(ntilde.h1),
        util_1.bigIntToBufferBE(ntilde.h2),
        util_1.bigIntToBufferBE(ntilde.ntilde),
    ]);
    for (let i = 0; i < ITERATIONS; i++) {
        a.push(bigint_crypto_utils_1.randBetween(q1MulQ2));
        alpha.push(bigint_mod_arith_1.modPow(ntilde.h1, a[i], ntilde.ntilde));
        msgToHash = Buffer.concat([msgToHash, util_1.bigIntToBufferBE(alpha[i], Math.ceil(bigint_crypto_utils_1.bitLength(ntilde.ntilde) / 8))]);
    }
    const simulatedResponse = crypto_1.createHash('sha256').update(msgToHash).digest();
    const t = [];
    for (let i = 0; i < ITERATIONS; i++) {
        // Get the ith bit from a buffer of bytes.
        const ithBit = (simulatedResponse[Math.floor(i / 8)] >> (7 - (i % 8))) & 1;
        t.push((a[i] + ((BigInt(ithBit) * x) % q1MulQ2)) % q1MulQ2);
    }
    return { alpha, t };
}
exports.generateNtildeProof = generateNtildeProof;
/**
 * Verify discrete log proofs of h1 and h2 mod Ntilde.
 * @param {DeserializedNtilde} ntilde Ntilde, h1, h2 to generate the proofs for.
 * @param {DeserializedNtildeProof} ntildeProof Ntilde Proofs
 * @returns {boolean} true if proof is verified, false otherwise.
 */
async function verifyNtildeProof(ntilde, ntildeProof) {
    const h1ModNtilde = ntilde.h1 % ntilde.ntilde;
    const h2ModNtilde = ntilde.h2 % ntilde.ntilde;
    if (h1ModNtilde === BigInt(0) || h2ModNtilde === BigInt(0)) {
        return false;
    }
    if (h1ModNtilde === BigInt(1) || h2ModNtilde === BigInt(1)) {
        return false;
    }
    if (h1ModNtilde === h2ModNtilde) {
        return false;
    }
    if (ntildeProof.alpha.length > 256 ||
        ntildeProof.alpha.length !== ITERATIONS ||
        ntildeProof.t.length !== ITERATIONS) {
        return false;
    }
    let msgToHash = Buffer.concat([
        util_1.bigIntToBufferBE(ntilde.h1),
        util_1.bigIntToBufferBE(ntilde.h2),
        util_1.bigIntToBufferBE(ntilde.ntilde),
    ]);
    for (let i = 0; i < ntildeProof.alpha.length; i++) {
        msgToHash = Buffer.concat([
            msgToHash,
            util_1.bigIntToBufferBE(ntildeProof.alpha[i], Math.ceil(bigint_crypto_utils_1.bitLength(ntilde.ntilde) / 8)),
        ]);
    }
    const simulatedResponse = crypto_1.createHash('sha256').update(msgToHash).digest();
    for (let i = 0; i < ntildeProof.alpha.length; i++) {
        // Get the ith bit from a buffer of bytes.
        const ithBit = (simulatedResponse[Math.floor(i / 8)] >> (7 - (i % 8))) & 1;
        const h1PowTi = bigint_mod_arith_1.modPow(ntilde.h1, ntildeProof.t[i], ntilde.ntilde);
        const h2PowCi = bigint_mod_arith_1.modPow(ntilde.h2, BigInt(ithBit), ntilde.ntilde);
        const alphaMulh2PowCi = (ntildeProof.alpha[i] * h2PowCi) % ntilde.ntilde;
        if (h1PowTi !== alphaMulh2PowCi) {
            return false;
        }
    }
    return true;
}
exports.verifyNtildeProof = verifyNtildeProof;
/**
 * Generate a zero-knowledge range proof that an encrypted value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {bigint} c The ciphertext.
 * @param {bigint} m The plaintext.
 * @param {bigint} r The obfuscation value used to encrypt m.
 * @returns {RangeProof} The generated proof.
 */
async function prove(curve, modulusBits, pk, ntilde, c, m, r) {
    const modulusBytes = Math.floor((modulusBits + 7) / 8);
    const q = curve.order();
    const q3 = q ** BigInt(3);
    const qntilde = q * ntilde.ntilde;
    const q3ntilde = q3 * ntilde.ntilde;
    const alpha = bigint_crypto_utils_1.randBetween(q3);
    const beta = await util_1.randomPositiveCoPrimeTo(pk.n);
    const gamma = bigint_crypto_utils_1.randBetween(q3ntilde);
    const rho = bigint_crypto_utils_1.randBetween(qntilde);
    const z = (bigint_mod_arith_1.modPow(ntilde.h1, m, ntilde.ntilde) * bigint_mod_arith_1.modPow(ntilde.h2, rho, ntilde.ntilde)) % ntilde.ntilde;
    const u = (bigint_mod_arith_1.modPow(pk.g, alpha, pk._n2) * bigint_mod_arith_1.modPow(beta, pk.n, pk._n2)) % pk._n2;
    const w = (bigint_mod_arith_1.modPow(ntilde.h1, alpha, ntilde.ntilde) * bigint_mod_arith_1.modPow(ntilde.h2, gamma, ntilde.ntilde)) % ntilde.ntilde;
    const hash = crypto_1.createHash('sha256');
    hash.update('\x06\x00\x00\x00\x00\x00\x00\x00');
    hash.update(util_1.bigIntToBufferBE(pk.n, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(pk.g, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(c, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(z, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(u, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(w, modulusBytes));
    hash.update('$');
    const e = util_1.bigIntFromBufferBE(hash.digest()) % q;
    const s = (bigint_mod_arith_1.modPow(r, e, pk.n) * beta) % pk.n;
    const s1 = e * m + alpha;
    const s2 = e * rho + gamma;
    return { z, u, w, s, s1, s2 };
}
exports.prove = prove;
/**
 * Verify a zero-knowledge range proof that an encrypted value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {RangeProof} proof The range proof.
 * @param {bigint} c The ciphertext.
 * @returns {boolean} True if verification succeeds.
 */
function verify(curve, modulusBits, pk, ntilde, proof, c) {
    if (proof.u === BigInt(0) || proof.s === BigInt(0)) {
        return false;
    }
    const modulusBytes = Math.floor((modulusBits + 7) / 8);
    const q = curve.order();
    const q3 = q ** BigInt(3);
    if (proof.s1 > q3) {
        return false;
    }
    const hash = crypto_1.createHash('sha256');
    hash.update('\x06\x00\x00\x00\x00\x00\x00\x00');
    hash.update(util_1.bigIntToBufferBE(pk.n, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(pk.g, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(c, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(proof.z, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(proof.u, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(proof.w, modulusBytes));
    hash.update('$');
    const e = util_1.bigIntFromBufferBE(hash.digest()) % q;
    let products;
    products = (bigint_mod_arith_1.modPow(pk.g, proof.s1, pk._n2) * bigint_mod_arith_1.modPow(proof.s, pk.n, pk._n2) * bigint_mod_arith_1.modPow(c, -e, pk._n2)) % pk._n2;
    if (proof.u !== products) {
        return false;
    }
    products =
        (((bigint_mod_arith_1.modPow(ntilde.h1, proof.s1, ntilde.ntilde) * bigint_mod_arith_1.modPow(ntilde.h2, proof.s2, ntilde.ntilde)) % ntilde.ntilde) *
            bigint_mod_arith_1.modPow(proof.z, -e, ntilde.ntilde)) %
            ntilde.ntilde;
    return proof.w === products;
}
exports.verify = verify;
/**
 * Generate a zero-knowledge range proof that a homomorphically manipulated value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {bigint} c1 The original ciphertext.
 * @param {bigint} c2 The manipulated ciphertext.
 * @param {bigint} x The plaintext value multiplied by the original plaintext.
 * @param {bigint} y The plaintext value that is added to x.
 * @param {bigint} r The obfuscation value used to encrypt x.
 * @param {bigint} X The curve's base point raised to x.
 * @returns {RangeProofWithCheck} The generated proof.
 */
async function proveWithCheck(curve, modulusBits, pk, ntilde, c1, c2, x, y, r, X) {
    const modulusBytes = Math.floor((modulusBits + 7) / 8);
    const q = curve.order();
    const q3 = q ** BigInt(3);
    const q7 = q ** BigInt(7);
    const qntilde = q * ntilde.ntilde;
    const q3ntilde = q3 * ntilde.ntilde;
    const alpha = bigint_crypto_utils_1.randBetween(q3);
    const rho = bigint_crypto_utils_1.randBetween(qntilde);
    const sigma = bigint_crypto_utils_1.randBetween(qntilde);
    const tau = bigint_crypto_utils_1.randBetween(q3ntilde);
    const rhoprm = bigint_crypto_utils_1.randBetween(q3ntilde);
    const beta = await util_1.randomPositiveCoPrimeTo(pk.n);
    const gamma = bigint_crypto_utils_1.randBetween(q7);
    const u = curve.basePointMult(curve.scalarReduce(alpha));
    const z = (bigint_mod_arith_1.modPow(ntilde.h1, x, ntilde.ntilde) * bigint_mod_arith_1.modPow(ntilde.h2, rho, ntilde.ntilde)) % ntilde.ntilde;
    const zprm = (bigint_mod_arith_1.modPow(ntilde.h1, alpha, ntilde.ntilde) * bigint_mod_arith_1.modPow(ntilde.h2, rhoprm, ntilde.ntilde)) % ntilde.ntilde;
    const t = (bigint_mod_arith_1.modPow(ntilde.h1, y, ntilde.ntilde) * bigint_mod_arith_1.modPow(ntilde.h2, sigma, ntilde.ntilde)) % ntilde.ntilde;
    const v = (((bigint_mod_arith_1.modPow(c1, alpha, pk._n2) * bigint_mod_arith_1.modPow(pk.g, gamma, pk._n2)) % pk._n2) * bigint_mod_arith_1.modPow(beta, pk.n, pk._n2)) % pk._n2;
    const w = (bigint_mod_arith_1.modPow(ntilde.h1, gamma, ntilde.ntilde) * bigint_mod_arith_1.modPow(ntilde.h2, tau, ntilde.ntilde)) % ntilde.ntilde;
    const hash = crypto_1.createHash('sha256');
    hash.update('\x0d\x00\x00\x00\x00\x00\x00\x00');
    hash.update(util_1.bigIntToBufferBE(pk.n, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(pk.g, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(X, 33));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(c1, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(c2, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(u, 33));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(z, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(zprm, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(t, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(v, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(w, modulusBytes));
    hash.update('$');
    const e = util_1.bigIntFromBufferBE(hash.digest()) % q;
    const s = (bigint_mod_arith_1.modPow(r, e, pk.n) * beta) % pk.n;
    const s1 = e * x + alpha;
    const s2 = e * rho + rhoprm;
    const t1 = e * y + gamma;
    const t2 = e * sigma + tau;
    return { z, zprm, t, v, w, s, s1, s2, t1, t2, u };
}
exports.proveWithCheck = proveWithCheck;
/**
 * Verify a zero-knowledge range proof that a homomorphically manipulated value is "small".
 * @param {BaseCurve} curve An elliptic curve to use for group operations.
 * @param {number} modulusBits The bit count of the prover's public key.
 * @param {PublicKey} pk The prover's public key.
 * @param {DeserializedNtilde} ntilde The verifier's Ntilde values.
 * @param {RangeProofWithCheck} proof The range proof.
 * @param {bigint} c1 The original ciphertext.
 * @param {bigint} c2 The manipulated ciphertext.
 * @param {bigint} X The curve's base point raised to x.
 * @returns {boolean} True if verification succeeds.
 */
function verifyWithCheck(curve, modulusBits, pk, ntilde, proof, c1, c2, X) {
    const modulusBytes = Math.floor((modulusBits + 7) / 8);
    const q = curve.order();
    const q3 = q ** BigInt(3);
    const q7 = q ** BigInt(7);
    if (proof.s1 > q3) {
        return false;
    }
    if (proof.t1 > q7) {
        return false;
    }
    const hash = crypto_1.createHash('sha256');
    hash.update('\x0d\x00\x00\x00\x00\x00\x00\x00');
    hash.update(util_1.bigIntToBufferBE(pk.n, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(pk.g, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(X, 33));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(c1, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(c2, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(proof.u, 33));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(proof.z, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(proof.zprm, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(proof.t, modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(proof.v, 2 * modulusBytes));
    hash.update('$');
    hash.update(util_1.bigIntToBufferBE(proof.w, modulusBytes));
    hash.update('$');
    const e = util_1.bigIntFromBufferBE(hash.digest()) % q;
    const gS1 = curve.basePointMult(curve.scalarReduce(proof.s1));
    const xEU = curve.pointAdd(curve.pointMultiply(X, e), proof.u);
    if (gS1 !== xEU) {
        return false;
    }
    let left, right;
    const h1ExpS1 = bigint_mod_arith_1.modPow(ntilde.h1, proof.s1, ntilde.ntilde);
    const h2ExpS2 = bigint_mod_arith_1.modPow(ntilde.h2, proof.s2, ntilde.ntilde);
    left = (h1ExpS1 * h2ExpS2) % ntilde.ntilde;
    const zExpE = bigint_mod_arith_1.modPow(proof.z, e, ntilde.ntilde);
    right = (zExpE * proof.zprm) % ntilde.ntilde;
    if (left !== right) {
        return false;
    }
    const h1ExpT1 = bigint_mod_arith_1.modPow(ntilde.h1, proof.t1, ntilde.ntilde);
    const h2ExpT2 = bigint_mod_arith_1.modPow(ntilde.h2, proof.t2, ntilde.ntilde);
    left = (h1ExpT1 * h2ExpT2) % ntilde.ntilde;
    const tExpE = bigint_mod_arith_1.modPow(proof.t, e, ntilde.ntilde);
    right = (tExpE * proof.w) % ntilde.ntilde;
    if (left !== right) {
        return false;
    }
    const c1ExpS1 = bigint_mod_arith_1.modPow(c1, proof.s1, pk._n2);
    const sExpN = bigint_mod_arith_1.modPow(proof.s, pk.n, pk._n2);
    const gammaExpT1 = bigint_mod_arith_1.modPow(pk.g, proof.t1, pk._n2);
    left = (((c1ExpS1 * sExpN) % pk._n2) * gammaExpT1) % pk._n2;
    const c2ExpE = bigint_mod_arith_1.modPow(c2, e, pk._n2);
    right = (c2ExpE * proof.v) % pk._n2;
    return left === right;
}
exports.verifyWithCheck = verifyWithCheck;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2Vwcm9vZi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy90c3MvZWNkc2EvcmFuZ2Vwcm9vZi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7O0dBR0c7QUFDSCxtQ0FBb0M7QUFHcEMsNkRBQTZEO0FBQzdELHVEQUFrRDtBQVNsRCxxQ0FBMkY7QUFDM0YsMkNBQXdDO0FBQ3hDLG1DQUE4QztBQUU5QywyRkFBMkY7QUFDM0YsTUFBTSxVQUFVLEdBQUcsR0FBRyxDQUFDO0FBRWhCLEtBQUssVUFBVSxrQkFBa0IsQ0FBQyxVQUFvQjtJQUMzRCxNQUFNLE9BQU8sR0FBRyxJQUFJLGlCQUFPLEVBQUUsQ0FBQztJQUM5QixNQUFNLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNyQixNQUFNLFFBQVEsR0FBc0IsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFNBQWlCLEVBQUUsRUFBRTtRQUN2RSxPQUFPLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM5QyxDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3JDLENBQUM7QUFQRCxnREFPQztBQUVELEtBQUssVUFBVSxlQUFlLENBQUMsU0FBUyxHQUFHLDJCQUFtQixFQUFFLEtBQUssR0FBRyxFQUFFO0lBQ3hFLElBQUksU0FBUyxHQUFHLDJCQUFtQixFQUFFO1FBQ25DLGtDQUFrQztRQUNsQyxzQ0FBc0M7UUFDdEMsT0FBTyxDQUFDLElBQUksQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO0tBQzlFO0lBQ0QsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDN0MsTUFBTSxVQUFVLEdBQUcsU0FBUyxHQUFHLFVBQVUsQ0FBQztJQUMxQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQzlCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsTUFBTSxrQkFBa0IsQ0FBQyxDQUFDLFVBQVUsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQ2xFLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDaEIsd0dBQXdHO1FBQ3hHLElBQUksK0JBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxTQUFTLEVBQUU7WUFDOUIsU0FBUztTQUNWO1FBQ0QsT0FBTyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztLQUNoRjtJQUNELE1BQU0sSUFBSSxLQUFLLENBQ2IsaURBQWlELFNBQVMsVUFBVSxLQUFLLDREQUE0RCxDQUN0SSxDQUFDO0FBQ0osQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLGNBQWMsQ0FBQyxTQUFTLEdBQUcsMkJBQW1CO0lBQ2xFLE1BQU0sRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxNQUFNLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMvRCxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLDhCQUF1QixDQUFDLE1BQU0sQ0FBQyxFQUFFLDhCQUF1QixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2RyxNQUFNLEVBQUUsR0FBRyx5QkFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDekMsTUFBTSxFQUFFLEdBQUcseUJBQU0sQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xDLE1BQU0sSUFBSSxHQUFHLHlCQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNqQyxNQUFNLENBQUMsYUFBYSxFQUFFLGFBQWEsQ0FBQyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQztRQUN2RCxtQkFBbUIsQ0FDakI7WUFDRSxFQUFFLEVBQUUsRUFBRTtZQUNOLEVBQUUsRUFBRSxFQUFFO1lBQ04sTUFBTSxFQUFFLE1BQU07U0FDZixFQUNELEVBQUUsRUFDRixFQUFFLEVBQ0YsRUFBRSxDQUNIO1FBQ0QsbUJBQW1CLENBQ2pCO1lBQ0UsRUFBRSxFQUFFLEVBQUU7WUFDTixFQUFFLEVBQUUsRUFBRTtZQUNOLE1BQU0sRUFBRSxNQUFNO1NBQ2YsRUFDRCxJQUFJLEVBQ0osRUFBRSxFQUNGLEVBQUUsQ0FDSDtLQUNGLENBQUMsQ0FBQztJQUNILE9BQU87UUFDTCxNQUFNO1FBQ04sRUFBRTtRQUNGLEVBQUU7UUFDRixXQUFXLEVBQUU7WUFDWCxPQUFPLEVBQUU7Z0JBQ1AsS0FBSyxFQUFFLGFBQWEsQ0FBQyxLQUFLO2dCQUMxQixDQUFDLEVBQUUsYUFBYSxDQUFDLENBQUM7YUFDbkI7WUFDRCxPQUFPLEVBQUU7Z0JBQ1AsS0FBSyxFQUFFLGFBQWEsQ0FBQyxLQUFLO2dCQUMxQixDQUFDLEVBQUUsYUFBYSxDQUFDLENBQUM7YUFDbkI7U0FDRjtLQUNGLENBQUM7QUFDSixDQUFDO0FBM0NELHdDQTJDQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0ksS0FBSyxVQUFVLG1CQUFtQixDQUN2QyxNQUEwQixFQUMxQixDQUFTLEVBQ1QsRUFBVSxFQUNWLEVBQVU7SUFFVixNQUFNLE9BQU8sR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQ3hCLE1BQU0sQ0FBQyxHQUFhLEVBQUUsQ0FBQztJQUN2QixNQUFNLEtBQUssR0FBYSxFQUFFLENBQUM7SUFDM0IsSUFBSSxTQUFTLEdBQVcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUNwQyx1QkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQzNCLHVCQUFnQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDM0IsdUJBQWdCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztLQUNoQyxDQUFDLENBQUM7SUFDSCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsVUFBVSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ25DLENBQUMsQ0FBQyxJQUFJLENBQUMsaUNBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1FBQzdCLEtBQUssQ0FBQyxJQUFJLENBQUMseUJBQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUNuRCxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVMsRUFBRSx1QkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQywrQkFBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM3RztJQUNELE1BQU0saUJBQWlCLEdBQUcsbUJBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDMUUsTUFBTSxDQUFDLEdBQWEsRUFBRSxDQUFDO0lBQ3ZCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDbkMsMENBQTBDO1FBQzFDLE1BQU0sTUFBTSxHQUFHLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzNFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDO0tBQzdEO0lBQ0QsT0FBTyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUN0QixDQUFDO0FBM0JELGtEQTJCQztBQUVEOzs7OztHQUtHO0FBQ0ksS0FBSyxVQUFVLGlCQUFpQixDQUNyQyxNQUEwQixFQUMxQixXQUFvQztJQUVwQyxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDOUMsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLEVBQUUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzlDLElBQUksV0FBVyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxXQUFXLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQzFELE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLFdBQVcsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUMxRCxPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSSxXQUFXLEtBQUssV0FBVyxFQUFFO1FBQy9CLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxJQUNFLFdBQVcsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEdBQUc7UUFDOUIsV0FBVyxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssVUFBVTtRQUN2QyxXQUFXLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxVQUFVLEVBQ25DO1FBQ0EsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELElBQUksU0FBUyxHQUFXLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDcEMsdUJBQWdCLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUMzQix1QkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQzNCLHVCQUFnQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7S0FDaEMsQ0FBQyxDQUFDO0lBQ0gsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ2pELFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1lBQ3hCLFNBQVM7WUFDVCx1QkFBZ0IsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsK0JBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDaEYsQ0FBQyxDQUFDO0tBQ0o7SUFDRCxNQUFNLGlCQUFpQixHQUFHLG1CQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO0lBQzFFLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNqRCwwQ0FBMEM7UUFDMUMsTUFBTSxNQUFNLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDM0UsTUFBTSxPQUFPLEdBQUcseUJBQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ25FLE1BQU0sT0FBTyxHQUFHLHlCQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2pFLE1BQU0sZUFBZSxHQUFHLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ3pFLElBQUksT0FBTyxLQUFLLGVBQWUsRUFBRTtZQUMvQixPQUFPLEtBQUssQ0FBQztTQUNkO0tBQ0Y7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUE3Q0QsOENBNkNDO0FBQ0Q7Ozs7Ozs7Ozs7R0FVRztBQUNJLEtBQUssVUFBVSxLQUFLLENBQ3pCLEtBQWdCLEVBQ2hCLFdBQW1CLEVBQ25CLEVBQWEsRUFDYixNQUEwQixFQUMxQixDQUFTLEVBQ1QsQ0FBUyxFQUNULENBQVM7SUFFVCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN4QixNQUFNLEVBQUUsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFCLE1BQU0sT0FBTyxHQUFHLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ2xDLE1BQU0sUUFBUSxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGlDQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDOUIsTUFBTSxJQUFJLEdBQUcsTUFBTSw4QkFBdUIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakQsTUFBTSxLQUFLLEdBQUcsaUNBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNwQyxNQUFNLEdBQUcsR0FBRyxpQ0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2pDLE1BQU0sQ0FBQyxHQUFHLENBQUMseUJBQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcseUJBQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQ3hHLE1BQU0sQ0FBQyxHQUFHLENBQUMseUJBQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcseUJBQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO0lBQzlFLE1BQU0sQ0FBQyxHQUFHLENBQUMseUJBQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcseUJBQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzlHLE1BQU0sSUFBSSxHQUFHLG1CQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDbEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO0lBQ2hELElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ2xELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDL0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDL0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixNQUFNLENBQUMsR0FBRyx5QkFBa0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDaEQsTUFBTSxDQUFDLEdBQUcsQ0FBQyx5QkFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDN0MsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7SUFDekIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxLQUFLLENBQUM7SUFDM0IsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUM7QUFDaEMsQ0FBQztBQXhDRCxzQkF3Q0M7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDSCxTQUFnQixNQUFNLENBQ3BCLEtBQWdCLEVBQ2hCLFdBQW1CLEVBQ25CLEVBQWEsRUFDYixNQUEwQixFQUMxQixLQUFpQixFQUNqQixDQUFTO0lBRVQsSUFBSSxLQUFLLENBQUMsQ0FBQyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUNsRCxPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN2RCxNQUFNLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDeEIsTUFBTSxFQUFFLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMxQixJQUFJLEtBQUssQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQ2pCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxNQUFNLElBQUksR0FBRyxtQkFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2xDLElBQUksQ0FBQyxNQUFNLENBQUMsa0NBQWtDLENBQUMsQ0FBQztJQUNoRCxJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNsRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ2xELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDbkQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNyRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUN6RCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3JELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsTUFBTSxDQUFDLEdBQUcseUJBQWtCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2hELElBQUksUUFBZ0IsQ0FBQztJQUNyQixRQUFRLEdBQUcsQ0FBQyx5QkFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcseUJBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLHlCQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7SUFDN0csSUFBSSxLQUFLLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtRQUN4QixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsUUFBUTtRQUNOLENBQUMsQ0FBQyxDQUFDLHlCQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1lBQzFHLHlCQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDckMsTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUNoQixPQUFPLEtBQUssQ0FBQyxDQUFDLEtBQUssUUFBUSxDQUFDO0FBQzlCLENBQUM7QUExQ0Qsd0JBMENDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7R0FhRztBQUNJLEtBQUssVUFBVSxjQUFjLENBQ2xDLEtBQWdCLEVBQ2hCLFdBQW1CLEVBQ25CLEVBQWEsRUFDYixNQUEwQixFQUMxQixFQUFVLEVBQ1YsRUFBVSxFQUNWLENBQVMsRUFDVCxDQUFTLEVBQ1QsQ0FBUyxFQUNULENBQVM7SUFFVCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN4QixNQUFNLEVBQUUsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFCLE1BQU0sRUFBRSxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUIsTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDbEMsTUFBTSxRQUFRLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDcEMsTUFBTSxLQUFLLEdBQUcsaUNBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM5QixNQUFNLEdBQUcsR0FBRyxpQ0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2pDLE1BQU0sS0FBSyxHQUFHLGlDQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbkMsTUFBTSxHQUFHLEdBQUcsaUNBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsQyxNQUFNLE1BQU0sR0FBRyxpQ0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3JDLE1BQU0sSUFBSSxHQUFHLE1BQU0sOEJBQXVCLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2pELE1BQU0sS0FBSyxHQUFHLGlDQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDOUIsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDekQsTUFBTSxDQUFDLEdBQUcsQ0FBQyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDeEcsTUFBTSxJQUFJLEdBQUcsQ0FBQyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDbEgsTUFBTSxDQUFDLEdBQUcsQ0FBQyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDMUcsTUFBTSxDQUFDLEdBQ0wsQ0FBQyxDQUFDLENBQUMseUJBQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyx5QkFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyx5QkFBTSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7SUFDL0csTUFBTSxDQUFDLEdBQUcsQ0FBQyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDNUcsTUFBTSxJQUFJLEdBQUcsbUJBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsQyxJQUFJLENBQUMsTUFBTSxDQUFDLGtDQUFrQyxDQUFDLENBQUM7SUFDaEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNsRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDckMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNyQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDL0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ2xELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUMvQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ25ELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUMvQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLE1BQU0sQ0FBQyxHQUFHLHlCQUFrQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoRCxNQUFNLENBQUMsR0FBRyxDQUFDLHlCQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM3QyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUN6QixNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLE1BQU0sQ0FBQztJQUM1QixNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUN6QixNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsS0FBSyxHQUFHLEdBQUcsQ0FBQztJQUMzQixPQUFPLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQ3BELENBQUM7QUEvREQsd0NBK0RDO0FBRUQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxTQUFnQixlQUFlLENBQzdCLEtBQWdCLEVBQ2hCLFdBQW1CLEVBQ25CLEVBQWEsRUFDYixNQUEwQixFQUMxQixLQUEwQixFQUMxQixFQUFVLEVBQ1YsRUFBVSxFQUNWLENBQVM7SUFFVCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3ZELE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN4QixNQUFNLEVBQUUsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFCLE1BQU0sRUFBRSxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUIsSUFBSSxLQUFLLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUNqQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsSUFBSSxLQUFLLENBQUMsRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUNqQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsTUFBTSxJQUFJLEdBQUcsbUJBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNsQyxJQUFJLENBQUMsTUFBTSxDQUFDLGtDQUFrQyxDQUFDLENBQUM7SUFDaEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDbEQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNsRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDckMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNwRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3BELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDM0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNyRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLElBQUksQ0FBQyxNQUFNLENBQUMsdUJBQWdCLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQ3hELElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakIsSUFBSSxDQUFDLE1BQU0sQ0FBQyx1QkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDckQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDekQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQixJQUFJLENBQUMsTUFBTSxDQUFDLHVCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztJQUNyRCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2pCLE1BQU0sQ0FBQyxHQUFHLHlCQUFrQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNoRCxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDOUQsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDL0QsSUFBSSxHQUFHLEtBQUssR0FBRyxFQUFFO1FBQ2YsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELElBQUksSUFBSSxFQUFFLEtBQUssQ0FBQztJQUNoQixNQUFNLE9BQU8sR0FBRyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDM0QsTUFBTSxPQUFPLEdBQUcseUJBQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzNELElBQUksR0FBRyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzNDLE1BQU0sS0FBSyxHQUFHLHlCQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hELEtBQUssR0FBRyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztJQUM3QyxJQUFJLElBQUksS0FBSyxLQUFLLEVBQUU7UUFDbEIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELE1BQU0sT0FBTyxHQUFHLHlCQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzRCxNQUFNLE9BQU8sR0FBRyx5QkFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDM0QsSUFBSSxHQUFHLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDM0MsTUFBTSxLQUFLLEdBQUcseUJBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEQsS0FBSyxHQUFHLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBQzFDLElBQUksSUFBSSxLQUFLLEtBQUssRUFBRTtRQUNsQixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsTUFBTSxPQUFPLEdBQUcseUJBQU0sQ0FBQyxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDN0MsTUFBTSxLQUFLLEdBQUcseUJBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzVDLE1BQU0sVUFBVSxHQUFHLHlCQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNsRCxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO0lBQzVELE1BQU0sTUFBTSxHQUFHLHlCQUFNLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDckMsS0FBSyxHQUFHLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDO0lBQ3BDLE9BQU8sSUFBSSxLQUFLLEtBQUssQ0FBQztBQUN4QixDQUFDO0FBMUVELDBDQTBFQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogWmVybyBLbm93bGVkZ2UgUmFuZ2UgUHJvb2ZzIGFzIGRlc2NyaWJlZCBpbiAoVHdvLXBhcnR5IGdlbmVyYXRpb24gb2YgRFNBIHNpZ25hdHVyZXMpWzFdLlxuICogWzFdOiBodHRwczovL3JlaXRlcm1rLmdpdGh1Yi5pby9wYXBlcnMvMjAwNC9JSklTLnBkZlxuICovXG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCB7IEJhc2VDdXJ2ZSB9IGZyb20gJy4uLy4uL2N1cnZlcyc7XG5pbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdwYWlsbGllci1iaWdpbnQnO1xuaW1wb3J0IHsgYml0TGVuZ3RoLCByYW5kQmV0d2VlbiB9IGZyb20gJ2JpZ2ludC1jcnlwdG8tdXRpbHMnO1xuaW1wb3J0IHsgbW9kSW52LCBtb2RQb3cgfSBmcm9tICdiaWdpbnQtbW9kLWFyaXRoJztcbmltcG9ydCB7XG4gIERlc2VyaWFsaXplZE50aWxkZSxcbiAgRGVzZXJpYWxpemVkTnRpbGRlUHJvb2YsXG4gIFJTQU1vZHVsdXMsXG4gIFJhbmdlUHJvb2YsXG4gIFJhbmdlUHJvb2ZXaXRoQ2hlY2ssXG4gIERlc2VyaWFsaXplZE50aWxkZVdpdGhQcm9vZnMsXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgYmlnSW50RnJvbUJ1ZmZlckJFLCBiaWdJbnRUb0J1ZmZlckJFLCByYW5kb21Qb3NpdGl2ZUNvUHJpbWVUbyB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgT3BlblNTTCB9IGZyb20gJy4uLy4uL29wZW5zc2wnO1xuaW1wb3J0IHsgbWluTW9kdWx1c0JpdExlbmd0aCB9IGZyb20gJy4vaW5kZXgnO1xuXG4vLyAxMjggYXMgcmVjb21tZW5kIGJ5IGh0dHBzOi8vYmxvZy52ZXJpY2hhaW5zLmlvL3AvdnNhLTIwMjItMTIwLW11bHRpY2hhaW4ta2V5LWV4dHJhY3Rpb24uXG5jb25zdCBJVEVSQVRJT05TID0gMTI4O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTYWZlUHJpbWVzKGJpdExlbmd0aHM6IG51bWJlcltdKTogUHJvbWlzZTxiaWdpbnRbXT4ge1xuICBjb25zdCBvcGVuU1NMID0gbmV3IE9wZW5TU0woKTtcbiAgYXdhaXQgb3BlblNTTC5pbml0KCk7XG4gIGNvbnN0IHByb21pc2VzOiBQcm9taXNlPGJpZ2ludD5bXSA9IGJpdExlbmd0aHMubWFwKChiaXRsZW5ndGg6IG51bWJlcikgPT4ge1xuICAgIHJldHVybiBvcGVuU1NMLmdlbmVyYXRlU2FmZVByaW1lKGJpdGxlbmd0aCk7XG4gIH0pO1xuICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU1vZHVsdXMoYml0bGVuZ3RoID0gbWluTW9kdWx1c0JpdExlbmd0aCwgcmV0cnkgPSAxMCk6IFByb21pc2U8UlNBTW9kdWx1cz4ge1xuICBpZiAoYml0bGVuZ3RoIDwgbWluTW9kdWx1c0JpdExlbmd0aCkge1xuICAgIC8vIGh0dHBzOi8vd3d3LmtleWxlbmd0aC5jb20vZW4vNi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybignR2VuZXJhdGluZyBhIG1vZHVsdXMgd2l0aCBsZXNzIHRoYW4gMzA3MiBpcyBub3QgcmVjb21tZW5kZWQhJyk7XG4gIH1cbiAgY29uc3QgYml0bGVuZ3RoUCA9IE1hdGguZmxvb3IoYml0bGVuZ3RoIC8gMik7XG4gIGNvbnN0IGJpdGxlbmd0aFEgPSBiaXRsZW5ndGggLSBiaXRsZW5ndGhQO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJldHJ5OyBpKyspIHtcbiAgICBjb25zdCBbcCwgcV0gPSBhd2FpdCBnZW5lcmF0ZVNhZmVQcmltZXMoW2JpdGxlbmd0aFAsIGJpdGxlbmd0aFFdKTtcbiAgICBjb25zdCBuID0gcCAqIHE7XG4gICAgLy8gRm9yIGxhcmdlIGJpdCBsZW5ndGhzLCB0aGUgcHJvYmFiaWxpdHkgb2YgZ2VuZXJhdGluZyBhIG1vZHVsdXMgd2l0aCB0aGUgd3JvbmcgYml0IGxlbmd0aCBpcyB2ZXJ5IGxvdy5cbiAgICBpZiAoYml0TGVuZ3RoKG4pICE9PSBiaXRsZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4geyBuLCBxMTogKHAgLSBCaWdJbnQoMSkpIC8gQmlnSW50KDIpLCBxMjogKHEgLSBCaWdJbnQoMSkpIC8gQmlnSW50KDIpIH07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBVbmFibGUgdG8gZ2VuZXJhdGUgbW9kdWx1cyB3aXRoIGJpdCBsZW5ndGggb2YgJHtiaXRsZW5ndGh9IGFmdGVyICR7cmV0cnl9IHRyaWVzLiBQbGVhc2UgdHJ5IGFnYWluIG9yIHJlYWNoIG91dCB0byBzdXBwb3J0QGJpdGdvLmNvbWBcbiAgKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBcImNoYWxsZW5nZVwiIHZhbHVlcyBmb3IgcmFuZ2UgcHJvb2ZzLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdGxlbmd0aCBUaGUgYml0IGxlbmd0aCBvZiB0aGUgbW9kdWx1cyB0byBnZW5lcmF0ZS4gVGhpcyBzaG91bGRcbiAqIGJlIHRoZSBzYW1lIGFzIHRoZSBiaXQgbGVuZ3RoIG9mIHRoZSBwYWlsbGllciBwdWJsaWMga2V5cyB1c2VkIGZvciBNdEEuXG4gKiBAcmV0dXJucyB7RGVzZXJpYWxpemVkTnRpbGRlfSBUaGUgZ2VuZXJhdGVkIE50aWxkZSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU50aWxkZShiaXRsZW5ndGggPSBtaW5Nb2R1bHVzQml0TGVuZ3RoKTogUHJvbWlzZTxEZXNlcmlhbGl6ZWROdGlsZGVXaXRoUHJvb2ZzPiB7XG4gIGNvbnN0IHsgbjogbnRpbGRlLCBxMSwgcTIgfSA9IGF3YWl0IGdlbmVyYXRlTW9kdWx1cyhiaXRsZW5ndGgpO1xuICBjb25zdCBbZjEsIGYyXSA9IGF3YWl0IFByb21pc2UuYWxsKFtyYW5kb21Qb3NpdGl2ZUNvUHJpbWVUbyhudGlsZGUpLCByYW5kb21Qb3NpdGl2ZUNvUHJpbWVUbyhudGlsZGUpXSk7XG4gIGNvbnN0IGgxID0gbW9kUG93KGYxLCBCaWdJbnQoMiksIG50aWxkZSk7XG4gIGNvbnN0IGgyID0gbW9kUG93KGgxLCBmMiwgbnRpbGRlKTtcbiAgY29uc3QgYmV0YSA9IG1vZEludihmMiwgcTEgKiBxMik7XG4gIGNvbnN0IFtoMXdydEgyUHJvb2ZzLCBoMndydEgxUHJvb2ZzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICBnZW5lcmF0ZU50aWxkZVByb29mKFxuICAgICAge1xuICAgICAgICBoMTogaDEsXG4gICAgICAgIGgyOiBoMixcbiAgICAgICAgbnRpbGRlOiBudGlsZGUsXG4gICAgICB9LFxuICAgICAgZjIsXG4gICAgICBxMSxcbiAgICAgIHEyXG4gICAgKSxcbiAgICBnZW5lcmF0ZU50aWxkZVByb29mKFxuICAgICAge1xuICAgICAgICBoMTogaDIsXG4gICAgICAgIGgyOiBoMSxcbiAgICAgICAgbnRpbGRlOiBudGlsZGUsXG4gICAgICB9LFxuICAgICAgYmV0YSxcbiAgICAgIHExLFxuICAgICAgcTJcbiAgICApLFxuICBdKTtcbiAgcmV0dXJuIHtcbiAgICBudGlsZGUsXG4gICAgaDEsXG4gICAgaDIsXG4gICAgbnRpbGRlUHJvb2Y6IHtcbiAgICAgIGgxV3J0SDI6IHtcbiAgICAgICAgYWxwaGE6IGgxd3J0SDJQcm9vZnMuYWxwaGEsXG4gICAgICAgIHQ6IGgxd3J0SDJQcm9vZnMudCxcbiAgICAgIH0sXG4gICAgICBoMldydEgxOiB7XG4gICAgICAgIGFscGhhOiBoMndydEgxUHJvb2ZzLmFscGhhLFxuICAgICAgICB0OiBoMndydEgxUHJvb2ZzLnQsXG4gICAgICB9LFxuICAgIH0sXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgaXRlcmF0aW9ucyBvZiBOdGlsZGUsIGgxLCBoMiBkaXNjcmV0ZSBsb2cgcHJvb2ZzLlxuICogQHBhcmFtIHtEZXNlcmlhbGl6ZWROdGlsZGV9IG50aWxkZSBOdGlsZGUsIGgxLCBoMiB0byBnZW5lcmF0ZSB0aGUgcHJvb2ZzIGZvci5cbiAqIEBwYXJhbSB7YmlnaW50fSB4IEVpdGhlciBhbHBoYSBvciBiZXRhIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIGEgZGlzY3JldGUgbG9nIHByb29mIG9mXG4gKiBoMSB3LnIudCBoMiBvciBoMiB3LnIudCBoMS5cbiAqIEBwYXJhbSB7YmlnaW50fSBxMSBUaGUgU29waGllIEdlcm1haW4gcHJpbWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBmaXJzdCBzYWZlIHByaW1lIHAxIHVzZWQgdG8gZ2VuZXJhdGUgTnRpbGRlLlxuICogQHBhcmFtIHtiaWdpbnR9IHEyIFRoZSBTb3BoaWUgR2VybWFpbiBwcmltZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNlY29uZCBzYWZlIHByaW1lIHAyIHVzZWQgdG8gZ2VuZXJhdGUgTnRpbGRlLlxuICogQHJldHVybnMge050aWxkZVByb29mfSBUaGUgZ2VuZXJhdGVkIE50aWxkZSBQcm9vZnMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZU50aWxkZVByb29mKFxuICBudGlsZGU6IERlc2VyaWFsaXplZE50aWxkZSxcbiAgeDogYmlnaW50LFxuICBxMTogYmlnaW50LFxuICBxMjogYmlnaW50XG4pOiBQcm9taXNlPERlc2VyaWFsaXplZE50aWxkZVByb29mPiB7XG4gIGNvbnN0IHExTXVsUTIgPSBxMSAqIHEyO1xuICBjb25zdCBhOiBiaWdpbnRbXSA9IFtdO1xuICBjb25zdCBhbHBoYTogYmlnaW50W10gPSBbXTtcbiAgbGV0IG1zZ1RvSGFzaDogQnVmZmVyID0gQnVmZmVyLmNvbmNhdChbXG4gICAgYmlnSW50VG9CdWZmZXJCRShudGlsZGUuaDEpLFxuICAgIGJpZ0ludFRvQnVmZmVyQkUobnRpbGRlLmgyKSxcbiAgICBiaWdJbnRUb0J1ZmZlckJFKG50aWxkZS5udGlsZGUpLFxuICBdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBJVEVSQVRJT05TOyBpKyspIHtcbiAgICBhLnB1c2gocmFuZEJldHdlZW4ocTFNdWxRMikpO1xuICAgIGFscGhhLnB1c2gobW9kUG93KG50aWxkZS5oMSwgYVtpXSwgbnRpbGRlLm50aWxkZSkpO1xuICAgIG1zZ1RvSGFzaCA9IEJ1ZmZlci5jb25jYXQoW21zZ1RvSGFzaCwgYmlnSW50VG9CdWZmZXJCRShhbHBoYVtpXSwgTWF0aC5jZWlsKGJpdExlbmd0aChudGlsZGUubnRpbGRlKSAvIDgpKV0pO1xuICB9XG4gIGNvbnN0IHNpbXVsYXRlZFJlc3BvbnNlID0gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKG1zZ1RvSGFzaCkuZGlnZXN0KCk7XG4gIGNvbnN0IHQ6IGJpZ2ludFtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgLy8gR2V0IHRoZSBpdGggYml0IGZyb20gYSBidWZmZXIgb2YgYnl0ZXMuXG4gICAgY29uc3QgaXRoQml0ID0gKHNpbXVsYXRlZFJlc3BvbnNlW01hdGguZmxvb3IoaSAvIDgpXSA+PiAoNyAtIChpICUgOCkpKSAmIDE7XG4gICAgdC5wdXNoKChhW2ldICsgKChCaWdJbnQoaXRoQml0KSAqIHgpICUgcTFNdWxRMikpICUgcTFNdWxRMik7XG4gIH1cbiAgcmV0dXJuIHsgYWxwaGEsIHQgfTtcbn1cblxuLyoqXG4gKiBWZXJpZnkgZGlzY3JldGUgbG9nIHByb29mcyBvZiBoMSBhbmQgaDIgbW9kIE50aWxkZS5cbiAqIEBwYXJhbSB7RGVzZXJpYWxpemVkTnRpbGRlfSBudGlsZGUgTnRpbGRlLCBoMSwgaDIgdG8gZ2VuZXJhdGUgdGhlIHByb29mcyBmb3IuXG4gKiBAcGFyYW0ge0Rlc2VyaWFsaXplZE50aWxkZVByb29mfSBudGlsZGVQcm9vZiBOdGlsZGUgUHJvb2ZzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBwcm9vZiBpcyB2ZXJpZmllZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5TnRpbGRlUHJvb2YoXG4gIG50aWxkZTogRGVzZXJpYWxpemVkTnRpbGRlLFxuICBudGlsZGVQcm9vZjogRGVzZXJpYWxpemVkTnRpbGRlUHJvb2Zcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBoMU1vZE50aWxkZSA9IG50aWxkZS5oMSAlIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IGgyTW9kTnRpbGRlID0gbnRpbGRlLmgyICUgbnRpbGRlLm50aWxkZTtcbiAgaWYgKGgxTW9kTnRpbGRlID09PSBCaWdJbnQoMCkgfHwgaDJNb2ROdGlsZGUgPT09IEJpZ0ludCgwKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaDFNb2ROdGlsZGUgPT09IEJpZ0ludCgxKSB8fCBoMk1vZE50aWxkZSA9PT0gQmlnSW50KDEpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChoMU1vZE50aWxkZSA9PT0gaDJNb2ROdGlsZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFxuICAgIG50aWxkZVByb29mLmFscGhhLmxlbmd0aCA+IDI1NiB8fFxuICAgIG50aWxkZVByb29mLmFscGhhLmxlbmd0aCAhPT0gSVRFUkFUSU9OUyB8fFxuICAgIG50aWxkZVByb29mLnQubGVuZ3RoICE9PSBJVEVSQVRJT05TXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgbXNnVG9IYXNoOiBCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtcbiAgICBiaWdJbnRUb0J1ZmZlckJFKG50aWxkZS5oMSksXG4gICAgYmlnSW50VG9CdWZmZXJCRShudGlsZGUuaDIpLFxuICAgIGJpZ0ludFRvQnVmZmVyQkUobnRpbGRlLm50aWxkZSksXG4gIF0pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG50aWxkZVByb29mLmFscGhhLmxlbmd0aDsgaSsrKSB7XG4gICAgbXNnVG9IYXNoID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBtc2dUb0hhc2gsXG4gICAgICBiaWdJbnRUb0J1ZmZlckJFKG50aWxkZVByb29mLmFscGhhW2ldLCBNYXRoLmNlaWwoYml0TGVuZ3RoKG50aWxkZS5udGlsZGUpIC8gOCkpLFxuICAgIF0pO1xuICB9XG4gIGNvbnN0IHNpbXVsYXRlZFJlc3BvbnNlID0gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKG1zZ1RvSGFzaCkuZGlnZXN0KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnRpbGRlUHJvb2YuYWxwaGEubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBHZXQgdGhlIGl0aCBiaXQgZnJvbSBhIGJ1ZmZlciBvZiBieXRlcy5cbiAgICBjb25zdCBpdGhCaXQgPSAoc2ltdWxhdGVkUmVzcG9uc2VbTWF0aC5mbG9vcihpIC8gOCldID4+ICg3IC0gKGkgJSA4KSkpICYgMTtcbiAgICBjb25zdCBoMVBvd1RpID0gbW9kUG93KG50aWxkZS5oMSwgbnRpbGRlUHJvb2YudFtpXSwgbnRpbGRlLm50aWxkZSk7XG4gICAgY29uc3QgaDJQb3dDaSA9IG1vZFBvdyhudGlsZGUuaDIsIEJpZ0ludChpdGhCaXQpLCBudGlsZGUubnRpbGRlKTtcbiAgICBjb25zdCBhbHBoYU11bGgyUG93Q2kgPSAobnRpbGRlUHJvb2YuYWxwaGFbaV0gKiBoMlBvd0NpKSAlIG50aWxkZS5udGlsZGU7XG4gICAgaWYgKGgxUG93VGkgIT09IGFscGhhTXVsaDJQb3dDaSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSB6ZXJvLWtub3dsZWRnZSByYW5nZSBwcm9vZiB0aGF0IGFuIGVuY3J5cHRlZCB2YWx1ZSBpcyBcInNtYWxsXCIuXG4gKiBAcGFyYW0ge0Jhc2VDdXJ2ZX0gY3VydmUgQW4gZWxsaXB0aWMgY3VydmUgdG8gdXNlIGZvciBncm91cCBvcGVyYXRpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZHVsdXNCaXRzIFRoZSBiaXQgY291bnQgb2YgdGhlIHByb3ZlcidzIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcGsgVGhlIHByb3ZlcidzIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0ge0Rlc2VyaWFsaXplZE50aWxkZX0gbnRpbGRlIFRoZSB2ZXJpZmllcidzIE50aWxkZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2JpZ2ludH0gYyBUaGUgY2lwaGVydGV4dC5cbiAqIEBwYXJhbSB7YmlnaW50fSBtIFRoZSBwbGFpbnRleHQuXG4gKiBAcGFyYW0ge2JpZ2ludH0gciBUaGUgb2JmdXNjYXRpb24gdmFsdWUgdXNlZCB0byBlbmNyeXB0IG0uXG4gKiBAcmV0dXJucyB7UmFuZ2VQcm9vZn0gVGhlIGdlbmVyYXRlZCBwcm9vZi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb3ZlKFxuICBjdXJ2ZTogQmFzZUN1cnZlLFxuICBtb2R1bHVzQml0czogbnVtYmVyLFxuICBwazogUHVibGljS2V5LFxuICBudGlsZGU6IERlc2VyaWFsaXplZE50aWxkZSxcbiAgYzogYmlnaW50LFxuICBtOiBiaWdpbnQsXG4gIHI6IGJpZ2ludFxuKTogUHJvbWlzZTxSYW5nZVByb29mPiB7XG4gIGNvbnN0IG1vZHVsdXNCeXRlcyA9IE1hdGguZmxvb3IoKG1vZHVsdXNCaXRzICsgNykgLyA4KTtcbiAgY29uc3QgcSA9IGN1cnZlLm9yZGVyKCk7XG4gIGNvbnN0IHEzID0gcSAqKiBCaWdJbnQoMyk7XG4gIGNvbnN0IHFudGlsZGUgPSBxICogbnRpbGRlLm50aWxkZTtcbiAgY29uc3QgcTNudGlsZGUgPSBxMyAqIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IGFscGhhID0gcmFuZEJldHdlZW4ocTMpO1xuICBjb25zdCBiZXRhID0gYXdhaXQgcmFuZG9tUG9zaXRpdmVDb1ByaW1lVG8ocGsubik7XG4gIGNvbnN0IGdhbW1hID0gcmFuZEJldHdlZW4ocTNudGlsZGUpO1xuICBjb25zdCByaG8gPSByYW5kQmV0d2VlbihxbnRpbGRlKTtcbiAgY29uc3QgeiA9IChtb2RQb3cobnRpbGRlLmgxLCBtLCBudGlsZGUubnRpbGRlKSAqIG1vZFBvdyhudGlsZGUuaDIsIHJobywgbnRpbGRlLm50aWxkZSkpICUgbnRpbGRlLm50aWxkZTtcbiAgY29uc3QgdSA9IChtb2RQb3cocGsuZywgYWxwaGEsIHBrLl9uMikgKiBtb2RQb3coYmV0YSwgcGsubiwgcGsuX24yKSkgJSBway5fbjI7XG4gIGNvbnN0IHcgPSAobW9kUG93KG50aWxkZS5oMSwgYWxwaGEsIG50aWxkZS5udGlsZGUpICogbW9kUG93KG50aWxkZS5oMiwgZ2FtbWEsIG50aWxkZS5udGlsZGUpKSAlIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgaGFzaC51cGRhdGUoJ1xceDA2XFx4MDBcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwXFx4MDAnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShway5uLCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShway5nLCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShjLCAyICogbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoeiwgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUodSwgMiAqIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHcsIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBjb25zdCBlID0gYmlnSW50RnJvbUJ1ZmZlckJFKGhhc2guZGlnZXN0KCkpICUgcTtcbiAgY29uc3QgcyA9IChtb2RQb3cociwgZSwgcGsubikgKiBiZXRhKSAlIHBrLm47XG4gIGNvbnN0IHMxID0gZSAqIG0gKyBhbHBoYTtcbiAgY29uc3QgczIgPSBlICogcmhvICsgZ2FtbWE7XG4gIHJldHVybiB7IHosIHUsIHcsIHMsIHMxLCBzMiB9O1xufVxuXG4vKipcbiAqIFZlcmlmeSBhIHplcm8ta25vd2xlZGdlIHJhbmdlIHByb29mIHRoYXQgYW4gZW5jcnlwdGVkIHZhbHVlIGlzIFwic21hbGxcIi5cbiAqIEBwYXJhbSB7QmFzZUN1cnZlfSBjdXJ2ZSBBbiBlbGxpcHRpYyBjdXJ2ZSB0byB1c2UgZm9yIGdyb3VwIG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge251bWJlcn0gbW9kdWx1c0JpdHMgVGhlIGJpdCBjb3VudCBvZiB0aGUgcHJvdmVyJ3MgcHVibGljIGtleS5cbiAqIEBwYXJhbSB7UHVibGljS2V5fSBwayBUaGUgcHJvdmVyJ3MgcHVibGljIGtleS5cbiAqIEBwYXJhbSB7RGVzZXJpYWxpemVkTnRpbGRlfSBudGlsZGUgVGhlIHZlcmlmaWVyJ3MgTnRpbGRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7UmFuZ2VQcm9vZn0gcHJvb2YgVGhlIHJhbmdlIHByb29mLlxuICogQHBhcmFtIHtiaWdpbnR9IGMgVGhlIGNpcGhlcnRleHQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2ZXJpZmljYXRpb24gc3VjY2VlZHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnkoXG4gIGN1cnZlOiBCYXNlQ3VydmUsXG4gIG1vZHVsdXNCaXRzOiBudW1iZXIsXG4gIHBrOiBQdWJsaWNLZXksXG4gIG50aWxkZTogRGVzZXJpYWxpemVkTnRpbGRlLFxuICBwcm9vZjogUmFuZ2VQcm9vZixcbiAgYzogYmlnaW50XG4pOiBib29sZWFuIHtcbiAgaWYgKHByb29mLnUgPT09IEJpZ0ludCgwKSB8fCBwcm9vZi5zID09PSBCaWdJbnQoMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbW9kdWx1c0J5dGVzID0gTWF0aC5mbG9vcigobW9kdWx1c0JpdHMgKyA3KSAvIDgpO1xuICBjb25zdCBxID0gY3VydmUub3JkZXIoKTtcbiAgY29uc3QgcTMgPSBxICoqIEJpZ0ludCgzKTtcbiAgaWYgKHByb29mLnMxID4gcTMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpO1xuICBoYXNoLnVwZGF0ZSgnXFx4MDZcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwXFx4MDBcXHgwMCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHBrLm4sIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHBrLmcsIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKGMsIDIgKiBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShwcm9vZi56LCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShwcm9vZi51LCAyICogbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUocHJvb2YudywgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGNvbnN0IGUgPSBiaWdJbnRGcm9tQnVmZmVyQkUoaGFzaC5kaWdlc3QoKSkgJSBxO1xuICBsZXQgcHJvZHVjdHM6IGJpZ2ludDtcbiAgcHJvZHVjdHMgPSAobW9kUG93KHBrLmcsIHByb29mLnMxLCBway5fbjIpICogbW9kUG93KHByb29mLnMsIHBrLm4sIHBrLl9uMikgKiBtb2RQb3coYywgLWUsIHBrLl9uMikpICUgcGsuX24yO1xuICBpZiAocHJvb2YudSAhPT0gcHJvZHVjdHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvZHVjdHMgPVxuICAgICgoKG1vZFBvdyhudGlsZGUuaDEsIHByb29mLnMxLCBudGlsZGUubnRpbGRlKSAqIG1vZFBvdyhudGlsZGUuaDIsIHByb29mLnMyLCBudGlsZGUubnRpbGRlKSkgJSBudGlsZGUubnRpbGRlKSAqXG4gICAgICBtb2RQb3cocHJvb2YueiwgLWUsIG50aWxkZS5udGlsZGUpKSAlXG4gICAgbnRpbGRlLm50aWxkZTtcbiAgcmV0dXJuIHByb29mLncgPT09IHByb2R1Y3RzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgemVyby1rbm93bGVkZ2UgcmFuZ2UgcHJvb2YgdGhhdCBhIGhvbW9tb3JwaGljYWxseSBtYW5pcHVsYXRlZCB2YWx1ZSBpcyBcInNtYWxsXCIuXG4gKiBAcGFyYW0ge0Jhc2VDdXJ2ZX0gY3VydmUgQW4gZWxsaXB0aWMgY3VydmUgdG8gdXNlIGZvciBncm91cCBvcGVyYXRpb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IG1vZHVsdXNCaXRzIFRoZSBiaXQgY291bnQgb2YgdGhlIHByb3ZlcidzIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0ge1B1YmxpY0tleX0gcGsgVGhlIHByb3ZlcidzIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0ge0Rlc2VyaWFsaXplZE50aWxkZX0gbnRpbGRlIFRoZSB2ZXJpZmllcidzIE50aWxkZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2JpZ2ludH0gYzEgVGhlIG9yaWdpbmFsIGNpcGhlcnRleHQuXG4gKiBAcGFyYW0ge2JpZ2ludH0gYzIgVGhlIG1hbmlwdWxhdGVkIGNpcGhlcnRleHQuXG4gKiBAcGFyYW0ge2JpZ2ludH0geCBUaGUgcGxhaW50ZXh0IHZhbHVlIG11bHRpcGxpZWQgYnkgdGhlIG9yaWdpbmFsIHBsYWludGV4dC5cbiAqIEBwYXJhbSB7YmlnaW50fSB5IFRoZSBwbGFpbnRleHQgdmFsdWUgdGhhdCBpcyBhZGRlZCB0byB4LlxuICogQHBhcmFtIHtiaWdpbnR9IHIgVGhlIG9iZnVzY2F0aW9uIHZhbHVlIHVzZWQgdG8gZW5jcnlwdCB4LlxuICogQHBhcmFtIHtiaWdpbnR9IFggVGhlIGN1cnZlJ3MgYmFzZSBwb2ludCByYWlzZWQgdG8geC5cbiAqIEByZXR1cm5zIHtSYW5nZVByb29mV2l0aENoZWNrfSBUaGUgZ2VuZXJhdGVkIHByb29mLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvdmVXaXRoQ2hlY2soXG4gIGN1cnZlOiBCYXNlQ3VydmUsXG4gIG1vZHVsdXNCaXRzOiBudW1iZXIsXG4gIHBrOiBQdWJsaWNLZXksXG4gIG50aWxkZTogRGVzZXJpYWxpemVkTnRpbGRlLFxuICBjMTogYmlnaW50LFxuICBjMjogYmlnaW50LFxuICB4OiBiaWdpbnQsXG4gIHk6IGJpZ2ludCxcbiAgcjogYmlnaW50LFxuICBYOiBiaWdpbnRcbik6IFByb21pc2U8UmFuZ2VQcm9vZldpdGhDaGVjaz4ge1xuICBjb25zdCBtb2R1bHVzQnl0ZXMgPSBNYXRoLmZsb29yKChtb2R1bHVzQml0cyArIDcpIC8gOCk7XG4gIGNvbnN0IHEgPSBjdXJ2ZS5vcmRlcigpO1xuICBjb25zdCBxMyA9IHEgKiogQmlnSW50KDMpO1xuICBjb25zdCBxNyA9IHEgKiogQmlnSW50KDcpO1xuICBjb25zdCBxbnRpbGRlID0gcSAqIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IHEzbnRpbGRlID0gcTMgKiBudGlsZGUubnRpbGRlO1xuICBjb25zdCBhbHBoYSA9IHJhbmRCZXR3ZWVuKHEzKTtcbiAgY29uc3QgcmhvID0gcmFuZEJldHdlZW4ocW50aWxkZSk7XG4gIGNvbnN0IHNpZ21hID0gcmFuZEJldHdlZW4ocW50aWxkZSk7XG4gIGNvbnN0IHRhdSA9IHJhbmRCZXR3ZWVuKHEzbnRpbGRlKTtcbiAgY29uc3QgcmhvcHJtID0gcmFuZEJldHdlZW4ocTNudGlsZGUpO1xuICBjb25zdCBiZXRhID0gYXdhaXQgcmFuZG9tUG9zaXRpdmVDb1ByaW1lVG8ocGsubik7XG4gIGNvbnN0IGdhbW1hID0gcmFuZEJldHdlZW4ocTcpO1xuICBjb25zdCB1ID0gY3VydmUuYmFzZVBvaW50TXVsdChjdXJ2ZS5zY2FsYXJSZWR1Y2UoYWxwaGEpKTtcbiAgY29uc3QgeiA9IChtb2RQb3cobnRpbGRlLmgxLCB4LCBudGlsZGUubnRpbGRlKSAqIG1vZFBvdyhudGlsZGUuaDIsIHJobywgbnRpbGRlLm50aWxkZSkpICUgbnRpbGRlLm50aWxkZTtcbiAgY29uc3QgenBybSA9IChtb2RQb3cobnRpbGRlLmgxLCBhbHBoYSwgbnRpbGRlLm50aWxkZSkgKiBtb2RQb3cobnRpbGRlLmgyLCByaG9wcm0sIG50aWxkZS5udGlsZGUpKSAlIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IHQgPSAobW9kUG93KG50aWxkZS5oMSwgeSwgbnRpbGRlLm50aWxkZSkgKiBtb2RQb3cobnRpbGRlLmgyLCBzaWdtYSwgbnRpbGRlLm50aWxkZSkpICUgbnRpbGRlLm50aWxkZTtcbiAgY29uc3QgdiA9XG4gICAgKCgobW9kUG93KGMxLCBhbHBoYSwgcGsuX24yKSAqIG1vZFBvdyhway5nLCBnYW1tYSwgcGsuX24yKSkgJSBway5fbjIpICogbW9kUG93KGJldGEsIHBrLm4sIHBrLl9uMikpICUgcGsuX24yO1xuICBjb25zdCB3ID0gKG1vZFBvdyhudGlsZGUuaDEsIGdhbW1hLCBudGlsZGUubnRpbGRlKSAqIG1vZFBvdyhudGlsZGUuaDIsIHRhdSwgbnRpbGRlLm50aWxkZSkpICUgbnRpbGRlLm50aWxkZTtcbiAgY29uc3QgaGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpO1xuICBoYXNoLnVwZGF0ZSgnXFx4MGRcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwXFx4MDBcXHgwMCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHBrLm4sIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHBrLmcsIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKFgsIDMzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoYzEsIDIgKiBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShjMiwgMiAqIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHUsIDMzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoeiwgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoenBybSwgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUodCwgbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUodiwgMiAqIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHcsIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBjb25zdCBlID0gYmlnSW50RnJvbUJ1ZmZlckJFKGhhc2guZGlnZXN0KCkpICUgcTtcbiAgY29uc3QgcyA9IChtb2RQb3cociwgZSwgcGsubikgKiBiZXRhKSAlIHBrLm47XG4gIGNvbnN0IHMxID0gZSAqIHggKyBhbHBoYTtcbiAgY29uc3QgczIgPSBlICogcmhvICsgcmhvcHJtO1xuICBjb25zdCB0MSA9IGUgKiB5ICsgZ2FtbWE7XG4gIGNvbnN0IHQyID0gZSAqIHNpZ21hICsgdGF1O1xuICByZXR1cm4geyB6LCB6cHJtLCB0LCB2LCB3LCBzLCBzMSwgczIsIHQxLCB0MiwgdSB9O1xufVxuXG4vKipcbiAqIFZlcmlmeSBhIHplcm8ta25vd2xlZGdlIHJhbmdlIHByb29mIHRoYXQgYSBob21vbW9ycGhpY2FsbHkgbWFuaXB1bGF0ZWQgdmFsdWUgaXMgXCJzbWFsbFwiLlxuICogQHBhcmFtIHtCYXNlQ3VydmV9IGN1cnZlIEFuIGVsbGlwdGljIGN1cnZlIHRvIHVzZSBmb3IgZ3JvdXAgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2R1bHVzQml0cyBUaGUgYml0IGNvdW50IG9mIHRoZSBwcm92ZXIncyBwdWJsaWMga2V5LlxuICogQHBhcmFtIHtQdWJsaWNLZXl9IHBrIFRoZSBwcm92ZXIncyBwdWJsaWMga2V5LlxuICogQHBhcmFtIHtEZXNlcmlhbGl6ZWROdGlsZGV9IG50aWxkZSBUaGUgdmVyaWZpZXIncyBOdGlsZGUgdmFsdWVzLlxuICogQHBhcmFtIHtSYW5nZVByb29mV2l0aENoZWNrfSBwcm9vZiBUaGUgcmFuZ2UgcHJvb2YuXG4gKiBAcGFyYW0ge2JpZ2ludH0gYzEgVGhlIG9yaWdpbmFsIGNpcGhlcnRleHQuXG4gKiBAcGFyYW0ge2JpZ2ludH0gYzIgVGhlIG1hbmlwdWxhdGVkIGNpcGhlcnRleHQuXG4gKiBAcGFyYW0ge2JpZ2ludH0gWCBUaGUgY3VydmUncyBiYXNlIHBvaW50IHJhaXNlZCB0byB4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmVyaWZpY2F0aW9uIHN1Y2NlZWRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5V2l0aENoZWNrKFxuICBjdXJ2ZTogQmFzZUN1cnZlLFxuICBtb2R1bHVzQml0czogbnVtYmVyLFxuICBwazogUHVibGljS2V5LFxuICBudGlsZGU6IERlc2VyaWFsaXplZE50aWxkZSxcbiAgcHJvb2Y6IFJhbmdlUHJvb2ZXaXRoQ2hlY2ssXG4gIGMxOiBiaWdpbnQsXG4gIGMyOiBiaWdpbnQsXG4gIFg6IGJpZ2ludFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IG1vZHVsdXNCeXRlcyA9IE1hdGguZmxvb3IoKG1vZHVsdXNCaXRzICsgNykgLyA4KTtcbiAgY29uc3QgcSA9IGN1cnZlLm9yZGVyKCk7XG4gIGNvbnN0IHEzID0gcSAqKiBCaWdJbnQoMyk7XG4gIGNvbnN0IHE3ID0gcSAqKiBCaWdJbnQoNyk7XG4gIGlmIChwcm9vZi5zMSA+IHEzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwcm9vZi50MSA+IHE3KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgaGFzaC51cGRhdGUoJ1xceDBkXFx4MDBcXHgwMFxceDAwXFx4MDBcXHgwMFxceDAwXFx4MDAnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShway5uLCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShway5nLCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShYLCAzMykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKGMxLCAyICogbW9kdWx1c0J5dGVzKSk7XG4gIGhhc2gudXBkYXRlKCckJyk7XG4gIGhhc2gudXBkYXRlKGJpZ0ludFRvQnVmZmVyQkUoYzIsIDIgKiBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShwcm9vZi51LCAzMykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHByb29mLnosIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHByb29mLnpwcm0sIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHByb29mLnQsIG1vZHVsdXNCeXRlcykpO1xuICBoYXNoLnVwZGF0ZSgnJCcpO1xuICBoYXNoLnVwZGF0ZShiaWdJbnRUb0J1ZmZlckJFKHByb29mLnYsIDIgKiBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgaGFzaC51cGRhdGUoYmlnSW50VG9CdWZmZXJCRShwcm9vZi53LCBtb2R1bHVzQnl0ZXMpKTtcbiAgaGFzaC51cGRhdGUoJyQnKTtcbiAgY29uc3QgZSA9IGJpZ0ludEZyb21CdWZmZXJCRShoYXNoLmRpZ2VzdCgpKSAlIHE7XG4gIGNvbnN0IGdTMSA9IGN1cnZlLmJhc2VQb2ludE11bHQoY3VydmUuc2NhbGFyUmVkdWNlKHByb29mLnMxKSk7XG4gIGNvbnN0IHhFVSA9IGN1cnZlLnBvaW50QWRkKGN1cnZlLnBvaW50TXVsdGlwbHkoWCwgZSksIHByb29mLnUpO1xuICBpZiAoZ1MxICE9PSB4RVUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGxlZnQsIHJpZ2h0O1xuICBjb25zdCBoMUV4cFMxID0gbW9kUG93KG50aWxkZS5oMSwgcHJvb2YuczEsIG50aWxkZS5udGlsZGUpO1xuICBjb25zdCBoMkV4cFMyID0gbW9kUG93KG50aWxkZS5oMiwgcHJvb2YuczIsIG50aWxkZS5udGlsZGUpO1xuICBsZWZ0ID0gKGgxRXhwUzEgKiBoMkV4cFMyKSAlIG50aWxkZS5udGlsZGU7XG4gIGNvbnN0IHpFeHBFID0gbW9kUG93KHByb29mLnosIGUsIG50aWxkZS5udGlsZGUpO1xuICByaWdodCA9ICh6RXhwRSAqIHByb29mLnpwcm0pICUgbnRpbGRlLm50aWxkZTtcbiAgaWYgKGxlZnQgIT09IHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGgxRXhwVDEgPSBtb2RQb3cobnRpbGRlLmgxLCBwcm9vZi50MSwgbnRpbGRlLm50aWxkZSk7XG4gIGNvbnN0IGgyRXhwVDIgPSBtb2RQb3cobnRpbGRlLmgyLCBwcm9vZi50MiwgbnRpbGRlLm50aWxkZSk7XG4gIGxlZnQgPSAoaDFFeHBUMSAqIGgyRXhwVDIpICUgbnRpbGRlLm50aWxkZTtcbiAgY29uc3QgdEV4cEUgPSBtb2RQb3cocHJvb2YudCwgZSwgbnRpbGRlLm50aWxkZSk7XG4gIHJpZ2h0ID0gKHRFeHBFICogcHJvb2YudykgJSBudGlsZGUubnRpbGRlO1xuICBpZiAobGVmdCAhPT0gcmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYzFFeHBTMSA9IG1vZFBvdyhjMSwgcHJvb2YuczEsIHBrLl9uMik7XG4gIGNvbnN0IHNFeHBOID0gbW9kUG93KHByb29mLnMsIHBrLm4sIHBrLl9uMik7XG4gIGNvbnN0IGdhbW1hRXhwVDEgPSBtb2RQb3cocGsuZywgcHJvb2YudDEsIHBrLl9uMik7XG4gIGxlZnQgPSAoKChjMUV4cFMxICogc0V4cE4pICUgcGsuX24yKSAqIGdhbW1hRXhwVDEpICUgcGsuX24yO1xuICBjb25zdCBjMkV4cEUgPSBtb2RQb3coYzIsIGUsIHBrLl9uMik7XG4gIHJpZ2h0ID0gKGMyRXhwRSAqIHByb29mLnYpICUgcGsuX24yO1xuICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7XG59XG4iXX0=