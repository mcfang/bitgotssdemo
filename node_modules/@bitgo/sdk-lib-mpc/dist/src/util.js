"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDerivationPath = exports.randomBigInt = exports.randomPositiveCoPrimeLessThan = exports.randomPositiveCoPrimeTo = exports.getPaillierPublicKey = exports.clamp = exports.bigIntFromU8ABE = exports.bigIntFromBufferBE = exports.bigIntToBufferBE = exports.bigIntFromBufferLE = exports.bigIntToBufferLE = exports.bigIntToHex = exports.hexToBigInt = exports.convertBigIntArrToHexArr = exports.convertHexArrToBigIntArr = void 0;
const paillier_bigint_1 = require("paillier-bigint");
const bigint_crypto_utils_1 = require("bigint-crypto-utils");
const bigint_mod_arith_1 = require("bigint-mod-arith");
const crypto_1 = __importDefault(require("crypto"));
/**
 * Returns a bigint array from a hex string array
 * @param values
 */
function convertHexArrToBigIntArr(values) {
    return values.map((value) => {
        return hexToBigInt(value);
    });
}
exports.convertHexArrToBigIntArr = convertHexArrToBigIntArr;
/**
 * Returns a hex string array from a bigint array
 * @param values
 * @param hexLength - length to pad each big int number too
 */
function convertBigIntArrToHexArr(values, hexLength) {
    return values.map((value) => {
        return bigIntToHex(value, hexLength);
    });
}
exports.convertBigIntArrToHexArr = convertBigIntArrToHexArr;
function hexToBigInt(hex) {
    // Strangely bigint.toString(16) gives a hex string without 0x,
    // but it won't accept the same string without 0x to convert
    // to a bigint (BigInt(hex string)). So have to introduce this
    // check to convert to add 0x in case if hex string
    // doesn't have it.
    if (hex.slice(0, 2) === '0x') {
        return BigInt(hex);
    }
    return BigInt('0x' + hex);
}
exports.hexToBigInt = hexToBigInt;
/**
 * Returns an hex string of the given bigint
 *
 * @param {bigint} bigint - the bigint to be converted to hex
 * @param hexLength
 * @returns {string} - the hex value
 */
function bigIntToHex(bigint, hexLength) {
    let hex = bigint.toString(16);
    hex = '0'.slice(0, hex.length % 2) + hex;
    if (hexLength) {
        hex = hex.padStart(hexLength, '0');
    }
    return hex;
}
exports.bigIntToHex = bigIntToHex;
function bigIntToBufferLE(n, minBytes) {
    let v = n.toString(16);
    v = '0'.slice(0, v.length % 2) + v;
    const buf = Buffer.from(v, 'hex').reverse();
    if (minBytes && buf.length < minBytes) {
        return Buffer.concat([buf, Buffer.alloc(minBytes - buf.length)]);
    }
    return buf;
}
exports.bigIntToBufferLE = bigIntToBufferLE;
function bigIntFromBufferLE(buf) {
    return BigInt('0x' + Buffer.from(buf).reverse().toString('hex'));
}
exports.bigIntFromBufferLE = bigIntFromBufferLE;
function bigIntToBufferBE(n, minBytes) {
    let v = n.toString(16);
    v = '0'.slice(0, v.length % 2) + v;
    const buf = Buffer.from(v, 'hex');
    if (minBytes && buf.length < minBytes) {
        return Buffer.concat([Buffer.alloc(minBytes - buf.length), buf]);
    }
    return buf;
}
exports.bigIntToBufferBE = bigIntToBufferBE;
function bigIntFromBufferBE(buf) {
    return BigInt('0x' + buf.toString('hex'));
}
exports.bigIntFromBufferBE = bigIntFromBufferBE;
function bigIntFromU8ABE(buf) {
    return bigIntFromBufferBE(Buffer.from(buf));
}
exports.bigIntFromU8ABE = bigIntFromU8ABE;
function clamp(u) {
    u &= BigInt('0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8');
    u |= BigInt('0x4000000000000000000000000000000000000000000000000000000000000000');
    return u;
}
exports.clamp = clamp;
/**
 * Function get paillier public key simple varient
 * @param {bigint} n
 * @returns {bigint}
 */
function getPaillierPublicKey(n) {
    return new paillier_bigint_1.PublicKey(n, n + BigInt(1));
}
exports.getPaillierPublicKey = getPaillierPublicKey;
/**
 * Generate a random positive integer co-prime to x
 * @param x
 * @returns {Promise<bigint>}
 */
async function randomPositiveCoPrimeTo(x) {
    while (true) {
        const y = await randomBigInt(bigint_crypto_utils_1.bitLength(x));
        if (y > BigInt(0) && bigint_mod_arith_1.gcd(x, y) === BigInt(1)) {
            return y;
        }
    }
}
exports.randomPositiveCoPrimeTo = randomPositiveCoPrimeTo;
/**
 * Generate a random positive integer coprime less than x with the same bit depth.
 * @param x
 * @returns {Promise<bigint>}
 */
async function randomPositiveCoPrimeLessThan(x) {
    if (x <= BigInt(2)) {
        throw new Error('x must be larger than 2');
    }
    while (true) {
        const y = await randomBigInt(bigint_crypto_utils_1.bitLength(x));
        if (y > BigInt(0) && y < x && bigint_mod_arith_1.gcd(x, y) === BigInt(1)) {
            return y;
        }
    }
}
exports.randomPositiveCoPrimeLessThan = randomPositiveCoPrimeLessThan;
/**
 * Generate a random number of a given bitlength
 * @param bitlength
 * @returns {Promise<bigint>}
 */
async function randomBigInt(bitlength) {
    return bigIntFromBufferBE(Buffer.from(await bigint_crypto_utils_1.randBits(bitlength, true)));
}
exports.randomBigInt = randomBigInt;
/**
 * @param seed - used to construct derivation path deterministically
 * @param isMaster - if set, path starts with prefix `m/`
 * @return path `(m/)/999999/a/b` where `a` and `b` are 7-byte pseudorandom numbers based on seed
 */
function getDerivationPath(seed, isMaster = true) {
    const derivationPathInput = sha256(sha256(`${seed}`)).toString('hex');
    const derivationPathParts = [
        parseInt(derivationPathInput.slice(0, 7), 16),
        parseInt(derivationPathInput.slice(7, 14), 16),
    ];
    const prefix = isMaster ? 'm/' : '';
    return prefix + '999999/' + derivationPathParts.join('/');
}
exports.getDerivationPath = getDerivationPath;
function sha256(input) {
    return crypto_1.default.createHash('sha256').update(input).digest();
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHFEQUE0QztBQUM1Qyw2REFBMEQ7QUFDMUQsdURBQXVDO0FBQ3ZDLG9EQUE0QjtBQUU1Qjs7O0dBR0c7QUFDSCxTQUFnQix3QkFBd0IsQ0FBQyxNQUFnQjtJQUN2RCxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtRQUMxQixPQUFPLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFKRCw0REFJQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQix3QkFBd0IsQ0FBQyxNQUFnQixFQUFFLFNBQWtCO0lBQzNFLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO1FBQzFCLE9BQU8sV0FBVyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN2QyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFKRCw0REFJQztBQUVELFNBQWdCLFdBQVcsQ0FBQyxHQUFXO0lBQ3JDLCtEQUErRDtJQUMvRCw0REFBNEQ7SUFDNUQsOERBQThEO0lBQzlELG1EQUFtRDtJQUNuRCxtQkFBbUI7SUFDbkIsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDNUIsT0FBTyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDcEI7SUFDRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDNUIsQ0FBQztBQVZELGtDQVVDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsV0FBVyxDQUFDLE1BQWMsRUFBRSxTQUFrQjtJQUM1RCxJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzlC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OztHQUlHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQUMsSUFBWSxFQUFFLFFBQVEsR0FBRyxJQUFJO0lBQzdELE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEUsTUFBTSxtQkFBbUIsR0FBRztRQUMxQixRQUFRLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDN0MsUUFBUSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO0tBQy9DLENBQUM7SUFDRixNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQ3BDLE9BQU8sTUFBTSxHQUFHLFNBQVMsR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDNUQsQ0FBQztBQVJELDhDQVFDO0FBRUQsU0FBUyxNQUFNLENBQUMsS0FBd0I7SUFDdEMsT0FBTyxnQkFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDNUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ3BhaWxsaWVyLWJpZ2ludCc7XG5pbXBvcnQgeyBiaXRMZW5ndGgsIHJhbmRCaXRzIH0gZnJvbSAnYmlnaW50LWNyeXB0by11dGlscyc7XG5pbXBvcnQgeyBnY2QgfSBmcm9tICdiaWdpbnQtbW9kLWFyaXRoJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLyoqXG4gKiBSZXR1cm5zIGEgYmlnaW50IGFycmF5IGZyb20gYSBoZXggc3RyaW5nIGFycmF5XG4gKiBAcGFyYW0gdmFsdWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0SGV4QXJyVG9CaWdJbnRBcnIodmFsdWVzOiBzdHJpbmdbXSk6IGJpZ2ludFtdIHtcbiAgcmV0dXJuIHZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGhleFRvQmlnSW50KHZhbHVlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGhleCBzdHJpbmcgYXJyYXkgZnJvbSBhIGJpZ2ludCBhcnJheVxuICogQHBhcmFtIHZhbHVlc1xuICogQHBhcmFtIGhleExlbmd0aCAtIGxlbmd0aCB0byBwYWQgZWFjaCBiaWcgaW50IG51bWJlciB0b29cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRCaWdJbnRBcnJUb0hleEFycih2YWx1ZXM6IGJpZ2ludFtdLCBoZXhMZW5ndGg/OiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gIHJldHVybiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBiaWdJbnRUb0hleCh2YWx1ZSwgaGV4TGVuZ3RoKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0JpZ0ludChoZXg6IHN0cmluZyk6IGJpZ2ludCB7XG4gIC8vIFN0cmFuZ2VseSBiaWdpbnQudG9TdHJpbmcoMTYpIGdpdmVzIGEgaGV4IHN0cmluZyB3aXRob3V0IDB4LFxuICAvLyBidXQgaXQgd29uJ3QgYWNjZXB0IHRoZSBzYW1lIHN0cmluZyB3aXRob3V0IDB4IHRvIGNvbnZlcnRcbiAgLy8gdG8gYSBiaWdpbnQgKEJpZ0ludChoZXggc3RyaW5nKSkuIFNvIGhhdmUgdG8gaW50cm9kdWNlIHRoaXNcbiAgLy8gY2hlY2sgdG8gY29udmVydCB0byBhZGQgMHggaW4gY2FzZSBpZiBoZXggc3RyaW5nXG4gIC8vIGRvZXNuJ3QgaGF2ZSBpdC5cbiAgaWYgKGhleC5zbGljZSgwLCAyKSA9PT0gJzB4Jykge1xuICAgIHJldHVybiBCaWdJbnQoaGV4KTtcbiAgfVxuICByZXR1cm4gQmlnSW50KCcweCcgKyBoZXgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaGV4IHN0cmluZyBvZiB0aGUgZ2l2ZW4gYmlnaW50XG4gKlxuICogQHBhcmFtIHtiaWdpbnR9IGJpZ2ludCAtIHRoZSBiaWdpbnQgdG8gYmUgY29udmVydGVkIHRvIGhleFxuICogQHBhcmFtIGhleExlbmd0aFxuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaGV4IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaWdJbnRUb0hleChiaWdpbnQ6IGJpZ2ludCwgaGV4TGVuZ3RoPzogbnVtYmVyKTogc3RyaW5nIHtcbiAgbGV0IGhleCA9IGJpZ2ludC50b1N0cmluZygxNik7XG4gIGhleCA9ICcwJy5zbGljZSgwLCBoZXgubGVuZ3RoICUgMikgKyBoZXg7XG4gIGlmIChoZXhMZW5ndGgpIHtcbiAgICBoZXggPSBoZXgucGFkU3RhcnQoaGV4TGVuZ3RoLCAnMCcpO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaWdJbnRUb0J1ZmZlckxFKG46IGJpZ2ludCwgbWluQnl0ZXM/OiBudW1iZXIpOiBCdWZmZXIge1xuICBsZXQgdiA9IG4udG9TdHJpbmcoMTYpO1xuICB2ID0gJzAnLnNsaWNlKDAsIHYubGVuZ3RoICUgMikgKyB2O1xuICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbSh2LCAnaGV4JykucmV2ZXJzZSgpO1xuICBpZiAobWluQnl0ZXMgJiYgYnVmLmxlbmd0aCA8IG1pbkJ5dGVzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2J1ZiwgQnVmZmVyLmFsbG9jKG1pbkJ5dGVzIC0gYnVmLmxlbmd0aCldKTtcbiAgfVxuICByZXR1cm4gYnVmO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmlnSW50RnJvbUJ1ZmZlckxFKGJ1ZjogQnVmZmVyKTogYmlnaW50IHtcbiAgcmV0dXJuIEJpZ0ludCgnMHgnICsgQnVmZmVyLmZyb20oYnVmKS5yZXZlcnNlKCkudG9TdHJpbmcoJ2hleCcpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpZ0ludFRvQnVmZmVyQkUobjogYmlnaW50LCBtaW5CeXRlcz86IG51bWJlcik6IEJ1ZmZlciB7XG4gIGxldCB2ID0gbi50b1N0cmluZygxNik7XG4gIHYgPSAnMCcuc2xpY2UoMCwgdi5sZW5ndGggJSAyKSArIHY7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKHYsICdoZXgnKTtcbiAgaWYgKG1pbkJ5dGVzICYmIGJ1Zi5sZW5ndGggPCBtaW5CeXRlcykge1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtCdWZmZXIuYWxsb2MobWluQnl0ZXMgLSBidWYubGVuZ3RoKSwgYnVmXSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpZ0ludEZyb21CdWZmZXJCRShidWY6IEJ1ZmZlcik6IGJpZ2ludCB7XG4gIHJldHVybiBCaWdJbnQoJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4JykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmlnSW50RnJvbVU4QUJFKGJ1ZjogVWludDhBcnJheSk6IGJpZ2ludCB7XG4gIHJldHVybiBiaWdJbnRGcm9tQnVmZmVyQkUoQnVmZmVyLmZyb20oYnVmKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh1OiBiaWdpbnQpOiBiaWdpbnQge1xuICB1ICY9IEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY4Jyk7XG4gIHUgfD0gQmlnSW50KCcweDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTtcbiAgcmV0dXJuIHU7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gZ2V0IHBhaWxsaWVyIHB1YmxpYyBrZXkgc2ltcGxlIHZhcmllbnRcbiAqIEBwYXJhbSB7YmlnaW50fSBuXG4gKiBAcmV0dXJucyB7YmlnaW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFpbGxpZXJQdWJsaWNLZXkobjogYmlnaW50KTogUHVibGljS2V5IHtcbiAgcmV0dXJuIG5ldyBQdWJsaWNLZXkobiwgbiArIEJpZ0ludCgxKSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gcG9zaXRpdmUgaW50ZWdlciBjby1wcmltZSB0byB4XG4gKiBAcGFyYW0geFxuICogQHJldHVybnMge1Byb21pc2U8YmlnaW50Pn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJhbmRvbVBvc2l0aXZlQ29QcmltZVRvKHg6IGJpZ2ludCk6IFByb21pc2U8YmlnaW50PiB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeSA9IGF3YWl0IHJhbmRvbUJpZ0ludChiaXRMZW5ndGgoeCkpO1xuICAgIGlmICh5ID4gQmlnSW50KDApICYmIGdjZCh4LCB5KSA9PT0gQmlnSW50KDEpKSB7XG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSBwb3NpdGl2ZSBpbnRlZ2VyIGNvcHJpbWUgbGVzcyB0aGFuIHggd2l0aCB0aGUgc2FtZSBiaXQgZGVwdGguXG4gKiBAcGFyYW0geFxuICogQHJldHVybnMge1Byb21pc2U8YmlnaW50Pn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJhbmRvbVBvc2l0aXZlQ29QcmltZUxlc3NUaGFuKHg6IGJpZ2ludCk6IFByb21pc2U8YmlnaW50PiB7XG4gIGlmICh4IDw9IEJpZ0ludCgyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigneCBtdXN0IGJlIGxhcmdlciB0aGFuIDInKTtcbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHkgPSBhd2FpdCByYW5kb21CaWdJbnQoYml0TGVuZ3RoKHgpKTtcbiAgICBpZiAoeSA+IEJpZ0ludCgwKSAmJiB5IDwgeCAmJiBnY2QoeCwgeSkgPT09IEJpZ0ludCgxKSkge1xuICAgICAgcmV0dXJuIHk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gbnVtYmVyIG9mIGEgZ2l2ZW4gYml0bGVuZ3RoXG4gKiBAcGFyYW0gYml0bGVuZ3RoXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxiaWdpbnQ+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmFuZG9tQmlnSW50KGJpdGxlbmd0aDogbnVtYmVyKTogUHJvbWlzZTxiaWdpbnQ+IHtcbiAgcmV0dXJuIGJpZ0ludEZyb21CdWZmZXJCRShCdWZmZXIuZnJvbShhd2FpdCByYW5kQml0cyhiaXRsZW5ndGgsIHRydWUpKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHNlZWQgLSB1c2VkIHRvIGNvbnN0cnVjdCBkZXJpdmF0aW9uIHBhdGggZGV0ZXJtaW5pc3RpY2FsbHlcbiAqIEBwYXJhbSBpc01hc3RlciAtIGlmIHNldCwgcGF0aCBzdGFydHMgd2l0aCBwcmVmaXggYG0vYFxuICogQHJldHVybiBwYXRoIGAobS8pLzk5OTk5OS9hL2JgIHdoZXJlIGBhYCBhbmQgYGJgIGFyZSA3LWJ5dGUgcHNldWRvcmFuZG9tIG51bWJlcnMgYmFzZWQgb24gc2VlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVyaXZhdGlvblBhdGgoc2VlZDogc3RyaW5nLCBpc01hc3RlciA9IHRydWUpOiBzdHJpbmcge1xuICBjb25zdCBkZXJpdmF0aW9uUGF0aElucHV0ID0gc2hhMjU2KHNoYTI1NihgJHtzZWVkfWApKS50b1N0cmluZygnaGV4Jyk7XG4gIGNvbnN0IGRlcml2YXRpb25QYXRoUGFydHMgPSBbXG4gICAgcGFyc2VJbnQoZGVyaXZhdGlvblBhdGhJbnB1dC5zbGljZSgwLCA3KSwgMTYpLFxuICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoNywgMTQpLCAxNiksXG4gIF07XG4gIGNvbnN0IHByZWZpeCA9IGlzTWFzdGVyID8gJ20vJyA6ICcnO1xuICByZXR1cm4gcHJlZml4ICsgJzk5OTk5OS8nICsgZGVyaXZhdGlvblBhdGhQYXJ0cy5qb2luKCcvJyk7XG59XG5cbmZ1bmN0aW9uIHNoYTI1NihpbnB1dDogY3J5cHRvLkJpbmFyeUxpa2UpOiBCdWZmZXIge1xuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShpbnB1dCkuZGlnZXN0KCk7XG59XG4iXX0=