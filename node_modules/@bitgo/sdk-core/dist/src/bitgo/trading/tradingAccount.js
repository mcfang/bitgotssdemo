"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TradingAccount = void 0;
/**
 * @prettier
 */
const bignumber_js_1 = require("bignumber.js");
const trading_1 = require("../trading");
const TRADE_PAYLOAD_VERSION = '1.2.0';
class TradingAccount {
    constructor(enterpriseId, wallet, bitgo) {
        this.enterpriseId = enterpriseId;
        this.wallet = wallet;
        this.bitgo = bitgo;
    }
    get id() {
        return this.wallet.id();
    }
    /**
     * Builds a payload authorizing trade from this trading account.
     * @param params
     * @param params.amounts[] array of amounts that will be traded as part of the settlement
     * @param params.amounts[].accountId the accountId corresponding with the sending and receiving amounts for the settlement
     * @param params.amounts[].sendAmount amount of currency sent by trading account of given accountId
     * @param params.amounts[].sendCurrency currency of amount sent by trading account of given accountId
     * @param params.amounts[].receiveAmount amount of currency received by trading account of given accountId
     * @param params.amounts[].receiveCurrency currency of amount received by trading account of given accountId
     * @returns unsigned trade payload for the given parameters. This object should be stringified with JSON.stringify() before being submitted
     */
    async buildPayload(params) {
        const url = this.bitgo.microservicesUrl(`/api/trade/v1/enterprise/${this.enterpriseId}/account/${this.id}/payload`);
        const body = {
            version: TRADE_PAYLOAD_VERSION,
            amounts: params.amounts,
        };
        const response = (await this.bitgo.post(url).send(body).result());
        if (!this.verifyPayload(params, response.payload)) {
            throw new Error('Unable to verify trade payload. You may need to update the BitGo SDK, or the payload may have been tampered with.');
        }
        return JSON.parse(response.payload);
    }
    /**
     * Verifies that a payload received from BitGo sufficiently matches the expected parameters. This is used to prevent
     * man-in-the-middle attacks which could maliciously alter the contents of a payload.
     * @param params parameters used to build the payload
     * @param payload payload received from the BitGo API
     * @returns true if the payload's sensitive fields match, false if the payload may have been tampered with
     */
    verifyPayload(params, payload) {
        const payloadObj = JSON.parse(payload);
        const paramsCopy = JSON.parse(JSON.stringify(params)); // needs to be a deep copy
        // Verifies that for each party in the payload, we requested a matching party, only checking sensitive fields
        let validAmounts = 0;
        for (const amount of payloadObj.amounts) {
            const matchingExpectedParty = paramsCopy.amounts.findIndex((expectedAmount) => amount.accountId === expectedAmount.accountId &&
                amount.sendCurrency === expectedAmount.sendCurrency &&
                amount.sendSubtotal === expectedAmount.sendAmount &&
                amount.receiveAmount === expectedAmount.receiveAmount &&
                amount.receiveCurrency === expectedAmount.receiveCurrency);
            if (matchingExpectedParty === -1) {
                // matchingExpectedParty not found to the payloadObject
                // payload is not valid
                break;
            }
            if (amount.fees && amount.fees.length > 0) {
                let feeTotal = new bignumber_js_1.BigNumber(0);
                for (const fee of amount.fees) {
                    feeTotal = feeTotal.plus(new bignumber_js_1.BigNumber(fee.feeAmount));
                }
                const expectedTotalAmount = new bignumber_js_1.BigNumber(paramsCopy.amounts[matchingExpectedParty].sendAmount).plus(feeTotal);
                if (expectedTotalAmount.toString() !== amount.sendAmount) {
                    // expected total does not match the sendAmount of the payload
                    // payload is not valid
                    break;
                }
            }
            // matching party found, and fee found
            validAmounts = validAmounts + 1;
            // delete so we ensure no duplicates
            paramsCopy.amounts.splice(matchingExpectedParty, 1);
        }
        return (payloadObj.accountId === this.id &&
            payloadObj.amounts.length === params.amounts.length &&
            validAmounts === payloadObj.amounts.length);
    }
    /**
     * Calculates the necessary fees to complete a settlement between two parties, based on the amounts and currencies of the settlement.
     * @param params
     * @param params.counterpartyAccountId Account ID of the counterparty of the settlement
     * @param params.sendCurrency Currency to be sent as part of the settlement
     * @param params.sendAmount Amount of currency (in base units such as cents, satoshis, or wei) to be sent
     * @param params.receiveCurrency Currency to be received as part of the settlement
     * @param params.receiveAmount Amount of currency (in base units such as cents, satoshis, or wei) to be received
     * @returns Fee rate, currency, and total amount of the described settlement
     */
    async calculateSettlementFees(params) {
        const url = this.bitgo.microservicesUrl(`/api/trade/v1/enterprise/${this.enterpriseId}/account/${this.id}/calculatefees`);
        return await this.bitgo.post(url).send(params).result();
    }
    /**
     * Signs an arbitrary payload with the user key on this trading account
     * @param params
     * @param params.payload arbitrary payload object (string | Record<string, unknown>)
     * @param params.walletPassphrase passphrase on this trading account, used to unlock the account user key
     * @returns hex-encoded signature of the payload
     */
    async signPayload(params) {
        const key = (await this.wallet.baseCoin.keychains().get({ id: this.wallet.keyIds()[0] }));
        const prv = this.wallet.bitgo.decrypt({
            input: key.encryptedPrv,
            password: params.walletPassphrase,
        });
        const payload = typeof params.payload === 'string' ? params.payload : JSON.stringify(params.payload);
        return (await this.wallet.baseCoin.signMessage({ prv }, payload)).toString('hex');
    }
    affirmations() {
        return new trading_1.Affirmations(this.bitgo, this.enterpriseId, this);
    }
    settlements() {
        return new trading_1.Settlements(this.bitgo, this.enterpriseId, this);
    }
    partners() {
        return new trading_1.TradingPartners(this.bitgo, this.enterpriseId, this);
    }
}
exports.TradingAccount = TradingAccount;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhZGluZ0FjY291bnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYml0Z28vdHJhZGluZy90cmFkaW5nQWNjb3VudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILCtDQUF5QztBQUV6Qyx3Q0Fhb0I7QUFHcEIsTUFBTSxxQkFBcUIsR0FBRyxPQUFPLENBQUM7QUFFdEMsTUFBYSxjQUFjO0lBTXpCLFlBQVksWUFBb0IsRUFBRSxNQUFlLEVBQUUsS0FBZ0I7UUFDakUsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQUVELElBQUksRUFBRTtRQUNKLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBOEI7UUFDL0MsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyw0QkFBNEIsSUFBSSxDQUFDLFlBQVksWUFBWSxJQUFJLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUVwSCxNQUFNLElBQUksR0FBRztZQUNYLE9BQU8sRUFBRSxxQkFBcUI7WUFDOUIsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPO1NBQ3hCLENBQUM7UUFFRixNQUFNLFFBQVEsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFRLENBQUM7UUFFekUsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUNqRCxN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QUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsRSxDQUFDO0NBQ0Y7QUFwSkQsd0NBb0pDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQge1xuICBBZmZpcm1hdGlvbnMsXG4gIEJ1aWxkUGF5bG9hZFBhcmFtZXRlcnMsXG4gIENhbGN1bGF0ZVNldHRsZW1lbnRGZWVzUGFyYW1zLFxuICBJQWZmaXJtYXRpb25zLFxuICBJU2V0dGxlbWVudHMsXG4gIElUcmFkaW5nQWNjb3VudCxcbiAgSVRyYWRpbmdQYXJ0bmVycyxcbiAgUGF5bG9hZCxcbiAgU2V0dGxlbWVudEZlZXMsXG4gIFNldHRsZW1lbnRzLFxuICBTaWduUGF5bG9hZFBhcmFtZXRlcnMsXG4gIFRyYWRpbmdQYXJ0bmVycyxcbn0gZnJvbSAnLi4vdHJhZGluZyc7XG5pbXBvcnQgeyBJV2FsbGV0IH0gZnJvbSAnLi4vd2FsbGV0JztcblxuY29uc3QgVFJBREVfUEFZTE9BRF9WRVJTSU9OID0gJzEuMi4wJztcblxuZXhwb3J0IGNsYXNzIFRyYWRpbmdBY2NvdW50IGltcGxlbWVudHMgSVRyYWRpbmdBY2NvdW50IHtcbiAgcHJpdmF0ZSByZWFkb25seSBiaXRnbzogQml0R29CYXNlO1xuICBwcml2YXRlIHJlYWRvbmx5IGVudGVycHJpc2VJZDogc3RyaW5nO1xuXG4gIHB1YmxpYyB3YWxsZXQ6IElXYWxsZXQ7XG5cbiAgY29uc3RydWN0b3IoZW50ZXJwcmlzZUlkOiBzdHJpbmcsIHdhbGxldDogSVdhbGxldCwgYml0Z286IEJpdEdvQmFzZSkge1xuICAgIHRoaXMuZW50ZXJwcmlzZUlkID0gZW50ZXJwcmlzZUlkO1xuICAgIHRoaXMud2FsbGV0ID0gd2FsbGV0O1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgfVxuXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy53YWxsZXQuaWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBwYXlsb2FkIGF1dGhvcml6aW5nIHRyYWRlIGZyb20gdGhpcyB0cmFkaW5nIGFjY291bnQuXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10gYXJyYXkgb2YgYW1vdW50cyB0aGF0IHdpbGwgYmUgdHJhZGVkIGFzIHBhcnQgb2YgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10uYWNjb3VudElkIHRoZSBhY2NvdW50SWQgY29ycmVzcG9uZGluZyB3aXRoIHRoZSBzZW5kaW5nIGFuZCByZWNlaXZpbmcgYW1vdW50cyBmb3IgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10uc2VuZEFtb3VudCBhbW91bnQgb2YgY3VycmVuY3kgc2VudCBieSB0cmFkaW5nIGFjY291bnQgb2YgZ2l2ZW4gYWNjb3VudElkXG4gICAqIEBwYXJhbSBwYXJhbXMuYW1vdW50c1tdLnNlbmRDdXJyZW5jeSBjdXJyZW5jeSBvZiBhbW91bnQgc2VudCBieSB0cmFkaW5nIGFjY291bnQgb2YgZ2l2ZW4gYWNjb3VudElkXG4gICAqIEBwYXJhbSBwYXJhbXMuYW1vdW50c1tdLnJlY2VpdmVBbW91bnQgYW1vdW50IG9mIGN1cnJlbmN5IHJlY2VpdmVkIGJ5IHRyYWRpbmcgYWNjb3VudCBvZiBnaXZlbiBhY2NvdW50SWRcbiAgICogQHBhcmFtIHBhcmFtcy5hbW91bnRzW10ucmVjZWl2ZUN1cnJlbmN5IGN1cnJlbmN5IG9mIGFtb3VudCByZWNlaXZlZCBieSB0cmFkaW5nIGFjY291bnQgb2YgZ2l2ZW4gYWNjb3VudElkXG4gICAqIEByZXR1cm5zIHVuc2lnbmVkIHRyYWRlIHBheWxvYWQgZm9yIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLiBUaGlzIG9iamVjdCBzaG91bGQgYmUgc3RyaW5naWZpZWQgd2l0aCBKU09OLnN0cmluZ2lmeSgpIGJlZm9yZSBiZWluZyBzdWJtaXR0ZWRcbiAgICovXG4gIGFzeW5jIGJ1aWxkUGF5bG9hZChwYXJhbXM6IEJ1aWxkUGF5bG9hZFBhcmFtZXRlcnMpOiBQcm9taXNlPFBheWxvYWQ+IHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoYC9hcGkvdHJhZGUvdjEvZW50ZXJwcmlzZS8ke3RoaXMuZW50ZXJwcmlzZUlkfS9hY2NvdW50LyR7dGhpcy5pZH0vcGF5bG9hZGApO1xuXG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIHZlcnNpb246IFRSQURFX1BBWUxPQURfVkVSU0lPTixcbiAgICAgIGFtb3VudHM6IHBhcmFtcy5hbW91bnRzLFxuICAgIH07XG5cbiAgICBjb25zdCByZXNwb25zZSA9IChhd2FpdCB0aGlzLmJpdGdvLnBvc3QodXJsKS5zZW5kKGJvZHkpLnJlc3VsdCgpKSBhcyBhbnk7XG5cbiAgICBpZiAoIXRoaXMudmVyaWZ5UGF5bG9hZChwYXJhbXMsIHJlc3BvbnNlLnBheWxvYWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmFibGUgdG8gdmVyaWZ5IHRyYWRlIHBheWxvYWQuIFlvdSBtYXkgbmVlZCB0byB1cGRhdGUgdGhlIEJpdEdvIFNESywgb3IgdGhlIHBheWxvYWQgbWF5IGhhdmUgYmVlbiB0YW1wZXJlZCB3aXRoLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UucGF5bG9hZCkgYXMgUGF5bG9hZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGF0IGEgcGF5bG9hZCByZWNlaXZlZCBmcm9tIEJpdEdvIHN1ZmZpY2llbnRseSBtYXRjaGVzIHRoZSBleHBlY3RlZCBwYXJhbWV0ZXJzLiBUaGlzIGlzIHVzZWQgdG8gcHJldmVudFxuICAgKiBtYW4taW4tdGhlLW1pZGRsZSBhdHRhY2tzIHdoaWNoIGNvdWxkIG1hbGljaW91c2x5IGFsdGVyIHRoZSBjb250ZW50cyBvZiBhIHBheWxvYWQuXG4gICAqIEBwYXJhbSBwYXJhbXMgcGFyYW1ldGVycyB1c2VkIHRvIGJ1aWxkIHRoZSBwYXlsb2FkXG4gICAqIEBwYXJhbSBwYXlsb2FkIHBheWxvYWQgcmVjZWl2ZWQgZnJvbSB0aGUgQml0R28gQVBJXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHBheWxvYWQncyBzZW5zaXRpdmUgZmllbGRzIG1hdGNoLCBmYWxzZSBpZiB0aGUgcGF5bG9hZCBtYXkgaGF2ZSBiZWVuIHRhbXBlcmVkIHdpdGhcbiAgICovXG4gIHZlcmlmeVBheWxvYWQocGFyYW1zOiBCdWlsZFBheWxvYWRQYXJhbWV0ZXJzLCBwYXlsb2FkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBwYXlsb2FkT2JqID0gSlNPTi5wYXJzZShwYXlsb2FkKTtcbiAgICBjb25zdCBwYXJhbXNDb3B5ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXJhbXMpKTsgLy8gbmVlZHMgdG8gYmUgYSBkZWVwIGNvcHlcblxuICAgIC8vIFZlcmlmaWVzIHRoYXQgZm9yIGVhY2ggcGFydHkgaW4gdGhlIHBheWxvYWQsIHdlIHJlcXVlc3RlZCBhIG1hdGNoaW5nIHBhcnR5LCBvbmx5IGNoZWNraW5nIHNlbnNpdGl2ZSBmaWVsZHNcbiAgICBsZXQgdmFsaWRBbW91bnRzID0gMDtcbiAgICBmb3IgKGNvbnN0IGFtb3VudCBvZiBwYXlsb2FkT2JqLmFtb3VudHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoaW5nRXhwZWN0ZWRQYXJ0eSA9IHBhcmFtc0NvcHkuYW1vdW50cy5maW5kSW5kZXgoXG4gICAgICAgIChleHBlY3RlZEFtb3VudCkgPT5cbiAgICAgICAgICBhbW91bnQuYWNjb3VudElkID09PSBleHBlY3RlZEFtb3VudC5hY2NvdW50SWQgJiZcbiAgICAgICAgICBhbW91bnQuc2VuZEN1cnJlbmN5ID09PSBleHBlY3RlZEFtb3VudC5zZW5kQ3VycmVuY3kgJiZcbiAgICAgICAgICBhbW91bnQuc2VuZFN1YnRvdGFsID09PSBleHBlY3RlZEFtb3VudC5zZW5kQW1vdW50ICYmXG4gICAgICAgICAgYW1vdW50LnJlY2VpdmVBbW91bnQgPT09IGV4cGVjdGVkQW1vdW50LnJlY2VpdmVBbW91bnQgJiZcbiAgICAgICAgICBhbW91bnQucmVjZWl2ZUN1cnJlbmN5ID09PSBleHBlY3RlZEFtb3VudC5yZWNlaXZlQ3VycmVuY3lcbiAgICAgICk7XG5cbiAgICAgIGlmIChtYXRjaGluZ0V4cGVjdGVkUGFydHkgPT09IC0xKSB7XG4gICAgICAgIC8vIG1hdGNoaW5nRXhwZWN0ZWRQYXJ0eSBub3QgZm91bmQgdG8gdGhlIHBheWxvYWRPYmplY3RcbiAgICAgICAgLy8gcGF5bG9hZCBpcyBub3QgdmFsaWRcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbW91bnQuZmVlcyAmJiBhbW91bnQuZmVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBmZWVUb3RhbCA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgICAgIGZvciAoY29uc3QgZmVlIG9mIGFtb3VudC5mZWVzKSB7XG4gICAgICAgICAgZmVlVG90YWwgPSBmZWVUb3RhbC5wbHVzKG5ldyBCaWdOdW1iZXIoZmVlLmZlZUFtb3VudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUb3RhbEFtb3VudCA9IG5ldyBCaWdOdW1iZXIocGFyYW1zQ29weS5hbW91bnRzW21hdGNoaW5nRXhwZWN0ZWRQYXJ0eV0uc2VuZEFtb3VudCkucGx1cyhmZWVUb3RhbCk7XG4gICAgICAgIGlmIChleHBlY3RlZFRvdGFsQW1vdW50LnRvU3RyaW5nKCkgIT09IGFtb3VudC5zZW5kQW1vdW50KSB7XG4gICAgICAgICAgLy8gZXhwZWN0ZWQgdG90YWwgZG9lcyBub3QgbWF0Y2ggdGhlIHNlbmRBbW91bnQgb2YgdGhlIHBheWxvYWRcbiAgICAgICAgICAvLyBwYXlsb2FkIGlzIG5vdCB2YWxpZFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG1hdGNoaW5nIHBhcnR5IGZvdW5kLCBhbmQgZmVlIGZvdW5kXG4gICAgICB2YWxpZEFtb3VudHMgPSB2YWxpZEFtb3VudHMgKyAxO1xuICAgICAgLy8gZGVsZXRlIHNvIHdlIGVuc3VyZSBubyBkdXBsaWNhdGVzXG4gICAgICBwYXJhbXNDb3B5LmFtb3VudHMuc3BsaWNlKG1hdGNoaW5nRXhwZWN0ZWRQYXJ0eSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHBheWxvYWRPYmouYWNjb3VudElkID09PSB0aGlzLmlkICYmXG4gICAgICBwYXlsb2FkT2JqLmFtb3VudHMubGVuZ3RoID09PSBwYXJhbXMuYW1vdW50cy5sZW5ndGggJiZcbiAgICAgIHZhbGlkQW1vdW50cyA9PT0gcGF5bG9hZE9iai5hbW91bnRzLmxlbmd0aFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbmVjZXNzYXJ5IGZlZXMgdG8gY29tcGxldGUgYSBzZXR0bGVtZW50IGJldHdlZW4gdHdvIHBhcnRpZXMsIGJhc2VkIG9uIHRoZSBhbW91bnRzIGFuZCBjdXJyZW5jaWVzIG9mIHRoZSBzZXR0bGVtZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuY291bnRlcnBhcnR5QWNjb3VudElkIEFjY291bnQgSUQgb2YgdGhlIGNvdW50ZXJwYXJ0eSBvZiB0aGUgc2V0dGxlbWVudFxuICAgKiBAcGFyYW0gcGFyYW1zLnNlbmRDdXJyZW5jeSBDdXJyZW5jeSB0byBiZSBzZW50IGFzIHBhcnQgb2YgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5zZW5kQW1vdW50IEFtb3VudCBvZiBjdXJyZW5jeSAoaW4gYmFzZSB1bml0cyBzdWNoIGFzIGNlbnRzLCBzYXRvc2hpcywgb3Igd2VpKSB0byBiZSBzZW50XG4gICAqIEBwYXJhbSBwYXJhbXMucmVjZWl2ZUN1cnJlbmN5IEN1cnJlbmN5IHRvIGJlIHJlY2VpdmVkIGFzIHBhcnQgb2YgdGhlIHNldHRsZW1lbnRcbiAgICogQHBhcmFtIHBhcmFtcy5yZWNlaXZlQW1vdW50IEFtb3VudCBvZiBjdXJyZW5jeSAoaW4gYmFzZSB1bml0cyBzdWNoIGFzIGNlbnRzLCBzYXRvc2hpcywgb3Igd2VpKSB0byBiZSByZWNlaXZlZFxuICAgKiBAcmV0dXJucyBGZWUgcmF0ZSwgY3VycmVuY3ksIGFuZCB0b3RhbCBhbW91bnQgb2YgdGhlIGRlc2NyaWJlZCBzZXR0bGVtZW50XG4gICAqL1xuICBhc3luYyBjYWxjdWxhdGVTZXR0bGVtZW50RmVlcyhwYXJhbXM6IENhbGN1bGF0ZVNldHRsZW1lbnRGZWVzUGFyYW1zKTogUHJvbWlzZTxTZXR0bGVtZW50RmVlcz4ge1xuICAgIGNvbnN0IHVybCA9IHRoaXMuYml0Z28ubWljcm9zZXJ2aWNlc1VybChcbiAgICAgIGAvYXBpL3RyYWRlL3YxL2VudGVycHJpc2UvJHt0aGlzLmVudGVycHJpc2VJZH0vYWNjb3VudC8ke3RoaXMuaWR9L2NhbGN1bGF0ZWZlZXNgXG4gICAgKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLnBvc3QodXJsKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgYW4gYXJiaXRyYXJ5IHBheWxvYWQgd2l0aCB0aGUgdXNlciBrZXkgb24gdGhpcyB0cmFkaW5nIGFjY291bnRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnBheWxvYWQgYXJiaXRyYXJ5IHBheWxvYWQgb2JqZWN0IChzdHJpbmcgfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIHBhc3NwaHJhc2Ugb24gdGhpcyB0cmFkaW5nIGFjY291bnQsIHVzZWQgdG8gdW5sb2NrIHRoZSBhY2NvdW50IHVzZXIga2V5XG4gICAqIEByZXR1cm5zIGhleC1lbmNvZGVkIHNpZ25hdHVyZSBvZiB0aGUgcGF5bG9hZFxuICAgKi9cbiAgYXN5bmMgc2lnblBheWxvYWQocGFyYW1zOiBTaWduUGF5bG9hZFBhcmFtZXRlcnMpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGtleSA9IChhd2FpdCB0aGlzLndhbGxldC5iYXNlQ29pbi5rZXljaGFpbnMoKS5nZXQoeyBpZDogdGhpcy53YWxsZXQua2V5SWRzKClbMF0gfSkpIGFzIGFueTtcbiAgICBjb25zdCBwcnYgPSB0aGlzLndhbGxldC5iaXRnby5kZWNyeXB0KHtcbiAgICAgIGlucHV0OiBrZXkuZW5jcnlwdGVkUHJ2LFxuICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgIH0pO1xuICAgIGNvbnN0IHBheWxvYWQgPSB0eXBlb2YgcGFyYW1zLnBheWxvYWQgPT09ICdzdHJpbmcnID8gcGFyYW1zLnBheWxvYWQgOiBKU09OLnN0cmluZ2lmeShwYXJhbXMucGF5bG9hZCk7XG4gICAgcmV0dXJuICgoYXdhaXQgdGhpcy53YWxsZXQuYmFzZUNvaW4uc2lnbk1lc3NhZ2UoeyBwcnYgfSwgcGF5bG9hZCkpIGFzIGFueSkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgYWZmaXJtYXRpb25zKCk6IElBZmZpcm1hdGlvbnMge1xuICAgIHJldHVybiBuZXcgQWZmaXJtYXRpb25zKHRoaXMuYml0Z28sIHRoaXMuZW50ZXJwcmlzZUlkLCB0aGlzKTtcbiAgfVxuXG4gIHNldHRsZW1lbnRzKCk6IElTZXR0bGVtZW50cyB7XG4gICAgcmV0dXJuIG5ldyBTZXR0bGVtZW50cyh0aGlzLmJpdGdvLCB0aGlzLmVudGVycHJpc2VJZCwgdGhpcyk7XG4gIH1cblxuICBwYXJ0bmVycygpOiBJVHJhZGluZ1BhcnRuZXJzIHtcbiAgICByZXR1cm4gbmV3IFRyYWRpbmdQYXJ0bmVycyh0aGlzLmJpdGdvLCB0aGlzLmVudGVycHJpc2VJZCwgdGhpcyk7XG4gIH1cbn1cbiJdfQ==