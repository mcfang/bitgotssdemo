"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Affirmations = void 0;
const trading_1 = require("../trading");
class Affirmations {
    constructor(bitgo, enterpriseId, account) {
        this.bitgo = bitgo;
        this.enterpriseId = enterpriseId;
        this.account = account;
    }
    /**
     * Lists all affirmations for an enterprise
     * @param status optional status to filter affirmations by
     */
    async list(status) {
        let url;
        if (this.account) {
            url = this.bitgo.microservicesUrl(`/api/trade/v1/enterprise/${this.enterpriseId}/account/${this.account.id}/affirmations`);
        }
        else {
            url = this.bitgo.microservicesUrl(`/api/trade/v1/enterprise/${this.enterpriseId}/affirmations`);
        }
        if (status) {
            url = `${url}?status=${status}`;
        }
        const response = (await this.bitgo.get(url).result());
        return response.affirmations.map((affirmation) => new trading_1.Affirmation(affirmation, this.bitgo, this.enterpriseId));
    }
    /**
     * Retrieves a single affirmation by its ID
     * @param id ID of the affirmation to retrieve
     * @param accountId ID of the trading account that the affirmation belongs to
     */
    async get({ id, accountId }) {
        const account = (this.account && this.account.id) || accountId;
        if (!account) {
            throw new Error('accountId must be provided in parameters for an enterprise context');
        }
        const url = this.bitgo.microservicesUrl(`/api/trade/v1/enterprise/${this.enterpriseId}/account/${account}/affirmations/${id}`);
        const response = await this.bitgo.get(url).result();
        return new trading_1.Affirmation(response, this.bitgo, this.enterpriseId);
    }
}
exports.Affirmations = Affirmations;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWZmaXJtYXRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3RyYWRpbmcvYWZmaXJtYXRpb25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUlBLHdDQUFzSDtBQUV0SCxNQUFhLFlBQVk7SUFLdkIsWUFBWSxLQUFnQixFQUFFLFlBQW9CLEVBQUUsT0FBeUI7UUFDM0UsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBMEI7UUFDbkMsSUFBSSxHQUFHLENBQUM7UUFDUixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQy9CLDRCQUE0QixJQUFJLENBQUMsWUFBWSxZQUFZLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxlQUFlLENBQ3hGLENBQUM7U0FDSDthQUFNO1lBQ0wsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsNEJBQTRCLElBQUksQ0FBQyxZQUFZLGVBQWUsQ0FBQyxDQUFDO1NBQ2pHO1FBQ0QsSUFBSSxNQUFNLEVBQUU7WUFDVixHQUFHLEdBQUcsR0FBRyxHQUFHLFdBQVcsTUFBTSxFQUFFLENBQUM7U0FDakM7UUFFRCxNQUFNLFFBQVEsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQVEsQ0FBQztRQUU3RCxPQUFPLFFBQVEsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxJQUFJLHFCQUFXLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDakgsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBNEI7UUFDbkQsTUFBTSxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksU0FBUyxDQUFDO1FBQy9ELElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDWixNQUFNLElBQUksS0FBSyxDQUFDLG9FQUFvRSxDQUFDLENBQUM7U0FDdkY7UUFFRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUNyQyw0QkFBNEIsSUFBSSxDQUFDLFlBQVksWUFBWSxPQUFPLGlCQUFpQixFQUFFLEVBQUUsQ0FDdEYsQ0FBQztRQUNGLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDcEQsT0FBTyxJQUFJLHFCQUFXLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ2xFLENBQUM7Q0FDRjtBQWxERCxvQ0FrREMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IHsgQWZmaXJtYXRpb24sIEFmZmlybWF0aW9uU3RhdHVzLCBHZXRBZmZpcm1hdGlvblBhcmFtZXRlcnMsIElBZmZpcm1hdGlvbnMsIElUcmFkaW5nQWNjb3VudCB9IGZyb20gJy4uL3RyYWRpbmcnO1xuXG5leHBvcnQgY2xhc3MgQWZmaXJtYXRpb25zIGltcGxlbWVudHMgSUFmZmlybWF0aW9ucyB7XG4gIHByaXZhdGUgYml0Z286IEJpdEdvQmFzZTtcbiAgcHJpdmF0ZSBlbnRlcnByaXNlSWQ6IHN0cmluZztcbiAgcHJpdmF0ZSBhY2NvdW50PzogSVRyYWRpbmdBY2NvdW50O1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIGVudGVycHJpc2VJZDogc3RyaW5nLCBhY2NvdW50PzogSVRyYWRpbmdBY2NvdW50KSB7XG4gICAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICAgIHRoaXMuZW50ZXJwcmlzZUlkID0gZW50ZXJwcmlzZUlkO1xuICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnQ7XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgYWxsIGFmZmlybWF0aW9ucyBmb3IgYW4gZW50ZXJwcmlzZVxuICAgKiBAcGFyYW0gc3RhdHVzIG9wdGlvbmFsIHN0YXR1cyB0byBmaWx0ZXIgYWZmaXJtYXRpb25zIGJ5XG4gICAqL1xuICBhc3luYyBsaXN0KHN0YXR1cz86IEFmZmlybWF0aW9uU3RhdHVzKTogUHJvbWlzZTxBZmZpcm1hdGlvbltdPiB7XG4gICAgbGV0IHVybDtcbiAgICBpZiAodGhpcy5hY2NvdW50KSB7XG4gICAgICB1cmwgPSB0aGlzLmJpdGdvLm1pY3Jvc2VydmljZXNVcmwoXG4gICAgICAgIGAvYXBpL3RyYWRlL3YxL2VudGVycHJpc2UvJHt0aGlzLmVudGVycHJpc2VJZH0vYWNjb3VudC8ke3RoaXMuYWNjb3VudC5pZH0vYWZmaXJtYXRpb25zYFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsID0gdGhpcy5iaXRnby5taWNyb3NlcnZpY2VzVXJsKGAvYXBpL3RyYWRlL3YxL2VudGVycHJpc2UvJHt0aGlzLmVudGVycHJpc2VJZH0vYWZmaXJtYXRpb25zYCk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMpIHtcbiAgICAgIHVybCA9IGAke3VybH0/c3RhdHVzPSR7c3RhdHVzfWA7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgdGhpcy5iaXRnby5nZXQodXJsKS5yZXN1bHQoKSkgYXMgYW55O1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmFmZmlybWF0aW9ucy5tYXAoKGFmZmlybWF0aW9uKSA9PiBuZXcgQWZmaXJtYXRpb24oYWZmaXJtYXRpb24sIHRoaXMuYml0Z28sIHRoaXMuZW50ZXJwcmlzZUlkKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgc2luZ2xlIGFmZmlybWF0aW9uIGJ5IGl0cyBJRFxuICAgKiBAcGFyYW0gaWQgSUQgb2YgdGhlIGFmZmlybWF0aW9uIHRvIHJldHJpZXZlXG4gICAqIEBwYXJhbSBhY2NvdW50SWQgSUQgb2YgdGhlIHRyYWRpbmcgYWNjb3VudCB0aGF0IHRoZSBhZmZpcm1hdGlvbiBiZWxvbmdzIHRvXG4gICAqL1xuICBhc3luYyBnZXQoeyBpZCwgYWNjb3VudElkIH06IEdldEFmZmlybWF0aW9uUGFyYW1ldGVycyk6IFByb21pc2U8QWZmaXJtYXRpb24+IHtcbiAgICBjb25zdCBhY2NvdW50ID0gKHRoaXMuYWNjb3VudCAmJiB0aGlzLmFjY291bnQuaWQpIHx8IGFjY291bnRJZDtcbiAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWNjb3VudElkIG11c3QgYmUgcHJvdmlkZWQgaW4gcGFyYW1ldGVycyBmb3IgYW4gZW50ZXJwcmlzZSBjb250ZXh0Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gdGhpcy5iaXRnby5taWNyb3NlcnZpY2VzVXJsKFxuICAgICAgYC9hcGkvdHJhZGUvdjEvZW50ZXJwcmlzZS8ke3RoaXMuZW50ZXJwcmlzZUlkfS9hY2NvdW50LyR7YWNjb3VudH0vYWZmaXJtYXRpb25zLyR7aWR9YFxuICAgICk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpdGdvLmdldCh1cmwpLnJlc3VsdCgpO1xuICAgIHJldHVybiBuZXcgQWZmaXJtYXRpb24ocmVzcG9uc2UsIHRoaXMuYml0Z28sIHRoaXMuZW50ZXJwcmlzZUlkKTtcbiAgfVxufVxuIl19