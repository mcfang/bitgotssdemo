"use strict";
/**
 * @prettier
 *
 * Utility methods for Ellipic-Curve Diffie-Hellman (ECDH) shared secret generation
 *
 * > Elliptic-curve Diffie–Hellman (ECDH) is a key agreement protocol that allows two parties, each having an
 * > elliptic-curve public–private key pair, to establish a shared secret over an insecure channel.
 * > This shared secret may be directly used as a key, or to derive another key. The key, or the derived key, can then
 * > be used to encrypt subsequent communications using a symmetric-key cipher. It is a variant of the Diffie–Hellman
 * > protocol using elliptic-curve cryptography.
 *
 * https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyEcdhSignature = exports.signMessageWithDerivedEcdhKey = exports.getSharedSecret = void 0;
const assert = __importStar(require("assert"));
const secp256k1 = __importStar(require("secp256k1"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
/**
 * Calculate the Elliptic Curve Diffie Hellman
 * @param privateKey HDNode of private key
 * @param publicKey [neutered] HDNode of public key
 * @returns Buffer public key buffer that can be used as shared secret (see note)
 */
function getSharedSecret(privateKey, publicKey) {
    function isBIP32Interface(k) {
        return k.constructor.name === 'BIP32';
    }
    function isECPairInterface(k) {
        return k.constructor.name === 'ECPair';
    }
    if (isBIP32Interface(privateKey)) {
        if (!privateKey.privateKey) {
            throw new Error(`privateNode must be private key`);
        }
        privateKey = privateKey.privateKey;
    }
    else if (isECPairInterface(privateKey)) {
        if (privateKey.privateKey === undefined || !Buffer.isBuffer(privateKey.privateKey)) {
            throw new Error(`unexpected ECPair`);
        }
        privateKey = privateKey.privateKey;
    }
    if (!Buffer.isBuffer(publicKey)) {
        publicKey = publicKey.publicKey;
    }
    if (!Buffer.isBuffer(privateKey) || !Buffer.isBuffer(publicKey)) {
        throw new Error(`invalid state`);
    }
    assert.strictEqual(privateKey.length, 32);
    assert.strictEqual(publicKey.length, 33);
    // FIXME(BG-34386): we should use `secp256k1.ecdh()` in the future
    //                  see discussion here https://github.com/bitcoin-core/secp256k1/issues/352
    const buffer = Buffer.from(secp256k1.publicKeyTweakMul(publicKey, privateKey))
        // remove leading parity bit
        .slice(1);
    assert.strictEqual(buffer.length, 32);
    return buffer;
}
exports.getSharedSecret = getSharedSecret;
/**
 Signs a message using a given ecdh xprv at a given path
 */
function signMessageWithDerivedEcdhKey(message, xprv, path) {
    return utxo_lib_1.bip32.fromBase58(xprv).derivePath(path).sign(Buffer.from(message));
}
exports.signMessageWithDerivedEcdhKey = signMessageWithDerivedEcdhKey;
/**
 Verifies if a message was signed using the given ecdh key
 @param message message to verify
 @param signature hex encoded signature used to sign the message
 @param ecdhXpub pubkey/derived pubkey of ecdh keychain used to sign
 */
function verifyEcdhSignature(message, signature, ecdhXpub) {
    const ecPairInterface = utxo_lib_1.ECPair.fromPublicKey(ecdhXpub);
    return ecPairInterface.verify(Buffer.from(message), Buffer.from(signature, 'hex'));
}
exports.verifyEcdhSignature = verifyEcdhSignature;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNkaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9iaXRnby9lY2RoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7O0dBWUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFSCwrQ0FBaUM7QUFDakMscURBQXVDO0FBQ3ZDLDhDQUFpRjtBQUVqRjs7Ozs7R0FLRztBQUNILFNBQWdCLGVBQWUsQ0FDN0IsVUFBcUQsRUFDckQsU0FBa0M7SUFFbEMsU0FBUyxnQkFBZ0IsQ0FBQyxDQUFNO1FBQzlCLE9BQU8sQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDO0lBQ3hDLENBQUM7SUFDRCxTQUFTLGlCQUFpQixDQUFDLENBQU07UUFDL0IsT0FBTyxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksS0FBSyxRQUFRLENBQUM7SUFDekMsQ0FBQztJQUNELElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDaEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLEVBQUU7WUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1NBQ3BEO1FBQ0QsVUFBVSxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUM7S0FDcEM7U0FBTSxJQUFJLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQ3hDLElBQUksVUFBVSxDQUFDLFVBQVUsS0FBSyxTQUFTLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNsRixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7U0FDdEM7UUFDRCxVQUFVLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQztLQUNwQztJQUVELElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1FBQy9CLFNBQVMsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDO0tBQ2pDO0lBRUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1FBQy9ELE1BQU0sSUFBSSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7S0FDbEM7SUFFRCxNQUFNLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDMUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRXpDLGtFQUFrRTtJQUNsRSw0RkFBNEY7SUFDNUYsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQzVFLDRCQUE0QjtTQUMzQixLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDWixNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDdEMsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQXhDRCwwQ0F3Q0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLDZCQUE2QixDQUFDLE9BQWUsRUFBRSxJQUFZLEVBQUUsSUFBWTtJQUN2RixPQUFPLGdCQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQzVFLENBQUM7QUFGRCxzRUFFQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsbUJBQW1CLENBQUMsT0FBZSxFQUFFLFNBQWlCLEVBQUUsUUFBZ0I7SUFDdEYsTUFBTSxlQUFlLEdBQUcsaUJBQU0sQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDdkQsT0FBTyxlQUFlLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNyRixDQUFDO0FBSEQsa0RBR0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICpcbiAqIFV0aWxpdHkgbWV0aG9kcyBmb3IgRWxsaXBpYy1DdXJ2ZSBEaWZmaWUtSGVsbG1hbiAoRUNESCkgc2hhcmVkIHNlY3JldCBnZW5lcmF0aW9uXG4gKlxuICogPiBFbGxpcHRpYy1jdXJ2ZSBEaWZmaWXigJNIZWxsbWFuIChFQ0RIKSBpcyBhIGtleSBhZ3JlZW1lbnQgcHJvdG9jb2wgdGhhdCBhbGxvd3MgdHdvIHBhcnRpZXMsIGVhY2ggaGF2aW5nIGFuXG4gKiA+IGVsbGlwdGljLWN1cnZlIHB1YmxpY+KAk3ByaXZhdGUga2V5IHBhaXIsIHRvIGVzdGFibGlzaCBhIHNoYXJlZCBzZWNyZXQgb3ZlciBhbiBpbnNlY3VyZSBjaGFubmVsLlxuICogPiBUaGlzIHNoYXJlZCBzZWNyZXQgbWF5IGJlIGRpcmVjdGx5IHVzZWQgYXMgYSBrZXksIG9yIHRvIGRlcml2ZSBhbm90aGVyIGtleS4gVGhlIGtleSwgb3IgdGhlIGRlcml2ZWQga2V5LCBjYW4gdGhlblxuICogPiBiZSB1c2VkIHRvIGVuY3J5cHQgc3Vic2VxdWVudCBjb21tdW5pY2F0aW9ucyB1c2luZyBhIHN5bW1ldHJpYy1rZXkgY2lwaGVyLiBJdCBpcyBhIHZhcmlhbnQgb2YgdGhlIERpZmZpZeKAk0hlbGxtYW5cbiAqID4gcHJvdG9jb2wgdXNpbmcgZWxsaXB0aWMtY3VydmUgY3J5cHRvZ3JhcGh5LlxuICpcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VsbGlwdGljLWN1cnZlX0RpZmZpZSVFMiU4MCU5M0hlbGxtYW5cbiAqL1xuXG5pbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCAqIGFzIHNlY3AyNTZrMSBmcm9tICdzZWNwMjU2azEnO1xuaW1wb3J0IHsgRUNQYWlySW50ZXJmYWNlLCBCSVAzMkludGVyZmFjZSwgYmlwMzIsIEVDUGFpciB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hblxuICogQHBhcmFtIHByaXZhdGVLZXkgSEROb2RlIG9mIHByaXZhdGUga2V5XG4gKiBAcGFyYW0gcHVibGljS2V5IFtuZXV0ZXJlZF0gSEROb2RlIG9mIHB1YmxpYyBrZXlcbiAqIEByZXR1cm5zIEJ1ZmZlciBwdWJsaWMga2V5IGJ1ZmZlciB0aGF0IGNhbiBiZSB1c2VkIGFzIHNoYXJlZCBzZWNyZXQgKHNlZSBub3RlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KFxuICBwcml2YXRlS2V5OiBCSVAzMkludGVyZmFjZSB8IEVDUGFpckludGVyZmFjZSB8IEJ1ZmZlcixcbiAgcHVibGljS2V5OiBCSVAzMkludGVyZmFjZSB8IEJ1ZmZlclxuKTogQnVmZmVyIHtcbiAgZnVuY3Rpb24gaXNCSVAzMkludGVyZmFjZShrOiBhbnkpOiBrIGlzIEJJUDMySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gay5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQklQMzInO1xuICB9XG4gIGZ1bmN0aW9uIGlzRUNQYWlySW50ZXJmYWNlKGs6IGFueSk6IGsgaXMgRUNQYWlySW50ZXJmYWNlIHtcbiAgICByZXR1cm4gay5jb25zdHJ1Y3Rvci5uYW1lID09PSAnRUNQYWlyJztcbiAgfVxuICBpZiAoaXNCSVAzMkludGVyZmFjZShwcml2YXRlS2V5KSkge1xuICAgIGlmICghcHJpdmF0ZUtleS5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGVOb2RlIG11c3QgYmUgcHJpdmF0ZSBrZXlgKTtcbiAgICB9XG4gICAgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXkucHJpdmF0ZUtleTtcbiAgfSBlbHNlIGlmIChpc0VDUGFpckludGVyZmFjZShwcml2YXRlS2V5KSkge1xuICAgIGlmIChwcml2YXRlS2V5LnByaXZhdGVLZXkgPT09IHVuZGVmaW5lZCB8fCAhQnVmZmVyLmlzQnVmZmVyKHByaXZhdGVLZXkucHJpdmF0ZUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBFQ1BhaXJgKTtcbiAgICB9XG4gICAgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXkucHJpdmF0ZUtleTtcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHB1YmxpY0tleSkpIHtcbiAgICBwdWJsaWNLZXkgPSBwdWJsaWNLZXkucHVibGljS2V5O1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocHJpdmF0ZUtleSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihwdWJsaWNLZXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHN0YXRlYCk7XG4gIH1cblxuICBhc3NlcnQuc3RyaWN0RXF1YWwocHJpdmF0ZUtleS5sZW5ndGgsIDMyKTtcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKHB1YmxpY0tleS5sZW5ndGgsIDMzKTtcblxuICAvLyBGSVhNRShCRy0zNDM4Nik6IHdlIHNob3VsZCB1c2UgYHNlY3AyNTZrMS5lY2RoKClgIGluIHRoZSBmdXR1cmVcbiAgLy8gICAgICAgICAgICAgICAgICBzZWUgZGlzY3Vzc2lvbiBoZXJlIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luLWNvcmUvc2VjcDI1NmsxL2lzc3Vlcy8zNTJcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKHB1YmxpY0tleSwgcHJpdmF0ZUtleSkpXG4gICAgLy8gcmVtb3ZlIGxlYWRpbmcgcGFyaXR5IGJpdFxuICAgIC5zbGljZSgxKTtcbiAgYXNzZXJ0LnN0cmljdEVxdWFsKGJ1ZmZlci5sZW5ndGgsIDMyKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqXG4gU2lnbnMgYSBtZXNzYWdlIHVzaW5nIGEgZ2l2ZW4gZWNkaCB4cHJ2IGF0IGEgZ2l2ZW4gcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbk1lc3NhZ2VXaXRoRGVyaXZlZEVjZGhLZXkobWVzc2FnZTogc3RyaW5nLCB4cHJ2OiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IEJ1ZmZlciB7XG4gIHJldHVybiBiaXAzMi5mcm9tQmFzZTU4KHhwcnYpLmRlcml2ZVBhdGgocGF0aCkuc2lnbihCdWZmZXIuZnJvbShtZXNzYWdlKSk7XG59XG5cbi8qKlxuIFZlcmlmaWVzIGlmIGEgbWVzc2FnZSB3YXMgc2lnbmVkIHVzaW5nIHRoZSBnaXZlbiBlY2RoIGtleVxuIEBwYXJhbSBtZXNzYWdlIG1lc3NhZ2UgdG8gdmVyaWZ5XG4gQHBhcmFtIHNpZ25hdHVyZSBoZXggZW5jb2RlZCBzaWduYXR1cmUgdXNlZCB0byBzaWduIHRoZSBtZXNzYWdlXG4gQHBhcmFtIGVjZGhYcHViIHB1YmtleS9kZXJpdmVkIHB1YmtleSBvZiBlY2RoIGtleWNoYWluIHVzZWQgdG8gc2lnblxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5RWNkaFNpZ25hdHVyZShtZXNzYWdlOiBzdHJpbmcsIHNpZ25hdHVyZTogc3RyaW5nLCBlY2RoWHB1YjogQnVmZmVyKTogYm9vbGVhbiB7XG4gIGNvbnN0IGVjUGFpckludGVyZmFjZSA9IEVDUGFpci5mcm9tUHVibGljS2V5KGVjZGhYcHViKTtcbiAgcmV0dXJuIGVjUGFpckludGVyZmFjZS52ZXJpZnkoQnVmZmVyLmZyb20obWVzc2FnZSksIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgJ2hleCcpKTtcbn1cbiJdfQ==