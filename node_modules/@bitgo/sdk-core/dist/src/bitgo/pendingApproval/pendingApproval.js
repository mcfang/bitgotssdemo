"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PendingApproval = void 0;
/**
 * @prettier
 */
const _ = __importStar(require("lodash"));
const common = __importStar(require("../../common"));
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const pendingApproval_1 = require("../pendingApproval");
const utils_1 = require("../utils");
class PendingApproval {
    constructor(bitgo, baseCoin, pendingApprovalData, wallet) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
        this.wallet = wallet;
        this.tssUtils = new utils_1.TssUtils(this.bitgo, this.baseCoin, wallet);
        this._pendingApproval = pendingApprovalData;
    }
    /**
     * Get the id for this PendingApproval
     */
    id() {
        return this._pendingApproval.id;
    }
    /**
     * Get the owner type (wallet or enterprise)
     * Pending approvals can be approved or modified by different scopes (depending on how they were created)
     * If a pending approval is owned by a wallet, then it can be approved by administrators of the wallet
     * If a pending approval is owned by an enterprise, then it can be approved by administrators of the enterprise
     */
    ownerType() {
        if (this._pendingApproval.wallet) {
            return pendingApproval_1.OwnerType.WALLET;
        }
        else if (this._pendingApproval.enterprise) {
            return pendingApproval_1.OwnerType.ENTERPRISE;
        }
        else {
            throw new Error('unexpected pending approval owner: neither wallet nor enterprise was present');
        }
    }
    /**
     * Get the id of the wallet which is associated with this PendingApproval
     */
    walletId() {
        return this._pendingApproval.wallet;
    }
    /**
     * Get the enterprise ID that is associated with this PendingApproval
     */
    enterpriseId() {
        return this._pendingApproval.enterprise;
    }
    /**
     * Get the state of this PendingApproval
     */
    state() {
        return this._pendingApproval.state;
    }
    /**
     * Get the id of the user that performed the action resulting in this PendingApproval
     */
    creator() {
        return this._pendingApproval.creator;
    }
    /**
     * Get the type of the pending approval (what it approves)
     */
    type() {
        if (!this._pendingApproval.info) {
            throw new Error('pending approval info is not available');
        }
        return this._pendingApproval.info.type;
    }
    /**
     * Get information about this PendingApproval
     */
    info() {
        return this._pendingApproval.info;
    }
    /**
     * Get the number of approvals that are required for this PendingApproval to be approved.
     * Defaults to 1 if approvalsRequired doesn't exist on the object
     */
    approvalsRequired() {
        return this._pendingApproval.approvalsRequired || 1;
    }
    /**
     * Generate a url for this PendingApproval for making requests to the server.
     * @param extra
     */
    url(extra = '') {
        return this.baseCoin.url('/pendingapprovals/' + this.id() + extra);
    }
    /**
     * Refetches this PendingApproval from the server and returns it.
     *
     * Note that this mutates the PendingApproval object in place.
     * @param params
     */
    async get(params = {}) {
        this._pendingApproval = await this.bitgo.get(this.url()).result();
        return this;
    }
    /**
     * Helper function to ensure that self.wallet is set
     */
    async populateWallet() {
        const transactionRequest = this.info().transactionRequest;
        if (_.isUndefined(transactionRequest)) {
            throw new Error('missing required object property transactionRequest');
        }
        if (_.isUndefined(this.wallet)) {
            const updatedWallet = await this.baseCoin.wallets().get({ id: transactionRequest.sourceWallet });
            if (_.isUndefined(updatedWallet)) {
                throw new Error('unexpected - unable to get wallet using sourcewallet');
            }
            this.wallet = updatedWallet;
        }
        if (this.wallet.id() !== transactionRequest.sourceWallet) {
            throw new Error('unexpected source wallet for pending approval');
        }
        // otherwise returns undefined
        return;
    }
    /**
     * Sets this PendingApproval to an approved state
     */
    async approve(params = {}) {
        var _a, _b, _c, _d, _e, _f;
        common.validateParams(params, [], ['walletPassphrase', 'otp']);
        let canRecreateTransaction = true;
        params.previewPendingTxs = true;
        params.pendingApprovalId = this.id();
        /*
         * Cold wallets cannot recreate transactions if the only thing provided is the wallet passphrase
         *
         * The transaction can be recreated if either
         * – there is an xprv
         * – there is a walletPassphrase and the wallet is not cold (because if it's cold, the passphrase is of little use)
         *
         * Therefore, if neither of these is true, the transaction cannot be recreated, which is reflected in the if
         * statement below.
         */
        const isColdWallet = !!_.get(this.wallet, '_wallet.isCold');
        const isOFCWallet = this.baseCoin.getFamily() === 'ofc'; // Off-chain transactions don't need to be rebuilt
        if (!params.xprv && !(params.walletPassphrase && !isColdWallet && !isOFCWallet)) {
            canRecreateTransaction = false;
        }
        // If there are no recipients, then the transaction cannot be recreated
        const recipients = ((_c = (_b = (_a = this.info()) === null || _a === void 0 ? void 0 : _a.transactionRequest) === null || _b === void 0 ? void 0 : _b.buildParams) === null || _c === void 0 ? void 0 : _c.recipients) || [];
        const type = (_f = (_e = (_d = this.info()) === null || _d === void 0 ? void 0 : _d.transactionRequest) === null || _e === void 0 ? void 0 : _e.buildParams) === null || _f === void 0 ? void 0 : _f.type;
        // We only want to not recreate transactions with no recipients if it is a UTXO coin.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (utxolib.isValidNetwork(this.baseCoin.network) && recipients.length === 0 && type !== 'consolidate') {
            canRecreateTransaction = false;
        }
        const reqId = new utils_1.RequestTracer();
        /*
         * Internal helper function to get the serialized transaction which is being approved
         */
        const getApprovalTransaction = async () => {
            if (this.type() === 'transactionRequest') {
                /*
                 * If this is a request for approving a transaction, depending on whether this user has a private key to the wallet
                 * (some admins may not have the spend permission), the transaction could either be rebroadcast as is, or it could
                 * be reconstructed. It is preferable to reconstruct a tx in order to adhere to the latest network conditions
                 * such as newer unspents, different fees, or a higher sequence id
                 */
                if (params.tx) {
                    // the approval tx was reconstructed and explicitly specified - pass it through
                    return {
                        txHex: params.tx,
                    };
                }
                const transaction = _.get(this.info(), `transactionRequest.coinSpecific.${this.baseCoin.type}`);
                // this user may not have spending privileges or a passphrase may not have been passed in
                if (!canRecreateTransaction) {
                    if (!_.isObject(transaction)) {
                        throw new Error('there is neither an original transaction object nor can a new one be recreated');
                    }
                    return transaction;
                }
                this.bitgo.setRequestTracer(reqId);
                await this.populateWallet();
                if (this._pendingApproval.txRequestId) {
                    return await this.recreateAndSignTSSTransaction(params, reqId);
                }
                return await this.recreateAndSignTransaction(params);
            }
        };
        /*
         * Internal helper function to prepare the approval payload and send it to bitgo
         */
        const sendApproval = (transaction) => {
            const approvalParams = { state: 'approved', otp: params.otp };
            if (transaction) {
                // if the transaction already has a half signed property, we take that directly
                approvalParams.halfSigned = transaction.halfSigned || transaction;
            }
            this.bitgo.setRequestTracer(reqId);
            return this.bitgo.put(this.url()).send(approvalParams).result();
        };
        try {
            const approvalTransaction = (await getApprovalTransaction());
            this.bitgo.setRequestTracer(reqId);
            return await sendApproval(approvalTransaction);
        }
        catch (e) {
            if (!canRecreateTransaction &&
                (e.message.indexOf('could not find unspent output for input') !== -1 ||
                    e.message.indexOf('transaction conflicts with an existing transaction in the send queue') !== -1)) {
                throw new Error('unspents expired, wallet passphrase or xprv required to recreate transaction');
            }
            throw e;
        }
    }
    /**
     * Sets this PendingApproval to a rejected state
     * @param params
     */
    async reject(params = {}) {
        return await this.bitgo.put(this.url()).send({ state: 'rejected' }).result();
    }
    /**
     * Alias for PendingApproval.reject()
     *
     * @deprecated
     * @param params
     */
    async cancel(params = {}) {
        return await this.reject(params);
    }
    /**
     * Recreate and sign TSS transaction
     * @param {ApproveOptions} params needed to get txs and use the walletPassphrase to tss sign
     * @param {RequestTracer} reqId id tracer.
     */
    async recreateAndSignTSSTransaction(params, reqId) {
        const { walletPassphrase } = params;
        const txRequestId = this._pendingApproval.txRequestId;
        if (!this.wallet) {
            throw new Error('Wallet not found');
        }
        if (!walletPassphrase) {
            throw new Error('walletPassphrase not found');
        }
        if (!txRequestId) {
            throw new Error('txRequestId not found');
        }
        const decryptedPrv = await this.wallet.getPrv({ walletPassphrase });
        const txRequest = await this.tssUtils.recreateTxRequest(txRequestId, decryptedPrv, reqId);
        return {
            txHex: txRequest.unsignedTxs[0].serializedTxHex,
        };
    }
    /**
     * Recreate a transaction for a pending approval to respond to updated network conditions
     * @param params
     */
    async recreateAndSignTransaction(params = {}) {
        // this method only makes sense with existing transaction requests
        const transactionRequest = this.info().transactionRequest;
        if (_.isUndefined(transactionRequest)) {
            throw new Error('cannot recreate transaction without transaction request');
        }
        if (_.isUndefined(this.wallet)) {
            throw new Error('cannot recreate transaction without wallet');
        }
        const originalPrebuild = transactionRequest.coinSpecific[this.baseCoin.type];
        const recipients = transactionRequest.recipients;
        const prebuildParams = _.extend({}, params, { recipients: recipients }, transactionRequest.buildParams);
        if (!_.isUndefined(originalPrebuild.hopTransaction)) {
            prebuildParams.hop = true;
        }
        if (transactionRequest.buildParams && transactionRequest.buildParams.type === 'consolidate') {
            // consolidate tag is in the build params - this is a consolidation transaction, so
            // it needs to be rebuilt using the special consolidation build route
            prebuildParams.prebuildTx = await this.bitgo
                .post(this.wallet.url(`/consolidateUnspents`))
                .send(prebuildParams)
                .result();
            delete prebuildParams.recipients;
        }
        const signedTransaction = await this.wallet.prebuildAndSignTransaction(prebuildParams);
        // compare PAYGo fees
        const originalParsedTransaction = (await this.baseCoin.parseTransaction({
            txParams: prebuildParams,
            wallet: this.wallet,
            txPrebuild: originalPrebuild,
        }));
        const recreatedParsedTransaction = (await this.baseCoin.parseTransaction({
            txParams: prebuildParams,
            wallet: this.wallet,
            txPrebuild: signedTransaction,
        }));
        if (_.isUndefined(recreatedParsedTransaction.implicitExternalSpendAmount)) {
            return signedTransaction;
        }
        if (typeof recreatedParsedTransaction.implicitExternalSpendAmount !== 'bigint' &&
            !_.isFinite(recreatedParsedTransaction.implicitExternalSpendAmount)) {
            throw new Error('implicit external spend amount could not be determined');
        }
        if (!_.isUndefined(originalParsedTransaction.implicitExternalSpendAmount) &&
            recreatedParsedTransaction.implicitExternalSpendAmount > originalParsedTransaction.implicitExternalSpendAmount) {
            throw new Error('recreated transaction is using a higher pay-as-you-go-fee');
        }
        return signedTransaction;
    }
}
exports.PendingApproval = PendingApproval;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVuZGluZ0FwcHJvdmFsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3BlbmRpbmdBcHByb3ZhbC9wZW5kaW5nQXBwcm92YWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsMENBQTRCO0FBQzVCLHFEQUF1QztBQUN2Qyx5REFBMkM7QUFHM0Msd0RBUTRCO0FBQzVCLG9DQUFtRDtBQUduRCxNQUFhLGVBQWU7SUFPMUIsWUFBWSxLQUFnQixFQUFFLFFBQW1CLEVBQUUsbUJBQXdDLEVBQUUsTUFBZ0I7UUFDM0csSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGdCQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ2hFLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxtQkFBbUIsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxFQUFFO1FBQ0EsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFNBQVM7UUFDUCxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUU7WUFDaEMsT0FBTywyQkFBUyxDQUFDLE1BQU0sQ0FBQztTQUN6QjthQUFNLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRTtZQUMzQyxPQUFPLDJCQUFTLENBQUMsVUFBVSxDQUFDO1NBQzdCO2FBQU07WUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLDhFQUE4RSxDQUFDLENBQUM7U0FDakc7SUFDSCxDQUFDO0lBRUQ7O09B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SSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztZQUN0RSxRQUFRLEVBQUUsY0FBYztZQUN4QixNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU07WUFDbkIsVUFBVSxFQUFFLGdCQUFnQjtTQUM3QixDQUFDLENBQVEsQ0FBQztRQUNYLE1BQU0sMEJBQTBCLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUM7WUFDdkUsUUFBUSxFQUFFLGNBQWM7WUFDeEIsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ25CLFVBQVUsRUFBRSxpQkFBaUI7U0FDOUIsQ0FBQyxDQUFRLENBQUM7UUFFWCxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsMEJBQTBCLENBQUMsMkJBQTJCLENBQUMsRUFBRTtZQUN6RSxPQUFPLGlCQUFpQixDQUFDO1NBQzFCO1FBRUQsSUFDRSxPQUFPLDBCQUEwQixDQUFDLDJCQUEyQixLQUFLLFFBQVE7WUFDMUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLDBCQUEwQixDQUFDLDJCQUEyQixDQUFDLEVBQ25FO1lBQ0EsTUFBTSxJQUFJLEtBQUssQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO1NBQzNFO1FBQ0QsSUFDRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMseUJBQXlCLENBQUMsMkJBQTJCLENBQUM7WUFDckUsMEJBQTBCLENBQUMsMkJBQTJCLEdBQUcseUJBQXlCLENBQUMsMkJBQTJCLEVBQzlHO1lBQ0EsTUFBTSxJQUFJLEtBQUssQ0FBQywyREFBMkQsQ0FBQyxDQUFDO1NBQzlFO1FBQ0QsT0FBTyxpQkFBaUIsQ0FBQztJQUMzQixDQUFDO0NBQ0Y7QUFuV0QsMENBbVdDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4uLy4uL2NvbW1vbic7XG5pbXBvcnQgKiBhcyB1dHhvbGliIGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBJQmFzZUNvaW4gfSBmcm9tICcuLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IHtcbiAgQXBwcm92ZU9wdGlvbnMsXG4gIElQZW5kaW5nQXBwcm92YWwsXG4gIE93bmVyVHlwZSxcbiAgUGVuZGluZ0FwcHJvdmFsRGF0YSxcbiAgUGVuZGluZ0FwcHJvdmFsSW5mbyxcbiAgU3RhdGUsXG4gIFR5cGUsXG59IGZyb20gJy4uL3BlbmRpbmdBcHByb3ZhbCc7XG5pbXBvcnQgeyBSZXF1ZXN0VHJhY2VyLCBUc3NVdGlscyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IElXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuXG5leHBvcnQgY2xhc3MgUGVuZGluZ0FwcHJvdmFsIGltcGxlbWVudHMgSVBlbmRpbmdBcHByb3ZhbCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvQmFzZTtcbiAgcHJpdmF0ZSByZWFkb25seSBiYXNlQ29pbjogSUJhc2VDb2luO1xuICBwcml2YXRlIHRzc1V0aWxzOiBUc3NVdGlscztcbiAgcHJpdmF0ZSB3YWxsZXQ/OiBJV2FsbGV0O1xuICBwcml2YXRlIF9wZW5kaW5nQXBwcm92YWw6IFBlbmRpbmdBcHByb3ZhbERhdGE7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgYmFzZUNvaW46IElCYXNlQ29pbiwgcGVuZGluZ0FwcHJvdmFsRGF0YTogUGVuZGluZ0FwcHJvdmFsRGF0YSwgd2FsbGV0PzogSVdhbGxldCkge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gICAgdGhpcy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgdGhpcy50c3NVdGlscyA9IG5ldyBUc3NVdGlscyh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCB3YWxsZXQpO1xuICAgIHRoaXMuX3BlbmRpbmdBcHByb3ZhbCA9IHBlbmRpbmdBcHByb3ZhbERhdGE7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpZCBmb3IgdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG93bmVyIHR5cGUgKHdhbGxldCBvciBlbnRlcnByaXNlKVxuICAgKiBQZW5kaW5nIGFwcHJvdmFscyBjYW4gYmUgYXBwcm92ZWQgb3IgbW9kaWZpZWQgYnkgZGlmZmVyZW50IHNjb3BlcyAoZGVwZW5kaW5nIG9uIGhvdyB0aGV5IHdlcmUgY3JlYXRlZClcbiAgICogSWYgYSBwZW5kaW5nIGFwcHJvdmFsIGlzIG93bmVkIGJ5IGEgd2FsbGV0LCB0aGVuIGl0IGNhbiBiZSBhcHByb3ZlZCBieSBhZG1pbmlzdHJhdG9ycyBvZiB0aGUgd2FsbGV0XG4gICAqIElmIGEgcGVuZGluZyBhcHByb3ZhbCBpcyBvd25lZCBieSBhbiBlbnRlcnByaXNlLCB0aGVuIGl0IGNhbiBiZSBhcHByb3ZlZCBieSBhZG1pbmlzdHJhdG9ycyBvZiB0aGUgZW50ZXJwcmlzZVxuICAgKi9cbiAgb3duZXJUeXBlKCk6IE93bmVyVHlwZSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdBcHByb3ZhbC53YWxsZXQpIHtcbiAgICAgIHJldHVybiBPd25lclR5cGUuV0FMTEVUO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fcGVuZGluZ0FwcHJvdmFsLmVudGVycHJpc2UpIHtcbiAgICAgIHJldHVybiBPd25lclR5cGUuRU5URVJQUklTRTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHBlbmRpbmcgYXBwcm92YWwgb3duZXI6IG5laXRoZXIgd2FsbGV0IG5vciBlbnRlcnByaXNlIHdhcyBwcmVzZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaWQgb2YgdGhlIHdhbGxldCB3aGljaCBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIHdhbGxldElkKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC53YWxsZXQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbnRlcnByaXNlIElEIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgUGVuZGluZ0FwcHJvdmFsXG4gICAqL1xuICBlbnRlcnByaXNlSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmVudGVycHJpc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZSBvZiB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgc3RhdGUoKTogU3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuc3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBpZCBvZiB0aGUgdXNlciB0aGF0IHBlcmZvcm1lZCB0aGUgYWN0aW9uIHJlc3VsdGluZyBpbiB0aGlzIFBlbmRpbmdBcHByb3ZhbFxuICAgKi9cbiAgY3JlYXRvcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuY3JlYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHR5cGUgb2YgdGhlIHBlbmRpbmcgYXBwcm92YWwgKHdoYXQgaXQgYXBwcm92ZXMpXG4gICAqL1xuICB0eXBlKCk6IFR5cGUge1xuICAgIGlmICghdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGVuZGluZyBhcHByb3ZhbCBpbmZvIGlzIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ0FwcHJvdmFsLmluZm8udHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBQZW5kaW5nQXBwcm92YWxcbiAgICovXG4gIGluZm8oKTogUGVuZGluZ0FwcHJvdmFsSW5mbyB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdBcHByb3ZhbC5pbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIGFwcHJvdmFscyB0aGF0IGFyZSByZXF1aXJlZCBmb3IgdGhpcyBQZW5kaW5nQXBwcm92YWwgdG8gYmUgYXBwcm92ZWQuXG4gICAqIERlZmF1bHRzIHRvIDEgaWYgYXBwcm92YWxzUmVxdWlyZWQgZG9lc24ndCBleGlzdCBvbiB0aGUgb2JqZWN0XG4gICAqL1xuICBhcHByb3ZhbHNSZXF1aXJlZCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWwuYXBwcm92YWxzUmVxdWlyZWQgfHwgMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVybCBmb3IgdGhpcyBQZW5kaW5nQXBwcm92YWwgZm9yIG1ha2luZyByZXF1ZXN0cyB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0gZXh0cmFcbiAgICovXG4gIHVybChleHRyYSA9ICcnKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi51cmwoJy9wZW5kaW5nYXBwcm92YWxzLycgKyB0aGlzLmlkKCkgKyBleHRyYSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmZXRjaGVzIHRoaXMgUGVuZGluZ0FwcHJvdmFsIGZyb20gdGhlIHNlcnZlciBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbXV0YXRlcyB0aGUgUGVuZGluZ0FwcHJvdmFsIG9iamVjdCBpbiBwbGFjZS5cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZ2V0KHBhcmFtczogUmVjb3JkPHN0cmluZywgbmV2ZXI+ID0ge30pOiBQcm9taXNlPFBlbmRpbmdBcHByb3ZhbD4ge1xuICAgIHRoaXMuX3BlbmRpbmdBcHByb3ZhbCA9IGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCkpLnJlc3VsdCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBlbnN1cmUgdGhhdCBzZWxmLndhbGxldCBpcyBzZXRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcG9wdWxhdGVXYWxsZXQoKTogUHJvbWlzZTx1bmRlZmluZWQ+IHtcbiAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3QgPSB0aGlzLmluZm8oKS50cmFuc2FjdGlvblJlcXVlc3Q7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHJhbnNhY3Rpb25SZXF1ZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIG9iamVjdCBwcm9wZXJ0eSB0cmFuc2FjdGlvblJlcXVlc3QnKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLndhbGxldCkpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZWRXYWxsZXQ6IElXYWxsZXQgPSBhd2FpdCB0aGlzLmJhc2VDb2luLndhbGxldHMoKS5nZXQoeyBpZDogdHJhbnNhY3Rpb25SZXF1ZXN0LnNvdXJjZVdhbGxldCB9KTtcblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodXBkYXRlZFdhbGxldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIC0gdW5hYmxlIHRvIGdldCB3YWxsZXQgdXNpbmcgc291cmNld2FsbGV0Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMud2FsbGV0ID0gdXBkYXRlZFdhbGxldDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53YWxsZXQuaWQoKSAhPT0gdHJhbnNhY3Rpb25SZXF1ZXN0LnNvdXJjZVdhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIHNvdXJjZSB3YWxsZXQgZm9yIHBlbmRpbmcgYXBwcm92YWwnKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWRcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIFBlbmRpbmdBcHByb3ZhbCB0byBhbiBhcHByb3ZlZCBzdGF0ZVxuICAgKi9cbiAgYXN5bmMgYXBwcm92ZShwYXJhbXM6IEFwcHJvdmVPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3dhbGxldFBhc3NwaHJhc2UnLCAnb3RwJ10pO1xuXG4gICAgbGV0IGNhblJlY3JlYXRlVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgIHBhcmFtcy5wcmV2aWV3UGVuZGluZ1R4cyA9IHRydWU7XG4gICAgcGFyYW1zLnBlbmRpbmdBcHByb3ZhbElkID0gdGhpcy5pZCgpO1xuICAgIC8qXG4gICAgICogQ29sZCB3YWxsZXRzIGNhbm5vdCByZWNyZWF0ZSB0cmFuc2FjdGlvbnMgaWYgdGhlIG9ubHkgdGhpbmcgcHJvdmlkZWQgaXMgdGhlIHdhbGxldCBwYXNzcGhyYXNlXG4gICAgICpcbiAgICAgKiBUaGUgdHJhbnNhY3Rpb24gY2FuIGJlIHJlY3JlYXRlZCBpZiBlaXRoZXJcbiAgICAgKiDigJMgdGhlcmUgaXMgYW4geHBydlxuICAgICAqIOKAkyB0aGVyZSBpcyBhIHdhbGxldFBhc3NwaHJhc2UgYW5kIHRoZSB3YWxsZXQgaXMgbm90IGNvbGQgKGJlY2F1c2UgaWYgaXQncyBjb2xkLCB0aGUgcGFzc3BocmFzZSBpcyBvZiBsaXR0bGUgdXNlKVxuICAgICAqXG4gICAgICogVGhlcmVmb3JlLCBpZiBuZWl0aGVyIG9mIHRoZXNlIGlzIHRydWUsIHRoZSB0cmFuc2FjdGlvbiBjYW5ub3QgYmUgcmVjcmVhdGVkLCB3aGljaCBpcyByZWZsZWN0ZWQgaW4gdGhlIGlmXG4gICAgICogc3RhdGVtZW50IGJlbG93LlxuICAgICAqL1xuICAgIGNvbnN0IGlzQ29sZFdhbGxldCA9ICEhXy5nZXQodGhpcy53YWxsZXQsICdfd2FsbGV0LmlzQ29sZCcpO1xuICAgIGNvbnN0IGlzT0ZDV2FsbGV0ID0gdGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKSA9PT0gJ29mYyc7IC8vIE9mZi1jaGFpbiB0cmFuc2FjdGlvbnMgZG9uJ3QgbmVlZCB0byBiZSByZWJ1aWx0XG4gICAgaWYgKCFwYXJhbXMueHBydiAmJiAhKHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlICYmICFpc0NvbGRXYWxsZXQgJiYgIWlzT0ZDV2FsbGV0KSkge1xuICAgICAgY2FuUmVjcmVhdGVUcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyByZWNpcGllbnRzLCB0aGVuIHRoZSB0cmFuc2FjdGlvbiBjYW5ub3QgYmUgcmVjcmVhdGVkXG4gICAgY29uc3QgcmVjaXBpZW50cyA9IHRoaXMuaW5mbygpPy50cmFuc2FjdGlvblJlcXVlc3Q/LmJ1aWxkUGFyYW1zPy5yZWNpcGllbnRzIHx8IFtdO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmluZm8oKT8udHJhbnNhY3Rpb25SZXF1ZXN0Py5idWlsZFBhcmFtcz8udHlwZTtcblxuICAgIC8vIFdlIG9ubHkgd2FudCB0byBub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb25zIHdpdGggbm8gcmVjaXBpZW50cyBpZiBpdCBpcyBhIFVUWE8gY29pbi5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGlmICh1dHhvbGliLmlzVmFsaWROZXR3b3JrKCh0aGlzLmJhc2VDb2luIGFzIGFueSkubmV0d29yaykgJiYgcmVjaXBpZW50cy5sZW5ndGggPT09IDAgJiYgdHlwZSAhPT0gJ2NvbnNvbGlkYXRlJykge1xuICAgICAgY2FuUmVjcmVhdGVUcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcblxuICAgIC8qXG4gICAgICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiB3aGljaCBpcyBiZWluZyBhcHByb3ZlZFxuICAgICAqL1xuICAgIGNvbnN0IGdldEFwcHJvdmFsVHJhbnNhY3Rpb24gPSBhc3luYyAoKTogUHJvbWlzZTx7IHR4SGV4OiBzdHJpbmcgfSB8IHVuZGVmaW5lZD4gPT4ge1xuICAgICAgaWYgKHRoaXMudHlwZSgpID09PSAndHJhbnNhY3Rpb25SZXF1ZXN0Jykge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJZiB0aGlzIGlzIGEgcmVxdWVzdCBmb3IgYXBwcm92aW5nIGEgdHJhbnNhY3Rpb24sIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoaXMgdXNlciBoYXMgYSBwcml2YXRlIGtleSB0byB0aGUgd2FsbGV0XG4gICAgICAgICAqIChzb21lIGFkbWlucyBtYXkgbm90IGhhdmUgdGhlIHNwZW5kIHBlcm1pc3Npb24pLCB0aGUgdHJhbnNhY3Rpb24gY291bGQgZWl0aGVyIGJlIHJlYnJvYWRjYXN0IGFzIGlzLCBvciBpdCBjb3VsZFxuICAgICAgICAgKiBiZSByZWNvbnN0cnVjdGVkLiBJdCBpcyBwcmVmZXJhYmxlIHRvIHJlY29uc3RydWN0IGEgdHggaW4gb3JkZXIgdG8gYWRoZXJlIHRvIHRoZSBsYXRlc3QgbmV0d29yayBjb25kaXRpb25zXG4gICAgICAgICAqIHN1Y2ggYXMgbmV3ZXIgdW5zcGVudHMsIGRpZmZlcmVudCBmZWVzLCBvciBhIGhpZ2hlciBzZXF1ZW5jZSBpZFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHBhcmFtcy50eCkge1xuICAgICAgICAgIC8vIHRoZSBhcHByb3ZhbCB0eCB3YXMgcmVjb25zdHJ1Y3RlZCBhbmQgZXhwbGljaXRseSBzcGVjaWZpZWQgLSBwYXNzIGl0IHRocm91Z2hcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhIZXg6IHBhcmFtcy50eCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBfLmdldCh0aGlzLmluZm8oKSwgYHRyYW5zYWN0aW9uUmVxdWVzdC5jb2luU3BlY2lmaWMuJHt0aGlzLmJhc2VDb2luLnR5cGV9YCkgYXMge1xuICAgICAgICAgIHR4SGV4OiBzdHJpbmc7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGhpcyB1c2VyIG1heSBub3QgaGF2ZSBzcGVuZGluZyBwcml2aWxlZ2VzIG9yIGEgcGFzc3BocmFzZSBtYXkgbm90IGhhdmUgYmVlbiBwYXNzZWQgaW5cbiAgICAgICAgaWYgKCFjYW5SZWNyZWF0ZVRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgaWYgKCFfLmlzT2JqZWN0KHRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGVyZSBpcyBuZWl0aGVyIGFuIG9yaWdpbmFsIHRyYW5zYWN0aW9uIG9iamVjdCBub3IgY2FuIGEgbmV3IG9uZSBiZSByZWNyZWF0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wb3B1bGF0ZVdhbGxldCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nQXBwcm92YWwudHhSZXF1ZXN0SWQpIHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWNyZWF0ZUFuZFNpZ25UU1NUcmFuc2FjdGlvbihwYXJhbXMsIHJlcUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWNyZWF0ZUFuZFNpZ25UcmFuc2FjdGlvbihwYXJhbXMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKlxuICAgICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBwcmVwYXJlIHRoZSBhcHByb3ZhbCBwYXlsb2FkIGFuZCBzZW5kIGl0IHRvIGJpdGdvXG4gICAgICovXG4gICAgY29uc3Qgc2VuZEFwcHJvdmFsID0gKHRyYW5zYWN0aW9uOiB7IHR4SGV4OiBzdHJpbmc7IGhhbGZTaWduZWQ/OiBzdHJpbmcgfSk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICBjb25zdCBhcHByb3ZhbFBhcmFtczogYW55ID0geyBzdGF0ZTogJ2FwcHJvdmVkJywgb3RwOiBwYXJhbXMub3RwIH07XG4gICAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gaWYgdGhlIHRyYW5zYWN0aW9uIGFscmVhZHkgaGFzIGEgaGFsZiBzaWduZWQgcHJvcGVydHksIHdlIHRha2UgdGhhdCBkaXJlY3RseVxuICAgICAgICBhcHByb3ZhbFBhcmFtcy5oYWxmU2lnbmVkID0gdHJhbnNhY3Rpb24uaGFsZlNpZ25lZCB8fCB0cmFuc2FjdGlvbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgICByZXR1cm4gdGhpcy5iaXRnby5wdXQodGhpcy51cmwoKSkuc2VuZChhcHByb3ZhbFBhcmFtcykucmVzdWx0KCk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhcHByb3ZhbFRyYW5zYWN0aW9uID0gKGF3YWl0IGdldEFwcHJvdmFsVHJhbnNhY3Rpb24oKSkgYXMgYW55O1xuICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHJlcUlkKTtcbiAgICAgIHJldHVybiBhd2FpdCBzZW5kQXBwcm92YWwoYXBwcm92YWxUcmFuc2FjdGlvbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKFxuICAgICAgICAhY2FuUmVjcmVhdGVUcmFuc2FjdGlvbiAmJlxuICAgICAgICAoZS5tZXNzYWdlLmluZGV4T2YoJ2NvdWxkIG5vdCBmaW5kIHVuc3BlbnQgb3V0cHV0IGZvciBpbnB1dCcpICE9PSAtMSB8fFxuICAgICAgICAgIGUubWVzc2FnZS5pbmRleE9mKCd0cmFuc2FjdGlvbiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyB0cmFuc2FjdGlvbiBpbiB0aGUgc2VuZCBxdWV1ZScpICE9PSAtMSlcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3BlbnRzIGV4cGlyZWQsIHdhbGxldCBwYXNzcGhyYXNlIG9yIHhwcnYgcmVxdWlyZWQgdG8gcmVjcmVhdGUgdHJhbnNhY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcyBQZW5kaW5nQXBwcm92YWwgdG8gYSByZWplY3RlZCBzdGF0ZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZWplY3QocGFyYW1zOiBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4gPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28ucHV0KHRoaXMudXJsKCkpLnNlbmQoeyBzdGF0ZTogJ3JlamVjdGVkJyB9KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGlhcyBmb3IgUGVuZGluZ0FwcHJvdmFsLnJlamVjdCgpXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGNhbmNlbChwYXJhbXM6IFJlY29yZDxzdHJpbmcsIG5ldmVyPiA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5yZWplY3QocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNyZWF0ZSBhbmQgc2lnbiBUU1MgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtBcHByb3ZlT3B0aW9uc30gcGFyYW1zIG5lZWRlZCB0byBnZXQgdHhzIGFuZCB1c2UgdGhlIHdhbGxldFBhc3NwaHJhc2UgdG8gdHNzIHNpZ25cbiAgICogQHBhcmFtIHtSZXF1ZXN0VHJhY2VyfSByZXFJZCBpZCB0cmFjZXIuXG4gICAqL1xuICBhc3luYyByZWNyZWF0ZUFuZFNpZ25UU1NUcmFuc2FjdGlvbihwYXJhbXM6IEFwcHJvdmVPcHRpb25zLCByZXFJZDogUmVxdWVzdFRyYWNlcik6IFByb21pc2U8eyB0eEhleDogc3RyaW5nIH0+IHtcbiAgICBjb25zdCB7IHdhbGxldFBhc3NwaHJhc2UgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eFJlcXVlc3RJZCA9IHRoaXMuX3BlbmRpbmdBcHByb3ZhbC50eFJlcXVlc3RJZDtcblxuICAgIGlmICghdGhpcy53YWxsZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FsbGV0IG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGlmICghd2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YWxsZXRQYXNzcGhyYXNlIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGlmICghdHhSZXF1ZXN0SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHhSZXF1ZXN0SWQgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjcnlwdGVkUHJ2ID0gYXdhaXQgdGhpcy53YWxsZXQuZ2V0UHJ2KHsgd2FsbGV0UGFzc3BocmFzZSB9KTtcbiAgICBjb25zdCB0eFJlcXVlc3QgPSBhd2FpdCB0aGlzLnRzc1V0aWxzLnJlY3JlYXRlVHhSZXF1ZXN0KHR4UmVxdWVzdElkLCBkZWNyeXB0ZWRQcnYsIHJlcUlkKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHhIZXg6IHR4UmVxdWVzdC51bnNpZ25lZFR4c1swXS5zZXJpYWxpemVkVHhIZXgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNyZWF0ZSBhIHRyYW5zYWN0aW9uIGZvciBhIHBlbmRpbmcgYXBwcm92YWwgdG8gcmVzcG9uZCB0byB1cGRhdGVkIG5ldHdvcmsgY29uZGl0aW9uc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZWNyZWF0ZUFuZFNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IGFueSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICAvLyB0aGlzIG1ldGhvZCBvbmx5IG1ha2VzIHNlbnNlIHdpdGggZXhpc3RpbmcgdHJhbnNhY3Rpb24gcmVxdWVzdHNcbiAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3QgPSB0aGlzLmluZm8oKS50cmFuc2FjdGlvblJlcXVlc3Q7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHJhbnNhY3Rpb25SZXF1ZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVjcmVhdGUgdHJhbnNhY3Rpb24gd2l0aG91dCB0cmFuc2FjdGlvbiByZXF1ZXN0Jyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodGhpcy53YWxsZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCByZWNyZWF0ZSB0cmFuc2FjdGlvbiB3aXRob3V0IHdhbGxldCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsUHJlYnVpbGQgPSB0cmFuc2FjdGlvblJlcXVlc3QuY29pblNwZWNpZmljW3RoaXMuYmFzZUNvaW4udHlwZV07XG5cbiAgICBjb25zdCByZWNpcGllbnRzID0gdHJhbnNhY3Rpb25SZXF1ZXN0LnJlY2lwaWVudHM7XG4gICAgY29uc3QgcHJlYnVpbGRQYXJhbXMgPSBfLmV4dGVuZCh7fSwgcGFyYW1zLCB7IHJlY2lwaWVudHM6IHJlY2lwaWVudHMgfSwgdHJhbnNhY3Rpb25SZXF1ZXN0LmJ1aWxkUGFyYW1zKTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChvcmlnaW5hbFByZWJ1aWxkLmhvcFRyYW5zYWN0aW9uKSkge1xuICAgICAgcHJlYnVpbGRQYXJhbXMuaG9wID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHJhbnNhY3Rpb25SZXF1ZXN0LmJ1aWxkUGFyYW1zICYmIHRyYW5zYWN0aW9uUmVxdWVzdC5idWlsZFBhcmFtcy50eXBlID09PSAnY29uc29saWRhdGUnKSB7XG4gICAgICAvLyBjb25zb2xpZGF0ZSB0YWcgaXMgaW4gdGhlIGJ1aWxkIHBhcmFtcyAtIHRoaXMgaXMgYSBjb25zb2xpZGF0aW9uIHRyYW5zYWN0aW9uLCBzb1xuICAgICAgLy8gaXQgbmVlZHMgdG8gYmUgcmVidWlsdCB1c2luZyB0aGUgc3BlY2lhbCBjb25zb2xpZGF0aW9uIGJ1aWxkIHJvdXRlXG4gICAgICBwcmVidWlsZFBhcmFtcy5wcmVidWlsZFR4ID0gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgICAucG9zdCh0aGlzLndhbGxldC51cmwoYC9jb25zb2xpZGF0ZVVuc3BlbnRzYCkpXG4gICAgICAgIC5zZW5kKHByZWJ1aWxkUGFyYW1zKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgICBkZWxldGUgcHJlYnVpbGRQYXJhbXMucmVjaXBpZW50cztcbiAgICB9XG5cbiAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMud2FsbGV0LnByZWJ1aWxkQW5kU2lnblRyYW5zYWN0aW9uKHByZWJ1aWxkUGFyYW1zKTtcbiAgICAvLyBjb21wYXJlIFBBWUdvIGZlZXNcbiAgICBjb25zdCBvcmlnaW5hbFBhcnNlZFRyYW5zYWN0aW9uID0gKGF3YWl0IHRoaXMuYmFzZUNvaW4ucGFyc2VUcmFuc2FjdGlvbih7XG4gICAgICB0eFBhcmFtczogcHJlYnVpbGRQYXJhbXMsXG4gICAgICB3YWxsZXQ6IHRoaXMud2FsbGV0LFxuICAgICAgdHhQcmVidWlsZDogb3JpZ2luYWxQcmVidWlsZCxcbiAgICB9KSkgYXMgYW55O1xuICAgIGNvbnN0IHJlY3JlYXRlZFBhcnNlZFRyYW5zYWN0aW9uID0gKGF3YWl0IHRoaXMuYmFzZUNvaW4ucGFyc2VUcmFuc2FjdGlvbih7XG4gICAgICB0eFBhcmFtczogcHJlYnVpbGRQYXJhbXMsXG4gICAgICB3YWxsZXQ6IHRoaXMud2FsbGV0LFxuICAgICAgdHhQcmVidWlsZDogc2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgfSkpIGFzIGFueTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHJlY3JlYXRlZFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudCkpIHtcbiAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgcmVjcmVhdGVkUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50ICE9PSAnYmlnaW50JyAmJlxuICAgICAgIV8uaXNGaW5pdGUocmVjcmVhdGVkUGFyc2VkVHJhbnNhY3Rpb24uaW1wbGljaXRFeHRlcm5hbFNwZW5kQW1vdW50KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbXBsaWNpdCBleHRlcm5hbCBzcGVuZCBhbW91bnQgY291bGQgbm90IGJlIGRldGVybWluZWQnKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIV8uaXNVbmRlZmluZWQob3JpZ2luYWxQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQpICYmXG4gICAgICByZWNyZWF0ZWRQYXJzZWRUcmFuc2FjdGlvbi5pbXBsaWNpdEV4dGVybmFsU3BlbmRBbW91bnQgPiBvcmlnaW5hbFBhcnNlZFRyYW5zYWN0aW9uLmltcGxpY2l0RXh0ZXJuYWxTcGVuZEFtb3VudFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNyZWF0ZWQgdHJhbnNhY3Rpb24gaXMgdXNpbmcgYSBoaWdoZXIgcGF5LWFzLXlvdS1nby1mZWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9uO1xuICB9XG59XG4iXX0=