"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCoin = void 0;
/**
 * @prettier
 */
const crypto = __importStar(require("crypto"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bignumber_js_1 = require("bignumber.js");
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const bip32util_1 = require("../bip32util");
const account_lib_1 = require("../../account-lib");
const enterprise_1 = require("../enterprise");
const keychain_1 = require("../keychain");
const market_1 = require("../market");
const pendingApproval_1 = require("../pendingApproval");
const wallet_1 = require("../wallet");
const webhook_1 = require("../webhook");
class BaseCoin {
    constructor(bitgo) {
        this.bitgo = bitgo;
        this._url = this.bitgo.url('/', 2);
        this._wallets = new wallet_1.Wallets(this.bitgo, this);
        this._keychains = new keychain_1.Keychains(this.bitgo, this);
        this._webhooks = new webhook_1.Webhooks(this.bitgo, this);
        this._pendingApprovals = new pendingApproval_1.PendingApprovals(this.bitgo, this);
        this._enterprises = new enterprise_1.Enterprises(this.bitgo, this);
        this._markets = new market_1.Markets(this.bitgo, this);
    }
    url(suffix) {
        return this._url + this.getChain() + suffix;
    }
    wallets() {
        return this._wallets;
    }
    enterprises() {
        return this._enterprises;
    }
    keychains() {
        return this._keychains;
    }
    webhooks() {
        return this._webhooks;
    }
    pendingApprovals() {
        return this._pendingApprovals;
    }
    markets() {
        return this._markets;
    }
    static get coinTokenPatternSeparator() {
        return this._coinTokenPatternSeparator;
    }
    get type() {
        return this.getChain();
    }
    /**
     * Flag for sending value of 0.
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return false;
    }
    /**
     * Use `sendMany()` to perform wallet sweep.
     * FIXME(BG-39738): add coin.sweepWallet() instead
     */
    sweepWithSendMany() {
        return false;
    }
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed() {
        return false;
    }
    /**
     * Flag for determining whether this coin supports account consolidations
     * from its receive addresses to the root address.
     * @returns {boolean} True if okay to consolidate over this coin; false, otherwise
     */
    allowsAccountConsolidations() {
        return false;
    }
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: false,
            supportsMultipleTokenEnablements: false,
        };
    }
    /**
     * Flag indicating if this coin supports TSS wallets.
     * @returns {boolean} True if TSS Wallets can be created for this coin
     */
    supportsTss() {
        return false;
    }
    /**
     * Flag indicating if this blockchain runs on EVM architecture.
     * @returns {boolean} True if the blockchain runs on EVM architecture.
     */
    isEVM() {
        return false;
    }
    /**
     * Flag indicating if this coin supports BLS-DKG wallets.
     * @returns {boolean} True if BLS-DKG Wallets can be created for this coin
     */
    supportsBlsDkg() {
        return false;
    }
    /**
     * Convert a currency amount represented in base units (satoshi, wei, atoms, drops, stroops)
     * to big units (btc, eth, xrp, xlm)
     */
    baseUnitsToBigUnits(baseUnits) {
        bignumber_js_1.BigNumber.set({ DECIMAL_PLACES: 24 });
        const dividend = this.getBaseFactor();
        const bigNumber = new bignumber_js_1.BigNumber(baseUnits).dividedBy(dividend);
        // set the format so commas aren't added to large coin amounts
        return bigNumber.toFormat(null, null, { groupSeparator: '', decimalSeparator: '.' });
    }
    /**
     * Convert a currency amount represented in big units (btc, eth, xrp, xlm)
     * to base units (satoshi, wei, atoms, drops, stroops)
     * @param bigUnits
     */
    bigUnitsToBaseUnits(bigUnits) {
        const multiplier = this.getBaseFactor();
        const bigNumber = new bignumber_js_1.BigNumber(bigUnits).times(multiplier);
        if (!bigNumber.isInteger()) {
            throw new Error(`non-integer output resulted from multiplying ${bigUnits} by ${multiplier}`);
        }
        return bigNumber.toFixed(0);
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        return bip32util_1.signMessage(message, utxo_lib_1.bip32.fromBase58(key.prv), utxolib.networks.bitcoin);
    }
    /**
     * Create signatures for the backup and bitgo keys using the user key.
     * We can verify the signatures when fetching the keys from wallet-platform later.
     * Currently only `AbstractUtxoCoin` implements and uses the complementary `verifyKeySignature` method.
     * @param prv - the user private key
     * @param backupKeychain - contains the backup public key
     * @param bitgoKeychain - contains the bitgo public key
     */
    async createKeySignatures(prv, backupKeychain, bitgoKeychain) {
        return {
            backup: (await this.signMessage({ prv }, backupKeychain.pub)).toString('hex'),
            bitgo: (await this.signMessage({ prv }, bitgoKeychain.pub)).toString('hex'),
        };
    }
    /**
     * Decompose a raw transaction into useful information.
     * @param options - coin-specific
     */
    explainTransaction(options) {
        throw new Error(`not implemented`);
    }
    /**
     * @deprecated use {@see isWalletAddress} instead
     */
    verifyAddress(params) {
        return this.isWalletAddress(params);
    }
    /**
     * convert address into desired address format.
     * @param address
     * @param format
     */
    canonicalAddress(address, format) {
        return address;
    }
    /**
     * Check whether a coin supports blockTarget for transactions to be included in
     * @returns {boolean}
     */
    supportsBlockTarget() {
        return false;
    }
    /**
     * Check whether a coin supports lightning transactions
     * @returns {boolean}
     */
    supportsLightning() {
        return false;
    }
    /**
     * Check whether a coin supports message signing
     * @returns {boolean}
     */
    supportsMessageSigning() {
        return false;
    }
    /**
     * Check whether a coin supports signing of Typed data
     * @returns {boolean}
     */
    supportsSigningTypedData() {
        return false;
    }
    /**
     * Hook to add additional parameters to the wallet generation
     * @param walletParams
     * @param keychains
     * @return {*}
     */
    supplementGenerateWallet(walletParams, keychains) {
        return Promise.resolve(walletParams);
    }
    /**
     * Get extra parameters for prebuilding a tx. Add things like hop transaction params
     */
    getExtraPrebuildParams(buildParams) {
        return Promise.resolve({});
    }
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    postProcessPrebuild(prebuildResponse) {
        return Promise.resolve(prebuildResponse);
    }
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     */
    presignTransaction(params) {
        return Promise.resolve(params);
    }
    /**
     * Create a new wallet object from a wallet data object
     * @param walletParams
     */
    newWalletObject(walletParams) {
        return new wallet_1.Wallet(this.bitgo, this, walletParams);
    }
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Integer} params.numBlocks The number of blocks to target for conformation (Only works for btc)
     * @returns {Object} The info returned from the merchant server
     */
    async feeEstimate(params) {
        const query = {};
        if (params && params.numBlocks) {
            query.numBlocks = params.numBlocks;
        }
        return this.bitgo.get(this.url('/tx/fee')).query(query).result();
    }
    /**
     * The cold wallet tool uses this function to derive an extended key that is based on the passed key and seed
     * @param key
     * @param seed
     * @returns {{key: string, derivationPath: string}}
     */
    deriveKeyWithSeed({ key, seed }) {
        function sha256(input) {
            return crypto.createHash('sha256').update(input).digest();
        }
        const derivationPathInput = sha256(sha256(`${seed}`)).toString('hex');
        const derivationPathParts = [
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        const derivationPath = 'm/999999/' + derivationPathParts.join('/');
        const keyNode = utxo_lib_1.bip32.fromBase58(key);
        const derivedKeyNode = keyNode.derivePath(derivationPath);
        return {
            key: derivedKeyNode.toBase58(),
            derivationPath: derivationPath,
        };
    }
    /**
     * Specifies what key we will need for signing - right now we just need the
     * user key.
     */
    keyIdsForSigning() {
        return [keychain_1.KeyIndices.USER];
    }
    /**
     * Perform additional checks before adding a bitgo key. Base controller
     * is a no-op, but coin-specific controller may do something
     * @param params
     */
    preCreateBitGo(params) {
        return;
    }
    /**
     * @deprecated - use getBip32Keys() in conjunction with isValidAddress instead
     */
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Return wether the given m of n wallet signers/ key amounts are valid for the coin
     */
    isValidMofNSetup({ m, n }) {
        return m === 2 && n === 3;
    }
    /**
     * Returns the portion of the transaction that needs to be signed in Buffer format.
     * Only needed for coins that support adding signatures directly (e.g. TSS).
     *
     * @param {String} serializedTx - the unsigned transaction in broadcast format
     * @returns {Promise<Buffer>} - the portion of the transaction that needs to be signed
     */
    async getSignablePayload(serializedTx) {
        return Buffer.from(serializedTx);
    }
    /**
     * Returns the MPC algorithm (ecdsa or eddsa) used for coins that support TSS
     */
    getMPCAlgorithm() {
        throw new Error('no MPC algorithm is defined for this coin');
    }
    async recoverToken(params) {
        throw new account_lib_1.NotImplementedError('recoverToken is not supported for this coin');
    }
    getInscriptionBuilder(wallet) {
        throw new account_lib_1.NotImplementedError('Inscription Builder is not supported for this coin');
    }
    /**
     * Function to get coin specific hash function used to generate transaction digests.
     * @returns {@see Hash} hash function if implemented, otherwise throws exception
     */
    getHashFunction() {
        throw new account_lib_1.NotImplementedError('getHashFunction is not supported for this coin');
    }
}
exports.BaseCoin = BaseCoin;
BaseCoin._coinTokenPatternSeparator = ':';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZUNvaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYml0Z28vYmFzZUNvaW4vYmFzZUNvaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsK0NBQWlDO0FBQ2pDLDhDQUF3QztBQUN4QywrQ0FBeUM7QUFFekMseURBQTJDO0FBRzNDLDRDQUEyQztBQUMzQyxtREFBd0Q7QUFFeEQsOENBQTRDO0FBQzVDLDBDQUFvRDtBQUNwRCxzQ0FBb0M7QUFDcEMsd0RBQXNEO0FBQ3RELHNDQUFxRDtBQUNyRCx3Q0FBc0M7QUEwQnRDLE1BQXNCLFFBQVE7SUFXNUIsWUFBc0IsS0FBZ0I7UUFDcEMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGdCQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksb0JBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxrQkFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksa0NBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUNoRSxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksd0JBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3RELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxnQkFBTyxDQUFD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QUUsQ0FBQyxFQUFFLENBQUMsRUFBOEI7UUFDbkQsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUIsQ0FBQztJQWdCRDs7Ozs7O09BTUc7SUFDSCxLQUFLLENBQUMsa0JBQWtCLENBQUMsWUFBb0I7UUFDM0MsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7T0FFRztJQUNILGVBQWU7UUFDYixNQUFNLElBQUksS0FBSyxDQUFDLDJDQUEyQyxDQUFDLENBQUM7SUFDL0QsQ0FBQztJQUVELEtBQUssQ0FBQyxZQUFZLENBQUMsTUFBaUM7UUFDbEQsTUFBTSxJQUFJLGlDQUFtQixDQUFDLDZDQUE2QyxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVELHFCQUFxQixDQUFDLE1BQWM7UUFDbEMsTUFBTSxJQUFJLGlDQUFtQixDQUFDLG9EQUFvRCxDQUFDLENBQUM7SUFDdEYsQ0FBQztJQUVEOzs7T0FHRztJQUNILGVBQWU7UUFDYixNQUFNLElBQUksaUNBQW1CLENBQUMsZ0RBQWdELENBQUMsQ0FBQztJQUNsRixDQUFDOztBQWxjSCw0QkFtY0M7QUExYjJCLG1DQUEwQixHQUFHLEdBQUcsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgYmlwMzIgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcblxuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuXG5pbXBvcnQgeyBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyB9IGZyb20gJy4uL3JlY292ZXJ5JztcbmltcG9ydCB7IHNpZ25NZXNzYWdlIH0gZnJvbSAnLi4vYmlwMzJ1dGlsJztcbmltcG9ydCB7IE5vdEltcGxlbWVudGVkRXJyb3IgfSBmcm9tICcuLi8uLi9hY2NvdW50LWxpYic7XG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IHsgRW50ZXJwcmlzZXMgfSBmcm9tICcuLi9lbnRlcnByaXNlJztcbmltcG9ydCB7IEtleWNoYWlucywgS2V5SW5kaWNlcyB9IGZyb20gJy4uL2tleWNoYWluJztcbmltcG9ydCB7IE1hcmtldHMgfSBmcm9tICcuLi9tYXJrZXQnO1xuaW1wb3J0IHsgUGVuZGluZ0FwcHJvdmFscyB9IGZyb20gJy4uL3BlbmRpbmdBcHByb3ZhbCc7XG5pbXBvcnQgeyBXYWxsZXRzLCBJV2FsbGV0LCBXYWxsZXQgfSBmcm9tICcuLi93YWxsZXQnO1xuaW1wb3J0IHsgV2ViaG9va3MgfSBmcm9tICcuLi93ZWJob29rJztcbmltcG9ydCB7XG4gIEV4dHJhUHJlYnVpbGRQYXJhbXNPcHRpb25zLFxuICBGZWVFc3RpbWF0ZU9wdGlvbnMsXG4gIElCYXNlQ29pbixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIElUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBLZXljaGFpbnNUcmlwbGV0LFxuICBLZXlQYWlyLFxuICBNUENBbGdvcml0aG0sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBQcmVjcmVhdGVCaXRHb09wdGlvbnMsXG4gIFByZXNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFJlY292ZXJUb2tlblRyYW5zYWN0aW9uLFxuICBSZWNvdmVyV2FsbGV0VG9rZW5PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyxcbiAgVG9rZW5FbmFibGVtZW50Q29uZmlnLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxufSBmcm9tICcuL2lCYXNlQ29pbic7XG5pbXBvcnQgeyBJSW5zY3JpcHRpb25CdWlsZGVyIH0gZnJvbSAnLi4vaW5zY3JpcHRpb25CdWlsZGVyJztcbmltcG9ydCB7IEhhc2ggfSBmcm9tICdjcnlwdG8nO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNvaW4gaW1wbGVtZW50cyBJQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYml0Z286IEJpdEdvQmFzZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF91cmw6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9lbnRlcnByaXNlczogRW50ZXJwcmlzZXM7XG4gIHByb3RlY3RlZCByZWFkb25seSBfd2FsbGV0czogV2FsbGV0cztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9rZXljaGFpbnM6IEtleWNoYWlucztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF93ZWJob29rczogV2ViaG9va3M7XG4gIHByb3RlY3RlZCByZWFkb25seSBfcGVuZGluZ0FwcHJvdmFsczogUGVuZGluZ0FwcHJvdmFscztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9tYXJrZXRzOiBNYXJrZXRzO1xuICBwcm90ZWN0ZWQgc3RhdGljIHJlYWRvbmx5IF9jb2luVG9rZW5QYXR0ZXJuU2VwYXJhdG9yID0gJzonO1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlKSB7XG4gICAgdGhpcy5iaXRnbyA9IGJpdGdvO1xuICAgIHRoaXMuX3VybCA9IHRoaXMuYml0Z28udXJsKCcvJywgMik7XG4gICAgdGhpcy5fd2FsbGV0cyA9IG5ldyBXYWxsZXRzKHRoaXMuYml0Z28sIHRoaXMpO1xuICAgIHRoaXMuX2tleWNoYWlucyA9IG5ldyBLZXljaGFpbnModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fd2ViaG9va3MgPSBuZXcgV2ViaG9va3ModGhpcy5iaXRnbywgdGhpcyk7XG4gICAgdGhpcy5fcGVuZGluZ0FwcHJvdmFscyA9IG5ldyBQZW5kaW5nQXBwcm92YWxzKHRoaXMuYml0Z28sIHRoaXMpO1xuICAgIHRoaXMuX2VudGVycHJpc2VzID0gbmV3IEVudGVycHJpc2VzKHRoaXMuYml0Z28sIHRoaXMpO1xuICAgIHRoaXMuX21hcmtldHMgPSBuZXcgTWFya2V0cyh0aGlzLmJpdGdvLCB0aGlzKTtcbiAgfVxuXG4gIHB1YmxpYyB1cmwoc3VmZml4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl91cmwgKyB0aGlzLmdldENoYWluKCkgKyBzdWZmaXg7XG4gIH1cblxuICBwdWJsaWMgd2FsbGV0cygpOiBXYWxsZXRzIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0cztcbiAgfVxuXG4gIHB1YmxpYyBlbnRlcnByaXNlcygpOiBFbnRlcnByaXNlcyB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGVycHJpc2VzO1xuICB9XG5cbiAgcHVibGljIGtleWNoYWlucygpOiBLZXljaGFpbnMge1xuICAgIHJldHVybiB0aGlzLl9rZXljaGFpbnM7XG4gIH1cblxuICBwdWJsaWMgd2ViaG9va3MoKTogV2ViaG9va3Mge1xuICAgIHJldHVybiB0aGlzLl93ZWJob29rcztcbiAgfVxuXG4gIHB1YmxpYyBwZW5kaW5nQXBwcm92YWxzKCk6IFBlbmRpbmdBcHByb3ZhbHMge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWxzO1xuICB9XG5cbiAgcHVibGljIG1hcmtldHMoKTogTWFya2V0cyB7XG4gICAgcmV0dXJuIHRoaXMuX21hcmtldHM7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGdldCBjb2luVG9rZW5QYXR0ZXJuU2VwYXJhdG9yKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3I7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDaGFpbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGNoYWluIHdoaWNoIHN1cHBvcnRzIHRoaXMgY29pbiAoZWcsICdidGMnLCAnZXRoJylcbiAgICovXG4gIGFic3RyYWN0IGdldENoYWluKCk6IHN0cmluZztcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgY29pbiBmYW1pbHkgKGVnLiBmb3IgdGJ0YywgdGhpcyB3b3VsZCBiZSBidGMpXG4gICAqL1xuICBhYnN0cmFjdCBnZXRGYW1pbHkoKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBIdW1hbiByZWFkYWJsZSBmdWxsIG5hbWUgZm9yIHRoZSBjb2luXG4gICAqL1xuICBhYnN0cmFjdCBnZXRGdWxsTmFtZSgpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgdmFsdWUgb2YgMC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgYHNlbmRNYW55KClgIHRvIHBlcmZvcm0gd2FsbGV0IHN3ZWVwLlxuICAgKiBGSVhNRShCRy0zOTczOCk6IGFkZCBjb2luLnN3ZWVwV2FsbGV0KCkgaW5zdGVhZFxuICAgKi9cbiAgc3dlZXBXaXRoU2VuZE1hbnkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgZm9yIHNlbmRpbmcgZGF0YSBhbG9uZyB3aXRoIHRyYW5zYWN0aW9uc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBva2F5IHRvIHNlbmQgdHggZGF0YSAoRVRIKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICB0cmFuc2FjdGlvbkRhdGFBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoaXMgY29pbiBzdXBwb3J0cyBhY2NvdW50IGNvbnNvbGlkYXRpb25zXG4gICAqIGZyb20gaXRzIHJlY2VpdmUgYWRkcmVzc2VzIHRvIHRoZSByb290IGFkZHJlc3MuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gY29uc29saWRhdGUgb3ZlciB0aGlzIGNvaW47IGZhbHNlLCBvdGhlcndpc2VcbiAgICovXG4gIGFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjb25maWcgZm9yIGhvdyB0b2tlbiBlbmFibGVtZW50cyB3b3JrIGZvciB0aGlzIGNvaW5cbiAgICogQHJldHVybnNcbiAgICogICAgcmVxdWlyZXNUb2tlbkVuYWJsZW1lbnQ6IFRydWUgaWYgdG9rZW5zIG5lZWQgdG8gYmUgZW5hYmxlZCBmb3IgdGhpcyBjb2luXG4gICAqICAgIHN1cHBvcnRzTXVsdGlwbGVUb2tlbkVuYWJsZW1lbnRzOiBUcnVlIGlmIG11bHRpcGxlIHRva2VucyBjYW4gYmUgZW5hYmxlZCBpbiBvbmUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldFRva2VuRW5hYmxlbWVudENvbmZpZygpOiBUb2tlbkVuYWJsZW1lbnRDb25maWcge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlc1Rva2VuRW5hYmxlbWVudDogZmFsc2UsXG4gICAgICBzdXBwb3J0c011bHRpcGxlVG9rZW5FbmFibGVtZW50czogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBjb2luIHN1cHBvcnRzIFRTUyB3YWxsZXRzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBUU1MgV2FsbGV0cyBjYW4gYmUgY3JlYXRlZCBmb3IgdGhpcyBjb2luXG4gICAqL1xuICBzdXBwb3J0c1RzcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgYmxvY2tjaGFpbiBydW5zIG9uIEVWTSBhcmNoaXRlY3R1cmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBibG9ja2NoYWluIHJ1bnMgb24gRVZNIGFyY2hpdGVjdHVyZS5cbiAgICovXG4gIGlzRVZNKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBjb2luIHN1cHBvcnRzIEJMUy1ES0cgd2FsbGV0cy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgQkxTLURLRyBXYWxsZXRzIGNhbiBiZSBjcmVhdGVkIGZvciB0aGlzIGNvaW5cbiAgICovXG4gIHN1cHBvcnRzQmxzRGtnKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmYWN0b3IgYmV0d2VlbiB0aGUgYmFzZSB1bml0IGFuZCBpdHMgc21hbGxlc3Qgc3ViZGl2aXNvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBhYnN0cmFjdCBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB8IHN0cmluZztcblxuICAvKipcbiAgICogQ29udmVydCBhIGN1cnJlbmN5IGFtb3VudCByZXByZXNlbnRlZCBpbiBiYXNlIHVuaXRzIChzYXRvc2hpLCB3ZWksIGF0b21zLCBkcm9wcywgc3Ryb29wcylcbiAgICogdG8gYmlnIHVuaXRzIChidGMsIGV0aCwgeHJwLCB4bG0pXG4gICAqL1xuICBiYXNlVW5pdHNUb0JpZ1VuaXRzKGJhc2VVbml0czogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgICBCaWdOdW1iZXIuc2V0KHsgREVDSU1BTF9QTEFDRVM6IDI0IH0pO1xuICAgIGNvbnN0IGRpdmlkZW5kID0gdGhpcy5nZXRCYXNlRmFjdG9yKCk7XG4gICAgY29uc3QgYmlnTnVtYmVyID0gbmV3IEJpZ051bWJlcihiYXNlVW5pdHMpLmRpdmlkZWRCeShkaXZpZGVuZCk7XG4gICAgLy8gc2V0IHRoZSBmb3JtYXQgc28gY29tbWFzIGFyZW4ndCBhZGRlZCB0byBsYXJnZSBjb2luIGFtb3VudHNcbiAgICByZXR1cm4gYmlnTnVtYmVyLnRvRm9ybWF0KG51bGwgYXMgYW55LCBudWxsIGFzIGFueSwgeyBncm91cFNlcGFyYXRvcjogJycsIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgY3VycmVuY3kgYW1vdW50IHJlcHJlc2VudGVkIGluIGJpZyB1bml0cyAoYnRjLCBldGgsIHhycCwgeGxtKVxuICAgKiB0byBiYXNlIHVuaXRzIChzYXRvc2hpLCB3ZWksIGF0b21zLCBkcm9wcywgc3Ryb29wcylcbiAgICogQHBhcmFtIGJpZ1VuaXRzXG4gICAqL1xuICBiaWdVbml0c1RvQmFzZVVuaXRzKGJpZ1VuaXRzOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IG11bHRpcGxpZXIgPSB0aGlzLmdldEJhc2VGYWN0b3IoKTtcbiAgICBjb25zdCBiaWdOdW1iZXIgPSBuZXcgQmlnTnVtYmVyKGJpZ1VuaXRzKS50aW1lcyhtdWx0aXBsaWVyKTtcbiAgICBpZiAoIWJpZ051bWJlci5pc0ludGVnZXIoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBub24taW50ZWdlciBvdXRwdXQgcmVzdWx0ZWQgZnJvbSBtdWx0aXBseWluZyAke2JpZ1VuaXRzfSBieSAke211bHRpcGxpZXJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBiaWdOdW1iZXIudG9GaXhlZCgwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIG1lc3NhZ2Ugd2l0aCBwcml2YXRlIGtleVxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqL1xuICBhc3luYyBzaWduTWVzc2FnZShrZXk6IHsgcHJ2OiBzdHJpbmcgfSwgbWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICByZXR1cm4gc2lnbk1lc3NhZ2UobWVzc2FnZSwgYmlwMzIuZnJvbUJhc2U1OChrZXkucHJ2KSwgdXR4b2xpYi5uZXR3b3Jrcy5iaXRjb2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgc2lnbmF0dXJlcyBmb3IgdGhlIGJhY2t1cCBhbmQgYml0Z28ga2V5cyB1c2luZyB0aGUgdXNlciBrZXkuXG4gICAqIFdlIGNhbiB2ZXJpZnkgdGhlIHNpZ25hdHVyZXMgd2hlbiBmZXRjaGluZyB0aGUga2V5cyBmcm9tIHdhbGxldC1wbGF0Zm9ybSBsYXRlci5cbiAgICogQ3VycmVudGx5IG9ubHkgYEFic3RyYWN0VXR4b0NvaW5gIGltcGxlbWVudHMgYW5kIHVzZXMgdGhlIGNvbXBsZW1lbnRhcnkgYHZlcmlmeUtleVNpZ25hdHVyZWAgbWV0aG9kLlxuICAgKiBAcGFyYW0gcHJ2IC0gdGhlIHVzZXIgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIGJhY2t1cEtleWNoYWluIC0gY29udGFpbnMgdGhlIGJhY2t1cCBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBiaXRnb0tleWNoYWluIC0gY29udGFpbnMgdGhlIGJpdGdvIHB1YmxpYyBrZXlcbiAgICovXG4gIHB1YmxpYyBhc3luYyBjcmVhdGVLZXlTaWduYXR1cmVzKFxuICAgIHBydjogc3RyaW5nLFxuICAgIGJhY2t1cEtleWNoYWluOiB7IHB1Yjogc3RyaW5nIH0sXG4gICAgYml0Z29LZXljaGFpbjogeyBwdWI6IHN0cmluZyB9XG4gICk6IFByb21pc2U8e1xuICAgIGJhY2t1cDogc3RyaW5nO1xuICAgIGJpdGdvOiBzdHJpbmc7XG4gIH0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFja3VwOiAoYXdhaXQgdGhpcy5zaWduTWVzc2FnZSh7IHBydiB9LCBiYWNrdXBLZXljaGFpbi5wdWIpKS50b1N0cmluZygnaGV4JyksXG4gICAgICBiaXRnbzogKGF3YWl0IHRoaXMuc2lnbk1lc3NhZ2UoeyBwcnYgfSwgYml0Z29LZXljaGFpbi5wdWIpKS50b1N0cmluZygnaGV4JyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXBvc2UgYSByYXcgdHJhbnNhY3Rpb24gaW50byB1c2VmdWwgaW5mb3JtYXRpb24uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gY29pbi1zcGVjaWZpY1xuICAgKi9cbiAgZXhwbGFpblRyYW5zYWN0aW9uKG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBQcm9taXNlPElUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPGFueSwgc3RyaW5nIHwgbnVtYmVyPiB8IHVuZGVmaW5lZD4ge1xuICAgIHRocm93IG5ldyBFcnJvcihgbm90IGltcGxlbWVudGVkYCk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBjb21wbGllcyB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICovXG4gIGFic3RyYWN0IHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHtAc2VlIGlzV2FsbGV0QWRkcmVzc30gaW5zdGVhZFxuICAgKi9cbiAgdmVyaWZ5QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuaXNXYWxsZXRBZGRyZXNzKHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJuIHRydWUgaWZmIGFkZHJlc3MgaXMgYSB3YWxsZXQgYWRkcmVzcy4gTXVzdCByZXR1cm4gZmFsc2UgaWYgYWRkcmVzcyBpcyBvdXRzaWRlIHdhbGxldC5cbiAgICovXG4gIGFic3RyYWN0IGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPjtcblxuICAvKipcbiAgICogY29udmVydCBhZGRyZXNzIGludG8gZGVzaXJlZCBhZGRyZXNzIGZvcm1hdC5cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICogQHBhcmFtIGZvcm1hdFxuICAgKi9cbiAgY2Fub25pY2FsQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcsIGZvcm1hdD86IHVua25vd24pOiBzdHJpbmcge1xuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYSBjb2luIHN1cHBvcnRzIGJsb2NrVGFyZ2V0IGZvciB0cmFuc2FjdGlvbnMgdG8gYmUgaW5jbHVkZWQgaW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBzdXBwb3J0c0Jsb2NrVGFyZ2V0KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGEgY29pbiBzdXBwb3J0cyBsaWdodG5pbmcgdHJhbnNhY3Rpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3VwcG9ydHNMaWdodG5pbmcoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYSBjb2luIHN1cHBvcnRzIG1lc3NhZ2Ugc2lnbmluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN1cHBvcnRzTWVzc2FnZVNpZ25pbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgYSBjb2luIHN1cHBvcnRzIHNpZ25pbmcgb2YgVHlwZWQgZGF0YVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN1cHBvcnRzU2lnbmluZ1R5cGVkRGF0YSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSG9vayB0byBhZGQgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIHRoZSB3YWxsZXQgZ2VuZXJhdGlvblxuICAgKiBAcGFyYW0gd2FsbGV0UGFyYW1zXG4gICAqIEBwYXJhbSBrZXljaGFpbnNcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMsIGtleWNoYWluczogS2V5Y2hhaW5zVHJpcGxldCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh3YWxsZXRQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBleHRyYSBwYXJhbWV0ZXJzIGZvciBwcmVidWlsZGluZyBhIHR4LiBBZGQgdGhpbmdzIGxpa2UgaG9wIHRyYW5zYWN0aW9uIHBhcmFtc1xuICAgKi9cbiAgZ2V0RXh0cmFQcmVidWlsZFBhcmFtcyhidWlsZFBhcmFtczogRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZ5IHByZWJ1aWxkIGFmdGVyIHJlY2VpdmluZyBpdCBmcm9tIHRoZSBzZXJ2ZXIuIEFkZCB0aGluZ3MgbGlrZSBubG9ja3RpbWVcbiAgICovXG4gIHBvc3RQcm9jZXNzUHJlYnVpbGQocHJlYnVpbGRSZXNwb25zZTogVHJhbnNhY3Rpb25QcmVidWlsZCk6IFByb21pc2U8VHJhbnNhY3Rpb25QcmVidWlsZD4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJlYnVpbGRSZXNwb25zZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29pbi1zcGVjaWZpYyB0aGluZ3MgZG9uZSBiZWZvcmUgc2lnbmluZyBhIHRyYW5zYWN0aW9uLCBpLmUuIHZlcmlmaWNhdGlvblxuICAgKi9cbiAgcHJlc2lnblRyYW5zYWN0aW9uKHBhcmFtczogUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8UHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucz4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgd2FsbGV0IG9iamVjdCBmcm9tIGEgd2FsbGV0IGRhdGEgb2JqZWN0XG4gICAqIEBwYXJhbSB3YWxsZXRQYXJhbXNcbiAgICovXG4gIG5ld1dhbGxldE9iamVjdCh3YWxsZXRQYXJhbXM6IGFueSk6IElXYWxsZXQge1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMsIHdhbGxldFBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggZmVlIGVzdGltYXRlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZlclxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoZSBwYXJhbXMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gcGFyYW1zLm51bUJsb2NrcyBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0byB0YXJnZXQgZm9yIGNvbmZvcm1hdGlvbiAoT25seSB3b3JrcyBmb3IgYnRjKVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaW5mbyByZXR1cm5lZCBmcm9tIHRoZSBtZXJjaGFudCBzZXJ2ZXJcbiAgICovXG4gIGFzeW5jIGZlZUVzdGltYXRlKHBhcmFtczogRmVlRXN0aW1hdGVPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBxdWVyeTogYW55ID0ge307XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMubnVtQmxvY2tzKSB7XG4gICAgICBxdWVyeS5udW1CbG9ja3MgPSBwYXJhbXMubnVtQmxvY2tzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLnVybCgnL3R4L2ZlZScpKS5xdWVyeShxdWVyeSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbGQgd2FsbGV0IHRvb2wgdXNlcyB0aGlzIGZ1bmN0aW9uIHRvIGRlcml2ZSBhbiBleHRlbmRlZCBrZXkgdGhhdCBpcyBiYXNlZCBvbiB0aGUgcGFzc2VkIGtleSBhbmQgc2VlZFxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHt7a2V5OiBzdHJpbmcsIGRlcml2YXRpb25QYXRoOiBzdHJpbmd9fVxuICAgKi9cbiAgZGVyaXZlS2V5V2l0aFNlZWQoeyBrZXksIHNlZWQgfTogeyBrZXk6IHN0cmluZzsgc2VlZDogc3RyaW5nIH0pOiB7IGtleTogc3RyaW5nOyBkZXJpdmF0aW9uUGF0aDogc3RyaW5nIH0ge1xuICAgIGZ1bmN0aW9uIHNoYTI1NihpbnB1dCkge1xuICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaW5wdXQpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aElucHV0ID0gc2hhMjU2KHNoYTI1NihgJHtzZWVkfWApKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGhQYXJ0cyA9IFtcbiAgICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoMCwgNyksIDE2KSxcbiAgICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoNywgMTQpLCAxNiksXG4gICAgXTtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9ICdtLzk5OTk5OS8nICsgZGVyaXZhdGlvblBhdGhQYXJ0cy5qb2luKCcvJyk7XG4gICAgY29uc3Qga2V5Tm9kZSA9IGJpcDMyLmZyb21CYXNlNTgoa2V5KTtcbiAgICBjb25zdCBkZXJpdmVkS2V5Tm9kZSA9IGtleU5vZGUuZGVyaXZlUGF0aChkZXJpdmF0aW9uUGF0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZGVyaXZlZEtleU5vZGUudG9CYXNlNTgoKSxcbiAgICAgIGRlcml2YXRpb25QYXRoOiBkZXJpdmF0aW9uUGF0aCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGF0IGtleSB3ZSB3aWxsIG5lZWQgZm9yIHNpZ25pbmcgLSByaWdodCBub3cgd2UganVzdCBuZWVkIHRoZVxuICAgKiB1c2VyIGtleS5cbiAgICovXG4gIGtleUlkc0ZvclNpZ25pbmcoKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBbS2V5SW5kaWNlcy5VU0VSXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFkZGl0aW9uYWwgY2hlY2tzIGJlZm9yZSBhZGRpbmcgYSBiaXRnbyBrZXkuIEJhc2UgY29udHJvbGxlclxuICAgKiBpcyBhIG5vLW9wLCBidXQgY29pbi1zcGVjaWZpYyBjb250cm9sbGVyIG1heSBkbyBzb21ldGhpbmdcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgcHJlQ3JlYXRlQml0R28ocGFyYW1zOiBQcmVjcmVhdGVCaXRHb09wdGlvbnMpOiB2b2lkIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgLSB1c2UgZ2V0QmlwMzJLZXlzKCkgaW4gY29uanVuY3Rpb24gd2l0aCBpc1ZhbGlkQWRkcmVzcyBpbnN0ZWFkXG4gICAqL1xuICBpbml0aWF0ZVJlY292ZXJ5KHBhcmFtczogSW5pdGlhdGVSZWNvdmVyeU9wdGlvbnMpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZXByZWNhdGVkIG1ldGhvZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgdXNlZCBpbiBQZW5kaW5nQXBwcm92YWwgZm9yIGNvbXBhcmluZyBQQVlHbyBmZWVzIHB1cnBvc2VcbiAgICogQHBhcmFtIHBhcmFtcyBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqL1xuICBhYnN0cmFjdCBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPjtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXkgcGFpciBvbiB0aGUgY3VydmUgdXNlZCBieSB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKi9cbiAgYWJzdHJhY3QgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGFic3RyYWN0IGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2V0aGVyIHRoZSBnaXZlbiBtIG9mIG4gd2FsbGV0IHNpZ25lcnMvIGtleSBhbW91bnRzIGFyZSB2YWxpZCBmb3IgdGhlIGNvaW5cbiAgICovXG4gIGlzVmFsaWRNb2ZOU2V0dXAoeyBtLCBuIH06IHsgbT86IG51bWJlcjsgbj86IG51bWJlciB9KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG0gPT09IDIgJiYgbiA9PT0gMztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBgYWRkcmVzc2AgaXMgYSBwbGF1c2libHkgdmFsaWQgYWRkcmVzcyBmb3IgdGhlIGdpdmVuIGNvaW4uXG4gICAqXG4gICAqIERvZXMgbm90IHZlcmlmeSB0aGF0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8gYSB3YWxsZXQuIEZvciB0aGF0LFxuICAgKiB1c2UgW1t2ZXJpZnlBZGRyZXNzXV1cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGFic3RyYWN0IGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNpZ24gYSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYWJzdHJhY3Qgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwb3J0aW9uIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGF0IG5lZWRzIHRvIGJlIHNpZ25lZCBpbiBCdWZmZXIgZm9ybWF0LlxuICAgKiBPbmx5IG5lZWRlZCBmb3IgY29pbnMgdGhhdCBzdXBwb3J0IGFkZGluZyBzaWduYXR1cmVzIGRpcmVjdGx5IChlLmcuIFRTUykuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJpYWxpemVkVHggLSB0aGUgdW5zaWduZWQgdHJhbnNhY3Rpb24gaW4gYnJvYWRjYXN0IGZvcm1hdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSAtIHRoZSBwb3J0aW9uIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGF0IG5lZWRzIHRvIGJlIHNpZ25lZFxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmFibGVQYXlsb2FkKHNlcmlhbGl6ZWRUeDogc3RyaW5nKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VyaWFsaXplZFR4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBNUEMgYWxnb3JpdGhtIChlY2RzYSBvciBlZGRzYSkgdXNlZCBmb3IgY29pbnMgdGhhdCBzdXBwb3J0IFRTU1xuICAgKi9cbiAgZ2V0TVBDQWxnb3JpdGhtKCk6IE1QQ0FsZ29yaXRobSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdubyBNUEMgYWxnb3JpdGhtIGlzIGRlZmluZWQgZm9yIHRoaXMgY29pbicpO1xuICB9XG5cbiAgYXN5bmMgcmVjb3ZlclRva2VuKHBhcmFtczogUmVjb3ZlcldhbGxldFRva2VuT3B0aW9ucyk6IFByb21pc2U8UmVjb3ZlclRva2VuVHJhbnNhY3Rpb24+IHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigncmVjb3ZlclRva2VuIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHRoaXMgY29pbicpO1xuICB9XG5cbiAgZ2V0SW5zY3JpcHRpb25CdWlsZGVyKHdhbGxldDogV2FsbGV0KTogSUluc2NyaXB0aW9uQnVpbGRlciB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ0luc2NyaXB0aW9uIEJ1aWxkZXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBjb2luJyk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gZ2V0IGNvaW4gc3BlY2lmaWMgaGFzaCBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRyYW5zYWN0aW9uIGRpZ2VzdHMuXG4gICAqIEByZXR1cm5zIHtAc2VlIEhhc2h9IGhhc2ggZnVuY3Rpb24gaWYgaW1wbGVtZW50ZWQsIG90aGVyd2lzZSB0aHJvd3MgZXhjZXB0aW9uXG4gICAqL1xuICBnZXRIYXNoRnVuY3Rpb24oKTogSGFzaCB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2dldEhhc2hGdW5jdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIGNvaW4nKTtcbiAgfVxufVxuIl19