"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallets = void 0;
/**
 * @prettier
 */
const assert_1 = __importDefault(require("assert"));
const bignumber_js_1 = require("bignumber.js");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const _ = __importStar(require("lodash"));
const api_1 = require("../../api");
const common = __importStar(require("../../common"));
const ecdh_1 = require("../ecdh");
const utils_1 = require("../utils");
const wallet_1 = require("./wallet");
class Wallets {
    constructor(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a wallet by ID (proxy for getWallet)
     * @param params
     */
    async get(params = {}) {
        return this.getWallet(params);
    }
    /**
     * List a user's wallets
     * @param params
     * @returns {*}
     */
    async list(params = {}) {
        const queryObject = {};
        if (params.skip && params.prevId) {
            throw new Error('cannot specify both skip and prevId');
        }
        if (params.getbalances) {
            if (!_.isBoolean(params.getbalances)) {
                throw new Error('invalid getbalances argument, expecting boolean');
            }
            queryObject.getbalances = params.getbalances;
        }
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            queryObject.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            queryObject.limit = params.limit;
        }
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            queryObject.allTokens = params.allTokens;
        }
        const body = (await this.bitgo.get(this.baseCoin.url('/wallet')).query(queryObject).result());
        body.wallets = body.wallets.map((w) => new wallet_1.Wallet(this.bitgo, this.baseCoin, w));
        return body;
    }
    /**
     * add
     * Add a new wallet (advanced mode).
     * This allows you to manually submit the keys, type, m and n of the wallet
     * Parameters include:
     *    "label": label of the wallet to be shown in UI
     *    "m": number of keys required to unlock wallet (2)
     *    "n": number of keys available on the wallet (3)
     *    "keys": array of keychain ids
     */
    async add(params) {
        params = params || {};
        common.validateParams(params, [], ['label', 'enterprise', 'type']);
        if (typeof params.label !== 'string') {
            throw new Error('missing required string parameter label');
        }
        // no need to pass keys for (single) custodial wallets
        if (params.type !== 'custodial') {
            if (Array.isArray(params.keys) === false || !_.isNumber(params.m) || !_.isNumber(params.n)) {
                throw new Error('invalid argument');
            }
            // TODO: support more types of multisig
            if (!this.baseCoin.isValidMofNSetup(params)) {
                throw new Error('unsupported multi-sig type');
            }
        }
        if (params.gasPrice && !_.isNumber(params.gasPrice)) {
            throw new Error('invalid argument for gasPrice - number expected');
        }
        if (params.walletVersion && !_.isNumber(params.walletVersion)) {
            throw new Error('invalid argument for walletVersion - number expected');
        }
        if (params.tags && Array.isArray(params.tags) === false) {
            throw new Error('invalid argument for tags - array expected');
        }
        if (params.clientFlags && Array.isArray(params.clientFlags) === false) {
            throw new Error('invalid argument for clientFlags - array expected');
        }
        if (params.isCold && !_.isBoolean(params.isCold)) {
            throw new Error('invalid argument for isCold - boolean expected');
        }
        if (params.isCustodial && !_.isBoolean(params.isCustodial)) {
            throw new Error('invalid argument for isCustodial - boolean expected');
        }
        if (params.address && (!_.isString(params.address) || !this.baseCoin.isValidAddress(params.address))) {
            throw new Error('invalid argument for address - valid address string expected');
        }
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(params).result();
        return {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
        };
    }
    /**
     * Generate a new wallet
     * 1. Creates the user keychain locally on the client, and encrypts it with the provided passphrase
     * 2. If no pub was provided, creates the backup keychain locally on the client, and encrypts it with the provided passphrase
     * 3. Uploads the encrypted user and backup keychains to BitGo
     * 4. Creates the BitGo key on the service
     * 5. Creates the wallet on BitGo with the 3 public keys above
     * @param params
     * @param params.label
     * @param params.passphrase
     * @param params.userKey User xpub
     * @param params.backupXpub Backup xpub
     * @param params.backupXpubProvider
     * @param params.backupProvider Third party backup provider for TSS
     * @param params.enterprise
     * @param params.disableTransactionNotifications
     * @param params.passcodeEncryptionCode
     * @param params.coldDerivationSeed
     * @param params.gasPrice
     * @param params.disableKRSEmail
     * @param params.walletVersion
     * @param params.multisigType optional multisig type, 'onchain' or 'tss' or 'blsdkg'; if absent, we will defer to the coin's default type
     * @param params.isDistributedCustody optional parameter for creating bitgo key. This is only necessary if you want to create
     *                                    a distributed custody wallet. If provided, you must have the enterprise license and pass in
     *                                    `params.enterprise` into `generateWallet` as well.
     * @returns {*}
     */
    async generateWallet(params = {}) {
        common.validateParams(params, ['label'], ['passphrase', 'userKey', 'backupXpub']);
        if (typeof params.label !== 'string') {
            throw new Error('missing required string parameter label');
        }
        const isTss = params.multisigType === 'tss' && this.baseCoin.supportsTss();
        const label = params.label;
        const passphrase = params.passphrase;
        const canEncrypt = !!passphrase && typeof passphrase === 'string';
        const isCold = !!params.userKey && params.multisigType !== 'onchain';
        const walletParams = {
            label: label,
            m: 2,
            n: 3,
            keys: [],
            isCold,
        };
        if (!_.isUndefined(params.passcodeEncryptionCode)) {
            if (!_.isString(params.passcodeEncryptionCode)) {
                throw new Error('passcodeEncryptionCode must be a string');
            }
        }
        if (!_.isUndefined(params.enterprise)) {
            if (!_.isString(params.enterprise)) {
                throw new Error('invalid enterprise argument, expecting string');
            }
            walletParams.enterprise = params.enterprise;
        }
        else {
            // enterprise not defined
            if (params.multisigType === 'tss' && params.backupProvider === 'BitGoTrustAsKrs') {
                throw new Error('The enterprise id is required when creating TSS wallet with BitGo Trust as KRS.');
            }
        }
        // EVM TSS wallets must use wallet version 3
        if ((isTss && this.baseCoin.isEVM()) !== (params.walletVersion === 3)) {
            throw new Error('EVM TSS wallets are only supported for wallet version 3');
        }
        if (isTss) {
            if (isCold) {
                throw new Error('TSS cold wallets are not supported at this time');
            }
            if (!this.baseCoin.supportsTss()) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support TSS at this time`);
            }
            return this.generateMpcWallet({
                multisigType: 'tss',
                label,
                passphrase,
                originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                enterprise: params.enterprise,
                walletVersion: params.walletVersion,
                backupProvider: params.backupProvider,
            });
        }
        const isBlsDkg = params.multisigType ? params.multisigType === 'blsdkg' : this.baseCoin.supportsBlsDkg();
        if (isBlsDkg) {
            if (!canEncrypt) {
                throw new Error('cannot generate BLS-DKG keys without passphrase');
            }
            if (isCold) {
                throw new Error('BLS-DKG cold wallets are not supported at this time');
            }
            if (!this.baseCoin.supportsBlsDkg()) {
                throw new Error(`coin ${this.baseCoin.getFamily()} does not support BLS-DKG at this time`);
            }
            return this.generateMpcWallet({ multisigType: 'blsdkg', label, passphrase });
        }
        // Handle distributed custody
        if (params.isDistributedCustody) {
            if (!params.enterprise) {
                throw new Error('must provide enterprise when creating distributed custody wallet');
            }
            if (!walletParams.isCold) {
                throw new Error('distributed custody wallets must be cold');
            }
        }
        const hasBackupXpub = !!params.backupXpub;
        const hasBackupXpubProvider = !!params.backupXpubProvider;
        if (hasBackupXpub && hasBackupXpubProvider) {
            throw new Error('Cannot provide more than one backupXpub or backupXpubProvider flag');
        }
        if (params.gasPrice && params.eip1559) {
            throw new Error('can not use both eip1559 and gasPrice values');
        }
        if (!_.isUndefined(params.disableTransactionNotifications)) {
            if (!_.isBoolean(params.disableTransactionNotifications)) {
                throw new Error('invalid disableTransactionNotifications argument, expecting boolean');
            }
            walletParams.disableTransactionNotifications = params.disableTransactionNotifications;
        }
        if (!_.isUndefined(params.gasPrice)) {
            const gasPriceBN = new bignumber_js_1.BigNumber(params.gasPrice);
            if (gasPriceBN.isNaN()) {
                throw new Error('invalid gas price argument, expecting number or number as string');
            }
            walletParams.gasPrice = gasPriceBN.toString();
        }
        if (!_.isUndefined(params.eip1559) && !_.isEmpty(params.eip1559)) {
            const maxFeePerGasBN = new bignumber_js_1.BigNumber(params.eip1559.maxFeePerGas);
            if (maxFeePerGasBN.isNaN()) {
                throw new Error('invalid max fee argument, expecting number or number as string');
            }
            const maxPriorityFeePerGasBN = new bignumber_js_1.BigNumber(params.eip1559.maxPriorityFeePerGas);
            if (maxPriorityFeePerGasBN.isNaN()) {
                throw new Error('invalid priority fee argument, expecting number or number as string');
            }
            walletParams.eip1559 = {
                maxFeePerGas: maxFeePerGasBN.toString(),
                maxPriorityFeePerGas: maxPriorityFeePerGasBN.toString(),
            };
        }
        if (!_.isUndefined(params.disableKRSEmail)) {
            if (!_.isBoolean(params.disableKRSEmail)) {
                throw new Error('invalid disableKRSEmail argument, expecting boolean');
            }
            walletParams.disableKRSEmail = params.disableKRSEmail;
        }
        if (!_.isUndefined(params.walletVersion)) {
            if (!_.isNumber(params.walletVersion)) {
                throw new Error('invalid walletVersion provided, expecting number');
            }
            walletParams.walletVersion = params.walletVersion;
        }
        // Ensure each krsSpecific param is either a string, boolean, or number
        const { krsSpecific } = params;
        if (!_.isUndefined(krsSpecific)) {
            Object.keys(krsSpecific).forEach((key) => {
                const val = krsSpecific[key];
                if (!_.isBoolean(val) && !_.isString(val) && !_.isNumber(val)) {
                    throw new Error('krsSpecific object contains illegal values. values must be strings, booleans, or numbers');
                }
            });
        }
        let derivationPath = undefined;
        const reqId = new utils_1.RequestTracer();
        // Add the user keychain
        const userKeychainPromise = async () => {
            let userKeychainParams;
            let userKeychain;
            // User provided user key
            if (params.userKey) {
                userKeychain = { pub: params.userKey };
                userKeychainParams = userKeychain;
                if (params.coldDerivationSeed) {
                    // the derivation only makes sense when a key already exists
                    const derivation = this.baseCoin.deriveKeyWithSeed({
                        key: params.userKey,
                        seed: params.coldDerivationSeed,
                    });
                    derivationPath = derivation.derivationPath;
                    userKeychain.pub = derivation.key;
                    userKeychain.derivedFromParentWithSeed = params.coldDerivationSeed;
                }
            }
            else {
                if (!canEncrypt) {
                    throw new Error('cannot generate user keypair without passphrase');
                }
                // Create the user key.
                userKeychain = this.baseCoin.keychains().create();
                userKeychain.encryptedPrv = this.bitgo.encrypt({ password: passphrase, input: userKeychain.prv });
                userKeychainParams = {
                    pub: userKeychain.pub,
                    encryptedPrv: userKeychain.encryptedPrv,
                    originalPasscodeEncryptionCode: params.passcodeEncryptionCode,
                };
            }
            userKeychainParams.reqId = reqId;
            const newUserKeychain = await this.baseCoin.keychains().add(userKeychainParams);
            return _.extend({}, newUserKeychain, userKeychain);
        };
        const backupKeychainPromise = async () => {
            if (params.backupXpubProvider) {
                // If requested, use a KRS or backup key provider
                return this.baseCoin.keychains().createBackup({
                    provider: params.backupXpubProvider || 'defaultRMGBackupProvider',
                    disableKRSEmail: params.disableKRSEmail,
                    krsSpecific: params.krsSpecific,
                    type: this.baseCoin.getChain(),
                    reqId,
                });
            }
            // User provided backup xpub
            if (params.backupXpub) {
                // user provided backup ethereum address
                return this.baseCoin.keychains().add({
                    pub: params.backupXpub,
                    source: 'backup',
                    reqId,
                });
            }
            else {
                if (!canEncrypt) {
                    throw new Error('cannot generate backup keypair without passphrase');
                }
                // No provided backup xpub or address, so default to creating one here
                return this.baseCoin.keychains().createBackup({ reqId });
            }
        };
        const { userKeychain, backupKeychain, bitgoKeychain } = await utils_1.promiseProps({
            userKeychain: userKeychainPromise(),
            backupKeychain: backupKeychainPromise(),
            bitgoKeychain: this.baseCoin
                .keychains()
                .createBitGo({ enterprise: params.enterprise, reqId, isDistributedCustody: params.isDistributedCustody }),
        });
        walletParams.keys = [userKeychain.id, backupKeychain.id, bitgoKeychain.id];
        walletParams.isCold = isCold;
        const { prv } = userKeychain;
        if (_.isString(prv)) {
            assert_1.default(backupKeychain.pub);
            assert_1.default(bitgoKeychain.pub);
            walletParams.keySignatures = {
                backup: (await this.baseCoin.signMessage({ prv }, backupKeychain.pub)).toString('hex'),
                bitgo: (await this.baseCoin.signMessage({ prv }, bitgoKeychain.pub)).toString('hex'),
            };
        }
        if (_.includes(['xrp', 'xlm', 'cspr'], this.baseCoin.getFamily()) && !_.isUndefined(params.rootPrivateKey)) {
            walletParams.rootPrivateKey = params.rootPrivateKey;
        }
        const keychains = {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        this.bitgo.setRequestTracer(reqId);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain: userKeychain,
            backupKeychain: backupKeychain,
            bitgoKeychain: bitgoKeychain,
        };
        if (!_.isUndefined(backupKeychain.prv)) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        if (!_.isUndefined(derivationPath)) {
            userKeychain.derivationPath = derivationPath;
        }
        return result;
    }
    /**
     * List the user's wallet shares
     * @param params
     */
    async listShares(params = {}) {
        return await this.bitgo.get(this.baseCoin.url('/walletshare')).result();
    }
    /**
     * Gets a wallet share information, including the encrypted sharing keychain. requires unlock if keychain is present.
     * @param params
     * @param params.walletShareId - the wallet share to get information on
     */
    async getShare(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo.get(this.baseCoin.url('/walletshare/' + params.walletShareId)).result();
    }
    /**
     * Update a wallet share
     * @param params.walletShareId - the wallet share to update
     * @param params.state - the new state of the wallet share
     * @param params
     */
    async updateShare(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo
            .post(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send(params)
            .result();
    }
    /**
     * Resend a wallet share invitation email
     * @param params
     * @param params.walletShareId - the wallet share whose invitiation should be resent
     */
    async resendShareInvite(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        const urlParts = params.walletShareId + '/resendemail';
        return this.bitgo.post(this.baseCoin.url('/walletshare/' + urlParts)).result();
    }
    /**
     * Cancel a wallet share
     * @param params
     * @param params.walletShareId - the wallet share to update
     */
    async cancelShare(params = {}) {
        common.validateParams(params, ['walletShareId'], []);
        return await this.bitgo
            .del(this.baseCoin.url('/walletshare/' + params.walletShareId))
            .send()
            .result();
    }
    /**
     * Accepts a wallet share, adding the wallet to the user's list
     * Needs a user's password to decrypt the shared key
     *
     * @param params
     * @param params.walletShareId - the wallet share to accept
     * @param params.userPassword - (required if more a keychain was shared) user's password to decrypt the shared wallet
     * @param params.newWalletPassphrase - new wallet passphrase for saving the shared wallet prv.
     *                                     If left blank and a wallet with more than view permissions was shared,
     *                                     then the user's login password is used.
     * @param params.overrideEncryptedPrv - set only if the prv was received out-of-band.
     */
    async acceptShare(params = {}) {
        common.validateParams(params, ['walletShareId'], ['overrideEncryptedPrv', 'userPassword', 'newWalletPassphrase']);
        let encryptedPrv = params.overrideEncryptedPrv;
        const walletShare = (await this.getShare({ walletShareId: params.walletShareId }));
        // Return right away if there is no keychain to decrypt, or if explicit encryptedPrv was provided
        if (!walletShare.keychain || !walletShare.keychain.encryptedPrv || encryptedPrv) {
            return this.updateShare({
                walletShareId: params.walletShareId,
                state: 'accepted',
            });
        }
        // More than viewing was requested, so we need to process the wallet keys using the shared ecdh scheme
        if (_.isUndefined(params.userPassword)) {
            throw new Error('userPassword param must be provided to decrypt shared key');
        }
        const sharingKeychain = (await this.bitgo.getECDHKeychain());
        if (_.isUndefined(sharingKeychain.encryptedXprv)) {
            throw new Error('encryptedXprv was not found on sharing keychain');
        }
        // Now we have the sharing keychain, we can work out the secret used for sharing the wallet with us
        sharingKeychain.prv = this.bitgo.decrypt({
            password: params.userPassword,
            input: sharingKeychain.encryptedXprv,
        });
        const secret = ecdh_1.getSharedSecret(
        // Derive key by path (which is used between these 2 users only)
        utxo_lib_1.bip32.fromBase58(sharingKeychain.prv).derivePath(api_1.sanitizeLegacyPath(walletShare.keychain.path)), Buffer.from(walletShare.keychain.fromPubKey, 'hex')).toString('hex');
        // Yes! We got the secret successfully here, now decrypt the shared wallet prv
        const decryptedSharedWalletPrv = this.bitgo.decrypt({
            password: secret,
            input: walletShare.keychain.encryptedPrv,
        });
        // We will now re-encrypt the wallet with our own password
        const newWalletPassphrase = params.newWalletPassphrase || params.userPassword;
        encryptedPrv = this.bitgo.encrypt({
            password: newWalletPassphrase,
            input: decryptedSharedWalletPrv,
        });
        const updateParams = {
            walletShareId: params.walletShareId,
            state: 'accepted',
        };
        if (encryptedPrv) {
            updateParams.encryptedPrv = encryptedPrv;
        }
        return this.updateShare(updateParams);
    }
    /**
     * Get a wallet by its ID
     * @param params
     * @param params.id wallet id
     * @returns {*}
     */
    async getWallet(params = {}) {
        common.validateParams(params, ['id'], []);
        const query = {};
        if (params.allTokens) {
            if (!_.isBoolean(params.allTokens)) {
                throw new Error('invalid allTokens argument, expecting boolean');
            }
            query.allTokens = params.allTokens;
        }
        this.bitgo.setRequestTracer(params.reqId || new utils_1.RequestTracer());
        const wallet = await this.bitgo
            .get(this.baseCoin.url('/wallet/' + params.id))
            .query(query)
            .result();
        return new wallet_1.Wallet(this.bitgo, this.baseCoin, wallet);
    }
    /**
     * Get a wallet by its address
     * @param params
     * @param params.address wallet address
     * @returns {*}
     */
    async getWalletByAddress(params = {}) {
        common.validateParams(params, ['address'], []);
        this.bitgo.setRequestTracer(params.reqId || new utils_1.RequestTracer());
        const wallet = await this.bitgo.get(this.baseCoin.url('/wallet/address/' + params.address)).result();
        return new wallet_1.Wallet(this.bitgo, this.baseCoin, wallet);
    }
    /**
     * For any given supported coin, get total balances for all wallets of that
     * coin type on the account.
     * @param params
     * @returns {*}
     */
    async getTotalBalances(params = {}) {
        return await this.bitgo.get(this.baseCoin.url('/wallet/balances')).result();
    }
    /**
     * Generates a TSS or BLS-DKG Wallet.
     * @param params
     * @private
     */
    async generateMpcWallet(params) {
        const reqId = new utils_1.RequestTracer();
        this.bitgo.setRequestTracer(reqId);
        const walletParams = {
            label: params.label,
            m: 2,
            n: 3,
            keys: [],
            isCold: false,
            multisigType: params.multisigType,
            enterprise: params.enterprise,
            walletVersion: params.walletVersion,
        };
        // Create MPC Keychains
        const keychains = await this.baseCoin.keychains().createMpc({
            multisigType: params.multisigType,
            passphrase: params.passphrase,
            enterprise: params.enterprise,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            backupProvider: params.backupProvider,
        });
        const { userKeychain, backupKeychain, bitgoKeychain } = keychains;
        walletParams.keys = [userKeychain.id, backupKeychain.id, bitgoKeychain.id];
        // Create Wallet
        const finalWalletParams = await this.baseCoin.supplementGenerateWallet(walletParams, keychains);
        const newWallet = await this.bitgo.post(this.baseCoin.url('/wallet')).send(finalWalletParams).result();
        const result = {
            wallet: new wallet_1.Wallet(this.bitgo, this.baseCoin, newWallet),
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        if (!_.isUndefined(backupKeychain.prv) && !_.isUndefined(params.backupProvider)) {
            result.warning = 'Be sure to backup the backup keychain -- it is not stored anywhere else!';
        }
        return result;
    }
}
exports.Wallets = Wallets;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9iaXRnby93YWxsZXQvd2FsbGV0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCxvREFBNEI7QUFDNUIsK0NBQXlDO0FBQ3pDLDhDQUF3QztBQUN4QywwQ0FBNEI7QUFDNUIsbUNBQStDO0FBQy9DLHFEQUF1QztBQUd2QyxrQ0FBMEM7QUFFMUMsb0NBQXVEO0FBYXZELHFDQUFrQztBQUVsQyxNQUFhLE9BQU87SUFJbEIsWUFBWSxLQUFnQixFQUFFLFFBQW1CO1FBQy9DLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0lBQzNCLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsR0FBRyxDQUFDLFNBQTJCLEVBQUU7UUFDckMsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUE0QixFQUFFO1FBQ3ZDLE1BQU0sV0FBVyxHQUFzQixFQUFFLENBQUM7UUFFMUMsSUFBSSxNQUFNLENBQUMsSUFBSSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDaEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1NBQ3hEO1FBRUQsSUFBSSxNQUFNLENBQUMsV0FBVyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDcEMsTUFBTSxJQUFJLEtBQUssQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO2FBQ3BFO1lBQ0QsV0FBVyxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO1NBQzlDO1FBQ0QsSUFBSSxNQUFNLENB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TyxHQUFHLDBFQUEwRSxDQUFDO1NBQzdGO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztDQUNGO0FBcnBCRCwwQkFxcEJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGJpcDMyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IHNhbml0aXplTGVnYWN5UGF0aCB9IGZyb20gJy4uLy4uL2FwaSc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vLi4vY29tbW9uJztcbmltcG9ydCB7IElCYXNlQ29pbiwgS2V5Y2hhaW5zVHJpcGxldCwgU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBnZXRTaGFyZWRTZWNyZXQgfSBmcm9tICcuLi9lY2RoJztcbmltcG9ydCB7IEtleWNoYWluIH0gZnJvbSAnLi4va2V5Y2hhaW4nO1xuaW1wb3J0IHsgcHJvbWlzZVByb3BzLCBSZXF1ZXN0VHJhY2VyIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHtcbiAgQWNjZXB0U2hhcmVPcHRpb25zLFxuICBBZGRXYWxsZXRPcHRpb25zLFxuICBHZW5lcmF0ZU1wY1dhbGxldE9wdGlvbnMsXG4gIEdlbmVyYXRlV2FsbGV0T3B0aW9ucyxcbiAgR2V0V2FsbGV0QnlBZGRyZXNzT3B0aW9ucyxcbiAgR2V0V2FsbGV0T3B0aW9ucyxcbiAgSVdhbGxldHMsXG4gIExpc3RXYWxsZXRPcHRpb25zLFxuICBVcGRhdGVTaGFyZU9wdGlvbnMsXG4gIFdhbGxldFdpdGhLZXljaGFpbnMsXG59IGZyb20gJy4vaVdhbGxldHMnO1xuaW1wb3J0IHsgV2FsbGV0IH0gZnJvbSAnLi93YWxsZXQnO1xuXG5leHBvcnQgY2xhc3MgV2FsbGV0cyBpbXBsZW1lbnRzIElXYWxsZXRzIHtcbiAgcHJpdmF0ZSByZWFkb25seSBiaXRnbzogQml0R29CYXNlO1xuICBwcml2YXRlIHJlYWRvbmx5IGJhc2VDb2luOiBJQmFzZUNvaW47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgYmFzZUNvaW46IElCYXNlQ29pbikge1xuICAgIHRoaXMuYml0Z28gPSBiaXRnbztcbiAgICB0aGlzLmJhc2VDb2luID0gYmFzZUNvaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgd2FsbGV0IGJ5IElEIChwcm94eSBmb3IgZ2V0V2FsbGV0KVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBnZXQocGFyYW1zOiBHZXRXYWxsZXRPcHRpb25zID0ge30pOiBQcm9taXNlPFdhbGxldD4ge1xuICAgIHJldHVybiB0aGlzLmdldFdhbGxldChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3QgYSB1c2VyJ3Mgd2FsbGV0c1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgbGlzdChwYXJhbXM6IExpc3RXYWxsZXRPcHRpb25zID0ge30pOiBQcm9taXNlPHsgd2FsbGV0czogV2FsbGV0W10gfT4ge1xuICAgIGNvbnN0IHF1ZXJ5T2JqZWN0OiBMaXN0V2FsbGV0T3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHBhcmFtcy5za2lwICYmIHBhcmFtcy5wcmV2SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNwZWNpZnkgYm90aCBza2lwIGFuZCBwcmV2SWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmdldGJhbGFuY2VzKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5nZXRiYWxhbmNlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGdldGJhbGFuY2VzIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnlPYmplY3QuZ2V0YmFsYW5jZXMgPSBwYXJhbXMuZ2V0YmFsYW5jZXM7XG4gICAgfVxuICAgIGlmIChwYXJhbXMucHJldklkKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByZXZJZCBhcmd1bWVudCwgZXhwZWN0aW5nIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgcXVlcnlPYmplY3QucHJldklkID0gcGFyYW1zLnByZXZJZDtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5saW1pdCkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5saW1pdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxpbWl0IGFyZ3VtZW50LCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICBxdWVyeU9iamVjdC5saW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFsbFRva2Vucykge1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihwYXJhbXMuYWxsVG9rZW5zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWxsVG9rZW5zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgcXVlcnlPYmplY3QuYWxsVG9rZW5zID0gcGFyYW1zLmFsbFRva2VucztcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gKGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0JykpLnF1ZXJ5KHF1ZXJ5T2JqZWN0KS5yZXN1bHQoKSkgYXMgYW55O1xuICAgIGJvZHkud2FsbGV0cyA9IGJvZHkud2FsbGV0cy5tYXAoKHcpID0+IG5ldyBXYWxsZXQodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgdykpO1xuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIGFkZFxuICAgKiBBZGQgYSBuZXcgd2FsbGV0IChhZHZhbmNlZCBtb2RlKS5cbiAgICogVGhpcyBhbGxvd3MgeW91IHRvIG1hbnVhbGx5IHN1Ym1pdCB0aGUga2V5cywgdHlwZSwgbSBhbmQgbiBvZiB0aGUgd2FsbGV0XG4gICAqIFBhcmFtZXRlcnMgaW5jbHVkZTpcbiAgICogICAgXCJsYWJlbFwiOiBsYWJlbCBvZiB0aGUgd2FsbGV0IHRvIGJlIHNob3duIGluIFVJXG4gICAqICAgIFwibVwiOiBudW1iZXIgb2Yga2V5cyByZXF1aXJlZCB0byB1bmxvY2sgd2FsbGV0ICgyKVxuICAgKiAgICBcIm5cIjogbnVtYmVyIG9mIGtleXMgYXZhaWxhYmxlIG9uIHRoZSB3YWxsZXQgKDMpXG4gICAqICAgIFwia2V5c1wiOiBhcnJheSBvZiBrZXljaGFpbiBpZHNcbiAgICovXG4gIGFzeW5jIGFkZChwYXJhbXM6IEFkZFdhbGxldE9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ2xhYmVsJywgJ2VudGVycHJpc2UnLCAndHlwZSddKTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLmxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBwYXJhbWV0ZXIgbGFiZWwnKTtcbiAgICB9XG5cbiAgICAvLyBubyBuZWVkIHRvIHBhc3Mga2V5cyBmb3IgKHNpbmdsZSkgY3VzdG9kaWFsIHdhbGxldHNcbiAgICBpZiAocGFyYW1zLnR5cGUgIT09ICdjdXN0b2RpYWwnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMua2V5cykgPT09IGZhbHNlIHx8ICFfLmlzTnVtYmVyKHBhcmFtcy5tKSB8fCAhXy5pc051bWJlcihwYXJhbXMubikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgbW9yZSB0eXBlcyBvZiBtdWx0aXNpZ1xuICAgICAgaWYgKCF0aGlzLmJhc2VDb2luLmlzVmFsaWRNb2ZOU2V0dXAocGFyYW1zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIG11bHRpLXNpZyB0eXBlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5nYXNQcmljZSAmJiAhXy5pc051bWJlcihwYXJhbXMuZ2FzUHJpY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGdhc1ByaWNlIC0gbnVtYmVyIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy53YWxsZXRWZXJzaW9uICYmICFfLmlzTnVtYmVyKHBhcmFtcy53YWxsZXRWZXJzaW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciB3YWxsZXRWZXJzaW9uIC0gbnVtYmVyIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy50YWdzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLnRhZ3MpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciB0YWdzIC0gYXJyYXkgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmNsaWVudEZsYWdzICYmIEFycmF5LmlzQXJyYXkocGFyYW1zLmNsaWVudEZsYWdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCBmb3IgY2xpZW50RmxhZ3MgLSBhcnJheSBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMuaXNDb2xkICYmICFfLmlzQm9vbGVhbihwYXJhbXMuaXNDb2xkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBpc0NvbGQgLSBib29sZWFuIGV4cGVjdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5pc0N1c3RvZGlhbCAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLmlzQ3VzdG9kaWFsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IGZvciBpc0N1c3RvZGlhbCAtIGJvb2xlYW4gZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFkZHJlc3MgJiYgKCFfLmlzU3RyaW5nKHBhcmFtcy5hZGRyZXNzKSB8fCAhdGhpcy5iYXNlQ29pbi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMuYWRkcmVzcykpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQgZm9yIGFkZHJlc3MgLSB2YWxpZCBhZGRyZXNzIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1dhbGxldCA9IGF3YWl0IHRoaXMuYml0Z28ucG9zdCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldCcpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhbGxldDogbmV3IFdhbGxldCh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luLCBuZXdXYWxsZXQpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgd2FsbGV0XG4gICAqIDEuIENyZWF0ZXMgdGhlIHVzZXIga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuICAgKiAyLiBJZiBubyBwdWIgd2FzIHByb3ZpZGVkLCBjcmVhdGVzIHRoZSBiYWNrdXAga2V5Y2hhaW4gbG9jYWxseSBvbiB0aGUgY2xpZW50LCBhbmQgZW5jcnlwdHMgaXQgd2l0aCB0aGUgcHJvdmlkZWQgcGFzc3BocmFzZVxuICAgKiAzLiBVcGxvYWRzIHRoZSBlbmNyeXB0ZWQgdXNlciBhbmQgYmFja3VwIGtleWNoYWlucyB0byBCaXRHb1xuICAgKiA0LiBDcmVhdGVzIHRoZSBCaXRHbyBrZXkgb24gdGhlIHNlcnZpY2VcbiAgICogNS4gQ3JlYXRlcyB0aGUgd2FsbGV0IG9uIEJpdEdvIHdpdGggdGhlIDMgcHVibGljIGtleXMgYWJvdmVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmxhYmVsXG4gICAqIEBwYXJhbSBwYXJhbXMucGFzc3BocmFzZVxuICAgKiBAcGFyYW0gcGFyYW1zLnVzZXJLZXkgVXNlciB4cHViXG4gICAqIEBwYXJhbSBwYXJhbXMuYmFja3VwWHB1YiBCYWNrdXAgeHB1YlxuICAgKiBAcGFyYW0gcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlclxuICAgKiBAcGFyYW0gcGFyYW1zLmJhY2t1cFByb3ZpZGVyIFRoaXJkIHBhcnR5IGJhY2t1cCBwcm92aWRlciBmb3IgVFNTXG4gICAqIEBwYXJhbSBwYXJhbXMuZW50ZXJwcmlzZVxuICAgKiBAcGFyYW0gcGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIHBhcmFtcy5wYXNzY29kZUVuY3J5cHRpb25Db2RlXG4gICAqIEBwYXJhbSBwYXJhbXMuY29sZERlcml2YXRpb25TZWVkXG4gICAqIEBwYXJhbSBwYXJhbXMuZ2FzUHJpY2VcbiAgICogQHBhcmFtIHBhcmFtcy5kaXNhYmxlS1JTRW1haWxcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRWZXJzaW9uXG4gICAqIEBwYXJhbSBwYXJhbXMubXVsdGlzaWdUeXBlIG9wdGlvbmFsIG11bHRpc2lnIHR5cGUsICdvbmNoYWluJyBvciAndHNzJyBvciAnYmxzZGtnJzsgaWYgYWJzZW50LCB3ZSB3aWxsIGRlZmVyIHRvIHRoZSBjb2luJ3MgZGVmYXVsdCB0eXBlXG4gICAqIEBwYXJhbSBwYXJhbXMuaXNEaXN0cmlidXRlZEN1c3RvZHkgb3B0aW9uYWwgcGFyYW1ldGVyIGZvciBjcmVhdGluZyBiaXRnbyBrZXkuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgaWYgeW91IHdhbnQgdG8gY3JlYXRlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBkaXN0cmlidXRlZCBjdXN0b2R5IHdhbGxldC4gSWYgcHJvdmlkZWQsIHlvdSBtdXN0IGhhdmUgdGhlIGVudGVycHJpc2UgbGljZW5zZSBhbmQgcGFzcyBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBwYXJhbXMuZW50ZXJwcmlzZWAgaW50byBgZ2VuZXJhdGVXYWxsZXRgIGFzIHdlbGwuXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVXYWxsZXQocGFyYW1zOiBHZW5lcmF0ZVdhbGxldE9wdGlvbnMgPSB7fSk6IFByb21pc2U8V2FsbGV0V2l0aEtleWNoYWlucz4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnbGFiZWwnXSwgWydwYXNzcGhyYXNlJywgJ3VzZXJLZXknLCAnYmFja3VwWHB1YiddKTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5sYWJlbCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFyYW1ldGVyIGxhYmVsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNUc3MgPSBwYXJhbXMubXVsdGlzaWdUeXBlID09PSAndHNzJyAmJiB0aGlzLmJhc2VDb2luLnN1cHBvcnRzVHNzKCk7XG4gICAgY29uc3QgbGFiZWwgPSBwYXJhbXMubGFiZWw7XG4gICAgY29uc3QgcGFzc3BocmFzZSA9IHBhcmFtcy5wYXNzcGhyYXNlO1xuICAgIGNvbnN0IGNhbkVuY3J5cHQgPSAhIXBhc3NwaHJhc2UgJiYgdHlwZW9mIHBhc3NwaHJhc2UgPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IGlzQ29sZCA9ICEhcGFyYW1zLnVzZXJLZXkgJiYgcGFyYW1zLm11bHRpc2lnVHlwZSAhPT0gJ29uY2hhaW4nO1xuICAgIGNvbnN0IHdhbGxldFBhcmFtczogU3VwcGxlbWVudEdlbmVyYXRlV2FsbGV0T3B0aW9ucyA9IHtcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIG06IDIsXG4gICAgICBuOiAzLFxuICAgICAga2V5czogW10sXG4gICAgICBpc0NvbGQsXG4gICAgfTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZSkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucGFzc2NvZGVFbmNyeXB0aW9uQ29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzY29kZUVuY3J5cHRpb25Db2RlIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmVudGVycHJpc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBlbnRlcnByaXNlIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMuZW50ZXJwcmlzZSA9IHBhcmFtcy5lbnRlcnByaXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnRlcnByaXNlIG5vdCBkZWZpbmVkXG4gICAgICBpZiAocGFyYW1zLm11bHRpc2lnVHlwZSA9PT0gJ3RzcycgJiYgcGFyYW1zLmJhY2t1cFByb3ZpZGVyID09PSAnQml0R29UcnVzdEFzS3JzJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbnRlcnByaXNlIGlkIGlzIHJlcXVpcmVkIHdoZW4gY3JlYXRpbmcgVFNTIHdhbGxldCB3aXRoIEJpdEdvIFRydXN0IGFzIEtSUy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFVk0gVFNTIHdhbGxldHMgbXVzdCB1c2Ugd2FsbGV0IHZlcnNpb24gM1xuICAgIGlmICgoaXNUc3MgJiYgdGhpcy5iYXNlQ29pbi5pc0VWTSgpKSAhPT0gKHBhcmFtcy53YWxsZXRWZXJzaW9uID09PSAzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFVk0gVFNTIHdhbGxldHMgYXJlIG9ubHkgc3VwcG9ydGVkIGZvciB3YWxsZXQgdmVyc2lvbiAzJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzVHNzKSB7XG4gICAgICBpZiAoaXNDb2xkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVFNTIGNvbGQgd2FsbGV0cyBhcmUgbm90IHN1cHBvcnRlZCBhdCB0aGlzIHRpbWUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmJhc2VDb2luLnN1cHBvcnRzVHNzKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2luICR7dGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKX0gZG9lcyBub3Qgc3VwcG9ydCBUU1MgYXQgdGhpcyB0aW1lYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTXBjV2FsbGV0KHtcbiAgICAgICAgbXVsdGlzaWdUeXBlOiAndHNzJyxcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIHBhc3NwaHJhc2UsXG4gICAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZTogcGFyYW1zLnBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICAgIGVudGVycHJpc2U6IHBhcmFtcy5lbnRlcnByaXNlLFxuICAgICAgICB3YWxsZXRWZXJzaW9uOiBwYXJhbXMud2FsbGV0VmVyc2lvbixcbiAgICAgICAgYmFja3VwUHJvdmlkZXI6IHBhcmFtcy5iYWNrdXBQcm92aWRlcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlzQmxzRGtnID0gcGFyYW1zLm11bHRpc2lnVHlwZSA/IHBhcmFtcy5tdWx0aXNpZ1R5cGUgPT09ICdibHNka2cnIDogdGhpcy5iYXNlQ29pbi5zdXBwb3J0c0Jsc0RrZygpO1xuICAgIGlmIChpc0Jsc0RrZykge1xuICAgICAgaWYgKCFjYW5FbmNyeXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdlbmVyYXRlIEJMUy1ES0cga2V5cyB3aXRob3V0IHBhc3NwaHJhc2UnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQ29sZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JMUy1ES0cgY29sZCB3YWxsZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGF0IHRoaXMgdGltZScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuYmFzZUNvaW4uc3VwcG9ydHNCbHNEa2coKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvaW4gJHt0aGlzLmJhc2VDb2luLmdldEZhbWlseSgpfSBkb2VzIG5vdCBzdXBwb3J0IEJMUy1ES0cgYXQgdGhpcyB0aW1lYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTXBjV2FsbGV0KHsgbXVsdGlzaWdUeXBlOiAnYmxzZGtnJywgbGFiZWwsIHBhc3NwaHJhc2UgfSk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGRpc3RyaWJ1dGVkIGN1c3RvZHlcbiAgICBpZiAocGFyYW1zLmlzRGlzdHJpYnV0ZWRDdXN0b2R5KSB7XG4gICAgICBpZiAoIXBhcmFtcy5lbnRlcnByaXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBwcm92aWRlIGVudGVycHJpc2Ugd2hlbiBjcmVhdGluZyBkaXN0cmlidXRlZCBjdXN0b2R5IHdhbGxldCcpO1xuICAgICAgfVxuICAgICAgaWYgKCF3YWxsZXRQYXJhbXMuaXNDb2xkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzdHJpYnV0ZWQgY3VzdG9keSB3YWxsZXRzIG11c3QgYmUgY29sZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhhc0JhY2t1cFhwdWIgPSAhIXBhcmFtcy5iYWNrdXBYcHViO1xuICAgIGNvbnN0IGhhc0JhY2t1cFhwdWJQcm92aWRlciA9ICEhcGFyYW1zLmJhY2t1cFhwdWJQcm92aWRlcjtcbiAgICBpZiAoaGFzQmFja3VwWHB1YiAmJiBoYXNCYWNrdXBYcHViUHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHByb3ZpZGUgbW9yZSB0aGFuIG9uZSBiYWNrdXBYcHViIG9yIGJhY2t1cFhwdWJQcm92aWRlciBmbGFnJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5nYXNQcmljZSAmJiBwYXJhbXMuZWlwMTU1OSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW4gbm90IHVzZSBib3RoIGVpcDE1NTkgYW5kIGdhc1ByaWNlIHZhbHVlcycpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucykpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkaXNhYmxlVHJhbnNhY3Rpb25Ob3RpZmljYXRpb25zIGFyZ3VtZW50LCBleHBlY3RpbmcgYm9vbGVhbicpO1xuICAgICAgfVxuICAgICAgd2FsbGV0UGFyYW1zLmRpc2FibGVUcmFuc2FjdGlvbk5vdGlmaWNhdGlvbnMgPSBwYXJhbXMuZGlzYWJsZVRyYW5zYWN0aW9uTm90aWZpY2F0aW9ucztcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmdhc1ByaWNlKSkge1xuICAgICAgY29uc3QgZ2FzUHJpY2VCTiA9IG5ldyBCaWdOdW1iZXIocGFyYW1zLmdhc1ByaWNlKTtcbiAgICAgIGlmIChnYXNQcmljZUJOLmlzTmFOKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGdhcyBwcmljZSBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlciBvciBudW1iZXIgYXMgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMuZ2FzUHJpY2UgPSBnYXNQcmljZUJOLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5laXAxNTU5KSAmJiAhXy5pc0VtcHR5KHBhcmFtcy5laXAxNTU5KSkge1xuICAgICAgY29uc3QgbWF4RmVlUGVyR2FzQk4gPSBuZXcgQmlnTnVtYmVyKHBhcmFtcy5laXAxNTU5Lm1heEZlZVBlckdhcyk7XG4gICAgICBpZiAobWF4RmVlUGVyR2FzQk4uaXNOYU4oKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4IGZlZSBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlciBvciBudW1iZXIgYXMgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhc0JOID0gbmV3IEJpZ051bWJlcihwYXJhbXMuZWlwMTU1OS5tYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICBpZiAobWF4UHJpb3JpdHlGZWVQZXJHYXNCTi5pc05hTigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmlvcml0eSBmZWUgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXIgb3IgbnVtYmVyIGFzIHN0cmluZycpO1xuICAgICAgfVxuICAgICAgd2FsbGV0UGFyYW1zLmVpcDE1NTkgPSB7XG4gICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzQk4udG9TdHJpbmcoKSxcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IG1heFByaW9yaXR5RmVlUGVyR2FzQk4udG9TdHJpbmcoKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5kaXNhYmxlS1JTRW1haWwpKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5kaXNhYmxlS1JTRW1haWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkaXNhYmxlS1JTRW1haWwgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMuZGlzYWJsZUtSU0VtYWlsID0gcGFyYW1zLmRpc2FibGVLUlNFbWFpbDtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldFZlcnNpb24pKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLndhbGxldFZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3YWxsZXRWZXJzaW9uIHByb3ZpZGVkLCBleHBlY3RpbmcgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMud2FsbGV0VmVyc2lvbiA9IHBhcmFtcy53YWxsZXRWZXJzaW9uO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBlYWNoIGtyc1NwZWNpZmljIHBhcmFtIGlzIGVpdGhlciBhIHN0cmluZywgYm9vbGVhbiwgb3IgbnVtYmVyXG4gICAgY29uc3QgeyBrcnNTcGVjaWZpYyB9ID0gcGFyYW1zO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChrcnNTcGVjaWZpYykpIHtcbiAgICAgIE9iamVjdC5rZXlzKGtyc1NwZWNpZmljKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0ga3JzU3BlY2lmaWNba2V5XTtcbiAgICAgICAgaWYgKCFfLmlzQm9vbGVhbih2YWwpICYmICFfLmlzU3RyaW5nKHZhbCkgJiYgIV8uaXNOdW1iZXIodmFsKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigna3JzU3BlY2lmaWMgb2JqZWN0IGNvbnRhaW5zIGlsbGVnYWwgdmFsdWVzLiB2YWx1ZXMgbXVzdCBiZSBzdHJpbmdzLCBib29sZWFucywgb3IgbnVtYmVycycpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgZGVyaXZhdGlvblBhdGg6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHJlcUlkID0gbmV3IFJlcXVlc3RUcmFjZXIoKTtcblxuICAgIC8vIEFkZCB0aGUgdXNlciBrZXljaGFpblxuICAgIGNvbnN0IHVzZXJLZXljaGFpblByb21pc2UgPSBhc3luYyAoKTogUHJvbWlzZTxLZXljaGFpbj4gPT4ge1xuICAgICAgbGV0IHVzZXJLZXljaGFpblBhcmFtcztcbiAgICAgIGxldCB1c2VyS2V5Y2hhaW47XG4gICAgICAvLyBVc2VyIHByb3ZpZGVkIHVzZXIga2V5XG4gICAgICBpZiAocGFyYW1zLnVzZXJLZXkpIHtcbiAgICAgICAgdXNlcktleWNoYWluID0geyBwdWI6IHBhcmFtcy51c2VyS2V5IH07XG4gICAgICAgIHVzZXJLZXljaGFpblBhcmFtcyA9IHVzZXJLZXljaGFpbjtcbiAgICAgICAgaWYgKHBhcmFtcy5jb2xkRGVyaXZhdGlvblNlZWQpIHtcbiAgICAgICAgICAvLyB0aGUgZGVyaXZhdGlvbiBvbmx5IG1ha2VzIHNlbnNlIHdoZW4gYSBrZXkgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICBjb25zdCBkZXJpdmF0aW9uID0gdGhpcy5iYXNlQ29pbi5kZXJpdmVLZXlXaXRoU2VlZCh7XG4gICAgICAgICAgICBrZXk6IHBhcmFtcy51c2VyS2V5LFxuICAgICAgICAgICAgc2VlZDogcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZXJpdmF0aW9uUGF0aCA9IGRlcml2YXRpb24uZGVyaXZhdGlvblBhdGg7XG4gICAgICAgICAgdXNlcktleWNoYWluLnB1YiA9IGRlcml2YXRpb24ua2V5O1xuICAgICAgICAgIHVzZXJLZXljaGFpbi5kZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkID0gcGFyYW1zLmNvbGREZXJpdmF0aW9uU2VlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjYW5FbmNyeXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZ2VuZXJhdGUgdXNlciBrZXlwYWlyIHdpdGhvdXQgcGFzc3BocmFzZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdXNlciBrZXkuXG4gICAgICAgIHVzZXJLZXljaGFpbiA9IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlKCk7XG4gICAgICAgIHVzZXJLZXljaGFpbi5lbmNyeXB0ZWRQcnYgPSB0aGlzLmJpdGdvLmVuY3J5cHQoeyBwYXNzd29yZDogcGFzc3BocmFzZSwgaW5wdXQ6IHVzZXJLZXljaGFpbi5wcnYgfSk7XG4gICAgICAgIHVzZXJLZXljaGFpblBhcmFtcyA9IHtcbiAgICAgICAgICBwdWI6IHVzZXJLZXljaGFpbi5wdWIsXG4gICAgICAgICAgZW5jcnlwdGVkUHJ2OiB1c2VyS2V5Y2hhaW4uZW5jcnlwdGVkUHJ2LFxuICAgICAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZTogcGFyYW1zLnBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHVzZXJLZXljaGFpblBhcmFtcy5yZXFJZCA9IHJlcUlkO1xuICAgICAgY29uc3QgbmV3VXNlcktleWNoYWluID0gYXdhaXQgdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5hZGQodXNlcktleWNoYWluUGFyYW1zKTtcbiAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgbmV3VXNlcktleWNoYWluLCB1c2VyS2V5Y2hhaW4pO1xuICAgIH07XG5cbiAgICBjb25zdCBiYWNrdXBLZXljaGFpblByb21pc2UgPSBhc3luYyAoKTogUHJvbWlzZTxLZXljaGFpbj4gPT4ge1xuICAgICAgaWYgKHBhcmFtcy5iYWNrdXBYcHViUHJvdmlkZXIpIHtcbiAgICAgICAgLy8gSWYgcmVxdWVzdGVkLCB1c2UgYSBLUlMgb3IgYmFja3VwIGtleSBwcm92aWRlclxuICAgICAgICByZXR1cm4gdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5jcmVhdGVCYWNrdXAoe1xuICAgICAgICAgIHByb3ZpZGVyOiBwYXJhbXMuYmFja3VwWHB1YlByb3ZpZGVyIHx8ICdkZWZhdWx0Uk1HQmFja3VwUHJvdmlkZXInLFxuICAgICAgICAgIGRpc2FibGVLUlNFbWFpbDogcGFyYW1zLmRpc2FibGVLUlNFbWFpbCxcbiAgICAgICAgICBrcnNTcGVjaWZpYzogcGFyYW1zLmtyc1NwZWNpZmljLFxuICAgICAgICAgIHR5cGU6IHRoaXMuYmFzZUNvaW4uZ2V0Q2hhaW4oKSxcbiAgICAgICAgICByZXFJZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZXIgcHJvdmlkZWQgYmFja3VwIHhwdWJcbiAgICAgIGlmIChwYXJhbXMuYmFja3VwWHB1Yikge1xuICAgICAgICAvLyB1c2VyIHByb3ZpZGVkIGJhY2t1cCBldGhlcmV1bSBhZGRyZXNzXG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZCh7XG4gICAgICAgICAgcHViOiBwYXJhbXMuYmFja3VwWHB1YixcbiAgICAgICAgICBzb3VyY2U6ICdiYWNrdXAnLFxuICAgICAgICAgIHJlcUlkLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY2FuRW5jcnlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGdlbmVyYXRlIGJhY2t1cCBrZXlwYWlyIHdpdGhvdXQgcGFzc3BocmFzZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHByb3ZpZGVkIGJhY2t1cCB4cHViIG9yIGFkZHJlc3MsIHNvIGRlZmF1bHQgdG8gY3JlYXRpbmcgb25lIGhlcmVcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuY3JlYXRlQmFja3VwKHsgcmVxSWQgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHsgdXNlcktleWNoYWluLCBiYWNrdXBLZXljaGFpbiwgYml0Z29LZXljaGFpbiB9OiBLZXljaGFpbnNUcmlwbGV0ID0gYXdhaXQgcHJvbWlzZVByb3BzKHtcbiAgICAgIHVzZXJLZXljaGFpbjogdXNlcktleWNoYWluUHJvbWlzZSgpLFxuICAgICAgYmFja3VwS2V5Y2hhaW46IGJhY2t1cEtleWNoYWluUHJvbWlzZSgpLFxuICAgICAgYml0Z29LZXljaGFpbjogdGhpcy5iYXNlQ29pblxuICAgICAgICAua2V5Y2hhaW5zKClcbiAgICAgICAgLmNyZWF0ZUJpdEdvKHsgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsIHJlcUlkLCBpc0Rpc3RyaWJ1dGVkQ3VzdG9keTogcGFyYW1zLmlzRGlzdHJpYnV0ZWRDdXN0b2R5IH0pLFxuICAgIH0pO1xuXG4gICAgd2FsbGV0UGFyYW1zLmtleXMgPSBbdXNlcktleWNoYWluLmlkLCBiYWNrdXBLZXljaGFpbi5pZCwgYml0Z29LZXljaGFpbi5pZF07XG5cbiAgICB3YWxsZXRQYXJhbXMuaXNDb2xkID0gaXNDb2xkO1xuXG4gICAgY29uc3QgeyBwcnYgfSA9IHVzZXJLZXljaGFpbjtcbiAgICBpZiAoXy5pc1N0cmluZyhwcnYpKSB7XG4gICAgICBhc3NlcnQoYmFja3VwS2V5Y2hhaW4ucHViKTtcbiAgICAgIGFzc2VydChiaXRnb0tleWNoYWluLnB1Yik7XG4gICAgICB3YWxsZXRQYXJhbXMua2V5U2lnbmF0dXJlcyA9IHtcbiAgICAgICAgYmFja3VwOiAoYXdhaXQgdGhpcy5iYXNlQ29pbi5zaWduTWVzc2FnZSh7IHBydiB9LCBiYWNrdXBLZXljaGFpbi5wdWIpKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgIGJpdGdvOiAoYXdhaXQgdGhpcy5iYXNlQ29pbi5zaWduTWVzc2FnZSh7IHBydiB9LCBiaXRnb0tleWNoYWluLnB1YikpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKF8uaW5jbHVkZXMoWyd4cnAnLCAneGxtJywgJ2NzcHInXSwgdGhpcy5iYXNlQ29pbi5nZXRGYW1pbHkoKSkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLnJvb3RQcml2YXRlS2V5KSkge1xuICAgICAgd2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5ID0gcGFyYW1zLnJvb3RQcml2YXRlS2V5O1xuICAgIH1cblxuICAgIGNvbnN0IGtleWNoYWlucyA9IHtcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICB9O1xuICAgIGNvbnN0IGZpbmFsV2FsbGV0UGFyYW1zID0gYXdhaXQgdGhpcy5iYXNlQ29pbi5zdXBwbGVtZW50R2VuZXJhdGVXYWxsZXQod2FsbGV0UGFyYW1zLCBrZXljaGFpbnMpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG4gICAgY29uc3QgbmV3V2FsbGV0ID0gYXdhaXQgdGhpcy5iaXRnby5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0JykpLnNlbmQoZmluYWxXYWxsZXRQYXJhbXMpLnJlc3VsdCgpO1xuXG4gICAgY29uc3QgcmVzdWx0OiBXYWxsZXRXaXRoS2V5Y2hhaW5zID0ge1xuICAgICAgd2FsbGV0OiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIG5ld1dhbGxldCksXG4gICAgICB1c2VyS2V5Y2hhaW46IHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluOiBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW46IGJpdGdvS2V5Y2hhaW4sXG4gICAgfTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChiYWNrdXBLZXljaGFpbi5wcnYpKSB7XG4gICAgICByZXN1bHQud2FybmluZyA9ICdCZSBzdXJlIHRvIGJhY2t1cCB0aGUgYmFja3VwIGtleWNoYWluIC0tIGl0IGlzIG5vdCBzdG9yZWQgYW55d2hlcmUgZWxzZSEnO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChkZXJpdmF0aW9uUGF0aCkpIHtcbiAgICAgIHVzZXJLZXljaGFpbi5kZXJpdmF0aW9uUGF0aCA9IGRlcml2YXRpb25QYXRoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCB0aGUgdXNlcidzIHdhbGxldCBzaGFyZXNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgbGlzdFNoYXJlcyhwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3dhbGxldHNoYXJlJykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSB3YWxsZXQgc2hhcmUgaW5mb3JtYXRpb24sIGluY2x1ZGluZyB0aGUgZW5jcnlwdGVkIHNoYXJpbmcga2V5Y2hhaW4uIHJlcXVpcmVzIHVubG9jayBpZiBrZXljaGFpbiBpcyBwcmVzZW50LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgdG8gZ2V0IGluZm9ybWF0aW9uIG9uXG4gICAqL1xuICBhc3luYyBnZXRTaGFyZShwYXJhbXM6IHsgd2FsbGV0U2hhcmVJZD86IHN0cmluZyB9ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnd2FsbGV0U2hhcmVJZCddLCBbXSk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSB3YWxsZXQgc2hhcmVcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byB1cGRhdGVcbiAgICogQHBhcmFtIHBhcmFtcy5zdGF0ZSAtIHRoZSBuZXcgc3RhdGUgb2YgdGhlIHdhbGxldCBzaGFyZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyB1cGRhdGVTaGFyZShwYXJhbXM6IFVwZGF0ZVNoYXJlT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0c2hhcmUvJyArIHBhcmFtcy53YWxsZXRTaGFyZUlkKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNlbmQgYSB3YWxsZXQgc2hhcmUgaW52aXRhdGlvbiBlbWFpbFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMud2FsbGV0U2hhcmVJZCAtIHRoZSB3YWxsZXQgc2hhcmUgd2hvc2UgaW52aXRpYXRpb24gc2hvdWxkIGJlIHJlc2VudFxuICAgKi9cbiAgYXN5bmMgcmVzZW5kU2hhcmVJbnZpdGUocGFyYW1zOiB7IHdhbGxldFNoYXJlSWQ/OiBzdHJpbmcgfSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10pO1xuXG4gICAgY29uc3QgdXJsUGFydHMgPSBwYXJhbXMud2FsbGV0U2hhcmVJZCArICcvcmVzZW5kZW1haWwnO1xuICAgIHJldHVybiB0aGlzLmJpdGdvLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgdXJsUGFydHMpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgYSB3YWxsZXQgc2hhcmVcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLndhbGxldFNoYXJlSWQgLSB0aGUgd2FsbGV0IHNoYXJlIHRvIHVwZGF0ZVxuICAgKi9cbiAgYXN5bmMgY2FuY2VsU2hhcmUocGFyYW1zOiB7IHdhbGxldFNoYXJlSWQ/OiBzdHJpbmcgfSA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ3dhbGxldFNoYXJlSWQnXSwgW10pO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5kZWwodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXRzaGFyZS8nICsgcGFyYW1zLndhbGxldFNoYXJlSWQpKVxuICAgICAgLnNlbmQoKVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSB3YWxsZXQgc2hhcmUsIGFkZGluZyB0aGUgd2FsbGV0IHRvIHRoZSB1c2VyJ3MgbGlzdFxuICAgKiBOZWVkcyBhIHVzZXIncyBwYXNzd29yZCB0byBkZWNyeXB0IHRoZSBzaGFyZWQga2V5XG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRTaGFyZUlkIC0gdGhlIHdhbGxldCBzaGFyZSB0byBhY2NlcHRcbiAgICogQHBhcmFtIHBhcmFtcy51c2VyUGFzc3dvcmQgLSAocmVxdWlyZWQgaWYgbW9yZSBhIGtleWNoYWluIHdhcyBzaGFyZWQpIHVzZXIncyBwYXNzd29yZCB0byBkZWNyeXB0IHRoZSBzaGFyZWQgd2FsbGV0XG4gICAqIEBwYXJhbSBwYXJhbXMubmV3V2FsbGV0UGFzc3BocmFzZSAtIG5ldyB3YWxsZXQgcGFzc3BocmFzZSBmb3Igc2F2aW5nIHRoZSBzaGFyZWQgd2FsbGV0IHBydi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgbGVmdCBibGFuayBhbmQgYSB3YWxsZXQgd2l0aCBtb3JlIHRoYW4gdmlldyBwZXJtaXNzaW9ucyB3YXMgc2hhcmVkLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIHRoZSB1c2VyJ3MgbG9naW4gcGFzc3dvcmQgaXMgdXNlZC5cbiAgICogQHBhcmFtIHBhcmFtcy5vdmVycmlkZUVuY3J5cHRlZFBydiAtIHNldCBvbmx5IGlmIHRoZSBwcnYgd2FzIHJlY2VpdmVkIG91dC1vZi1iYW5kLlxuICAgKi9cbiAgYXN5bmMgYWNjZXB0U2hhcmUocGFyYW1zOiBBY2NlcHRTaGFyZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3YWxsZXRTaGFyZUlkJ10sIFsnb3ZlcnJpZGVFbmNyeXB0ZWRQcnYnLCAndXNlclBhc3N3b3JkJywgJ25ld1dhbGxldFBhc3NwaHJhc2UnXSk7XG5cbiAgICBsZXQgZW5jcnlwdGVkUHJ2ID0gcGFyYW1zLm92ZXJyaWRlRW5jcnlwdGVkUHJ2O1xuXG4gICAgY29uc3Qgd2FsbGV0U2hhcmUgPSAoYXdhaXQgdGhpcy5nZXRTaGFyZSh7IHdhbGxldFNoYXJlSWQ6IHBhcmFtcy53YWxsZXRTaGFyZUlkIH0pKSBhcyBhbnk7XG5cbiAgICAvLyBSZXR1cm4gcmlnaHQgYXdheSBpZiB0aGVyZSBpcyBubyBrZXljaGFpbiB0byBkZWNyeXB0LCBvciBpZiBleHBsaWNpdCBlbmNyeXB0ZWRQcnYgd2FzIHByb3ZpZGVkXG4gICAgaWYgKCF3YWxsZXRTaGFyZS5rZXljaGFpbiB8fCAhd2FsbGV0U2hhcmUua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2IHx8IGVuY3J5cHRlZFBydikge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlU2hhcmUoe1xuICAgICAgICB3YWxsZXRTaGFyZUlkOiBwYXJhbXMud2FsbGV0U2hhcmVJZCxcbiAgICAgICAgc3RhdGU6ICdhY2NlcHRlZCcsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBNb3JlIHRoYW4gdmlld2luZyB3YXMgcmVxdWVzdGVkLCBzbyB3ZSBuZWVkIHRvIHByb2Nlc3MgdGhlIHdhbGxldCBrZXlzIHVzaW5nIHRoZSBzaGFyZWQgZWNkaCBzY2hlbWVcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlclBhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1c2VyUGFzc3dvcmQgcGFyYW0gbXVzdCBiZSBwcm92aWRlZCB0byBkZWNyeXB0IHNoYXJlZCBrZXknKTtcbiAgICB9XG5cbiAgICBjb25zdCBzaGFyaW5nS2V5Y2hhaW4gPSAoYXdhaXQgdGhpcy5iaXRnby5nZXRFQ0RIS2V5Y2hhaW4oKSkgYXMgYW55O1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHNoYXJpbmdLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmNyeXB0ZWRYcHJ2IHdhcyBub3QgZm91bmQgb24gc2hhcmluZyBrZXljaGFpbicpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIHRoZSBzaGFyaW5nIGtleWNoYWluLCB3ZSBjYW4gd29yayBvdXQgdGhlIHNlY3JldCB1c2VkIGZvciBzaGFyaW5nIHRoZSB3YWxsZXQgd2l0aCB1c1xuICAgIHNoYXJpbmdLZXljaGFpbi5wcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgcGFzc3dvcmQ6IHBhcmFtcy51c2VyUGFzc3dvcmQsXG4gICAgICBpbnB1dDogc2hhcmluZ0tleWNoYWluLmVuY3J5cHRlZFhwcnYsXG4gICAgfSk7XG4gICAgY29uc3Qgc2VjcmV0ID0gZ2V0U2hhcmVkU2VjcmV0KFxuICAgICAgLy8gRGVyaXZlIGtleSBieSBwYXRoICh3aGljaCBpcyB1c2VkIGJldHdlZW4gdGhlc2UgMiB1c2VycyBvbmx5KVxuICAgICAgYmlwMzIuZnJvbUJhc2U1OChzaGFyaW5nS2V5Y2hhaW4ucHJ2KS5kZXJpdmVQYXRoKHNhbml0aXplTGVnYWN5UGF0aCh3YWxsZXRTaGFyZS5rZXljaGFpbi5wYXRoKSksXG4gICAgICBCdWZmZXIuZnJvbSh3YWxsZXRTaGFyZS5rZXljaGFpbi5mcm9tUHViS2V5LCAnaGV4JylcbiAgICApLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIC8vIFllcyEgV2UgZ290IHRoZSBzZWNyZXQgc3VjY2Vzc2Z1bGx5IGhlcmUsIG5vdyBkZWNyeXB0IHRoZSBzaGFyZWQgd2FsbGV0IHBydlxuICAgIGNvbnN0IGRlY3J5cHRlZFNoYXJlZFdhbGxldFBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICBwYXNzd29yZDogc2VjcmV0LFxuICAgICAgaW5wdXQ6IHdhbGxldFNoYXJlLmtleWNoYWluLmVuY3J5cHRlZFBydixcbiAgICB9KTtcblxuICAgIC8vIFdlIHdpbGwgbm93IHJlLWVuY3J5cHQgdGhlIHdhbGxldCB3aXRoIG91ciBvd24gcGFzc3dvcmRcbiAgICBjb25zdCBuZXdXYWxsZXRQYXNzcGhyYXNlID0gcGFyYW1zLm5ld1dhbGxldFBhc3NwaHJhc2UgfHwgcGFyYW1zLnVzZXJQYXNzd29yZDtcbiAgICBlbmNyeXB0ZWRQcnYgPSB0aGlzLmJpdGdvLmVuY3J5cHQoe1xuICAgICAgcGFzc3dvcmQ6IG5ld1dhbGxldFBhc3NwaHJhc2UsXG4gICAgICBpbnB1dDogZGVjcnlwdGVkU2hhcmVkV2FsbGV0UHJ2LFxuICAgIH0pO1xuICAgIGNvbnN0IHVwZGF0ZVBhcmFtczogVXBkYXRlU2hhcmVPcHRpb25zID0ge1xuICAgICAgd2FsbGV0U2hhcmVJZDogcGFyYW1zLndhbGxldFNoYXJlSWQsXG4gICAgICBzdGF0ZTogJ2FjY2VwdGVkJyxcbiAgICB9O1xuXG4gICAgaWYgKGVuY3J5cHRlZFBydikge1xuICAgICAgdXBkYXRlUGFyYW1zLmVuY3J5cHRlZFBydiA9IGVuY3J5cHRlZFBydjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy51cGRhdGVTaGFyZSh1cGRhdGVQYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHdhbGxldCBieSBpdHMgSURcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmlkIHdhbGxldCBpZFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIGdldFdhbGxldChwYXJhbXM6IEdldFdhbGxldE9wdGlvbnMgPSB7fSk6IFByb21pc2U8V2FsbGV0PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpZCddLCBbXSk7XG5cbiAgICBjb25zdCBxdWVyeTogR2V0V2FsbGV0T3B0aW9ucyA9IHt9O1xuICAgIGlmIChwYXJhbXMuYWxsVG9rZW5zKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5hbGxUb2tlbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhbGxUb2tlbnMgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5hbGxUb2tlbnMgPSBwYXJhbXMuYWxsVG9rZW5zO1xuICAgIH1cblxuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQgfHwgbmV3IFJlcXVlc3RUcmFjZXIoKSk7XG5cbiAgICBjb25zdCB3YWxsZXQgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAuZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0LycgKyBwYXJhbXMuaWQpKVxuICAgICAgLnF1ZXJ5KHF1ZXJ5KVxuICAgICAgLnJlc3VsdCgpO1xuICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIHdhbGxldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgd2FsbGV0IGJ5IGl0cyBhZGRyZXNzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5hZGRyZXNzIHdhbGxldCBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgZ2V0V2FsbGV0QnlBZGRyZXNzKHBhcmFtczogR2V0V2FsbGV0QnlBZGRyZXNzT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxXYWxsZXQ+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgW10pO1xuXG4gICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpKTtcblxuICAgIGNvbnN0IHdhbGxldCA9IGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0L2FkZHJlc3MvJyArIHBhcmFtcy5hZGRyZXNzKSkucmVzdWx0KCk7XG4gICAgcmV0dXJuIG5ldyBXYWxsZXQodGhpcy5iaXRnbywgdGhpcy5iYXNlQ29pbiwgd2FsbGV0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYW55IGdpdmVuIHN1cHBvcnRlZCBjb2luLCBnZXQgdG90YWwgYmFsYW5jZXMgZm9yIGFsbCB3YWxsZXRzIG9mIHRoYXRcbiAgICogY29pbiB0eXBlIG9uIHRoZSBhY2NvdW50LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgZ2V0VG90YWxCYWxhbmNlcyhwYXJhbXM6IFJlY29yZDxzdHJpbmcsIG5ldmVyPiA9IHt9KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvYmFsYW5jZXMnKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgVFNTIG9yIEJMUy1ES0cgV2FsbGV0LlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlTXBjV2FsbGV0KHBhcmFtczogR2VuZXJhdGVNcGNXYWxsZXRPcHRpb25zKTogUHJvbWlzZTxXYWxsZXRXaXRoS2V5Y2hhaW5zPiB7XG4gICAgY29uc3QgcmVxSWQgPSBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihyZXFJZCk7XG5cbiAgICBjb25zdCB3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMgPSB7XG4gICAgICBsYWJlbDogcGFyYW1zLmxhYmVsLFxuICAgICAgbTogMixcbiAgICAgIG46IDMsXG4gICAgICBrZXlzOiBbXSxcbiAgICAgIGlzQ29sZDogZmFsc2UsXG4gICAgICBtdWx0aXNpZ1R5cGU6IHBhcmFtcy5tdWx0aXNpZ1R5cGUsXG4gICAgICBlbnRlcnByaXNlOiBwYXJhbXMuZW50ZXJwcmlzZSxcbiAgICAgIHdhbGxldFZlcnNpb246IHBhcmFtcy53YWxsZXRWZXJzaW9uLFxuICAgIH07XG5cbiAgICAvLyBDcmVhdGUgTVBDIEtleWNoYWluc1xuXG4gICAgY29uc3Qga2V5Y2hhaW5zID0gYXdhaXQgdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5jcmVhdGVNcGMoe1xuICAgICAgbXVsdGlzaWdUeXBlOiBwYXJhbXMubXVsdGlzaWdUeXBlLFxuICAgICAgcGFzc3BocmFzZTogcGFyYW1zLnBhc3NwaHJhc2UsXG4gICAgICBlbnRlcnByaXNlOiBwYXJhbXMuZW50ZXJwcmlzZSxcbiAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZTogcGFyYW1zLm9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICAgIGJhY2t1cFByb3ZpZGVyOiBwYXJhbXMuYmFja3VwUHJvdmlkZXIsXG4gICAgfSk7XG4gICAgY29uc3QgeyB1c2VyS2V5Y2hhaW4sIGJhY2t1cEtleWNoYWluLCBiaXRnb0tleWNoYWluIH0gPSBrZXljaGFpbnM7XG4gICAgd2FsbGV0UGFyYW1zLmtleXMgPSBbdXNlcktleWNoYWluLmlkLCBiYWNrdXBLZXljaGFpbi5pZCwgYml0Z29LZXljaGFpbi5pZF07XG5cbiAgICAvLyBDcmVhdGUgV2FsbGV0XG4gICAgY29uc3QgZmluYWxXYWxsZXRQYXJhbXMgPSBhd2FpdCB0aGlzLmJhc2VDb2luLnN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldCh3YWxsZXRQYXJhbXMsIGtleWNoYWlucyk7XG4gICAgY29uc3QgbmV3V2FsbGV0ID0gYXdhaXQgdGhpcy5iaXRnby5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcvd2FsbGV0JykpLnNlbmQoZmluYWxXYWxsZXRQYXJhbXMpLnJlc3VsdCgpO1xuXG4gICAgY29uc3QgcmVzdWx0OiBXYWxsZXRXaXRoS2V5Y2hhaW5zID0ge1xuICAgICAgd2FsbGV0OiBuZXcgV2FsbGV0KHRoaXMuYml0Z28sIHRoaXMuYmFzZUNvaW4sIG5ld1dhbGxldCksXG4gICAgICB1c2VyS2V5Y2hhaW4sXG4gICAgICBiYWNrdXBLZXljaGFpbixcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgfTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChiYWNrdXBLZXljaGFpbi5wcnYpICYmICFfLmlzVW5kZWZpbmVkKHBhcmFtcy5iYWNrdXBQcm92aWRlcikpIHtcbiAgICAgIHJlc3VsdC53YXJuaW5nID0gJ0JlIHN1cmUgdG8gYmFja3VwIHRoZSBiYWNrdXAga2V5Y2hhaW4gLS0gaXQgaXMgbm90IHN0b3JlZCBhbnl3aGVyZSBlbHNlISc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuIl19