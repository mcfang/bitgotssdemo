"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLightningInvoice = exports.validateLnurlInvoice = exports.fetchLnurlPayInvoice = exports.decodeLnurlPay = void 0;
const bolt11 = __importStar(require("bolt11"));
const crypto = __importStar(require("crypto"));
const request = __importStar(require("superagent"));
const iLightning_1 = require("./iLightning");
const lnurlCodec_1 = require("./lnurlCodec");
const decode_1 = require("../utils/decode");
/**
 * Decodes an LNURL-pay request and makes an HTTP request to the decoded url
 * to retrieve details for the requested payment.
 * @param lnurl A bech32 encoded LNURL-pay request string
 * @returns {DecodedLnurlPayRequest} An LNURL-pay request message specifying
 * a min and max amount for the payment, metadata describing what the payment
 * is for, and a callback that can be used to fetch a lightning invoice for
 * the payment.
 */
async function decodeLnurlPay(lnurl) {
    const url = lnurlCodec_1.decodeLnurl(lnurl);
    const { body } = await request.get(url);
    const decodedRes = decode_1.decodeOrElse(iLightning_1.LnurlPayResponse.name, iLightning_1.LnurlPayResponse, body, (errors) => {
        throw new Error(`error(s) parsing lnurl response: ${errors}`);
    });
    const domain = new URL(url).hostname;
    return {
        ...decodedRes,
        domain,
    };
}
exports.decodeLnurlPay = decodeLnurlPay;
/**
 * Fetches a lightning invoice from an LNURL-pay callback server for a specified
 * amount of millisatoshis.
 * @param params {LnurlPayParams} An object specifying an amount and a callback
 * url with which to request a lightning invoice for an LNURL-pay request.
 * @returns {string} A BOLT #11 encoded lightning invoice
 */
async function fetchLnurlPayInvoice(params) {
    const { callback, millisatAmount, metadata } = params;
    const { pr: invoice } = callback.includes('?')
        ? (await request.get(callback + `&amount=${millisatAmount}`)).body
        : (await request.get(callback).query({ amount: millisatAmount })).body;
    const parsedInvoice = parseLightningInvoice(invoice);
    validateLnurlInvoice(parsedInvoice, millisatAmount, metadata);
    return invoice;
}
exports.fetchLnurlPayInvoice = fetchLnurlPayInvoice;
function getNetworkForInvoice(invoice) {
    if (invoice.startsWith('lntbs')) {
        // signet invoices are not supported by our bolt11 dependency
        // because the `tbs` prefix used for the invoice does not match the `tb`
        // prefix used by on-chain signet addresses
        // see: https://github.com/bitcoinjs/bolt11/pull/58#issuecomment-1106495709
        // we can still decode the invoice however using a custom network
        return {
            bech32: 'tbs',
            pubKeyHash: 0x6f,
            scriptHash: 0xc4,
            validWitnessVersions: [0, 1],
        };
    }
    return undefined;
}
/**
 * @param {ParsedLightningInvoice} invoice - a parsed lightning invoice
 * @param {number} amount - amount intended to pay for the invoice
 * @param {string} metadata - metadata that is used to verify the fetched invoice
 * @throws error for invoice that does not match with amount and metadata
 */
function validateLnurlInvoice(invoice, millisatAmount, metadata) {
    const { millisatoshis, descriptionHash } = invoice;
    if (millisatoshis !== millisatAmount) {
        throw new Error('amount of invoice does not match with given amount');
    }
    const hash = crypto.createHash('sha256').update(metadata).digest('hex');
    if (descriptionHash !== hash) {
        throw new Error('invoice h tag does not match with hash of metadata');
    }
}
exports.validateLnurlInvoice = validateLnurlInvoice;
/**
 * @param {unknown} invoiceStr - a lightning invoice
 * @return {ParsedLightningInvoice}
 * @throws error for invalid lightning invoice
 */
function parseLightningInvoice(invoiceStr) {
    var _a, _b;
    if (typeof invoiceStr !== 'string') {
        throw new Error('invoice is malformed');
    }
    const decodedInvoice = bolt11.decode(invoiceStr, getNetworkForInvoice(invoiceStr));
    if (decodedInvoice.network === undefined) {
        throw new Error('invoice network is invalid');
    }
    const { millisatoshis, tags, payeeNodeKey } = decodedInvoice;
    const paymentHash = (_a = tags.find((tag) => tag.tagName === 'payment_hash')) === null || _a === void 0 ? void 0 : _a.data;
    if (paymentHash === undefined || typeof paymentHash !== 'string') {
        throw new Error('invoice payment hash is invalid');
    }
    if (payeeNodeKey === undefined) {
        throw new Error('invoice payee pub key is invalid');
    }
    if (millisatoshis === undefined) {
        throw new Error('invoice millisatoshis amount is invalid');
    }
    const descriptionHash = (_b = tags.find((tag) => tag.tagName === 'purpose_commit_hash')) === null || _b === void 0 ? void 0 : _b.data;
    if (descriptionHash !== undefined && typeof descriptionHash !== 'string') {
        throw new Error('invoice description hash is invalid');
    }
    return { millisatoshis, paymentHash, payeeNodeKey, descriptionHash };
}
exports.parseLightningInvoice = parseLightningInvoice;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGlnaHRuaW5nVXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYml0Z28vbGlnaHRuaW5nL2xpZ2h0bmluZ1V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQ0FBaUM7QUFDakMsK0NBQWlDO0FBQ2pDLG9EQUFzQztBQUN0Qyw2Q0FBd0Y7QUFDeEYsNkNBQTJDO0FBQzNDLDRDQUErQztBQWdCL0M7Ozs7Ozs7O0dBUUc7QUFDSSxLQUFLLFVBQVUsY0FBYyxDQUFDLEtBQWE7SUFDaEQsTUFBTSxHQUFHLEdBQUcsd0JBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMvQixNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLE1BQU0sVUFBVSxHQUFHLHFCQUFZLENBQUMsNkJBQWdCLENBQUMsSUFBSSxFQUFFLDZCQUFnQixFQUFFLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFO1FBQ3hGLE1BQU0sSUFBSSxLQUFLLENBQUMsb0NBQW9DLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDaEUsQ0FBQyxDQUFDLENBQUM7SUFDSCxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUM7SUFFckMsT0FBTztRQUNMLEdBQUcsVUFBVTtRQUNiLE1BQU07S0FDUCxDQUFDO0FBQ0osQ0FBQztBQVpELHdDQVlDO0FBRUQ7Ozs7OztHQU1HO0FBQ0ksS0FBSyxVQUFVLG9CQUFvQixDQUFDLE1BQXNCO0lBQy9ELE1BQU0sRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxHQUFHLE1BQU0sQ0FBQztJQUN0RCxNQUFNLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxHQUFHLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDO1FBQzVDLENBQUMsQ0FB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QUFHLE1BQUEsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLE9BQU8sS0FBSyxxQkFBcUIsQ0FBQywwQ0FBRSxJQUFJLENBQUM7SUFDeEYsSUFBSSxlQUFlLEtBQUssU0FBUyxJQUFJLE9BQU8sZUFBZSxLQUFLLFFBQVEsRUFBRTtRQUN4RSxNQUFNLElBQUksS0FBSyxDQUFDLHFDQUFxQyxDQUFDLENBQUM7S0FDeEQ7SUFFRCxPQUFPLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsZUFBZSxFQUFFLENBQUM7QUFDdkUsQ0FBQztBQTlCRCxzREE4QkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBib2x0MTEgZnJvbSAnYm9sdDExJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCB7IERlY29kZWRMbnVybFBheVJlcXVlc3QsIExudXJsUGF5UGFyYW1zLCBMbnVybFBheVJlc3BvbnNlIH0gZnJvbSAnLi9pTGlnaHRuaW5nJztcbmltcG9ydCB7IGRlY29kZUxudXJsIH0gZnJvbSAnLi9sbnVybENvZGVjJztcbmltcG9ydCB7IGRlY29kZU9yRWxzZSB9IGZyb20gJy4uL3V0aWxzL2RlY29kZSc7XG5cbmV4cG9ydCB0eXBlIFBhcnNlZExpZ2h0bmluZ0ludm9pY2UgPSB7XG4gIC8qKlxuICAgKiBUaGUgYW1vdW50IG9mIG1pbGxpc2F0b3NoaSByZXF1ZXN0ZWQgYnkgdGhpcyBpbnZvaWNlLiBJZiBudWxsIHRoZW5cbiAgICogdGhlIGludm9pY2UgZG9lcyBub3Qgc3BlY2lmeSBhbiBhbW91bnQgYW5kIHdpbGwgYWNjZXB0IGFueSBwYXltZW50LlxuICAgKi9cbiAgbWlsbGlzYXRvc2hpczogc3RyaW5nIHwgbnVsbDtcbiAgLyoqIFRoZSBoZXggZW5jb2RlZCBwYXltZW50IGhhc2ggZm9yIHRoZSBpbnZvaWNlICovXG4gIHBheW1lbnRIYXNoOiBzdHJpbmc7XG4gIC8qKiBUaGUgaGV4IGVuY29kZWQgbm9kZSBwdWIga2V5IG9mIHRoZSBwYXllZSB0aGF0IGNyZWF0ZWQgdGhlIGludm9pY2UgKi9cbiAgcGF5ZWVOb2RlS2V5OiBzdHJpbmc7XG4gIC8qKiBUaGUgaGV4IGVuY29kZWQgU0hBMjU2IGhhc2ggb2YgdGhlIGRlc2NyaXB0aW9uIG9mIHdoYXQgdGhlIGludm9pY2UgaXMgZm9yICovXG4gIGRlc2NyaXB0aW9uSGFzaD86IHN0cmluZztcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhbiBMTlVSTC1wYXkgcmVxdWVzdCBhbmQgbWFrZXMgYW4gSFRUUCByZXF1ZXN0IHRvIHRoZSBkZWNvZGVkIHVybFxuICogdG8gcmV0cmlldmUgZGV0YWlscyBmb3IgdGhlIHJlcXVlc3RlZCBwYXltZW50LlxuICogQHBhcmFtIGxudXJsIEEgYmVjaDMyIGVuY29kZWQgTE5VUkwtcGF5IHJlcXVlc3Qgc3RyaW5nXG4gKiBAcmV0dXJucyB7RGVjb2RlZExudXJsUGF5UmVxdWVzdH0gQW4gTE5VUkwtcGF5IHJlcXVlc3QgbWVzc2FnZSBzcGVjaWZ5aW5nXG4gKiBhIG1pbiBhbmQgbWF4IGFtb3VudCBmb3IgdGhlIHBheW1lbnQsIG1ldGFkYXRhIGRlc2NyaWJpbmcgd2hhdCB0aGUgcGF5bWVudFxuICogaXMgZm9yLCBhbmQgYSBjYWxsYmFjayB0aGF0IGNhbiBiZSB1c2VkIHRvIGZldGNoIGEgbGlnaHRuaW5nIGludm9pY2UgZm9yXG4gKiB0aGUgcGF5bWVudC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlY29kZUxudXJsUGF5KGxudXJsOiBzdHJpbmcpOiBQcm9taXNlPERlY29kZWRMbnVybFBheVJlcXVlc3Q+IHtcbiAgY29uc3QgdXJsID0gZGVjb2RlTG51cmwobG51cmwpO1xuICBjb25zdCB7IGJvZHkgfSA9IGF3YWl0IHJlcXVlc3QuZ2V0KHVybCk7XG4gIGNvbnN0IGRlY29kZWRSZXMgPSBkZWNvZGVPckVsc2UoTG51cmxQYXlSZXNwb25zZS5uYW1lLCBMbnVybFBheVJlc3BvbnNlLCBib2R5LCAoZXJyb3JzKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBlcnJvcihzKSBwYXJzaW5nIGxudXJsIHJlc3BvbnNlOiAke2Vycm9yc31gKTtcbiAgfSk7XG4gIGNvbnN0IGRvbWFpbiA9IG5ldyBVUkwodXJsKS5ob3N0bmFtZTtcblxuICByZXR1cm4ge1xuICAgIC4uLmRlY29kZWRSZXMsXG4gICAgZG9tYWluLFxuICB9O1xufVxuXG4vKipcbiAqIEZldGNoZXMgYSBsaWdodG5pbmcgaW52b2ljZSBmcm9tIGFuIExOVVJMLXBheSBjYWxsYmFjayBzZXJ2ZXIgZm9yIGEgc3BlY2lmaWVkXG4gKiBhbW91bnQgb2YgbWlsbGlzYXRvc2hpcy5cbiAqIEBwYXJhbSBwYXJhbXMge0xudXJsUGF5UGFyYW1zfSBBbiBvYmplY3Qgc3BlY2lmeWluZyBhbiBhbW91bnQgYW5kIGEgY2FsbGJhY2tcbiAqIHVybCB3aXRoIHdoaWNoIHRvIHJlcXVlc3QgYSBsaWdodG5pbmcgaW52b2ljZSBmb3IgYW4gTE5VUkwtcGF5IHJlcXVlc3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIEJPTFQgIzExIGVuY29kZWQgbGlnaHRuaW5nIGludm9pY2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTG51cmxQYXlJbnZvaWNlKHBhcmFtczogTG51cmxQYXlQYXJhbXMpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCB7IGNhbGxiYWNrLCBtaWxsaXNhdEFtb3VudCwgbWV0YWRhdGEgfSA9IHBhcmFtcztcbiAgY29uc3QgeyBwcjogaW52b2ljZSB9ID0gY2FsbGJhY2suaW5jbHVkZXMoJz8nKVxuICAgID8gKGF3YWl0IHJlcXVlc3QuZ2V0KGNhbGxiYWNrICsgYCZhbW91bnQ9JHttaWxsaXNhdEFtb3VudH1gKSkuYm9keVxuICAgIDogKGF3YWl0IHJlcXVlc3QuZ2V0KGNhbGxiYWNrKS5xdWVyeSh7IGFtb3VudDogbWlsbGlzYXRBbW91bnQgfSkpLmJvZHk7XG4gIGNvbnN0IHBhcnNlZEludm9pY2UgPSBwYXJzZUxpZ2h0bmluZ0ludm9pY2UoaW52b2ljZSk7XG4gIHZhbGlkYXRlTG51cmxJbnZvaWNlKHBhcnNlZEludm9pY2UsIG1pbGxpc2F0QW1vdW50LCBtZXRhZGF0YSk7XG5cbiAgcmV0dXJuIGludm9pY2U7XG59XG5cbmZ1bmN0aW9uIGdldE5ldHdvcmtGb3JJbnZvaWNlKGludm9pY2U6IHN0cmluZykge1xuICBpZiAoaW52b2ljZS5zdGFydHNXaXRoKCdsbnRicycpKSB7XG4gICAgLy8gc2lnbmV0IGludm9pY2VzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IG91ciBib2x0MTEgZGVwZW5kZW5jeVxuICAgIC8vIGJlY2F1c2UgdGhlIGB0YnNgIHByZWZpeCB1c2VkIGZvciB0aGUgaW52b2ljZSBkb2VzIG5vdCBtYXRjaCB0aGUgYHRiYFxuICAgIC8vIHByZWZpeCB1c2VkIGJ5IG9uLWNoYWluIHNpZ25ldCBhZGRyZXNzZXNcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYm9sdDExL3B1bGwvNTgjaXNzdWVjb21tZW50LTExMDY0OTU3MDlcbiAgICAvLyB3ZSBjYW4gc3RpbGwgZGVjb2RlIHRoZSBpbnZvaWNlIGhvd2V2ZXIgdXNpbmcgYSBjdXN0b20gbmV0d29ya1xuICAgIHJldHVybiB7XG4gICAgICBiZWNoMzI6ICd0YnMnLFxuICAgICAgcHViS2V5SGFzaDogMHg2ZixcbiAgICAgIHNjcmlwdEhhc2g6IDB4YzQsXG4gICAgICB2YWxpZFdpdG5lc3NWZXJzaW9uczogWzAsIDFdLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UGFyc2VkTGlnaHRuaW5nSW52b2ljZX0gaW52b2ljZSAtIGEgcGFyc2VkIGxpZ2h0bmluZyBpbnZvaWNlXG4gKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gYW1vdW50IGludGVuZGVkIHRvIHBheSBmb3IgdGhlIGludm9pY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRhZGF0YSAtIG1ldGFkYXRhIHRoYXQgaXMgdXNlZCB0byB2ZXJpZnkgdGhlIGZldGNoZWQgaW52b2ljZVxuICogQHRocm93cyBlcnJvciBmb3IgaW52b2ljZSB0aGF0IGRvZXMgbm90IG1hdGNoIHdpdGggYW1vdW50IGFuZCBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMbnVybEludm9pY2UoaW52b2ljZTogUGFyc2VkTGlnaHRuaW5nSW52b2ljZSwgbWlsbGlzYXRBbW91bnQ6IHN0cmluZywgbWV0YWRhdGE6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCB7IG1pbGxpc2F0b3NoaXMsIGRlc2NyaXB0aW9uSGFzaCB9ID0gaW52b2ljZTtcbiAgaWYgKG1pbGxpc2F0b3NoaXMgIT09IG1pbGxpc2F0QW1vdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhbW91bnQgb2YgaW52b2ljZSBkb2VzIG5vdCBtYXRjaCB3aXRoIGdpdmVuIGFtb3VudCcpO1xuICB9XG5cbiAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUobWV0YWRhdGEpLmRpZ2VzdCgnaGV4Jyk7XG4gIGlmIChkZXNjcmlwdGlvbkhhc2ggIT09IGhhc2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludm9pY2UgaCB0YWcgZG9lcyBub3QgbWF0Y2ggd2l0aCBoYXNoIG9mIG1ldGFkYXRhJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3Vua25vd259IGludm9pY2VTdHIgLSBhIGxpZ2h0bmluZyBpbnZvaWNlXG4gKiBAcmV0dXJuIHtQYXJzZWRMaWdodG5pbmdJbnZvaWNlfVxuICogQHRocm93cyBlcnJvciBmb3IgaW52YWxpZCBsaWdodG5pbmcgaW52b2ljZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VMaWdodG5pbmdJbnZvaWNlKGludm9pY2VTdHI6IHVua25vd24pOiBQYXJzZWRMaWdodG5pbmdJbnZvaWNlIHtcbiAgaWYgKHR5cGVvZiBpbnZvaWNlU3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52b2ljZSBpcyBtYWxmb3JtZWQnKTtcbiAgfVxuXG4gIGNvbnN0IGRlY29kZWRJbnZvaWNlID0gYm9sdDExLmRlY29kZShpbnZvaWNlU3RyLCBnZXROZXR3b3JrRm9ySW52b2ljZShpbnZvaWNlU3RyKSk7XG5cbiAgaWYgKGRlY29kZWRJbnZvaWNlLm5ldHdvcmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52b2ljZSBuZXR3b3JrIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIGNvbnN0IHsgbWlsbGlzYXRvc2hpcywgdGFncywgcGF5ZWVOb2RlS2V5IH0gPSBkZWNvZGVkSW52b2ljZTtcblxuICBjb25zdCBwYXltZW50SGFzaCA9IHRhZ3MuZmluZCgodGFnKSA9PiB0YWcudGFnTmFtZSA9PT0gJ3BheW1lbnRfaGFzaCcpPy5kYXRhO1xuICBpZiAocGF5bWVudEhhc2ggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgcGF5bWVudEhhc2ggIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZvaWNlIHBheW1lbnQgaGFzaCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgaWYgKHBheWVlTm9kZUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZvaWNlIHBheWVlIHB1YiBrZXkgaXMgaW52YWxpZCcpO1xuICB9XG4gIGlmIChtaWxsaXNhdG9zaGlzID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludm9pY2UgbWlsbGlzYXRvc2hpcyBhbW91bnQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgY29uc3QgZGVzY3JpcHRpb25IYXNoID0gdGFncy5maW5kKCh0YWcpID0+IHRhZy50YWdOYW1lID09PSAncHVycG9zZV9jb21taXRfaGFzaCcpPy5kYXRhO1xuICBpZiAoZGVzY3JpcHRpb25IYXNoICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGRlc2NyaXB0aW9uSGFzaCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludm9pY2UgZGVzY3JpcHRpb24gaGFzaCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4geyBtaWxsaXNhdG9zaGlzLCBwYXltZW50SGFzaCwgcGF5ZWVOb2RlS2V5LCBkZXNjcmlwdGlvbkhhc2ggfTtcbn1cbiJdfQ==