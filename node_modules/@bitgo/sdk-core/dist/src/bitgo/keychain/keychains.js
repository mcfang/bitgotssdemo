"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Keychains = void 0;
const _ = __importStar(require("lodash"));
const assert_1 = __importDefault(require("assert"));
const common = __importStar(require("../../common"));
const utils_1 = require("../utils");
const decode_1 = require("../utils/decode");
const ovcJsonCodec_1 = require("./ovcJsonCodec");
class Keychains {
    constructor(bitgo, baseCoin) {
        this.bitgo = bitgo;
        this.baseCoin = baseCoin;
    }
    /**
     * Get a keychain by ID
     * @param params
     * @param params.id
     * @param params.xpub (optional)
     * @param params.ethAddress (optional)
     * @param params.reqId (optional)
     */
    async get(params) {
        common.validateParams(params, [], ['xpub', 'ethAddress']);
        if (_.isUndefined(params.id)) {
            throw new Error('id must be defined');
        }
        const id = params.id;
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return await this.bitgo.get(this.baseCoin.url('/key/' + encodeURIComponent(id))).result();
    }
    /**
     * list the users keychains
     * @param params
     * @param params.limit - Max number of results in a single call.
     * @param params.prevId - Continue iterating (provided by nextBatchPrevId in the previous list)
     * @returns {*}
     */
    async list(params = {}) {
        const queryObject = {};
        if (!_.isUndefined(params.limit)) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            queryObject.limit = params.limit;
        }
        if (!_.isUndefined(params.prevId)) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            queryObject.prevId = params.prevId;
        }
        return this.bitgo.get(this.baseCoin.url('/key')).query(queryObject).result();
    }
    /**
     * Change the decryption password for all possible keychains associated with a user.
     *
     * This function iterates through all keys associated with the user, decrypts
     * them with the old password and re-encrypts them with the new password.
     *
     * This should be called when a user changes their login password, and are expecting
     * that their wallet passwords are changed to match the new login password.
     *
     * @param params
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns changedKeys Object - e.g.:
     *  {
     *    xpub1: encryptedPrv,
     *    ...
     *  }
     */
    async updatePassword(params) {
        common.validateParams(params, ['oldPassword', 'newPassword'], []);
        const changedKeys = {};
        let prevId;
        let keysLeft = true;
        while (keysLeft) {
            const result = await this.list({ limit: 500, prevId });
            for (const key of result.keys) {
                const oldEncryptedPrv = key.encryptedPrv;
                if (_.isUndefined(oldEncryptedPrv)) {
                    continue;
                }
                try {
                    const updatedKeychain = this.updateSingleKeychainPassword({
                        keychain: key,
                        oldPassword: params.oldPassword,
                        newPassword: params.newPassword,
                    });
                    if (updatedKeychain.encryptedPrv) {
                        const changedKeyIdentifier = updatedKeychain.type === 'tss' ? updatedKeychain.commonKeychain : updatedKeychain.pub;
                        if (changedKeyIdentifier) {
                            changedKeys[changedKeyIdentifier] = updatedKeychain.encryptedPrv;
                        }
                    }
                }
                catch (e) {
                    // if the password was incorrect, silence the error, throw otherwise
                    if (!e.message.includes('private key is incorrect')) {
                        throw e;
                    }
                }
            }
            if (result.nextBatchPrevId) {
                prevId = result.nextBatchPrevId;
            }
            else {
                keysLeft = false;
            }
        }
        return changedKeys;
    }
    /**
     * Update the password used to decrypt a single keychain
     * @param params
     * @param params.keychain - The keychain whose password should be updated
     * @param params.oldPassword - The old password used for encrypting the key
     * @param params.newPassword - The new password to be used for encrypting the key
     * @returns {object}
     */
    updateSingleKeychainPassword(params = {}) {
        if (!_.isString(params.oldPassword)) {
            throw new Error('expected old password to be a string');
        }
        if (!_.isString(params.newPassword)) {
            throw new Error('expected new password to be a string');
        }
        if (!_.isObject(params.keychain) || !_.isString(params.keychain.encryptedPrv)) {
            throw new Error('expected keychain to be an object with an encryptedPrv property');
        }
        const oldEncryptedPrv = params.keychain.encryptedPrv;
        try {
            const decryptedPrv = this.bitgo.decrypt({ input: oldEncryptedPrv, password: params.oldPassword });
            const newEncryptedPrv = this.bitgo.encrypt({ input: decryptedPrv, password: params.newPassword });
            return _.assign({}, params.keychain, { encryptedPrv: newEncryptedPrv });
        }
        catch (e) {
            // catching an error here means that the password was incorrect or, less likely, the input to decrypt is corrupted
            throw new Error('password used to decrypt keychain private key is incorrect');
        }
    }
    /**
     * Create a public/private key pair
     * @param params.seed
     */
    create(params = {}) {
        return this.baseCoin.generateKeyPair(params.seed);
    }
    /**
     * Add a keychain to BitGo's records
     * @param params
     */
    async add(params = {}) {
        params = params || {};
        common.validateParams(params, [], [
            'pub',
            'encryptedPrv',
            'keyType',
            'type',
            'source',
            'originalPasscodeEncryptionCode',
            'enterprise',
            'derivedFromParentWithSeed',
        ]);
        if (!_.isUndefined(params.disableKRSEmail)) {
            if (!_.isBoolean(params.disableKRSEmail)) {
                throw new Error('invalid disableKRSEmail argument, expecting boolean');
            }
        }
        if (params.reqId) {
            this.bitgo.setRequestTracer(params.reqId);
        }
        return await this.bitgo
            .post(this.baseCoin.url('/key'))
            .send({
            pub: params.pub,
            commonPub: params.commonPub,
            commonKeychain: params.commonKeychain,
            encryptedPrv: params.encryptedPrv,
            type: params.type,
            keyType: params.keyType,
            source: params.source,
            provider: params.provider,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            enterprise: params.enterprise,
            derivedFromParentWithSeed: params.derivedFromParentWithSeed,
            disableKRSEmail: params.disableKRSEmail,
            krsSpecific: params.krsSpecific,
            keyShares: params.keyShares,
            userGPGPublicKey: params.userGPGPublicKey,
            backupGPGPublicKey: params.backupGPGPublicKey,
            algoUsed: params.algoUsed,
            isDistributedCustody: params.isDistributedCustody,
        })
            .result();
    }
    /**
     * Create a BitGo key
     * @param params (empty)
     */
    async createBitGo(params = {}) {
        params.source = 'bitgo';
        this.baseCoin.preCreateBitGo(params);
        return await this.add(params);
    }
    /**
     * Create a backup key
     * @param params
     * @param params.provider (optional)
     */
    async createBackup(params = {}) {
        params.source = 'backup';
        const isTssBackupKey = params.prv && (params.commonKeychain || params.commonPub);
        if (_.isUndefined(params.provider) && !isTssBackupKey) {
            // if the provider is undefined, we generate a local key and add the source details
            const key = this.create();
            _.extend(params, key);
        }
        const serverResponse = await this.add(params);
        return _.extend({}, serverResponse, _.pick(params, ['prv', 'encryptedPrv', 'provider', 'source']));
    }
    /**
     * Gets keys for signing from a wallet
     * @param params
     * @returns {Promise<Keychain[]>}
     */
    async getKeysForSigning(params = {}) {
        if (!_.isObject(params.wallet)) {
            throw new Error('missing required param wallet');
        }
        const wallet = params.wallet;
        const reqId = params.reqId || new utils_1.RequestTracer();
        const ids = wallet.baseCoin.keyIdsForSigning();
        const keychainQueriesBluebirds = ids.map((id) => this.get({ id: wallet.keyIds()[id], reqId }));
        return Promise.all(keychainQueriesBluebirds);
    }
    /**
     * Convenience function to create and store MPC keychains with BitGo.
     * @param params passphrase used to encrypt secret materials
     * @return {Promise<KeychainsTriplet>} newly created User, Backup, and BitGo keys
     */
    async createMpc(params) {
        let MpcUtils;
        switch (params.multisigType) {
            case 'tss':
                MpcUtils = this.baseCoin.getMPCAlgorithm() === 'ecdsa' ? utils_1.ECDSAUtils.EcdsaUtils : utils_1.EDDSAUtils.default;
                break;
            case 'blsdkg':
                if (_.isUndefined(params.passphrase)) {
                    throw new Error('missing required param passphrase');
                }
                MpcUtils = utils_1.BlsUtils;
                break;
            default:
                throw new Error('Unsupported multi-sig type');
        }
        const mpcUtils = new MpcUtils(this.bitgo, this.baseCoin);
        return await mpcUtils.createKeychains({
            passphrase: params.passphrase,
            enterprise: params.enterprise,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            backupProvider: params.backupProvider,
        });
    }
    /**
     * It parses the JSON downloaded from the OVC for platform (BitGo),
     * and creates a corresponding TSS BitGo key. It also returns the JSON that needs
     * to be uploaded back to the OVCs containing the BitGo -> OVC shares.
     * @param ovcOutputJson JSON format of the file downloaded from the OVC for platform
     * @returns {BitGoKeyFromOvcShares}
     */
    async createTssBitGoKeyFromOvcShares(ovcOutputJson) {
        var _a, _b, _c, _d;
        const decodedOvcOutput = decode_1.decodeOrElse(ovcJsonCodec_1.OvcToBitGoJSON.name, ovcJsonCodec_1.OvcToBitGoJSON, ovcOutputJson, (errors) => {
            throw new Error(`Error(s) parsing OVC JSON: ${errors}`);
        });
        if (decodedOvcOutput.state !== 1) {
            throw new Error('State expected to be "1". Please complete the first two OVC operations');
        }
        // OVC-1 is responsible for the User key
        const ovc1 = decodedOvcOutput.ovc[1];
        // OVC-2 is responsible for the Backup key
        const ovc2 = decodedOvcOutput.ovc[2];
        const keyShares = [
            {
                from: 'user',
                to: 'bitgo',
                publicShare: ovc1.ovcToBitgoShare.publicShare,
                privateShare: ovc1.ovcToBitgoShare.privateShare,
                privateShareProof: (_a = ovc1.ovcToBitgoShare.uSig.toString()) !== null && _a !== void 0 ? _a : '',
                vssProof: (_b = ovc1.ovcToBitgoShare.vssProof) !== null && _b !== void 0 ? _b : '',
            },
            {
                from: 'backup',
                to: 'bitgo',
                publicShare: ovc2.ovcToBitgoShare.publicShare,
                privateShare: ovc2.ovcToBitgoShare.privateShare,
                privateShareProof: (_c = ovc2.ovcToBitgoShare.uSig.toString()) !== null && _c !== void 0 ? _c : '',
                vssProof: (_d = ovc2.ovcToBitgoShare.vssProof) !== null && _d !== void 0 ? _d : '',
            },
        ];
        const key = await this.baseCoin.keychains().add({
            source: 'bitgo',
            keyShares,
            keyType: 'tss',
            userGPGPublicKey: ovc1.gpgPubKey,
            backupGPGPublicKey: ovc2.gpgPubKey,
        });
        assert_1.default(key.keyShares);
        assert_1.default(key.commonKeychain);
        assert_1.default(key.walletHSMGPGPublicKeySigs);
        const bitgoToUserShare = key.keyShares.find((value) => value.from === 'bitgo' && value.to === 'user');
        assert_1.default(bitgoToUserShare);
        assert_1.default(bitgoToUserShare.vssProof);
        assert_1.default(bitgoToUserShare.paillierPublicKey);
        const bitgoToBackupShare = key.keyShares.find((value) => value.from === 'bitgo' && value.to === 'backup');
        assert_1.default(bitgoToBackupShare);
        assert_1.default(bitgoToBackupShare.vssProof);
        assert_1.default(bitgoToBackupShare.paillierPublicKey);
        // Create JSON data with platform shares for OVC-1 and OVC-2
        const bitgoToOvcOutput = {
            wallet: {
                ...decodedOvcOutput,
                platform: {
                    commonKeychain: key.commonKeychain,
                    walletGpgPubKeySigs: key.walletHSMGPGPublicKeySigs,
                    ovc: {
                        // BitGo to User (OVC-1)
                        1: {
                            bitgoToOvcShare: {
                                i: 1,
                                j: 3,
                                publicShare: bitgoToUserShare.publicShare,
                                privateShare: bitgoToUserShare.privateShare,
                                paillierPublicKey: bitgoToUserShare.paillierPublicKey,
                                vssProof: bitgoToUserShare.vssProof,
                            },
                        },
                        // BitGo to Backup (OVC-2)
                        2: {
                            bitgoToOvcShare: {
                                i: 2,
                                j: 3,
                                publicShare: bitgoToBackupShare.publicShare,
                                privateShare: bitgoToBackupShare.privateShare,
                                paillierPublicKey: bitgoToBackupShare.paillierPublicKey,
                                vssProof: bitgoToBackupShare.vssProof,
                            },
                        },
                    },
                },
            },
        };
        // Mark it ready for next operation, should be 2
        bitgoToOvcOutput.wallet.state += 1;
        const output = {
            bitGoKeyId: key.id,
            bitGoOutputJsonForOvc: bitgoToOvcOutput,
        };
        return decode_1.decodeOrElse(ovcJsonCodec_1.BitGoKeyFromOvcShares.name, ovcJsonCodec_1.BitGoKeyFromOvcShares, output, (errors) => {
            throw new Error(`Error producing the output: ${errors}`);
        });
    }
}
exports.Keychains = Keychains;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5Y2hhaW5zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL2tleWNoYWluL2tleWNoYWlucy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMENBQTRCO0FBQzVCLG9EQUE0QjtBQUM1QixxREFBdUM7QUFHdkMsb0NBQTJFO0FBaUIzRSw0Q0FBK0M7QUFDL0MsaURBQXVGO0FBRXZGLE1BQWEsU0FBUztJQUlwQixZQUFZLEtBQWdCLEVBQUUsUUFBbUI7UUFDL0MsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQTBCO1FBQ2xDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1FBRTFELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUNyQixJQUFJLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDaEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDM0M7UUFDRCxPQUFPLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxHQUFHLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUM1RixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lB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LENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQS9ZRCw4QkErWUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi4vLi4vY29tbW9uJztcbmltcG9ydCB7IElCYXNlQ29pbiwgS2V5Y2hhaW5zVHJpcGxldCwgS2V5UGFpciB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBCbHNVdGlscywgUmVxdWVzdFRyYWNlciwgRUREU0FVdGlscywgRUNEU0FVdGlscyB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIEFkZEtleWNoYWluT3B0aW9ucyxcbiAgQXBpS2V5U2hhcmUsXG4gIENoYW5nZWRLZXljaGFpbnMsXG4gIENyZWF0ZUJhY2t1cE9wdGlvbnMsXG4gIENyZWF0ZUJpdEdvT3B0aW9ucyxcbiAgQ3JlYXRlTXBjT3B0aW9ucyxcbiAgR2V0S2V5Y2hhaW5PcHRpb25zLFxuICBHZXRLZXlzRm9yU2lnbmluZ09wdGlvbnMsXG4gIElLZXljaGFpbnMsXG4gIEtleWNoYWluLFxuICBMaXN0S2V5Y2hhaW5PcHRpb25zLFxuICBMaXN0S2V5Y2hhaW5zUmVzdWx0LFxuICBVcGRhdGVQYXNzd29yZE9wdGlvbnMsXG4gIFVwZGF0ZVNpbmdsZUtleWNoYWluUGFzc3dvcmRPcHRpb25zLFxufSBmcm9tICcuL2lLZXljaGFpbnMnO1xuaW1wb3J0IHsgZGVjb2RlT3JFbHNlIH0gZnJvbSAnLi4vdXRpbHMvZGVjb2RlJztcbmltcG9ydCB7IEJpdEdvS2V5RnJvbU92Y1NoYXJlcywgQml0R29Ub092Y0pTT04sIE92Y1RvQml0R29KU09OIH0gZnJvbSAnLi9vdmNKc29uQ29kZWMnO1xuXG5leHBvcnQgY2xhc3MgS2V5Y2hhaW5zIGltcGxlbWVudHMgSUtleWNoYWlucyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYml0Z286IEJpdEdvQmFzZTtcbiAgcHJpdmF0ZSByZWFkb25seSBiYXNlQ29pbjogSUJhc2VDb2luO1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIGJhc2VDb2luOiBJQmFzZUNvaW4pIHtcbiAgICB0aGlzLmJpdGdvID0gYml0Z287XG4gICAgdGhpcy5iYXNlQ29pbiA9IGJhc2VDb2luO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGtleWNoYWluIGJ5IElEXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5pZFxuICAgKiBAcGFyYW0gcGFyYW1zLnhwdWIgKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0gcGFyYW1zLmV0aEFkZHJlc3MgKG9wdGlvbmFsKVxuICAgKiBAcGFyYW0gcGFyYW1zLnJlcUlkIChvcHRpb25hbClcbiAgICovXG4gIGFzeW5jIGdldChwYXJhbXM6IEdldEtleWNoYWluT3B0aW9ucyk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbXSwgWyd4cHViJywgJ2V0aEFkZHJlc3MnXSk7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMuaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGlkID0gcGFyYW1zLmlkO1xuICAgIGlmIChwYXJhbXMucmVxSWQpIHtcbiAgICAgIHRoaXMuYml0Z28uc2V0UmVxdWVzdFRyYWNlcihwYXJhbXMucmVxSWQpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iaXRnby5nZXQodGhpcy5iYXNlQ29pbi51cmwoJy9rZXkvJyArIGVuY29kZVVSSUNvbXBvbmVudChpZCkpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBsaXN0IHRoZSB1c2VycyBrZXljaGFpbnNcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLmxpbWl0IC0gTWF4IG51bWJlciBvZiByZXN1bHRzIGluIGEgc2luZ2xlIGNhbGwuXG4gICAqIEBwYXJhbSBwYXJhbXMucHJldklkIC0gQ29udGludWUgaXRlcmF0aW5nIChwcm92aWRlZCBieSBuZXh0QmF0Y2hQcmV2SWQgaW4gdGhlIHByZXZpb3VzIGxpc3QpXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgYXN5bmMgbGlzdChwYXJhbXM6IExpc3RLZXljaGFpbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8TGlzdEtleWNoYWluc1Jlc3VsdD4ge1xuICAgIGNvbnN0IHF1ZXJ5T2JqZWN0OiBhbnkgPSB7fTtcblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMubGltaXQpKSB7XG4gICAgICBpZiAoIV8uaXNOdW1iZXIocGFyYW1zLmxpbWl0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbGltaXQgYXJndW1lbnQsIGV4cGVjdGluZyBudW1iZXInKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5T2JqZWN0LmxpbWl0ID0gcGFyYW1zLmxpbWl0O1xuICAgIH1cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLnByZXZJZCkpIHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHJldklkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJldklkIGFyZ3VtZW50LCBleHBlY3Rpbmcgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBxdWVyeU9iamVjdC5wcmV2SWQgPSBwYXJhbXMucHJldklkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJpdGdvLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL2tleScpKS5xdWVyeShxdWVyeU9iamVjdCkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBkZWNyeXB0aW9uIHBhc3N3b3JkIGZvciBhbGwgcG9zc2libGUga2V5Y2hhaW5zIGFzc29jaWF0ZWQgd2l0aCBhIHVzZXIuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXRlcmF0ZXMgdGhyb3VnaCBhbGwga2V5cyBhc3NvY2lhdGVkIHdpdGggdGhlIHVzZXIsIGRlY3J5cHRzXG4gICAqIHRoZW0gd2l0aCB0aGUgb2xkIHBhc3N3b3JkIGFuZCByZS1lbmNyeXB0cyB0aGVtIHdpdGggdGhlIG5ldyBwYXNzd29yZC5cbiAgICpcbiAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIHdoZW4gYSB1c2VyIGNoYW5nZXMgdGhlaXIgbG9naW4gcGFzc3dvcmQsIGFuZCBhcmUgZXhwZWN0aW5nXG4gICAqIHRoYXQgdGhlaXIgd2FsbGV0IHBhc3N3b3JkcyBhcmUgY2hhbmdlZCB0byBtYXRjaCB0aGUgbmV3IGxvZ2luIHBhc3N3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMub2xkUGFzc3dvcmQgLSBUaGUgb2xkIHBhc3N3b3JkIHVzZWQgZm9yIGVuY3J5cHRpbmcgdGhlIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zLm5ld1Bhc3N3b3JkIC0gVGhlIG5ldyBwYXNzd29yZCB0byBiZSB1c2VkIGZvciBlbmNyeXB0aW5nIHRoZSBrZXlcbiAgICogQHJldHVybnMgY2hhbmdlZEtleXMgT2JqZWN0IC0gZS5nLjpcbiAgICogIHtcbiAgICogICAgeHB1YjE6IGVuY3J5cHRlZFBydixcbiAgICogICAgLi4uXG4gICAqICB9XG4gICAqL1xuICBhc3luYyB1cGRhdGVQYXNzd29yZChwYXJhbXM6IFVwZGF0ZVBhc3N3b3JkT3B0aW9ucyk6IFByb21pc2U8Q2hhbmdlZEtleWNoYWlucz4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFsnb2xkUGFzc3dvcmQnLCAnbmV3UGFzc3dvcmQnXSwgW10pO1xuICAgIGNvbnN0IGNoYW5nZWRLZXlzOiBDaGFuZ2VkS2V5Y2hhaW5zID0ge307XG4gICAgbGV0IHByZXZJZDtcbiAgICBsZXQga2V5c0xlZnQgPSB0cnVlO1xuICAgIHdoaWxlIChrZXlzTGVmdCkge1xuICAgICAgY29uc3QgcmVzdWx0OiBMaXN0S2V5Y2hhaW5zUmVzdWx0ID0gYXdhaXQgdGhpcy5saXN0KHsgbGltaXQ6IDUwMCwgcHJldklkIH0pO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgcmVzdWx0LmtleXMpIHtcbiAgICAgICAgY29uc3Qgb2xkRW5jcnlwdGVkUHJ2ID0ga2V5LmVuY3J5cHRlZFBydjtcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQob2xkRW5jcnlwdGVkUHJ2KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdXBkYXRlZEtleWNoYWluID0gdGhpcy51cGRhdGVTaW5nbGVLZXljaGFpblBhc3N3b3JkKHtcbiAgICAgICAgICAgIGtleWNoYWluOiBrZXksXG4gICAgICAgICAgICBvbGRQYXNzd29yZDogcGFyYW1zLm9sZFBhc3N3b3JkLFxuICAgICAgICAgICAgbmV3UGFzc3dvcmQ6IHBhcmFtcy5uZXdQYXNzd29yZCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodXBkYXRlZEtleWNoYWluLmVuY3J5cHRlZFBydikge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZEtleUlkZW50aWZpZXIgPVxuICAgICAgICAgICAgICB1cGRhdGVkS2V5Y2hhaW4udHlwZSA9PT0gJ3RzcycgPyB1cGRhdGVkS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4gOiB1cGRhdGVkS2V5Y2hhaW4ucHViO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRLZXlJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWRLZXlzW2NoYW5nZWRLZXlJZGVudGlmaWVyXSA9IHVwZGF0ZWRLZXljaGFpbi5lbmNyeXB0ZWRQcnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIHBhc3N3b3JkIHdhcyBpbmNvcnJlY3QsIHNpbGVuY2UgdGhlIGVycm9yLCB0aHJvdyBvdGhlcndpc2VcbiAgICAgICAgICBpZiAoIWUubWVzc2FnZS5pbmNsdWRlcygncHJpdmF0ZSBrZXkgaXMgaW5jb3JyZWN0JykpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0Lm5leHRCYXRjaFByZXZJZCkge1xuICAgICAgICBwcmV2SWQgPSByZXN1bHQubmV4dEJhdGNoUHJldklkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5c0xlZnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWRLZXlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgcGFzc3dvcmQgdXNlZCB0byBkZWNyeXB0IGEgc2luZ2xlIGtleWNoYWluXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5rZXljaGFpbiAtIFRoZSBrZXljaGFpbiB3aG9zZSBwYXNzd29yZCBzaG91bGQgYmUgdXBkYXRlZFxuICAgKiBAcGFyYW0gcGFyYW1zLm9sZFBhc3N3b3JkIC0gVGhlIG9sZCBwYXNzd29yZCB1c2VkIGZvciBlbmNyeXB0aW5nIHRoZSBrZXlcbiAgICogQHBhcmFtIHBhcmFtcy5uZXdQYXNzd29yZCAtIFRoZSBuZXcgcGFzc3dvcmQgdG8gYmUgdXNlZCBmb3IgZW5jcnlwdGluZyB0aGUga2V5XG4gICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAqL1xuICB1cGRhdGVTaW5nbGVLZXljaGFpblBhc3N3b3JkKHBhcmFtczogVXBkYXRlU2luZ2xlS2V5Y2hhaW5QYXNzd29yZE9wdGlvbnMgPSB7fSk6IEtleWNoYWluIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLm9sZFBhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBvbGQgcGFzc3dvcmQgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLm5ld1Bhc3N3b3JkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBuZXcgcGFzc3dvcmQgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLmtleWNoYWluKSB8fCAhXy5pc1N0cmluZyhwYXJhbXMua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBrZXljaGFpbiB0byBiZSBhbiBvYmplY3Qgd2l0aCBhbiBlbmNyeXB0ZWRQcnYgcHJvcGVydHknKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRFbmNyeXB0ZWRQcnYgPSBwYXJhbXMua2V5Y2hhaW4uZW5jcnlwdGVkUHJ2O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWNyeXB0ZWRQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogb2xkRW5jcnlwdGVkUHJ2LCBwYXNzd29yZDogcGFyYW1zLm9sZFBhc3N3b3JkIH0pO1xuICAgICAgY29uc3QgbmV3RW5jcnlwdGVkUHJ2ID0gdGhpcy5iaXRnby5lbmNyeXB0KHsgaW5wdXQ6IGRlY3J5cHRlZFBydiwgcGFzc3dvcmQ6IHBhcmFtcy5uZXdQYXNzd29yZCB9KTtcbiAgICAgIHJldHVybiBfLmFzc2lnbih7fSwgcGFyYW1zLmtleWNoYWluLCB7IGVuY3J5cHRlZFBydjogbmV3RW5jcnlwdGVkUHJ2IH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGNhdGNoaW5nIGFuIGVycm9yIGhlcmUgbWVhbnMgdGhhdCB0aGUgcGFzc3dvcmQgd2FzIGluY29ycmVjdCBvciwgbGVzcyBsaWtlbHksIHRoZSBpbnB1dCB0byBkZWNyeXB0IGlzIGNvcnJ1cHRlZFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZCB1c2VkIHRvIGRlY3J5cHQga2V5Y2hhaW4gcHJpdmF0ZSBrZXkgaXMgaW5jb3JyZWN0Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHB1YmxpYy9wcml2YXRlIGtleSBwYWlyXG4gICAqIEBwYXJhbSBwYXJhbXMuc2VlZFxuICAgKi9cbiAgY3JlYXRlKHBhcmFtczogeyBzZWVkPzogQnVmZmVyIH0gPSB7fSk6IEtleVBhaXIge1xuICAgIHJldHVybiB0aGlzLmJhc2VDb2luLmdlbmVyYXRlS2V5UGFpcihwYXJhbXMuc2VlZCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEga2V5Y2hhaW4gdG8gQml0R28ncyByZWNvcmRzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGFkZChwYXJhbXM6IEFkZEtleWNoYWluT3B0aW9ucyA9IHt9KTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMoXG4gICAgICBwYXJhbXMsXG4gICAgICBbXSxcbiAgICAgIFtcbiAgICAgICAgJ3B1YicsXG4gICAgICAgICdlbmNyeXB0ZWRQcnYnLFxuICAgICAgICAna2V5VHlwZScsXG4gICAgICAgICd0eXBlJyxcbiAgICAgICAgJ3NvdXJjZScsXG4gICAgICAgICdvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUnLFxuICAgICAgICAnZW50ZXJwcmlzZScsXG4gICAgICAgICdkZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkJyxcbiAgICAgIF1cbiAgICApO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5kaXNhYmxlS1JTRW1haWwpKSB7XG4gICAgICBpZiAoIV8uaXNCb29sZWFuKHBhcmFtcy5kaXNhYmxlS1JTRW1haWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkaXNhYmxlS1JTRW1haWwgYXJndW1lbnQsIGV4cGVjdGluZyBib29sZWFuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5yZXFJZCkge1xuICAgICAgdGhpcy5iaXRnby5zZXRSZXF1ZXN0VHJhY2VyKHBhcmFtcy5yZXFJZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYmFzZUNvaW4udXJsKCcva2V5JykpXG4gICAgICAuc2VuZCh7XG4gICAgICAgIHB1YjogcGFyYW1zLnB1YixcbiAgICAgICAgY29tbW9uUHViOiBwYXJhbXMuY29tbW9uUHViLFxuICAgICAgICBjb21tb25LZXljaGFpbjogcGFyYW1zLmNvbW1vbktleWNoYWluLFxuICAgICAgICBlbmNyeXB0ZWRQcnY6IHBhcmFtcy5lbmNyeXB0ZWRQcnYsXG4gICAgICAgIHR5cGU6IHBhcmFtcy50eXBlLFxuICAgICAgICBrZXlUeXBlOiBwYXJhbXMua2V5VHlwZSxcbiAgICAgICAgc291cmNlOiBwYXJhbXMuc291cmNlLFxuICAgICAgICBwcm92aWRlcjogcGFyYW1zLnByb3ZpZGVyLFxuICAgICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU6IHBhcmFtcy5vcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICAgIGVudGVycHJpc2U6IHBhcmFtcy5lbnRlcnByaXNlLFxuICAgICAgICBkZXJpdmVkRnJvbVBhcmVudFdpdGhTZWVkOiBwYXJhbXMuZGVyaXZlZEZyb21QYXJlbnRXaXRoU2VlZCxcbiAgICAgICAgZGlzYWJsZUtSU0VtYWlsOiBwYXJhbXMuZGlzYWJsZUtSU0VtYWlsLFxuICAgICAgICBrcnNTcGVjaWZpYzogcGFyYW1zLmtyc1NwZWNpZmljLFxuICAgICAgICBrZXlTaGFyZXM6IHBhcmFtcy5rZXlTaGFyZXMsXG4gICAgICAgIHVzZXJHUEdQdWJsaWNLZXk6IHBhcmFtcy51c2VyR1BHUHVibGljS2V5LFxuICAgICAgICBiYWNrdXBHUEdQdWJsaWNLZXk6IHBhcmFtcy5iYWNrdXBHUEdQdWJsaWNLZXksXG4gICAgICAgIGFsZ29Vc2VkOiBwYXJhbXMuYWxnb1VzZWQsXG4gICAgICAgIGlzRGlzdHJpYnV0ZWRDdXN0b2R5OiBwYXJhbXMuaXNEaXN0cmlidXRlZEN1c3RvZHksXG4gICAgICB9KVxuICAgICAgLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEJpdEdvIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zIChlbXB0eSlcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJpdEdvKHBhcmFtczogQ3JlYXRlQml0R29PcHRpb25zID0ge30pOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgcGFyYW1zLnNvdXJjZSA9ICdiaXRnbyc7XG5cbiAgICB0aGlzLmJhc2VDb2luLnByZUNyZWF0ZUJpdEdvKHBhcmFtcyBhcyBhbnkpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmFkZChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhY2t1cCBrZXlcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnByb3ZpZGVyIChvcHRpb25hbClcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJhY2t1cChwYXJhbXM6IENyZWF0ZUJhY2t1cE9wdGlvbnMgPSB7fSk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICBwYXJhbXMuc291cmNlID0gJ2JhY2t1cCc7XG5cbiAgICBjb25zdCBpc1Rzc0JhY2t1cEtleSA9IHBhcmFtcy5wcnYgJiYgKHBhcmFtcy5jb21tb25LZXljaGFpbiB8fCBwYXJhbXMuY29tbW9uUHViKTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5wcm92aWRlcikgJiYgIWlzVHNzQmFja3VwS2V5KSB7XG4gICAgICAvLyBpZiB0aGUgcHJvdmlkZXIgaXMgdW5kZWZpbmVkLCB3ZSBnZW5lcmF0ZSBhIGxvY2FsIGtleSBhbmQgYWRkIHRoZSBzb3VyY2UgZGV0YWlsc1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5jcmVhdGUoKTtcbiAgICAgIF8uZXh0ZW5kKHBhcmFtcywga2V5KTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJ2ZXJSZXNwb25zZSA9IGF3YWl0IHRoaXMuYWRkKHBhcmFtcyk7XG4gICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBzZXJ2ZXJSZXNwb25zZSwgXy5waWNrKHBhcmFtcywgWydwcnYnLCAnZW5jcnlwdGVkUHJ2JywgJ3Byb3ZpZGVyJywgJ3NvdXJjZSddKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBrZXlzIGZvciBzaWduaW5nIGZyb20gYSB3YWxsZXRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXljaGFpbltdPn1cbiAgICovXG4gIGFzeW5jIGdldEtleXNGb3JTaWduaW5nKHBhcmFtczogR2V0S2V5c0ZvclNpZ25pbmdPcHRpb25zID0ge30pOiBQcm9taXNlPEtleWNoYWluW10+IHtcbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zLndhbGxldCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSB3YWxsZXQnKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0ID0gcGFyYW1zLndhbGxldDtcbiAgICBjb25zdCByZXFJZCA9IHBhcmFtcy5yZXFJZCB8fCBuZXcgUmVxdWVzdFRyYWNlcigpO1xuICAgIGNvbnN0IGlkcyA9IHdhbGxldC5iYXNlQ29pbi5rZXlJZHNGb3JTaWduaW5nKCk7XG4gICAgY29uc3Qga2V5Y2hhaW5RdWVyaWVzQmx1ZWJpcmRzID0gaWRzLm1hcCgoaWQpID0+IHRoaXMuZ2V0KHsgaWQ6IHdhbGxldC5rZXlJZHMoKVtpZF0sIHJlcUlkIH0pKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoa2V5Y2hhaW5RdWVyaWVzQmx1ZWJpcmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBjcmVhdGUgYW5kIHN0b3JlIE1QQyBrZXljaGFpbnMgd2l0aCBCaXRHby5cbiAgICogQHBhcmFtIHBhcmFtcyBwYXNzcGhyYXNlIHVzZWQgdG8gZW5jcnlwdCBzZWNyZXQgbWF0ZXJpYWxzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8S2V5Y2hhaW5zVHJpcGxldD59IG5ld2x5IGNyZWF0ZWQgVXNlciwgQmFja3VwLCBhbmQgQml0R28ga2V5c1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlTXBjKHBhcmFtczogQ3JlYXRlTXBjT3B0aW9ucyk6IFByb21pc2U8S2V5Y2hhaW5zVHJpcGxldD4ge1xuICAgIGxldCBNcGNVdGlscztcbiAgICBzd2l0Y2ggKHBhcmFtcy5tdWx0aXNpZ1R5cGUpIHtcbiAgICAgIGNhc2UgJ3Rzcyc6XG4gICAgICAgIE1wY1V0aWxzID0gdGhpcy5iYXNlQ29pbi5nZXRNUENBbGdvcml0aG0oKSA9PT0gJ2VjZHNhJyA/IEVDRFNBVXRpbHMuRWNkc2FVdGlscyA6IEVERFNBVXRpbHMuZGVmYXVsdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdibHNka2cnOlxuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMucGFzc3BocmFzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgcGFyYW0gcGFzc3BocmFzZScpO1xuICAgICAgICB9XG4gICAgICAgIE1wY1V0aWxzID0gQmxzVXRpbHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBtdWx0aS1zaWcgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCBtcGNVdGlscyA9IG5ldyBNcGNVdGlscyh0aGlzLmJpdGdvLCB0aGlzLmJhc2VDb2luKTtcbiAgICByZXR1cm4gYXdhaXQgbXBjVXRpbHMuY3JlYXRlS2V5Y2hhaW5zKHtcbiAgICAgIHBhc3NwaHJhc2U6IHBhcmFtcy5wYXNzcGhyYXNlLFxuICAgICAgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsXG4gICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU6IHBhcmFtcy5vcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgICBiYWNrdXBQcm92aWRlcjogcGFyYW1zLmJhY2t1cFByb3ZpZGVyLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0IHBhcnNlcyB0aGUgSlNPTiBkb3dubG9hZGVkIGZyb20gdGhlIE9WQyBmb3IgcGxhdGZvcm0gKEJpdEdvKSxcbiAgICogYW5kIGNyZWF0ZXMgYSBjb3JyZXNwb25kaW5nIFRTUyBCaXRHbyBrZXkuIEl0IGFsc28gcmV0dXJucyB0aGUgSlNPTiB0aGF0IG5lZWRzXG4gICAqIHRvIGJlIHVwbG9hZGVkIGJhY2sgdG8gdGhlIE9WQ3MgY29udGFpbmluZyB0aGUgQml0R28gLT4gT1ZDIHNoYXJlcy5cbiAgICogQHBhcmFtIG92Y091dHB1dEpzb24gSlNPTiBmb3JtYXQgb2YgdGhlIGZpbGUgZG93bmxvYWRlZCBmcm9tIHRoZSBPVkMgZm9yIHBsYXRmb3JtXG4gICAqIEByZXR1cm5zIHtCaXRHb0tleUZyb21PdmNTaGFyZXN9XG4gICAqL1xuICBhc3luYyBjcmVhdGVUc3NCaXRHb0tleUZyb21PdmNTaGFyZXMob3ZjT3V0cHV0SnNvbjogdW5rbm93bik6IFByb21pc2U8Qml0R29LZXlGcm9tT3ZjU2hhcmVzPiB7XG4gICAgY29uc3QgZGVjb2RlZE92Y091dHB1dCA9IGRlY29kZU9yRWxzZShPdmNUb0JpdEdvSlNPTi5uYW1lLCBPdmNUb0JpdEdvSlNPTiwgb3ZjT3V0cHV0SnNvbiwgKGVycm9ycykgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvcihzKSBwYXJzaW5nIE9WQyBKU09OOiAke2Vycm9yc31gKTtcbiAgICB9KTtcblxuICAgIGlmIChkZWNvZGVkT3ZjT3V0cHV0LnN0YXRlICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0YXRlIGV4cGVjdGVkIHRvIGJlIFwiMVwiLiBQbGVhc2UgY29tcGxldGUgdGhlIGZpcnN0IHR3byBPVkMgb3BlcmF0aW9ucycpO1xuICAgIH1cblxuICAgIC8vIE9WQy0xIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgVXNlciBrZXlcbiAgICBjb25zdCBvdmMxID0gZGVjb2RlZE92Y091dHB1dC5vdmNbMV07XG4gICAgLy8gT1ZDLTIgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBCYWNrdXAga2V5XG4gICAgY29uc3Qgb3ZjMiA9IGRlY29kZWRPdmNPdXRwdXQub3ZjWzJdO1xuXG4gICAgY29uc3Qga2V5U2hhcmVzOiBBcGlLZXlTaGFyZVtdID0gW1xuICAgICAge1xuICAgICAgICBmcm9tOiAndXNlcicsXG4gICAgICAgIHRvOiAnYml0Z28nLFxuICAgICAgICBwdWJsaWNTaGFyZTogb3ZjMS5vdmNUb0JpdGdvU2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgIHByaXZhdGVTaGFyZTogb3ZjMS5vdmNUb0JpdGdvU2hhcmUucHJpdmF0ZVNoYXJlLFxuICAgICAgICBwcml2YXRlU2hhcmVQcm9vZjogb3ZjMS5vdmNUb0JpdGdvU2hhcmUudVNpZy50b1N0cmluZygpID8/ICcnLFxuICAgICAgICB2c3NQcm9vZjogb3ZjMS5vdmNUb0JpdGdvU2hhcmUudnNzUHJvb2YgPz8gJycsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBmcm9tOiAnYmFja3VwJyxcbiAgICAgICAgdG86ICdiaXRnbycsXG4gICAgICAgIHB1YmxpY1NoYXJlOiBvdmMyLm92Y1RvQml0Z29TaGFyZS5wdWJsaWNTaGFyZSxcbiAgICAgICAgcHJpdmF0ZVNoYXJlOiBvdmMyLm92Y1RvQml0Z29TaGFyZS5wcml2YXRlU2hhcmUsXG4gICAgICAgIHByaXZhdGVTaGFyZVByb29mOiBvdmMyLm92Y1RvQml0Z29TaGFyZS51U2lnLnRvU3RyaW5nKCkgPz8gJycsXG4gICAgICAgIHZzc1Byb29mOiBvdmMyLm92Y1RvQml0Z29TaGFyZS52c3NQcm9vZiA/PyAnJyxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuYmFzZUNvaW4ua2V5Y2hhaW5zKCkuYWRkKHtcbiAgICAgIHNvdXJjZTogJ2JpdGdvJyxcbiAgICAgIGtleVNoYXJlcyxcbiAgICAgIGtleVR5cGU6ICd0c3MnLFxuICAgICAgdXNlckdQR1B1YmxpY0tleTogb3ZjMS5ncGdQdWJLZXksXG4gICAgICBiYWNrdXBHUEdQdWJsaWNLZXk6IG92YzIuZ3BnUHViS2V5LFxuICAgIH0pO1xuICAgIGFzc2VydChrZXkua2V5U2hhcmVzKTtcbiAgICBhc3NlcnQoa2V5LmNvbW1vbktleWNoYWluKTtcbiAgICBhc3NlcnQoa2V5LndhbGxldEhTTUdQR1B1YmxpY0tleVNpZ3MpO1xuXG4gICAgY29uc3QgYml0Z29Ub1VzZXJTaGFyZSA9IGtleS5rZXlTaGFyZXMuZmluZChcbiAgICAgICh2YWx1ZTogeyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmcgfSkgPT4gdmFsdWUuZnJvbSA9PT0gJ2JpdGdvJyAmJiB2YWx1ZS50byA9PT0gJ3VzZXInXG4gICAgKTtcbiAgICBhc3NlcnQoYml0Z29Ub1VzZXJTaGFyZSk7XG4gICAgYXNzZXJ0KGJpdGdvVG9Vc2VyU2hhcmUudnNzUHJvb2YpO1xuICAgIGFzc2VydChiaXRnb1RvVXNlclNoYXJlLnBhaWxsaWVyUHVibGljS2V5KTtcbiAgICBjb25zdCBiaXRnb1RvQmFja3VwU2hhcmUgPSBrZXkua2V5U2hhcmVzLmZpbmQoXG4gICAgICAodmFsdWU6IHsgZnJvbTogc3RyaW5nOyB0bzogc3RyaW5nIH0pID0+IHZhbHVlLmZyb20gPT09ICdiaXRnbycgJiYgdmFsdWUudG8gPT09ICdiYWNrdXAnXG4gICAgKTtcbiAgICBhc3NlcnQoYml0Z29Ub0JhY2t1cFNoYXJlKTtcbiAgICBhc3NlcnQoYml0Z29Ub0JhY2t1cFNoYXJlLnZzc1Byb29mKTtcbiAgICBhc3NlcnQoYml0Z29Ub0JhY2t1cFNoYXJlLnBhaWxsaWVyUHVibGljS2V5KTtcblxuICAgIC8vIENyZWF0ZSBKU09OIGRhdGEgd2l0aCBwbGF0Zm9ybSBzaGFyZXMgZm9yIE9WQy0xIGFuZCBPVkMtMlxuICAgIGNvbnN0IGJpdGdvVG9PdmNPdXRwdXQ6IEJpdEdvVG9PdmNKU09OID0ge1xuICAgICAgd2FsbGV0OiB7XG4gICAgICAgIC4uLmRlY29kZWRPdmNPdXRwdXQsXG4gICAgICAgIHBsYXRmb3JtOiB7XG4gICAgICAgICAgY29tbW9uS2V5Y2hhaW46IGtleS5jb21tb25LZXljaGFpbixcbiAgICAgICAgICB3YWxsZXRHcGdQdWJLZXlTaWdzOiBrZXkud2FsbGV0SFNNR1BHUHVibGljS2V5U2lncyxcbiAgICAgICAgICBvdmM6IHtcbiAgICAgICAgICAgIC8vIEJpdEdvIHRvIFVzZXIgKE9WQy0xKVxuICAgICAgICAgICAgMToge1xuICAgICAgICAgICAgICBiaXRnb1RvT3ZjU2hhcmU6IHtcbiAgICAgICAgICAgICAgICBpOiAxLFxuICAgICAgICAgICAgICAgIGo6IDMsXG4gICAgICAgICAgICAgICAgcHVibGljU2hhcmU6IGJpdGdvVG9Vc2VyU2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZVNoYXJlOiBiaXRnb1RvVXNlclNoYXJlLnByaXZhdGVTaGFyZSxcbiAgICAgICAgICAgICAgICBwYWlsbGllclB1YmxpY0tleTogYml0Z29Ub1VzZXJTaGFyZS5wYWlsbGllclB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICB2c3NQcm9vZjogYml0Z29Ub1VzZXJTaGFyZS52c3NQcm9vZixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBCaXRHbyB0byBCYWNrdXAgKE9WQy0yKVxuICAgICAgICAgICAgMjoge1xuICAgICAgICAgICAgICBiaXRnb1RvT3ZjU2hhcmU6IHtcbiAgICAgICAgICAgICAgICBpOiAyLFxuICAgICAgICAgICAgICAgIGo6IDMsXG4gICAgICAgICAgICAgICAgcHVibGljU2hhcmU6IGJpdGdvVG9CYWNrdXBTaGFyZS5wdWJsaWNTaGFyZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlU2hhcmU6IGJpdGdvVG9CYWNrdXBTaGFyZS5wcml2YXRlU2hhcmUsXG4gICAgICAgICAgICAgICAgcGFpbGxpZXJQdWJsaWNLZXk6IGJpdGdvVG9CYWNrdXBTaGFyZS5wYWlsbGllclB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICB2c3NQcm9vZjogYml0Z29Ub0JhY2t1cFNoYXJlLnZzc1Byb29mLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgLy8gTWFyayBpdCByZWFkeSBmb3IgbmV4dCBvcGVyYXRpb24sIHNob3VsZCBiZSAyXG4gICAgYml0Z29Ub092Y091dHB1dC53YWxsZXQuc3RhdGUgKz0gMTtcblxuICAgIGNvbnN0IG91dHB1dDogQml0R29LZXlGcm9tT3ZjU2hhcmVzID0ge1xuICAgICAgYml0R29LZXlJZDoga2V5LmlkLFxuICAgICAgYml0R29PdXRwdXRKc29uRm9yT3ZjOiBiaXRnb1RvT3ZjT3V0cHV0LFxuICAgIH07XG5cbiAgICByZXR1cm4gZGVjb2RlT3JFbHNlKEJpdEdvS2V5RnJvbU92Y1NoYXJlcy5uYW1lLCBCaXRHb0tleUZyb21PdmNTaGFyZXMsIG91dHB1dCwgKGVycm9ycykgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBwcm9kdWNpbmcgdGhlIG91dHB1dDogJHtlcnJvcnN9YCk7XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==