"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyWalletSignature = exports.getTSSSignature = exports.getInitializedMpcInstance = exports.encryptYShare = exports.sendUserToBitgoGShare = exports.getBitgoToUserRShare = exports.offerUserToBitgoRShare = exports.createUserToBitGoGShare = exports.createUserSignShare = exports.createCombinedKey = exports.sendSignatureShare = exports.getTxRequest = void 0;
const assert_1 = __importDefault(require("assert"));
const libsodium_wrappers_sumo_1 = __importDefault(require("libsodium-wrappers-sumo"));
const tss_1 = __importDefault(require("./../../../account-lib/mpc/tss"));
const types_1 = require("../types");
const utils_1 = require("../../utils");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const _ = require("lodash");
const common_1 = require("../common");
Object.defineProperty(exports, "getTxRequest", { enumerable: true, get: function () { return common_1.getTxRequest; } });
Object.defineProperty(exports, "sendSignatureShare", { enumerable: true, get: function () { return common_1.sendSignatureShare; } });
/**
 * Combines YShares to combine the final TSS key
 * This can only be used to create the User or Backup key since it requires the common keychain from BitGo first
 *
 * @param params.keyShare - TSS key share
 * @param params.encryptedYShares - encrypted YShares with information on how to decrypt
 * @param params.commonKeychain - expected common keychain of the combined key
 * @returns {CombinedKey} combined TSS key
 */
async function createCombinedKey(params) {
    await tss_1.default.initialize();
    const MPC = new tss_1.default();
    const { keyShare, encryptedYShares, commonKeychain } = params;
    const yShares = [];
    let bitgoYShare;
    let userYShare;
    let backupYShare;
    for (const encryptedYShare of encryptedYShares) {
        const privateShare = await utils_1.readSignedMessage(encryptedYShare.yShare.encryptedPrivateShare, encryptedYShare.senderPublicArmor, encryptedYShare.recipientPrivateArmor);
        const yShare = {
            i: encryptedYShare.yShare.i,
            j: encryptedYShare.yShare.j,
            y: encryptedYShare.yShare.publicShare.slice(0, 64),
            v: encryptedYShare.yShare.publicShare.slice(64, 128),
            u: privateShare.slice(0, 64),
            chaincode: privateShare.slice(64),
        };
        switch (encryptedYShare.yShare.j) {
            case 1:
                userYShare = yShare;
                break;
            case 2:
                backupYShare = yShare;
                break;
            case 3:
                bitgoYShare = yShare;
                break;
            default:
                throw new Error('Invalid YShare index');
        }
        yShares.push(yShare);
    }
    const combinedKey = MPC.keyCombine(keyShare.uShare, yShares);
    if (combinedKey.pShare.y + combinedKey.pShare.chaincode !== commonKeychain) {
        throw new Error('Common keychains do not match');
    }
    if (!bitgoYShare) {
        throw new Error('Missing BitGo Y Share');
    }
    const signingMaterial = {
        uShare: keyShare.uShare,
        bitgoYShare,
        backupYShare,
        userYShare,
    };
    return {
        signingMaterial,
        commonKeychain,
    };
}
exports.createCombinedKey = createCombinedKey;
/**
 * Creates the User Sign Share containing the User XShare , the User to Bitgo RShare and User to Bitgo commitment
 *
 * @param {Buffer} signablePayload - the signablePayload as a buffer
 * @param {PShare} pShare - User's signing material
 * @returns {Promise<SignShare>} - User Sign Share
 */
async function createUserSignShare(signablePayload, pShare) {
    const MPC = await tss_1.default.initialize();
    if (pShare.i !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid PShare, PShare doesnt belong to the User');
    }
    const jShare = { i: types_1.ShareKeyPosition.BITGO, j: types_1.ShareKeyPosition.USER };
    return MPC.signShare(signablePayload, pShare, [jShare]);
}
exports.createUserSignShare = createUserSignShare;
/**
 * Creates the User to Bitgo GShare
 *
 * @param {SignShare} userSignShare - the User Sign Share
 * @param {SignatureShareRecord} bitgoToUserRShare - the Bitgo to User RShare
 * @param {YShare} backupToUserYShare - the backup key Y share received during wallet creation
 * @param {Buffer} signablePayload - the signable payload from a tx
 * @param {CommitmentShareRecord} [bitgoToUserCommitment] - the Bitgo to User Commitment
 * @returns {Promise<GShare>} - the User to Bitgo GShare
 */
async function createUserToBitGoGShare(userSignShare, bitgoToUserRShare, backupToUserYShare, bitgoToUserYShare, signablePayload, bitgoToUserCommitment) {
    if (userSignShare.xShare.i !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid XShare, doesnt belong to the User');
    }
    if (bitgoToUserRShare.from !== utils_1.SignatureShareType.BITGO || bitgoToUserRShare.to !== utils_1.SignatureShareType.USER) {
        throw new Error('Invalid RShare, is not from Bitgo to User');
    }
    if (backupToUserYShare.i !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid YShare, doesnt belong to the User');
    }
    if (backupToUserYShare.j !== types_1.ShareKeyPosition.BACKUP) {
        throw new Error('Invalid YShare, is not backup key');
    }
    let v, r, R;
    if (bitgoToUserRShare.share.length > 128) {
        v = bitgoToUserRShare.share.substring(0, 64);
        r = bitgoToUserRShare.share.substring(64, 128);
        R = bitgoToUserRShare.share.substring(128, 192);
    }
    else {
        r = bitgoToUserRShare.share.substring(0, 64);
        R = bitgoToUserRShare.share.substring(64, 128);
    }
    const updatedBitgoToUserRShare = {
        i: types_1.ShareKeyPosition.USER,
        j: types_1.ShareKeyPosition.BITGO,
        u: bitgoToUserYShare.u,
        v,
        r,
        R,
    };
    const MPC = await tss_1.default.initialize();
    if (bitgoToUserCommitment) {
        if (bitgoToUserCommitment.from !== utils_1.SignatureShareType.BITGO ||
            bitgoToUserCommitment.to !== utils_1.SignatureShareType.USER) {
            throw new Error('Invalid Commitment, is not from Bitgo to User');
        }
        if (bitgoToUserCommitment.type !== utils_1.CommitmentType.COMMITMENT) {
            throw new Error('Invalid Commitment type, got: ' + bitgoToUserCommitment.type + ' expected: commitment');
        }
        updatedBitgoToUserRShare.commitment = bitgoToUserCommitment.share;
    }
    return MPC.sign(signablePayload, userSignShare.xShare, [updatedBitgoToUserRShare], [backupToUserYShare]);
}
exports.createUserToBitGoGShare = createUserToBitGoGShare;
/**
 * Sends the User to Bitgo RShare to Bitgo
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @param {SignShare} userSignShare - the user Sign Share
 * @param {String} encryptedSignerShare - signer share encrypted to bitgo key
 * @returns {Promise<void>}
 */
async function offerUserToBitgoRShare(bitgo, walletId, txRequestId, userSignShare, encryptedSignerShare, apiMode = 'lite', vssProof, privateShareProof, userPublicGpgKey, publicShare) {
    const rShare = userSignShare.rShares[types_1.ShareKeyPosition.BITGO];
    if (_.isNil(rShare)) {
        throw new Error('userToBitgo RShare not found');
    }
    if (rShare.i !== types_1.ShareKeyPosition.BITGO || rShare.j !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid RShare, is not from User to Bitgo');
    }
    const signatureShare = {
        from: utils_1.SignatureShareType.USER,
        to: utils_1.SignatureShareType.BITGO,
        share: rShare.r + rShare.R,
        vssProof,
        privateShareProof,
        publicShare,
    };
    // TODO (BG-57944): implement message signing for EDDSA
    await common_1.sendSignatureShare(bitgo, walletId, txRequestId, signatureShare, utils_1.RequestType.tx, encryptedSignerShare, 'eddsa', apiMode, userPublicGpgKey);
}
exports.offerUserToBitgoRShare = offerUserToBitgoRShare;
/**
 * Gets the Bitgo to User RShare from Bitgo
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @returns {Promise<SignatureShareRecord>} - a Signature Share
 */
async function getBitgoToUserRShare(bitgo, walletId, txRequestId) {
    const txRequest = await common_1.getTxRequest(bitgo, walletId, txRequestId);
    let signatureShares;
    if (txRequest.apiVersion === 'full') {
        assert_1.default(txRequest.transactions, 'transactions required as part of txRequest');
        signatureShares = txRequest.transactions[0].signatureShares;
    }
    else {
        signatureShares = txRequest.signatureShares;
    }
    if (_.isNil(signatureShares) || _.isEmpty(signatureShares)) {
        throw new Error(`No signatures shares found for id: ${txRequestId}`);
    }
    // at this point we expect the only share to be the RShare
    const bitgoToUserRShare = signatureShares.find((sigShare) => sigShare.from === utils_1.SignatureShareType.BITGO && sigShare.to === utils_1.SignatureShareType.USER);
    if (_.isNil(bitgoToUserRShare)) {
        throw new Error(`Bitgo to User RShare not found for id: ${txRequestId}`);
    }
    return bitgoToUserRShare;
}
exports.getBitgoToUserRShare = getBitgoToUserRShare;
/**
 * Sends the User to Bitgo GShare to Bitgo
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @param {GShare} userToBitgoGShare - the User to Bitgo GShare
 * @returns {Promise<void>}
 */
async function sendUserToBitgoGShare(bitgo, walletId, txRequestId, userToBitgoGShare, apiMode = 'lite') {
    if (userToBitgoGShare.i !== types_1.ShareKeyPosition.USER) {
        throw new Error('Invalid GShare, doesnt belong to the User');
    }
    const signatureShare = {
        from: utils_1.SignatureShareType.USER,
        to: utils_1.SignatureShareType.BITGO,
        share: userToBitgoGShare.R + userToBitgoGShare.gamma,
    };
    // TODO (BG-57944): implement message signing for EDDSA
    await common_1.sendSignatureShare(bitgo, walletId, txRequestId, signatureShare, utils_1.RequestType.tx, undefined, 'eddsa', apiMode);
}
exports.sendUserToBitgoGShare = sendUserToBitgoGShare;
/**
 * Prepares a YShare to be exchanged with other key holders.
 * Output is in a format that is usable within BitGo's ecosystem.
 *
 * @param params.keyShare - TSS key share of the party preparing exchange materials
 * @param params.recipientIndex - index of the recipient (1, 2, or 3)
 * @param params.recipientGpgPublicArmor - recipient's public gpg key in armor format
 * @param params.senderGpgPrivateArmor - sender's private gpg key in armor format
 * @returns { EncryptedYShare } encrypted Y Share
 */
async function encryptYShare(params) {
    const { keyShare, recipientIndex, recipientGpgPublicArmor, senderGpgPrivateArmor } = params;
    const yShare = keyShare.yShares[recipientIndex];
    if (!yShare) {
        throw new Error('Invalid recipient');
    }
    const publicShare = Buffer.concat([
        Buffer.from(keyShare.uShare.y, 'hex'),
        Buffer.from(yShare.v, 'hex'),
        Buffer.from(keyShare.uShare.chaincode, 'hex'),
    ]).toString('hex');
    const privateShare = Buffer.concat([Buffer.from(yShare.u, 'hex'), Buffer.from(yShare.chaincode, 'hex')]).toString('hex');
    const encryptedPrivateShare = await utils_1.encryptAndSignText(privateShare, recipientGpgPublicArmor, senderGpgPrivateArmor);
    return {
        i: yShare.i,
        j: yShare.j,
        publicShare,
        encryptedPrivateShare,
    };
}
exports.encryptYShare = encryptYShare;
/**
 *
 * Initializes Eddsa instance
 *
 * @returns {Promise<Eddsa>} the Eddsa instance
 */
async function getInitializedMpcInstance() {
    const hdTree = await sdk_lib_mpc_1.Ed25519Bip32HdTree.initialize();
    return await tss_1.default.initialize(hdTree);
}
exports.getInitializedMpcInstance = getInitializedMpcInstance;
/**
 *
 * Generates a TSS signature using the user and backup key
 *
 * @param {UserSigningMaterial} userSigningMaterial decrypted user TSS key
 * @param {BackupSigningMaterial} backupSigningMaterial decrypted backup TSS key
 * @param {string} path bip32 derivation path
 * @param {BaseTransaction} transaction the transaction to sign
 * @returns {Buffer} the signature
 */
async function getTSSSignature(userSigningMaterial, backupSigningMaterial, path = 'm/0', transaction) {
    const MPC = await getInitializedMpcInstance();
    const userCombine = MPC.keyCombine(userSigningMaterial.uShare, [
        userSigningMaterial.bitgoYShare,
        userSigningMaterial.backupYShare,
    ]);
    const backupCombine = MPC.keyCombine(backupSigningMaterial.uShare, [
        backupSigningMaterial.bitgoYShare,
        backupSigningMaterial.userYShare,
    ]);
    const userSubkey = MPC.keyDerive(userSigningMaterial.uShare, [userSigningMaterial.bitgoYShare, userSigningMaterial.backupYShare], path);
    const backupSubkey = MPC.keyCombine(backupSigningMaterial.uShare, [
        userSubkey.yShares[2],
        backupSigningMaterial.bitgoYShare,
    ]);
    const messageBuffer = transaction.signablePayload;
    const userSignShare = MPC.signShare(messageBuffer, userSubkey.pShare, [userCombine.jShares[2]]);
    const backupSignShare = MPC.signShare(messageBuffer, backupSubkey.pShare, [backupCombine.jShares[1]]);
    const userSign = MPC.sign(messageBuffer, userSignShare.xShare, [backupSignShare.rShares[1]], [userSigningMaterial.bitgoYShare]);
    const backupSign = MPC.sign(messageBuffer, backupSignShare.xShare, [userSignShare.rShares[2]], [backupSigningMaterial.bitgoYShare]);
    const signature = MPC.signCombine([userSign, backupSign]);
    const result = MPC.verify(messageBuffer, signature);
    if (!result) {
        throw new Error('Invalid signature');
    }
    const rawSignature = Buffer.concat([Buffer.from(signature.R, 'hex'), Buffer.from(signature.sigma, 'hex')]);
    return rawSignature;
}
exports.getTSSSignature = getTSSSignature;
/**
 * Verifies that a TSS wallet signature was produced with the expected key and that the signed data contains the
 * expected common keychain, the expected user and backup key ids as well as the public share that is generated from the
 * private share that was passed in.
 */
async function verifyWalletSignature(params) {
    const rawNotations = await common_1.commonVerifyWalletSignature(params);
    const { decryptedShare, verifierIndex } = params;
    const publicShare = Buffer.from(await libsodium_wrappers_sumo_1.default.crypto_scalarmult_ed25519_base_noclamp(Buffer.from(decryptedShare.slice(0, 64), 'hex'))).toString('hex') + decryptedShare.slice(64);
    const publicShareRawNotationIndex = 2 + verifierIndex;
    assert_1.default(publicShare === Buffer.from(rawNotations[publicShareRawNotationIndex].value).toString(), 'bitgo share mismatch');
}
exports.verifyWalletSignature = verifyWalletSignature;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRkc2EuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvYml0Z28vdHNzL2VkZHNhL2VkZHNhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG9EQUE0QjtBQUU1QixzRkFBNkM7QUFDN0MseUVBQW9IO0FBVXBILG9DQUE0QztBQUM1Qyx1Q0FRcUI7QUFFckIsb0RBQXdEO0FBQ3hELDRCQUE2QjtBQUM3QixzQ0FBMEY7QUFFakYsNkZBRjZCLHFCQUFZLE9BRTdCO0FBQUUsbUdBRjZCLDJCQUFrQixPQUU3QjtBQUV6Qzs7Ozs7Ozs7R0FRRztBQUNJLEtBQUssVUFBVSxpQkFBaUIsQ0FBQyxNQUl2QztJQUNDLE1BQU0sYUFBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ3pCLE1BQU0sR0FBRyxHQUFHLElBQUksYUFBSyxFQUFFLENBQUM7SUFFeEIsTUFBTSxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxjQUFjLEVBQUUsR0FBRyxNQUFNLENBQUM7SUFDOUQsTUFBTSxPQUFPLEdBQWEsRUFBRSxDQUFDO0lBRTdCLElBQUksV0FBK0IsQ0FBQztJQUNwQyxJQUFJLFVBQThCLENBQUM7SUFDbkMsSUFBSSxZQUFnQyxDQUFDO0lBRXJDLEtBQUssTUFBTSxlQUFlLElBQUksZ0JBQWdCLEVBQUU7UUFDOUMsTUFBTSxZQUFZLEdBQUcsTUFBTSx5QkFBaUIsQ0FDMUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFDNUMsZUFBZSxDQUFDLGlCQUFpQixFQUNqQyxlQUFlLENBQUMscUJBQXFCLENBQ3RDLENBQUM7UUFFRixNQUFNLE1BQU0sR0FBVztZQUNyQixDQUFDLEVBQUUsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzNCLENBQUMsRUFBRSxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDM0IsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVB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QVksR0FBRyxNQUFNLG9DQUEyQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRS9ELE1BQU0sRUFBRSxjQUFjLEVBQUUsYUFBYSxFQUFFLEdBQUcsTUFBTSxDQUFDO0lBRWpELE1BQU0sV0FBVyxHQUNmLE1BQU0sQ0FBQyxJQUFJLENBQ1QsTUFBTSxpQ0FBTSxDQUFDLHNDQUFzQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FDckcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUMvQyxNQUFNLDJCQUEyQixHQUFHLENBQUMsR0FBRyxhQUFhLENBQUM7SUFFdEQsZ0JBQU0sQ0FDSixXQUFXLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsMkJBQTJCLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFDdkYsc0JBQXNCLENBQ3ZCLENBQUM7QUFDSixDQUFDO0FBdkJELHNEQXVCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBvcGVucGdwIGZyb20gJ29wZW5wZ3AnO1xuaW1wb3J0IHNvZGl1bSBmcm9tICdsaWJzb2RpdW0td3JhcHBlcnMtc3Vtbyc7XG5pbXBvcnQgRWRkc2EsIHsgR1NoYXJlLCBKU2hhcmUsIEtleVNoYXJlLCBQU2hhcmUsIFJTaGFyZSwgU2lnblNoYXJlLCBZU2hhcmUgfSBmcm9tICcuLy4uLy4uLy4uL2FjY291bnQtbGliL21wYy90c3MnO1xuaW1wb3J0IHsgQml0R29CYXNlIH0gZnJvbSAnLi4vLi4vYml0Z29CYXNlJztcbmltcG9ydCB7XG4gIERlY3J5cHRhYmxlWVNoYXJlLFxuICBDb21iaW5lZEtleSxcbiAgU2lnbmluZ01hdGVyaWFsLFxuICBFbmNyeXB0ZWRZU2hhcmUsXG4gIFVzZXJTaWduaW5nTWF0ZXJpYWwsXG4gIEJhY2t1cFNpZ25pbmdNYXRlcmlhbCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTaGFyZUtleVBvc2l0aW9uIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgZW5jcnlwdEFuZFNpZ25UZXh0LFxuICByZWFkU2lnbmVkTWVzc2FnZSxcbiAgU2lnbmF0dXJlU2hhcmVSZWNvcmQsXG4gIFNpZ25hdHVyZVNoYXJlVHlwZSxcbiAgUmVxdWVzdFR5cGUsXG4gIENvbW1pdG1lbnRTaGFyZVJlY29yZCxcbiAgQ29tbWl0bWVudFR5cGUsXG59IGZyb20gJy4uLy4uL3V0aWxzJztcbmltcG9ydCB7IEJhc2VUcmFuc2FjdGlvbiB9IGZyb20gJy4uLy4uLy4uL2FjY291bnQtbGliJztcbmltcG9ydCB7IEVkMjU1MTlCaXAzMkhkVHJlZSB9IGZyb20gJ0BiaXRnby9zZGstbGliLW1wYyc7XG5pbXBvcnQgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuaW1wb3J0IHsgY29tbW9uVmVyaWZ5V2FsbGV0U2lnbmF0dXJlLCBnZXRUeFJlcXVlc3QsIHNlbmRTaWduYXR1cmVTaGFyZSB9IGZyb20gJy4uL2NvbW1vbic7XG5cbmV4cG9ydCB7IGdldFR4UmVxdWVzdCwgc2VuZFNpZ25hdHVyZVNoYXJlIH07XG5cbi8qKlxuICogQ29tYmluZXMgWVNoYXJlcyB0byBjb21iaW5lIHRoZSBmaW5hbCBUU1Mga2V5XG4gKiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBVc2VyIG9yIEJhY2t1cCBrZXkgc2luY2UgaXQgcmVxdWlyZXMgdGhlIGNvbW1vbiBrZXljaGFpbiBmcm9tIEJpdEdvIGZpcnN0XG4gKlxuICogQHBhcmFtIHBhcmFtcy5rZXlTaGFyZSAtIFRTUyBrZXkgc2hhcmVcbiAqIEBwYXJhbSBwYXJhbXMuZW5jcnlwdGVkWVNoYXJlcyAtIGVuY3J5cHRlZCBZU2hhcmVzIHdpdGggaW5mb3JtYXRpb24gb24gaG93IHRvIGRlY3J5cHRcbiAqIEBwYXJhbSBwYXJhbXMuY29tbW9uS2V5Y2hhaW4gLSBleHBlY3RlZCBjb21tb24ga2V5Y2hhaW4gb2YgdGhlIGNvbWJpbmVkIGtleVxuICogQHJldHVybnMge0NvbWJpbmVkS2V5fSBjb21iaW5lZCBUU1Mga2V5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDb21iaW5lZEtleShwYXJhbXM6IHtcbiAga2V5U2hhcmU6IEtleVNoYXJlO1xuICBlbmNyeXB0ZWRZU2hhcmVzOiBEZWNyeXB0YWJsZVlTaGFyZVtdO1xuICBjb21tb25LZXljaGFpbjogc3RyaW5nO1xufSk6IFByb21pc2U8Q29tYmluZWRLZXk+IHtcbiAgYXdhaXQgRWRkc2EuaW5pdGlhbGl6ZSgpO1xuICBjb25zdCBNUEMgPSBuZXcgRWRkc2EoKTtcblxuICBjb25zdCB7IGtleVNoYXJlLCBlbmNyeXB0ZWRZU2hhcmVzLCBjb21tb25LZXljaGFpbiB9ID0gcGFyYW1zO1xuICBjb25zdCB5U2hhcmVzOiBZU2hhcmVbXSA9IFtdO1xuXG4gIGxldCBiaXRnb1lTaGFyZTogWVNoYXJlIHwgdW5kZWZpbmVkO1xuICBsZXQgdXNlcllTaGFyZTogWVNoYXJlIHwgdW5kZWZpbmVkO1xuICBsZXQgYmFja3VwWVNoYXJlOiBZU2hhcmUgfCB1bmRlZmluZWQ7XG5cbiAgZm9yIChjb25zdCBlbmNyeXB0ZWRZU2hhcmUgb2YgZW5jcnlwdGVkWVNoYXJlcykge1xuICAgIGNvbnN0IHByaXZhdGVTaGFyZSA9IGF3YWl0IHJlYWRTaWduZWRNZXNzYWdlKFxuICAgICAgZW5jcnlwdGVkWVNoYXJlLnlTaGFyZS5lbmNyeXB0ZWRQcml2YXRlU2hhcmUsXG4gICAgICBlbmNyeXB0ZWRZU2hhcmUuc2VuZGVyUHVibGljQXJtb3IsXG4gICAgICBlbmNyeXB0ZWRZU2hhcmUucmVjaXBpZW50UHJpdmF0ZUFybW9yXG4gICAgKTtcblxuICAgIGNvbnN0IHlTaGFyZTogWVNoYXJlID0ge1xuICAgICAgaTogZW5jcnlwdGVkWVNoYXJlLnlTaGFyZS5pLFxuICAgICAgajogZW5jcnlwdGVkWVNoYXJlLnlTaGFyZS5qLFxuICAgICAgeTogZW5jcnlwdGVkWVNoYXJlLnlTaGFyZS5wdWJsaWNTaGFyZS5zbGljZSgwLCA2NCksXG4gICAgICB2OiBlbmNyeXB0ZWRZU2hhcmUueVNoYXJlLnB1YmxpY1NoYXJlLnNsaWNlKDY0LCAxMjgpLFxuICAgICAgdTogcHJpdmF0ZVNoYXJlLnNsaWNlKDAsIDY0KSxcbiAgICAgIGNoYWluY29kZTogcHJpdmF0ZVNoYXJlLnNsaWNlKDY0KSxcbiAgICB9O1xuXG4gICAgc3dpdGNoIChlbmNyeXB0ZWRZU2hhcmUueVNoYXJlLmopIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdXNlcllTaGFyZSA9IHlTaGFyZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGJhY2t1cFlTaGFyZSA9IHlTaGFyZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGJpdGdvWVNoYXJlID0geVNoYXJlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBZU2hhcmUgaW5kZXgnKTtcbiAgICB9XG5cbiAgICB5U2hhcmVzLnB1c2goeVNoYXJlKTtcbiAgfVxuXG4gIGNvbnN0IGNvbWJpbmVkS2V5ID0gTVBDLmtleUNvbWJpbmUoa2V5U2hhcmUudVNoYXJlLCB5U2hhcmVzKTtcbiAgaWYgKGNvbWJpbmVkS2V5LnBTaGFyZS55ICsgY29tYmluZWRLZXkucFNoYXJlLmNoYWluY29kZSAhPT0gY29tbW9uS2V5Y2hhaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbW1vbiBrZXljaGFpbnMgZG8gbm90IG1hdGNoJyk7XG4gIH1cbiAgaWYgKCFiaXRnb1lTaGFyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBCaXRHbyBZIFNoYXJlJyk7XG4gIH1cblxuICBjb25zdCBzaWduaW5nTWF0ZXJpYWw6IFNpZ25pbmdNYXRlcmlhbCA9IHtcbiAgICB1U2hhcmU6IGtleVNoYXJlLnVTaGFyZSxcbiAgICBiaXRnb1lTaGFyZSxcbiAgICBiYWNrdXBZU2hhcmUsXG4gICAgdXNlcllTaGFyZSxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNpZ25pbmdNYXRlcmlhbCxcbiAgICBjb21tb25LZXljaGFpbixcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBVc2VyIFNpZ24gU2hhcmUgY29udGFpbmluZyB0aGUgVXNlciBYU2hhcmUgLCB0aGUgVXNlciB0byBCaXRnbyBSU2hhcmUgYW5kIFVzZXIgdG8gQml0Z28gY29tbWl0bWVudFxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYWJsZVBheWxvYWQgLSB0aGUgc2lnbmFibGVQYXlsb2FkIGFzIGEgYnVmZmVyXG4gKiBAcGFyYW0ge1BTaGFyZX0gcFNoYXJlIC0gVXNlcidzIHNpZ25pbmcgbWF0ZXJpYWxcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25TaGFyZT59IC0gVXNlciBTaWduIFNoYXJlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVVc2VyU2lnblNoYXJlKHNpZ25hYmxlUGF5bG9hZDogQnVmZmVyLCBwU2hhcmU6IFBTaGFyZSk6IFByb21pc2U8U2lnblNoYXJlPiB7XG4gIGNvbnN0IE1QQyA9IGF3YWl0IEVkZHNhLmluaXRpYWxpemUoKTtcblxuICBpZiAocFNoYXJlLmkgIT09IFNoYXJlS2V5UG9zaXRpb24uVVNFUikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQU2hhcmUsIFBTaGFyZSBkb2VzbnQgYmVsb25nIHRvIHRoZSBVc2VyJyk7XG4gIH1cbiAgY29uc3QgalNoYXJlOiBKU2hhcmUgPSB7IGk6IFNoYXJlS2V5UG9zaXRpb24uQklUR08sIGo6IFNoYXJlS2V5UG9zaXRpb24uVVNFUiB9O1xuICByZXR1cm4gTVBDLnNpZ25TaGFyZShzaWduYWJsZVBheWxvYWQsIHBTaGFyZSwgW2pTaGFyZV0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFVzZXIgdG8gQml0Z28gR1NoYXJlXG4gKlxuICogQHBhcmFtIHtTaWduU2hhcmV9IHVzZXJTaWduU2hhcmUgLSB0aGUgVXNlciBTaWduIFNoYXJlXG4gKiBAcGFyYW0ge1NpZ25hdHVyZVNoYXJlUmVjb3JkfSBiaXRnb1RvVXNlclJTaGFyZSAtIHRoZSBCaXRnbyB0byBVc2VyIFJTaGFyZVxuICogQHBhcmFtIHtZU2hhcmV9IGJhY2t1cFRvVXNlcllTaGFyZSAtIHRoZSBiYWNrdXAga2V5IFkgc2hhcmUgcmVjZWl2ZWQgZHVyaW5nIHdhbGxldCBjcmVhdGlvblxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hYmxlUGF5bG9hZCAtIHRoZSBzaWduYWJsZSBwYXlsb2FkIGZyb20gYSB0eFxuICogQHBhcmFtIHtDb21taXRtZW50U2hhcmVSZWNvcmR9IFtiaXRnb1RvVXNlckNvbW1pdG1lbnRdIC0gdGhlIEJpdGdvIHRvIFVzZXIgQ29tbWl0bWVudFxuICogQHJldHVybnMge1Byb21pc2U8R1NoYXJlPn0gLSB0aGUgVXNlciB0byBCaXRnbyBHU2hhcmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVVzZXJUb0JpdEdvR1NoYXJlKFxuICB1c2VyU2lnblNoYXJlOiBTaWduU2hhcmUsXG4gIGJpdGdvVG9Vc2VyUlNoYXJlOiBTaWduYXR1cmVTaGFyZVJlY29yZCxcbiAgYmFja3VwVG9Vc2VyWVNoYXJlOiBZU2hhcmUsXG4gIGJpdGdvVG9Vc2VyWVNoYXJlOiBZU2hhcmUsXG4gIHNpZ25hYmxlUGF5bG9hZDogQnVmZmVyLFxuICBiaXRnb1RvVXNlckNvbW1pdG1lbnQ/OiBDb21taXRtZW50U2hhcmVSZWNvcmRcbik6IFByb21pc2U8R1NoYXJlPiB7XG4gIGlmICh1c2VyU2lnblNoYXJlLnhTaGFyZS5pICE9PSBTaGFyZUtleVBvc2l0aW9uLlVTRVIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgWFNoYXJlLCBkb2VzbnQgYmVsb25nIHRvIHRoZSBVc2VyJyk7XG4gIH1cbiAgaWYgKGJpdGdvVG9Vc2VyUlNoYXJlLmZyb20gIT09IFNpZ25hdHVyZVNoYXJlVHlwZS5CSVRHTyB8fCBiaXRnb1RvVXNlclJTaGFyZS50byAhPT0gU2lnbmF0dXJlU2hhcmVUeXBlLlVTRVIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUlNoYXJlLCBpcyBub3QgZnJvbSBCaXRnbyB0byBVc2VyJyk7XG4gIH1cbiAgaWYgKGJhY2t1cFRvVXNlcllTaGFyZS5pICE9PSBTaGFyZUtleVBvc2l0aW9uLlVTRVIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgWVNoYXJlLCBkb2VzbnQgYmVsb25nIHRvIHRoZSBVc2VyJyk7XG4gIH1cbiAgaWYgKGJhY2t1cFRvVXNlcllTaGFyZS5qICE9PSBTaGFyZUtleVBvc2l0aW9uLkJBQ0tVUCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBZU2hhcmUsIGlzIG5vdCBiYWNrdXAga2V5Jyk7XG4gIH1cblxuICBsZXQgdiwgciwgUjtcbiAgaWYgKGJpdGdvVG9Vc2VyUlNoYXJlLnNoYXJlLmxlbmd0aCA+IDEyOCkge1xuICAgIHYgPSBiaXRnb1RvVXNlclJTaGFyZS5zaGFyZS5zdWJzdHJpbmcoMCwgNjQpO1xuICAgIHIgPSBiaXRnb1RvVXNlclJTaGFyZS5zaGFyZS5zdWJzdHJpbmcoNjQsIDEyOCk7XG4gICAgUiA9IGJpdGdvVG9Vc2VyUlNoYXJlLnNoYXJlLnN1YnN0cmluZygxMjgsIDE5Mik7XG4gIH0gZWxzZSB7XG4gICAgciA9IGJpdGdvVG9Vc2VyUlNoYXJlLnNoYXJlLnN1YnN0cmluZygwLCA2NCk7XG4gICAgUiA9IGJpdGdvVG9Vc2VyUlNoYXJlLnNoYXJlLnN1YnN0cmluZyg2NCwgMTI4KTtcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZWRCaXRnb1RvVXNlclJTaGFyZTogUlNoYXJlID0ge1xuICAgIGk6IFNoYXJlS2V5UG9zaXRpb24uVVNFUixcbiAgICBqOiBTaGFyZUtleVBvc2l0aW9uLkJJVEdPLFxuICAgIHU6IGJpdGdvVG9Vc2VyWVNoYXJlLnUsXG4gICAgdixcbiAgICByLFxuICAgIFIsXG4gIH07XG5cbiAgY29uc3QgTVBDID0gYXdhaXQgRWRkc2EuaW5pdGlhbGl6ZSgpO1xuXG4gIGlmIChiaXRnb1RvVXNlckNvbW1pdG1lbnQpIHtcbiAgICBpZiAoXG4gICAgICBiaXRnb1RvVXNlckNvbW1pdG1lbnQuZnJvbSAhPT0gU2lnbmF0dXJlU2hhcmVUeXBlLkJJVEdPIHx8XG4gICAgICBiaXRnb1RvVXNlckNvbW1pdG1lbnQudG8gIT09IFNpZ25hdHVyZVNoYXJlVHlwZS5VU0VSXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ29tbWl0bWVudCwgaXMgbm90IGZyb20gQml0Z28gdG8gVXNlcicpO1xuICAgIH1cbiAgICBpZiAoYml0Z29Ub1VzZXJDb21taXRtZW50LnR5cGUgIT09IENvbW1pdG1lbnRUeXBlLkNPTU1JVE1FTlQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBDb21taXRtZW50IHR5cGUsIGdvdDogJyArIGJpdGdvVG9Vc2VyQ29tbWl0bWVudC50eXBlICsgJyBleHBlY3RlZDogY29tbWl0bWVudCcpO1xuICAgIH1cbiAgICB1cGRhdGVkQml0Z29Ub1VzZXJSU2hhcmUuY29tbWl0bWVudCA9IGJpdGdvVG9Vc2VyQ29tbWl0bWVudC5zaGFyZTtcbiAgfVxuXG4gIHJldHVybiBNUEMuc2lnbihzaWduYWJsZVBheWxvYWQsIHVzZXJTaWduU2hhcmUueFNoYXJlLCBbdXBkYXRlZEJpdGdvVG9Vc2VyUlNoYXJlXSwgW2JhY2t1cFRvVXNlcllTaGFyZV0pO1xufVxuXG4vKipcbiAqIFNlbmRzIHRoZSBVc2VyIHRvIEJpdGdvIFJTaGFyZSB0byBCaXRnb1xuICogQHBhcmFtIHtCaXRHb0Jhc2V9IGJpdGdvIC0gdGhlIGJpdGdvIGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gd2FsbGV0SWQgLSB0aGUgd2FsbGV0IGlkXG4gKiBAcGFyYW0ge1N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0aGUgdHhSZXF1ZXN0IElkXG4gKiBAcGFyYW0ge1NpZ25TaGFyZX0gdXNlclNpZ25TaGFyZSAtIHRoZSB1c2VyIFNpZ24gU2hhcmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmNyeXB0ZWRTaWduZXJTaGFyZSAtIHNpZ25lciBzaGFyZSBlbmNyeXB0ZWQgdG8gYml0Z28ga2V5XG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG9mZmVyVXNlclRvQml0Z29SU2hhcmUoXG4gIGJpdGdvOiBCaXRHb0Jhc2UsXG4gIHdhbGxldElkOiBzdHJpbmcsXG4gIHR4UmVxdWVzdElkOiBzdHJpbmcsXG4gIHVzZXJTaWduU2hhcmU6IFNpZ25TaGFyZSxcbiAgZW5jcnlwdGVkU2lnbmVyU2hhcmU6IHN0cmluZyxcbiAgYXBpTW9kZTogJ2Z1bGwnIHwgJ2xpdGUnID0gJ2xpdGUnLFxuICB2c3NQcm9vZj86IHN0cmluZyxcbiAgcHJpdmF0ZVNoYXJlUHJvb2Y/OiBzdHJpbmcsXG4gIHVzZXJQdWJsaWNHcGdLZXk/OiBzdHJpbmcsXG4gIHB1YmxpY1NoYXJlPzogc3RyaW5nXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgclNoYXJlOiBSU2hhcmUgPSB1c2VyU2lnblNoYXJlLnJTaGFyZXNbU2hhcmVLZXlQb3NpdGlvbi5CSVRHT107XG4gIGlmIChfLmlzTmlsKHJTaGFyZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZXJUb0JpdGdvIFJTaGFyZSBub3QgZm91bmQnKTtcbiAgfVxuICBpZiAoclNoYXJlLmkgIT09IFNoYXJlS2V5UG9zaXRpb24uQklUR08gfHwgclNoYXJlLmogIT09IFNoYXJlS2V5UG9zaXRpb24uVVNFUikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBSU2hhcmUsIGlzIG5vdCBmcm9tIFVzZXIgdG8gQml0Z28nKTtcbiAgfVxuICBjb25zdCBzaWduYXR1cmVTaGFyZTogU2lnbmF0dXJlU2hhcmVSZWNvcmQgPSB7XG4gICAgZnJvbTogU2lnbmF0dXJlU2hhcmVUeXBlLlVTRVIsXG4gICAgdG86IFNpZ25hdHVyZVNoYXJlVHlwZS5CSVRHTyxcbiAgICBzaGFyZTogclNoYXJlLnIgKyByU2hhcmUuUixcbiAgICB2c3NQcm9vZixcbiAgICBwcml2YXRlU2hhcmVQcm9vZixcbiAgICBwdWJsaWNTaGFyZSxcbiAgfTtcblxuICAvLyBUT0RPIChCRy01Nzk0NCk6IGltcGxlbWVudCBtZXNzYWdlIHNpZ25pbmcgZm9yIEVERFNBXG4gIGF3YWl0IHNlbmRTaWduYXR1cmVTaGFyZShcbiAgICBiaXRnbyxcbiAgICB3YWxsZXRJZCxcbiAgICB0eFJlcXVlc3RJZCxcbiAgICBzaWduYXR1cmVTaGFyZSxcbiAgICBSZXF1ZXN0VHlwZS50eCxcbiAgICBlbmNyeXB0ZWRTaWduZXJTaGFyZSxcbiAgICAnZWRkc2EnLFxuICAgIGFwaU1vZGUsXG4gICAgdXNlclB1YmxpY0dwZ0tleVxuICApO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIEJpdGdvIHRvIFVzZXIgUlNoYXJlIGZyb20gQml0Z29cbiAqXG4gKiBAcGFyYW0ge0JpdEdvQmFzZX0gYml0Z28gLSB0aGUgYml0Z28gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSB3YWxsZXRJZCAtIHRoZSB3YWxsZXQgaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eFJlcXVlc3RJZCAtIHRoZSB0eFJlcXVlc3QgSWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25hdHVyZVNoYXJlUmVjb3JkPn0gLSBhIFNpZ25hdHVyZSBTaGFyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Qml0Z29Ub1VzZXJSU2hhcmUoXG4gIGJpdGdvOiBCaXRHb0Jhc2UsXG4gIHdhbGxldElkOiBzdHJpbmcsXG4gIHR4UmVxdWVzdElkOiBzdHJpbmdcbik6IFByb21pc2U8U2lnbmF0dXJlU2hhcmVSZWNvcmQ+IHtcbiAgY29uc3QgdHhSZXF1ZXN0ID0gYXdhaXQgZ2V0VHhSZXF1ZXN0KGJpdGdvLCB3YWxsZXRJZCwgdHhSZXF1ZXN0SWQpO1xuICBsZXQgc2lnbmF0dXJlU2hhcmVzO1xuICBpZiAodHhSZXF1ZXN0LmFwaVZlcnNpb24gPT09ICdmdWxsJykge1xuICAgIGFzc2VydCh0eFJlcXVlc3QudHJhbnNhY3Rpb25zLCAndHJhbnNhY3Rpb25zIHJlcXVpcmVkIGFzIHBhcnQgb2YgdHhSZXF1ZXN0Jyk7XG4gICAgc2lnbmF0dXJlU2hhcmVzID0gdHhSZXF1ZXN0LnRyYW5zYWN0aW9uc1swXS5zaWduYXR1cmVTaGFyZXM7XG4gIH0gZWxzZSB7XG4gICAgc2lnbmF0dXJlU2hhcmVzID0gdHhSZXF1ZXN0LnNpZ25hdHVyZVNoYXJlcztcbiAgfVxuICBpZiAoXy5pc05pbChzaWduYXR1cmVTaGFyZXMpIHx8IF8uaXNFbXB0eShzaWduYXR1cmVTaGFyZXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBzaWduYXR1cmVzIHNoYXJlcyBmb3VuZCBmb3IgaWQ6ICR7dHhSZXF1ZXN0SWR9YCk7XG4gIH1cbiAgLy8gYXQgdGhpcyBwb2ludCB3ZSBleHBlY3QgdGhlIG9ubHkgc2hhcmUgdG8gYmUgdGhlIFJTaGFyZVxuICBjb25zdCBiaXRnb1RvVXNlclJTaGFyZSA9IHNpZ25hdHVyZVNoYXJlcy5maW5kKFxuICAgIChzaWdTaGFyZSkgPT4gc2lnU2hhcmUuZnJvbSA9PT0gU2lnbmF0dXJlU2hhcmVUeXBlLkJJVEdPICYmIHNpZ1NoYXJlLnRvID09PSBTaWduYXR1cmVTaGFyZVR5cGUuVVNFUlxuICApO1xuICBpZiAoXy5pc05pbChiaXRnb1RvVXNlclJTaGFyZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdGdvIHRvIFVzZXIgUlNoYXJlIG5vdCBmb3VuZCBmb3IgaWQ6ICR7dHhSZXF1ZXN0SWR9YCk7XG4gIH1cbiAgcmV0dXJuIGJpdGdvVG9Vc2VyUlNoYXJlO1xufVxuXG4vKipcbiAqIFNlbmRzIHRoZSBVc2VyIHRvIEJpdGdvIEdTaGFyZSB0byBCaXRnb1xuICpcbiAqIEBwYXJhbSB7Qml0R29CYXNlfSBiaXRnbyAtIHRoZSBiaXRnbyBpbnN0YW5jZVxuICogQHBhcmFtIHtTdHJpbmd9IHdhbGxldElkIC0gdGhlIHdhbGxldCBpZFxuICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICogQHBhcmFtIHtHU2hhcmV9IHVzZXJUb0JpdGdvR1NoYXJlIC0gdGhlIFVzZXIgdG8gQml0Z28gR1NoYXJlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRVc2VyVG9CaXRnb0dTaGFyZShcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgdHhSZXF1ZXN0SWQ6IHN0cmluZyxcbiAgdXNlclRvQml0Z29HU2hhcmU6IEdTaGFyZSxcbiAgYXBpTW9kZTogJ2Z1bGwnIHwgJ2xpdGUnID0gJ2xpdGUnXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKHVzZXJUb0JpdGdvR1NoYXJlLmkgIT09IFNoYXJlS2V5UG9zaXRpb24uVVNFUikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBHU2hhcmUsIGRvZXNudCBiZWxvbmcgdG8gdGhlIFVzZXInKTtcbiAgfVxuICBjb25zdCBzaWduYXR1cmVTaGFyZTogU2lnbmF0dXJlU2hhcmVSZWNvcmQgPSB7XG4gICAgZnJvbTogU2lnbmF0dXJlU2hhcmVUeXBlLlVTRVIsXG4gICAgdG86IFNpZ25hdHVyZVNoYXJlVHlwZS5CSVRHTyxcbiAgICBzaGFyZTogdXNlclRvQml0Z29HU2hhcmUuUiArIHVzZXJUb0JpdGdvR1NoYXJlLmdhbW1hLFxuICB9O1xuXG4gIC8vIFRPRE8gKEJHLTU3OTQ0KTogaW1wbGVtZW50IG1lc3NhZ2Ugc2lnbmluZyBmb3IgRUREU0FcbiAgYXdhaXQgc2VuZFNpZ25hdHVyZVNoYXJlKGJpdGdvLCB3YWxsZXRJZCwgdHhSZXF1ZXN0SWQsIHNpZ25hdHVyZVNoYXJlLCBSZXF1ZXN0VHlwZS50eCwgdW5kZWZpbmVkLCAnZWRkc2EnLCBhcGlNb2RlKTtcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyBhIFlTaGFyZSB0byBiZSBleGNoYW5nZWQgd2l0aCBvdGhlciBrZXkgaG9sZGVycy5cbiAqIE91dHB1dCBpcyBpbiBhIGZvcm1hdCB0aGF0IGlzIHVzYWJsZSB3aXRoaW4gQml0R28ncyBlY29zeXN0ZW0uXG4gKlxuICogQHBhcmFtIHBhcmFtcy5rZXlTaGFyZSAtIFRTUyBrZXkgc2hhcmUgb2YgdGhlIHBhcnR5IHByZXBhcmluZyBleGNoYW5nZSBtYXRlcmlhbHNcbiAqIEBwYXJhbSBwYXJhbXMucmVjaXBpZW50SW5kZXggLSBpbmRleCBvZiB0aGUgcmVjaXBpZW50ICgxLCAyLCBvciAzKVxuICogQHBhcmFtIHBhcmFtcy5yZWNpcGllbnRHcGdQdWJsaWNBcm1vciAtIHJlY2lwaWVudCdzIHB1YmxpYyBncGcga2V5IGluIGFybW9yIGZvcm1hdFxuICogQHBhcmFtIHBhcmFtcy5zZW5kZXJHcGdQcml2YXRlQXJtb3IgLSBzZW5kZXIncyBwcml2YXRlIGdwZyBrZXkgaW4gYXJtb3IgZm9ybWF0XG4gKiBAcmV0dXJucyB7IEVuY3J5cHRlZFlTaGFyZSB9IGVuY3J5cHRlZCBZIFNoYXJlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0WVNoYXJlKHBhcmFtczoge1xuICBrZXlTaGFyZTogS2V5U2hhcmU7XG4gIHJlY2lwaWVudEluZGV4OiBudW1iZXI7XG4gIHJlY2lwaWVudEdwZ1B1YmxpY0FybW9yOiBzdHJpbmc7XG4gIHNlbmRlckdwZ1ByaXZhdGVBcm1vcjogc3RyaW5nO1xufSk6IFByb21pc2U8RW5jcnlwdGVkWVNoYXJlPiB7XG4gIGNvbnN0IHsga2V5U2hhcmUsIHJlY2lwaWVudEluZGV4LCByZWNpcGllbnRHcGdQdWJsaWNBcm1vciwgc2VuZGVyR3BnUHJpdmF0ZUFybW9yIH0gPSBwYXJhbXM7XG5cbiAgY29uc3QgeVNoYXJlID0ga2V5U2hhcmUueVNoYXJlc1tyZWNpcGllbnRJbmRleF07XG4gIGlmICgheVNoYXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlY2lwaWVudCcpO1xuICB9XG5cbiAgY29uc3QgcHVibGljU2hhcmUgPSBCdWZmZXIuY29uY2F0KFtcbiAgICBCdWZmZXIuZnJvbShrZXlTaGFyZS51U2hhcmUueSwgJ2hleCcpLFxuICAgIEJ1ZmZlci5mcm9tKHlTaGFyZS52ISwgJ2hleCcpLFxuICAgIEJ1ZmZlci5mcm9tKGtleVNoYXJlLnVTaGFyZS5jaGFpbmNvZGUsICdoZXgnKSxcbiAgXSkudG9TdHJpbmcoJ2hleCcpO1xuXG4gIGNvbnN0IHByaXZhdGVTaGFyZSA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKHlTaGFyZS51LCAnaGV4JyksIEJ1ZmZlci5mcm9tKHlTaGFyZS5jaGFpbmNvZGUsICdoZXgnKV0pLnRvU3RyaW5nKFxuICAgICdoZXgnXG4gICk7XG5cbiAgY29uc3QgZW5jcnlwdGVkUHJpdmF0ZVNoYXJlID0gYXdhaXQgZW5jcnlwdEFuZFNpZ25UZXh0KHByaXZhdGVTaGFyZSwgcmVjaXBpZW50R3BnUHVibGljQXJtb3IsIHNlbmRlckdwZ1ByaXZhdGVBcm1vcik7XG5cbiAgcmV0dXJuIHtcbiAgICBpOiB5U2hhcmUuaSxcbiAgICBqOiB5U2hhcmUuaixcbiAgICBwdWJsaWNTaGFyZSxcbiAgICBlbmNyeXB0ZWRQcml2YXRlU2hhcmUsXG4gIH07XG59XG5cbi8qKlxuICpcbiAqIEluaXRpYWxpemVzIEVkZHNhIGluc3RhbmNlXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8RWRkc2E+fSB0aGUgRWRkc2EgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEluaXRpYWxpemVkTXBjSW5zdGFuY2UoKSB7XG4gIGNvbnN0IGhkVHJlZSA9IGF3YWl0IEVkMjU1MTlCaXAzMkhkVHJlZS5pbml0aWFsaXplKCk7XG4gIHJldHVybiBhd2FpdCBFZGRzYS5pbml0aWFsaXplKGhkVHJlZSk7XG59XG5cbi8qKlxuICpcbiAqIEdlbmVyYXRlcyBhIFRTUyBzaWduYXR1cmUgdXNpbmcgdGhlIHVzZXIgYW5kIGJhY2t1cCBrZXlcbiAqXG4gKiBAcGFyYW0ge1VzZXJTaWduaW5nTWF0ZXJpYWx9IHVzZXJTaWduaW5nTWF0ZXJpYWwgZGVjcnlwdGVkIHVzZXIgVFNTIGtleVxuICogQHBhcmFtIHtCYWNrdXBTaWduaW5nTWF0ZXJpYWx9IGJhY2t1cFNpZ25pbmdNYXRlcmlhbCBkZWNyeXB0ZWQgYmFja3VwIFRTUyBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIGJpcDMyIGRlcml2YXRpb24gcGF0aFxuICogQHBhcmFtIHtCYXNlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIHRoZSB0cmFuc2FjdGlvbiB0byBzaWduXG4gKiBAcmV0dXJucyB7QnVmZmVyfSB0aGUgc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUU1NTaWduYXR1cmUoXG4gIHVzZXJTaWduaW5nTWF0ZXJpYWw6IFVzZXJTaWduaW5nTWF0ZXJpYWwsXG4gIGJhY2t1cFNpZ25pbmdNYXRlcmlhbDogQmFja3VwU2lnbmluZ01hdGVyaWFsLFxuICBwYXRoID0gJ20vMCcsXG4gIHRyYW5zYWN0aW9uOiBCYXNlVHJhbnNhY3Rpb25cbik6IFByb21pc2U8QnVmZmVyPiB7XG4gIGNvbnN0IE1QQyA9IGF3YWl0IGdldEluaXRpYWxpemVkTXBjSW5zdGFuY2UoKTtcblxuICBjb25zdCB1c2VyQ29tYmluZSA9IE1QQy5rZXlDb21iaW5lKHVzZXJTaWduaW5nTWF0ZXJpYWwudVNoYXJlLCBbXG4gICAgdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb1lTaGFyZSxcbiAgICB1c2VyU2lnbmluZ01hdGVyaWFsLmJhY2t1cFlTaGFyZSxcbiAgXSk7XG4gIGNvbnN0IGJhY2t1cENvbWJpbmUgPSBNUEMua2V5Q29tYmluZShiYWNrdXBTaWduaW5nTWF0ZXJpYWwudVNoYXJlLCBbXG4gICAgYmFja3VwU2lnbmluZ01hdGVyaWFsLmJpdGdvWVNoYXJlLFxuICAgIGJhY2t1cFNpZ25pbmdNYXRlcmlhbC51c2VyWVNoYXJlLFxuICBdKTtcblxuICBjb25zdCB1c2VyU3Via2V5ID0gTVBDLmtleURlcml2ZShcbiAgICB1c2VyU2lnbmluZ01hdGVyaWFsLnVTaGFyZSxcbiAgICBbdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb1lTaGFyZSwgdXNlclNpZ25pbmdNYXRlcmlhbC5iYWNrdXBZU2hhcmVdLFxuICAgIHBhdGhcbiAgKTtcblxuICBjb25zdCBiYWNrdXBTdWJrZXkgPSBNUEMua2V5Q29tYmluZShiYWNrdXBTaWduaW5nTWF0ZXJpYWwudVNoYXJlLCBbXG4gICAgdXNlclN1YmtleS55U2hhcmVzWzJdLFxuICAgIGJhY2t1cFNpZ25pbmdNYXRlcmlhbC5iaXRnb1lTaGFyZSxcbiAgXSk7XG5cbiAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IHRyYW5zYWN0aW9uLnNpZ25hYmxlUGF5bG9hZDtcbiAgY29uc3QgdXNlclNpZ25TaGFyZSA9IE1QQy5zaWduU2hhcmUobWVzc2FnZUJ1ZmZlciwgdXNlclN1YmtleS5wU2hhcmUsIFt1c2VyQ29tYmluZS5qU2hhcmVzWzJdXSk7XG4gIGNvbnN0IGJhY2t1cFNpZ25TaGFyZSA9IE1QQy5zaWduU2hhcmUobWVzc2FnZUJ1ZmZlciwgYmFja3VwU3Via2V5LnBTaGFyZSwgW2JhY2t1cENvbWJpbmUualNoYXJlc1sxXV0pO1xuICBjb25zdCB1c2VyU2lnbiA9IE1QQy5zaWduKFxuICAgIG1lc3NhZ2VCdWZmZXIsXG4gICAgdXNlclNpZ25TaGFyZS54U2hhcmUsXG4gICAgW2JhY2t1cFNpZ25TaGFyZS5yU2hhcmVzWzFdXSxcbiAgICBbdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb1lTaGFyZV1cbiAgKTtcbiAgY29uc3QgYmFja3VwU2lnbiA9IE1QQy5zaWduKFxuICAgIG1lc3NhZ2VCdWZmZXIsXG4gICAgYmFja3VwU2lnblNoYXJlLnhTaGFyZSxcbiAgICBbdXNlclNpZ25TaGFyZS5yU2hhcmVzWzJdXSxcbiAgICBbYmFja3VwU2lnbmluZ01hdGVyaWFsLmJpdGdvWVNoYXJlXVxuICApO1xuICBjb25zdCBzaWduYXR1cmUgPSBNUEMuc2lnbkNvbWJpbmUoW3VzZXJTaWduLCBiYWNrdXBTaWduXSk7XG4gIGNvbnN0IHJlc3VsdCA9IE1QQy52ZXJpZnkobWVzc2FnZUJ1ZmZlciwgc2lnbmF0dXJlKTtcbiAgaWYgKCFyZXN1bHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gIH1cbiAgY29uc3QgcmF3U2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oc2lnbmF0dXJlLlIsICdoZXgnKSwgQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNpZ21hLCAnaGV4JyldKTtcbiAgcmV0dXJuIHJhd1NpZ25hdHVyZTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGEgVFNTIHdhbGxldCBzaWduYXR1cmUgd2FzIHByb2R1Y2VkIHdpdGggdGhlIGV4cGVjdGVkIGtleSBhbmQgdGhhdCB0aGUgc2lnbmVkIGRhdGEgY29udGFpbnMgdGhlXG4gKiBleHBlY3RlZCBjb21tb24ga2V5Y2hhaW4sIHRoZSBleHBlY3RlZCB1c2VyIGFuZCBiYWNrdXAga2V5IGlkcyBhcyB3ZWxsIGFzIHRoZSBwdWJsaWMgc2hhcmUgdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGVcbiAqIHByaXZhdGUgc2hhcmUgdGhhdCB3YXMgcGFzc2VkIGluLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5V2FsbGV0U2lnbmF0dXJlKHBhcmFtczoge1xuICB3YWxsZXRTaWduYXR1cmU6IG9wZW5wZ3AuS2V5O1xuICBiaXRnb1B1Yjogb3BlbnBncC5LZXk7XG4gIGNvbW1vbktleWNoYWluOiBzdHJpbmc7XG4gIHVzZXJLZXlJZDogc3RyaW5nO1xuICBiYWNrdXBLZXlJZDogc3RyaW5nO1xuICBkZWNyeXB0ZWRTaGFyZTogc3RyaW5nO1xuICB2ZXJpZmllckluZGV4OiAxIHwgMjsgLy8gdGhlIGluZGV4IG9mIHRoZSB2ZXJpZmllciwgMSBtZWFucyB1c2VyLCAyIG1lYW5zIGJhY2t1cFxufSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByYXdOb3RhdGlvbnMgPSBhd2FpdCBjb21tb25WZXJpZnlXYWxsZXRTaWduYXR1cmUocGFyYW1zKTtcblxuICBjb25zdCB7IGRlY3J5cHRlZFNoYXJlLCB2ZXJpZmllckluZGV4IH0gPSBwYXJhbXM7XG5cbiAgY29uc3QgcHVibGljU2hhcmUgPVxuICAgIEJ1ZmZlci5mcm9tKFxuICAgICAgYXdhaXQgc29kaXVtLmNyeXB0b19zY2FsYXJtdWx0X2VkMjU1MTlfYmFzZV9ub2NsYW1wKEJ1ZmZlci5mcm9tKGRlY3J5cHRlZFNoYXJlLnNsaWNlKDAsIDY0KSwgJ2hleCcpKVxuICAgICkudG9TdHJpbmcoJ2hleCcpICsgZGVjcnlwdGVkU2hhcmUuc2xpY2UoNjQpO1xuICBjb25zdCBwdWJsaWNTaGFyZVJhd05vdGF0aW9uSW5kZXggPSAyICsgdmVyaWZpZXJJbmRleDtcblxuICBhc3NlcnQoXG4gICAgcHVibGljU2hhcmUgPT09IEJ1ZmZlci5mcm9tKHJhd05vdGF0aW9uc1twdWJsaWNTaGFyZVJhd05vdGF0aW9uSW5kZXhdLnZhbHVlKS50b1N0cmluZygpLFxuICAgICdiaXRnbyBzaGFyZSBtaXNtYXRjaCdcbiAgKTtcbn1cbiJdfQ==