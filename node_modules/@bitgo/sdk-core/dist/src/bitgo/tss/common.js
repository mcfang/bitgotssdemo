"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTxRequestChallenge = exports.commonVerifyWalletSignature = exports.exchangeEddsaCommitments = exports.sendSignatureShare = exports.getTxRequest = void 0;
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("../utils");
/**
 * Gets the latest Tx Request by id
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id
 * @param {String} txRequestId - the txRequest Id
 * @returns {Promise<TxRequest>}
 */
async function getTxRequest(bitgo, walletId, txRequestId) {
    const txRequestRes = await bitgo
        .get(bitgo.url('/wallet/' + walletId + '/txrequests', 2))
        .query({ txRequestIds: txRequestId, latest: 'true' })
        .result();
    if (txRequestRes.txRequests.length <= 0) {
        throw new Error(`Unable to find TxRequest with id ${txRequestId}`);
    }
    return txRequestRes.txRequests[0];
}
exports.getTxRequest = getTxRequest;
/**
 * Sends a Signature Share
 *
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {String} walletId - the wallet id  *
 * @param {String} txRequestId - the txRequest Id
 * @param {SignatureShareRecord} signatureShare - a Signature Share
 * @param requestType - The type of request being submitted (either tx or message for signing)
 * @param signerShare
 * @param mpcAlgorithm
 * @param apiMode
 * @returns {Promise<SignatureShareRecord>} - a Signature Share
 */
async function sendSignatureShare(bitgo, walletId, txRequestId, signatureShare, requestType, signerShare, mpcAlgorithm = 'eddsa', apiMode = 'lite', userPublicGpgKey) {
    let addendum = '';
    switch (requestType) {
        case utils_1.RequestType.tx:
            if (mpcAlgorithm === 'ecdsa' || apiMode === 'full') {
                addendum = '/transactions/0';
            }
            break;
        case utils_1.RequestType.message:
            if (mpcAlgorithm === 'ecdsa' || apiMode === 'full') {
                addendum = '/messages/0';
            }
            break;
    }
    const urlPath = '/wallet/' + walletId + '/txrequests/' + txRequestId + addendum + '/signatureshares';
    return bitgo
        .post(bitgo.url(urlPath, 2))
        .send({
        signatureShare,
        signerShare,
        userPublicGpgKey,
    })
        .result();
}
exports.sendSignatureShare = sendSignatureShare;
/**
 * Sends the client commitment and encrypted signer share to the server, getting back the server commitment
 * @param {BitGoBase} bitgo - the bitgo instance
 * @param {string} walletId - the wallet id
 * @param {string} txRequestId - the txRequest Id
 * @param {CommitmentShareRecord} commitmentShare - the client commitment share
 * @param {EncryptedSignerShareRecord} encryptedSignerShare - the client encrypted signer share
 * @param {string} [apiMode] - the txRequest api mode (full or lite) - defaults to lite
 * @returns {Promise<ExchangeCommitmentResponse>} - the server commitment share
 */
async function exchangeEddsaCommitments(bitgo, walletId, txRequestId, commitmentShare, encryptedSignerShare, apiMode = 'lite') {
    let addendum = '';
    if (apiMode === 'full') {
        addendum = '/transactions/0';
    }
    const urlPath = '/wallet/' + walletId + '/txrequests/' + txRequestId + addendum + '/commit';
    return await bitgo.post(bitgo.url(urlPath, 2)).send({ commitmentShare, encryptedSignerShare }).result();
}
exports.exchangeEddsaCommitments = exchangeEddsaCommitments;
/**
 * Verifies that a TSS wallet signature was produced with the expected key and that the signed data contains the
 * expected common keychain as well as the expected user and backup key ids
 */
async function commonVerifyWalletSignature(params) {
    const { walletSignature, bitgoPub, commonKeychain, userKeyId, backupKeyId } = params;
    // By ensuring that the fingerprints of the walletSignature and the bitgoPub are different and that any of the results
    // from calling verifyPrimaryUser is valid we know that the signature was actually produced by the private key
    // belonging to the bitgoPub.
    if (walletSignature.keyPacket.getFingerprint() === bitgoPub.keyPacket.getFingerprint()) {
        throw new Error('Invalid HSM GPG signature');
    }
    const verificationResult = await utils_1.verifyPrimaryUserWrapper(walletSignature, bitgoPub, false);
    const isValid = verificationResult.some((result) => result.valid);
    if (!isValid) {
        throw new Error('Invalid HSM GPG signature');
    }
    const primaryUser = await walletSignature.getPrimaryUser();
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore the rawNotations property is missing from the type but it actually exists
    const rawNotations = primaryUser.user.otherCertifications[0].rawNotations;
    assert_1.default(rawNotations.length === 5, 'invalid wallet signatures');
    assert_1.default(commonKeychain === Buffer.from(rawNotations[0].value).toString(), 'wallet signature does not match common keychain');
    assert_1.default(userKeyId === Buffer.from(rawNotations[1].value).toString(), `wallet signature does not match user key id`);
    assert_1.default(backupKeyId === Buffer.from(rawNotations[2].value).toString(), 'wallet signature does not match backup key id');
    return rawNotations;
}
exports.commonVerifyWalletSignature = commonVerifyWalletSignature;
/**
 * Gets challenge for a tx request from BitGo
 * supports Message and regular Transaction
 * @param bitgo
 * @param walletId
 * @param txRequestId
 * @param index
 * @param requestType
 * @param paillierModulus
 */
async function getTxRequestChallenge(bitgo, walletId, txRequestId, index, requestType, paillierModulus) {
    let addendum = '';
    switch (requestType) {
        case utils_1.RequestType.tx:
            addendum = '/transactions/' + index;
            break;
        case utils_1.RequestType.message:
            addendum = '/messages/' + index;
            break;
    }
    const urlPath = '/wallet/' + walletId + '/txrequests/' + txRequestId + addendum + '/challenge';
    return await bitgo.post(bitgo.url(urlPath, 2)).send({ paillierModulus }).result();
}
exports.getTxRequestChallenge = getTxRequestChallenge;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3Rzcy9jb21tb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0RBQTRCO0FBSzVCLG9DQVFrQjtBQUVsQjs7Ozs7OztHQU9HO0FBQ0ksS0FBSyxVQUFVLFlBQVksQ0FBQyxLQUFnQixFQUFFLFFBQWdCLEVBQUUsV0FBbUI7SUFDeEYsTUFBTSxZQUFZLEdBQUcsTUFBTSxLQUFLO1NBQzdCLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxRQUFRLEdBQUcsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3hELEtBQUssQ0FBQyxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDO1NBQ3BELE1BQU0sRUFBRSxDQUFDO0lBRVosSUFBSSxZQUFZLENBQUMsVUFBVSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7UUFDdkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxvQ0FBb0MsV0FBVyxFQUFFLENBQUMsQ0FBQztLQUNwRTtJQUVELE9BQU8sWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQyxDQUFDO0FBWEQsb0NBV0M7QUFFRDs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSSxLQUFLLFVBQVUsa0JBQWtCLENBQ3RDLEtBQWdCLEVBQ2hCLFFBQWdCLEVBQ2hCLFdBQW1CLEVBQ25CLGNBQW9DLEVBQ3BDLFdBQXdCLEVBQ3hCLFdBQW9CLEVBQ3BCLGVBQWtDLE9BQU8sRUFDekMsVUFBMkIsTUFBTSxFQUNqQyxnQkFBeUI7SUFFekIsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ2xCLFFBQVEsV0FBVyxFQUFFO1FBQ25CLEtBQUssbUJBQVcsQ0FBQyxFQUFFO1lBQ2pCLElBQUksWUFBWSxLQUFLLE9BQU8sSUFBSSxPQUFPLEtBQUssTUFBTSxFQUFFO2dCQUNsRCxRQUFR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QUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSw2Q0FBNkMsQ0FBQyxDQUFDO0lBQ25ILGdCQUFNLENBQ0osV0FBVyxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUM3RCwrQ0FBK0MsQ0FDaEQsQ0FBQztJQUVGLE9BQU8sWUFBWSxDQUFDO0FBQ3RCLENBQUM7QUF4Q0Qsa0VBd0NDO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0ksS0FBSyxVQUFVLHFCQUFxQixDQUN6QyxLQUFnQixFQUNoQixRQUFnQixFQUNoQixXQUFtQixFQUNuQixLQUFhLEVBQ2IsV0FBd0IsRUFDeEIsZUFBdUI7SUFFdkIsSUFBSSxRQUFRLEdBQUcsRUFBRSxDQUFDO0lBQ2xCLFFBQVEsV0FBVyxFQUFFO1FBQ25CLEtBQUssbUJBQVcsQ0FBQyxFQUFFO1lBQ2pCLFFBQVEsR0FBRyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7WUFDcEMsTUFBTTtRQUNSLEtBQUssbUJBQVcsQ0FBQyxPQUFPO1lBQ3RCLFFBQVEsR0FBRyxZQUFZLEdBQUcsS0FBSyxDQUFDO1lBQ2hDLE1BQU07S0FDVDtJQUNELE1BQU0sT0FBTyxHQUFHLFVBQVUsR0FBRyxRQUFRLEdBQUcsY0FBYyxHQUFHLFdBQVcsR0FBRyxRQUFRLEdBQUcsWUFBWSxDQUFDO0lBQy9GLE9BQU8sTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUNwRixDQUFDO0FBbkJELHNEQW1CQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCBvcGVucGdwIGZyb20gJ29wZW5wZ3AnO1xuXG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IHsgVHhSZXF1ZXN0Q2hhbGxlbmdlUmVzcG9uc2UgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7XG4gIFJlcXVlc3RUeXBlLFxuICBUeFJlcXVlc3QsXG4gIHZlcmlmeVByaW1hcnlVc2VyV3JhcHBlcixcbiAgU2lnbmF0dXJlU2hhcmVSZWNvcmQsXG4gIENvbW1pdG1lbnRTaGFyZVJlY29yZCxcbiAgRW5jcnlwdGVkU2lnbmVyU2hhcmVSZWNvcmQsXG4gIEV4Y2hhbmdlQ29tbWl0bWVudFJlc3BvbnNlLFxufSBmcm9tICcuLi91dGlscyc7XG5cbi8qKlxuICogR2V0cyB0aGUgbGF0ZXN0IFR4IFJlcXVlc3QgYnkgaWRcbiAqXG4gKiBAcGFyYW0ge0JpdEdvQmFzZX0gYml0Z28gLSB0aGUgYml0Z28gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSB3YWxsZXRJZCAtIHRoZSB3YWxsZXQgaWRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eFJlcXVlc3RJZCAtIHRoZSB0eFJlcXVlc3QgSWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPFR4UmVxdWVzdD59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUeFJlcXVlc3QoYml0Z286IEJpdEdvQmFzZSwgd2FsbGV0SWQ6IHN0cmluZywgdHhSZXF1ZXN0SWQ6IHN0cmluZyk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gIGNvbnN0IHR4UmVxdWVzdFJlcyA9IGF3YWl0IGJpdGdvXG4gICAgLmdldChiaXRnby51cmwoJy93YWxsZXQvJyArIHdhbGxldElkICsgJy90eHJlcXVlc3RzJywgMikpXG4gICAgLnF1ZXJ5KHsgdHhSZXF1ZXN0SWRzOiB0eFJlcXVlc3RJZCwgbGF0ZXN0OiAndHJ1ZScgfSlcbiAgICAucmVzdWx0KCk7XG5cbiAgaWYgKHR4UmVxdWVzdFJlcy50eFJlcXVlc3RzLmxlbmd0aCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBUeFJlcXVlc3Qgd2l0aCBpZCAke3R4UmVxdWVzdElkfWApO1xuICB9XG5cbiAgcmV0dXJuIHR4UmVxdWVzdFJlcy50eFJlcXVlc3RzWzBdO1xufVxuXG4vKipcbiAqIFNlbmRzIGEgU2lnbmF0dXJlIFNoYXJlXG4gKlxuICogQHBhcmFtIHtCaXRHb0Jhc2V9IGJpdGdvIC0gdGhlIGJpdGdvIGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ30gd2FsbGV0SWQgLSB0aGUgd2FsbGV0IGlkICAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0aGUgdHhSZXF1ZXN0IElkXG4gKiBAcGFyYW0ge1NpZ25hdHVyZVNoYXJlUmVjb3JkfSBzaWduYXR1cmVTaGFyZSAtIGEgU2lnbmF0dXJlIFNoYXJlXG4gKiBAcGFyYW0gcmVxdWVzdFR5cGUgLSBUaGUgdHlwZSBvZiByZXF1ZXN0IGJlaW5nIHN1Ym1pdHRlZCAoZWl0aGVyIHR4IG9yIG1lc3NhZ2UgZm9yIHNpZ25pbmcpXG4gKiBAcGFyYW0gc2lnbmVyU2hhcmVcbiAqIEBwYXJhbSBtcGNBbGdvcml0aG1cbiAqIEBwYXJhbSBhcGlNb2RlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduYXR1cmVTaGFyZVJlY29yZD59IC0gYSBTaWduYXR1cmUgU2hhcmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRTaWduYXR1cmVTaGFyZShcbiAgYml0Z286IEJpdEdvQmFzZSxcbiAgd2FsbGV0SWQ6IHN0cmluZyxcbiAgdHhSZXF1ZXN0SWQ6IHN0cmluZyxcbiAgc2lnbmF0dXJlU2hhcmU6IFNpZ25hdHVyZVNoYXJlUmVjb3JkLFxuICByZXF1ZXN0VHlwZTogUmVxdWVzdFR5cGUsXG4gIHNpZ25lclNoYXJlPzogc3RyaW5nLFxuICBtcGNBbGdvcml0aG06ICdlZGRzYScgfCAnZWNkc2EnID0gJ2VkZHNhJyxcbiAgYXBpTW9kZTogJ2Z1bGwnIHwgJ2xpdGUnID0gJ2xpdGUnLFxuICB1c2VyUHVibGljR3BnS2V5Pzogc3RyaW5nXG4pOiBQcm9taXNlPFNpZ25hdHVyZVNoYXJlUmVjb3JkPiB7XG4gIGxldCBhZGRlbmR1bSA9ICcnO1xuICBzd2l0Y2ggKHJlcXVlc3RUeXBlKSB7XG4gICAgY2FzZSBSZXF1ZXN0VHlwZS50eDpcbiAgICAgIGlmIChtcGNBbGdvcml0aG0gPT09ICdlY2RzYScgfHwgYXBpTW9kZSA9PT0gJ2Z1bGwnKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJy90cmFuc2FjdGlvbnMvMCc7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJlcXVlc3RUeXBlLm1lc3NhZ2U6XG4gICAgICBpZiAobXBjQWxnb3JpdGhtID09PSAnZWNkc2EnIHx8IGFwaU1vZGUgPT09ICdmdWxsJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcvbWVzc2FnZXMvMCc7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuICBjb25zdCB1cmxQYXRoID0gJy93YWxsZXQvJyArIHdhbGxldElkICsgJy90eHJlcXVlc3RzLycgKyB0eFJlcXVlc3RJZCArIGFkZGVuZHVtICsgJy9zaWduYXR1cmVzaGFyZXMnO1xuICByZXR1cm4gYml0Z29cbiAgICAucG9zdChiaXRnby51cmwodXJsUGF0aCwgMikpXG4gICAgLnNlbmQoe1xuICAgICAgc2lnbmF0dXJlU2hhcmUsXG4gICAgICBzaWduZXJTaGFyZSxcbiAgICAgIHVzZXJQdWJsaWNHcGdLZXksXG4gICAgfSlcbiAgICAucmVzdWx0KCk7XG59XG5cbi8qKlxuICogU2VuZHMgdGhlIGNsaWVudCBjb21taXRtZW50IGFuZCBlbmNyeXB0ZWQgc2lnbmVyIHNoYXJlIHRvIHRoZSBzZXJ2ZXIsIGdldHRpbmcgYmFjayB0aGUgc2VydmVyIGNvbW1pdG1lbnRcbiAqIEBwYXJhbSB7Qml0R29CYXNlfSBiaXRnbyAtIHRoZSBiaXRnbyBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIC0gdGhlIHdhbGxldCBpZFxuICogQHBhcmFtIHtzdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICogQHBhcmFtIHtDb21taXRtZW50U2hhcmVSZWNvcmR9IGNvbW1pdG1lbnRTaGFyZSAtIHRoZSBjbGllbnQgY29tbWl0bWVudCBzaGFyZVxuICogQHBhcmFtIHtFbmNyeXB0ZWRTaWduZXJTaGFyZVJlY29yZH0gZW5jcnlwdGVkU2lnbmVyU2hhcmUgLSB0aGUgY2xpZW50IGVuY3J5cHRlZCBzaWduZXIgc2hhcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXBpTW9kZV0gLSB0aGUgdHhSZXF1ZXN0IGFwaSBtb2RlIChmdWxsIG9yIGxpdGUpIC0gZGVmYXVsdHMgdG8gbGl0ZVxuICogQHJldHVybnMge1Byb21pc2U8RXhjaGFuZ2VDb21taXRtZW50UmVzcG9uc2U+fSAtIHRoZSBzZXJ2ZXIgY29tbWl0bWVudCBzaGFyZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhjaGFuZ2VFZGRzYUNvbW1pdG1lbnRzKFxuICBiaXRnbzogQml0R29CYXNlLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICB0eFJlcXVlc3RJZDogc3RyaW5nLFxuICBjb21taXRtZW50U2hhcmU6IENvbW1pdG1lbnRTaGFyZVJlY29yZCxcbiAgZW5jcnlwdGVkU2lnbmVyU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkLFxuICBhcGlNb2RlOiAnZnVsbCcgfCAnbGl0ZScgPSAnbGl0ZSdcbik6IFByb21pc2U8RXhjaGFuZ2VDb21taXRtZW50UmVzcG9uc2U+IHtcbiAgbGV0IGFkZGVuZHVtID0gJyc7XG4gIGlmIChhcGlNb2RlID09PSAnZnVsbCcpIHtcbiAgICBhZGRlbmR1bSA9ICcvdHJhbnNhY3Rpb25zLzAnO1xuICB9XG4gIGNvbnN0IHVybFBhdGggPSAnL3dhbGxldC8nICsgd2FsbGV0SWQgKyAnL3R4cmVxdWVzdHMvJyArIHR4UmVxdWVzdElkICsgYWRkZW5kdW0gKyAnL2NvbW1pdCc7XG4gIHJldHVybiBhd2FpdCBiaXRnby5wb3N0KGJpdGdvLnVybCh1cmxQYXRoLCAyKSkuc2VuZCh7IGNvbW1pdG1lbnRTaGFyZSwgZW5jcnlwdGVkU2lnbmVyU2hhcmUgfSkucmVzdWx0KCk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBhIFRTUyB3YWxsZXQgc2lnbmF0dXJlIHdhcyBwcm9kdWNlZCB3aXRoIHRoZSBleHBlY3RlZCBrZXkgYW5kIHRoYXQgdGhlIHNpZ25lZCBkYXRhIGNvbnRhaW5zIHRoZVxuICogZXhwZWN0ZWQgY29tbW9uIGtleWNoYWluIGFzIHdlbGwgYXMgdGhlIGV4cGVjdGVkIHVzZXIgYW5kIGJhY2t1cCBrZXkgaWRzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb21tb25WZXJpZnlXYWxsZXRTaWduYXR1cmUocGFyYW1zOiB7XG4gIHdhbGxldFNpZ25hdHVyZTogb3BlbnBncC5LZXk7XG4gIGJpdGdvUHViOiBvcGVucGdwLktleTtcbiAgY29tbW9uS2V5Y2hhaW46IHN0cmluZztcbiAgdXNlcktleUlkOiBzdHJpbmc7XG4gIGJhY2t1cEtleUlkOiBzdHJpbmc7XG59KTogUHJvbWlzZTx7IHZhbHVlOiBBcnJheUJ1ZmZlciB9W10+IHtcbiAgY29uc3QgeyB3YWxsZXRTaWduYXR1cmUsIGJpdGdvUHViLCBjb21tb25LZXljaGFpbiwgdXNlcktleUlkLCBiYWNrdXBLZXlJZCB9ID0gcGFyYW1zO1xuXG4gIC8vIEJ5IGVuc3VyaW5nIHRoYXQgdGhlIGZpbmdlcnByaW50cyBvZiB0aGUgd2FsbGV0U2lnbmF0dXJlIGFuZCB0aGUgYml0Z29QdWIgYXJlIGRpZmZlcmVudCBhbmQgdGhhdCBhbnkgb2YgdGhlIHJlc3VsdHNcbiAgLy8gZnJvbSBjYWxsaW5nIHZlcmlmeVByaW1hcnlVc2VyIGlzIHZhbGlkIHdlIGtub3cgdGhhdCB0aGUgc2lnbmF0dXJlIHdhcyBhY3R1YWxseSBwcm9kdWNlZCBieSB0aGUgcHJpdmF0ZSBrZXlcbiAgLy8gYmVsb25naW5nIHRvIHRoZSBiaXRnb1B1Yi5cbiAgaWYgKHdhbGxldFNpZ25hdHVyZS5rZXlQYWNrZXQuZ2V0RmluZ2VycHJpbnQoKSA9PT0gYml0Z29QdWIua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSFNNIEdQRyBzaWduYXR1cmUnKTtcbiAgfVxuXG4gIGNvbnN0IHZlcmlmaWNhdGlvblJlc3VsdCA9IGF3YWl0IHZlcmlmeVByaW1hcnlVc2VyV3JhcHBlcih3YWxsZXRTaWduYXR1cmUsIGJpdGdvUHViLCBmYWxzZSk7XG4gIGNvbnN0IGlzVmFsaWQgPSB2ZXJpZmljYXRpb25SZXN1bHQuc29tZSgocmVzdWx0KSA9PiByZXN1bHQudmFsaWQpO1xuICBpZiAoIWlzVmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSFNNIEdQRyBzaWduYXR1cmUnKTtcbiAgfVxuICBjb25zdCBwcmltYXJ5VXNlciA9IGF3YWl0IHdhbGxldFNpZ25hdHVyZS5nZXRQcmltYXJ5VXNlcigpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZSB0aGUgcmF3Tm90YXRpb25zIHByb3BlcnR5IGlzIG1pc3NpbmcgZnJvbSB0aGUgdHlwZSBidXQgaXQgYWN0dWFsbHkgZXhpc3RzXG4gIGNvbnN0IHJhd05vdGF0aW9uczogeyB2YWx1ZTogVWludDhBcnJheSB9W10gPSBwcmltYXJ5VXNlci51c2VyLm90aGVyQ2VydGlmaWNhdGlvbnNbMF0ucmF3Tm90YXRpb25zO1xuXG4gIGFzc2VydChyYXdOb3RhdGlvbnMubGVuZ3RoID09PSA1LCAnaW52YWxpZCB3YWxsZXQgc2lnbmF0dXJlcycpO1xuXG4gIGFzc2VydChcbiAgICBjb21tb25LZXljaGFpbiA9PT0gQnVmZmVyLmZyb20ocmF3Tm90YXRpb25zWzBdLnZhbHVlKS50b1N0cmluZygpLFxuICAgICd3YWxsZXQgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGNvbW1vbiBrZXljaGFpbidcbiAgKTtcbiAgYXNzZXJ0KHVzZXJLZXlJZCA9PT0gQnVmZmVyLmZyb20ocmF3Tm90YXRpb25zWzFdLnZhbHVlKS50b1N0cmluZygpLCBgd2FsbGV0IHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCB1c2VyIGtleSBpZGApO1xuICBhc3NlcnQoXG4gICAgYmFja3VwS2V5SWQgPT09IEJ1ZmZlci5mcm9tKHJhd05vdGF0aW9uc1syXS52YWx1ZSkudG9TdHJpbmcoKSxcbiAgICAnd2FsbGV0IHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBiYWNrdXAga2V5IGlkJ1xuICApO1xuXG4gIHJldHVybiByYXdOb3RhdGlvbnM7XG59XG5cbi8qKlxuICogR2V0cyBjaGFsbGVuZ2UgZm9yIGEgdHggcmVxdWVzdCBmcm9tIEJpdEdvXG4gKiBzdXBwb3J0cyBNZXNzYWdlIGFuZCByZWd1bGFyIFRyYW5zYWN0aW9uXG4gKiBAcGFyYW0gYml0Z29cbiAqIEBwYXJhbSB3YWxsZXRJZFxuICogQHBhcmFtIHR4UmVxdWVzdElkXG4gKiBAcGFyYW0gaW5kZXhcbiAqIEBwYXJhbSByZXF1ZXN0VHlwZVxuICogQHBhcmFtIHBhaWxsaWVyTW9kdWx1c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VHhSZXF1ZXN0Q2hhbGxlbmdlKFxuICBiaXRnbzogQml0R29CYXNlLFxuICB3YWxsZXRJZDogc3RyaW5nLFxuICB0eFJlcXVlc3RJZDogc3RyaW5nLFxuICBpbmRleDogc3RyaW5nLFxuICByZXF1ZXN0VHlwZTogUmVxdWVzdFR5cGUsXG4gIHBhaWxsaWVyTW9kdWx1czogc3RyaW5nXG4pOiBQcm9taXNlPFR4UmVxdWVzdENoYWxsZW5nZVJlc3BvbnNlPiB7XG4gIGxldCBhZGRlbmR1bSA9ICcnO1xuICBzd2l0Y2ggKHJlcXVlc3RUeXBlKSB7XG4gICAgY2FzZSBSZXF1ZXN0VHlwZS50eDpcbiAgICAgIGFkZGVuZHVtID0gJy90cmFuc2FjdGlvbnMvJyArIGluZGV4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSZXF1ZXN0VHlwZS5tZXNzYWdlOlxuICAgICAgYWRkZW5kdW0gPSAnL21lc3NhZ2VzLycgKyBpbmRleDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IHVybFBhdGggPSAnL3dhbGxldC8nICsgd2FsbGV0SWQgKyAnL3R4cmVxdWVzdHMvJyArIHR4UmVxdWVzdElkICsgYWRkZW5kdW0gKyAnL2NoYWxsZW5nZSc7XG4gIHJldHVybiBhd2FpdCBiaXRnby5wb3N0KGJpdGdvLnVybCh1cmxQYXRoLCAyKSkuc2VuZCh7IHBhaWxsaWVyTW9kdWx1cyB9KS5yZXN1bHQoKTtcbn1cbiJdfQ==