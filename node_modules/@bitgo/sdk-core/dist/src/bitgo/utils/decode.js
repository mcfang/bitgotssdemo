"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeOrElse = exports.decode = exports.validationErrors = void 0;
const function_1 = require("fp-ts/function");
const E = __importStar(require("fp-ts/Either"));
const Json = __importStar(require("fp-ts/Json"));
const O = __importStar(require("fp-ts/Option"));
const NEA = __importStar(require("fp-ts/ReadonlyNonEmptyArray"));
/**
 * Format an `Errors` object as a human-readable `string`. See `decode` in `decode.ts` for an example.
 * Inspired by
 * https://github.com/mmkal/ts/blob/94a9ba8f2931c9c91122d00b0bf1bd21b2be05cd/packages/io-ts-extra/src/reporters.ts#L11.
 */
const validationErrors = (typeAlias) => (errors) => {
    return errors
        .map((error) => function_1.pipe(NEA.fromReadonlyArray(error.context), O.map((context) => {
        const name = typeAlias || NEA.head(context).type.name;
        const lastType = NEA.last(context).type.name;
        const path = name + error.context.map((c) => c.key).join('.');
        return function_1.pipe(Json.stringify(error.value), E.getOrElse(() => error.value), (value) => `Invalid value '${value}' supplied to ${path}, expected ${lastType}.`);
    }), O.getOrElse(() => `Unable to decode ${typeAlias}, but no error reported`)))
        .join('\n');
};
exports.validationErrors = validationErrors;
function decode(codecName, codec, u) {
    return function_1.pipe(codec.decode(u), E.mapLeft((errors) => exports.validationErrors(codecName)(errors)));
}
exports.decode = decode;
/**
 * Decodes input `value` with `codec`. When decoding fails, calls the `orElse` function with the error message from
 * `validationErrors`.
 */
function decodeOrElse(codecName, codec, value, orElse) {
    return function_1.pipe(decode(codecName, codec, value), E.getOrElseW(orElse));
}
exports.decodeOrElse = decodeOrElse;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVjb2RlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3V0aWxzL2RlY29kZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkNBQXNDO0FBQ3RDLGdEQUFrQztBQUNsQyxpREFBbUM7QUFDbkMsZ0RBQWtDO0FBQ2xDLGlFQUFtRDtBQUduRDs7OztHQUlHO0FBQ0ksTUFBTSxnQkFBZ0IsR0FDM0IsQ0FBQyxTQUFpQixFQUFFLEVBQUUsQ0FDdEIsQ0FBQyxNQUFnQixFQUFVLEVBQUU7SUFDM0IsT0FBTyxNQUFNO1NBQ1YsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FDYixlQUFJLENBQ0YsR0FBRyxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFDcEMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO1FBQ2hCLE1BQU0sSUFBSSxHQUFHLFNBQVMsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDdEQsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQzdDLE1BQU0sSUFBSSxHQUFHLElBQUksR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM5RCxPQUFPLGVBQUksQ0FDVCxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFDM0IsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQzlCLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxrQkFBa0IsS0FBSyxpQkFBaUIsSUFBSSxjQUFjLFFBQVEsR0FBRyxDQUNqRixDQUFDO0lBQ0osQ0FBQyxDQUFDLEVBQ0YsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxvQkFBb0IsU0FBUyx5QkFBeUIsQ0FBQyxDQUMxRSxDQUNGO1NBQ0EsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hCLENBQUMsQ0FBQztBQXJCUyxRQUFBLGdCQUFnQixvQkFxQnpCO0FBRUosU0FBZ0IsTUFBTSxDQUFVLFNBQWlCLEVBQUUsS0FBc0IsRUFBRSxDQUFJO0lBQzdFLE9BQU8sZUFBSSxDQUNULEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQ2YsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsd0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FDM0QsQ0FBQztBQUNKLENBQUM7QUFMRCx3QkFLQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLFlBQVksQ0FDMUIsU0FBaUIsRUFDakIsS0FBc0IsRUFDdEIsS0FBUSxFQUNSLE1BQTZCO0lBRTdCLE9BQU8sZUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBUEQsb0NBT0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwaXBlIH0gZnJvbSAnZnAtdHMvZnVuY3Rpb24nO1xuaW1wb3J0ICogYXMgRSBmcm9tICdmcC10cy9FaXRoZXInO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICdmcC10cy9Kc29uJztcbmltcG9ydCAqIGFzIE8gZnJvbSAnZnAtdHMvT3B0aW9uJztcbmltcG9ydCAqIGFzIE5FQSBmcm9tICdmcC10cy9SZWFkb25seU5vbkVtcHR5QXJyYXknO1xuaW1wb3J0ICogYXMgdCBmcm9tICdpby10cyc7XG5cbi8qKlxuICogRm9ybWF0IGFuIGBFcnJvcnNgIG9iamVjdCBhcyBhIGh1bWFuLXJlYWRhYmxlIGBzdHJpbmdgLiBTZWUgYGRlY29kZWAgaW4gYGRlY29kZS50c2AgZm9yIGFuIGV4YW1wbGUuXG4gKiBJbnNwaXJlZCBieVxuICogaHR0cHM6Ly9naXRodWIuY29tL21ta2FsL3RzL2Jsb2IvOTRhOWJhOGYyOTMxYzljOTExMjJkMDBiMGJmMWJkMjFiMmJlMDVjZC9wYWNrYWdlcy9pby10cy1leHRyYS9zcmMvcmVwb3J0ZXJzLnRzI0wxMS5cbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRpb25FcnJvcnMgPVxuICAodHlwZUFsaWFzOiBzdHJpbmcpID0+XG4gIChlcnJvcnM6IHQuRXJyb3JzKTogc3RyaW5nID0+IHtcbiAgICByZXR1cm4gZXJyb3JzXG4gICAgICAubWFwKChlcnJvcikgPT5cbiAgICAgICAgcGlwZShcbiAgICAgICAgICBORUEuZnJvbVJlYWRvbmx5QXJyYXkoZXJyb3IuY29udGV4dCksXG4gICAgICAgICAgTy5tYXAoKGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlQWxpYXMgfHwgTkVBLmhlYWQoY29udGV4dCkudHlwZS5uYW1lO1xuICAgICAgICAgICAgY29uc3QgbGFzdFR5cGUgPSBORUEubGFzdChjb250ZXh0KS50eXBlLm5hbWU7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gbmFtZSArIGVycm9yLmNvbnRleHQubWFwKChjKSA9PiBjLmtleSkuam9pbignLicpO1xuICAgICAgICAgICAgcmV0dXJuIHBpcGUoXG4gICAgICAgICAgICAgIEpzb24uc3RyaW5naWZ5KGVycm9yLnZhbHVlKSxcbiAgICAgICAgICAgICAgRS5nZXRPckVsc2UoKCkgPT4gZXJyb3IudmFsdWUpLFxuICAgICAgICAgICAgICAodmFsdWUpID0+IGBJbnZhbGlkIHZhbHVlICcke3ZhbHVlfScgc3VwcGxpZWQgdG8gJHtwYXRofSwgZXhwZWN0ZWQgJHtsYXN0VHlwZX0uYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBPLmdldE9yRWxzZSgoKSA9PiBgVW5hYmxlIHRvIGRlY29kZSAke3R5cGVBbGlhc30sIGJ1dCBubyBlcnJvciByZXBvcnRlZGApXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIC5qb2luKCdcXG4nKTtcbiAgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZTxBLCBPLCBJPihjb2RlY05hbWU6IHN0cmluZywgY29kZWM6IHQuVHlwZTxBLCBPLCBJPiwgdTogSSk6IEUuRWl0aGVyPHN0cmluZywgQT4ge1xuICByZXR1cm4gcGlwZShcbiAgICBjb2RlYy5kZWNvZGUodSksXG4gICAgRS5tYXBMZWZ0KChlcnJvcnMpID0+IHZhbGlkYXRpb25FcnJvcnMoY29kZWNOYW1lKShlcnJvcnMpKVxuICApO1xufVxuXG4vKipcbiAqIERlY29kZXMgaW5wdXQgYHZhbHVlYCB3aXRoIGBjb2RlY2AuIFdoZW4gZGVjb2RpbmcgZmFpbHMsIGNhbGxzIHRoZSBgb3JFbHNlYCBmdW5jdGlvbiB3aXRoIHRoZSBlcnJvciBtZXNzYWdlIGZyb21cbiAqIGB2YWxpZGF0aW9uRXJyb3JzYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU9yRWxzZTxBLCBPLCBJLCBFPihcbiAgY29kZWNOYW1lOiBzdHJpbmcsXG4gIGNvZGVjOiB0LlR5cGU8QSwgTywgST4sXG4gIHZhbHVlOiBJLFxuICBvckVsc2U6IChlcnJvcnM6IHN0cmluZykgPT4gRVxuKTogRSB8IEEge1xuICByZXR1cm4gcGlwZShkZWNvZGUoY29kZWNOYW1lLCBjb2RlYywgdmFsdWUpLCBFLmdldE9yRWxzZVcob3JFbHNlKSk7XG59XG4iXX0=