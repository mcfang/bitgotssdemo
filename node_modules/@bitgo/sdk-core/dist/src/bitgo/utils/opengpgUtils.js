"use strict";
/* eslint-disable @typescript-eslint/ban-ts-comment */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateGPGKeyPair = exports.verifySignature = exports.signText = exports.readSignedMessage = exports.encryptAndSignText = exports.encryptText = exports.createShareProof = exports.createSharedDataProof = exports.verifySharedDataProof = exports.verifyShareProof = exports.getTrustGpgPubKey = exports.verifyPrimaryUserWrapper = exports.getBitgoGpgPubKey = void 0;
const pgp = __importStar(require("openpgp"));
const openpgp_1 = require("openpgp");
const _ = __importStar(require("lodash"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const crypto_1 = __importDefault(require("crypto"));
const sodium = require('libsodium-wrappers-sumo');
/**
 * Fetches BitGo's pubic gpg key used in MPC flows
 * @param {BitGo} bitgo BitGo object
 * @return {Key} public gpg key
 */
async function getBitgoGpgPubKey(bitgo) {
    const constants = await bitgo.fetchConstants();
    if (!constants.mpc || !constants.mpc.bitgoPublicKey) {
        throw new Error('Unable to create MPC keys - bitgoPublicKey is missing from constants');
    }
    const bitgoPublicKeyStr = constants.mpc.bitgoPublicKey;
    return await openpgp_1.readKey({ armoredKey: bitgoPublicKeyStr });
}
exports.getBitgoGpgPubKey = getBitgoGpgPubKey;
/**
 * Verifies the primary user on a GPG key using a reference key representing the user to be checked.
 * Allows a verification without a date check by wrapping verifyPrimaryUser of openpgp.
 * @param {Key} pubKey gpg key to check the primary user of.
 * @param {Key} primaryUser gpg key of the user to check.
 * @param {boolean} checkDates If false, disable date checks in the openpgp call to check the primary user.
 * @return {KeyValidityDict} list of users checked and whether each passed as a primary user in pubKey or not.
 */
async function verifyPrimaryUserWrapper(pubKey, primaryUser, checkDates) {
    if (checkDates) {
        return await pubKey.verifyPrimaryUser([primaryUser]);
    }
    else {
        return await pubKey.verifyPrimaryUser([primaryUser], null);
    }
}
exports.verifyPrimaryUserWrapper = verifyPrimaryUserWrapper;
/**
 * Fetches Trust pub key string
 * @param bitgo
 */
async function getTrustGpgPubKey(bitgo) {
    const constants = await bitgo.fetchConstants();
    if (!constants.trustPubKey) {
        throw new Error('Unable to get trustPubKey');
    }
    return openpgp_1.readKey({ armoredKey: constants.trustPubKey });
}
exports.getTrustGpgPubKey = getTrustGpgPubKey;
/**
 * Verify an Eddsa or Ecdsa KeyShare Proof.
 *
 * @param senderPubKey public key of the sender of the privateShareProof
 * @param privateShareProof u value proof
 * @param uValue u value from an Eddsa keyshare
 * @param algo
 * @return {boolean} whether uValue proof actually was signed by sender as part of their subkeys
 */
async function verifyShareProof(senderPubKey, privateShareProof, uValue, algo) {
    const decodedProof = await pgp.readKey({ armoredKey: privateShareProof });
    const senderGpgKey = await pgp.readKey({ armoredKey: senderPubKey });
    if (!(await verifyPrimaryUserWrapper(decodedProof, senderGpgKey, true))[0].valid) {
        return false;
    }
    const proofSubkeys = decodedProof.getSubkeys()[1];
    if (algo === 'eddsa') {
        const decodedUValueProof = Buffer.from(proofSubkeys.keyPacket.publicParams['Q'].slice(1)).toString('hex');
        const rawUValueProof = Buffer.from(sodium.crypto_scalarmult_ed25519_base_noclamp(Buffer.from(uValue, 'hex'))).toString('hex');
        return decodedUValueProof === rawUValueProof;
    }
    else if (algo === 'ecdsa') {
        const decodedUValueProof = Buffer.from(proofSubkeys.keyPacket.publicParams['Q']).toString('hex');
        const rawUValueProof = utxo_lib_1.ecc.pointFromScalar(Buffer.from(uValue, 'hex'), false);
        return rawUValueProof !== null && decodedUValueProof === Buffer.from(rawUValueProof).toString('hex');
    }
    else {
        throw new Error('Invalid algorithm provided');
    }
}
exports.verifyShareProof = verifyShareProof;
/**
 * Verify a shared data proof.
 *
 * @param senderPubKeyArm public key of the signer of the key with proof data
 * @param keyWithNotation signed reciever key with notation data
 * @param dataToVerify data to be checked against notation data in the signed key
 * @return {boolean} whether proof is valid
 */
async function verifySharedDataProof(senderPubKeyArm, keyWithNotation, dataToVerify) {
    const senderPubKey = await pgp.readKey({ armoredKey: senderPubKeyArm });
    const signedKey = await pgp.readKey({ armoredKey: keyWithNotation });
    if (!(await verifyPrimaryUserWrapper(signedKey, senderPubKey, true).then((values) => _.some(values, (value) => value.valid)))) {
        return false;
    }
    const primaryUser = await signedKey.getPrimaryUser();
    const anyInvalidProof = _.some(
    // @ts-ignore
    primaryUser.user.otherCertifications[0].rawNotations, (notation) => { var _a; return ((_a = dataToVerify.find((i) => i.name === notation.name)) === null || _a === void 0 ? void 0 : _a.value) !== Buffer.from(notation.value).toString(); });
    return !anyInvalidProof;
}
exports.verifySharedDataProof = verifySharedDataProof;
/**
 * Creates a proof through adding notation data to a GPG ceritifying signature.
 *
 * @param privateKeyArmored gpg private key in armor format of the sender
 * @param publicKeyToCertArmored gpg public key in armor fomrat of the reciever
 * @param notations data to be proofed
 * @return {string} keyshare proof
 */
async function createSharedDataProof(privateKeyArmored, publicKeyToCertArmored, notations) {
    const certifyingKey = await pgp.readKey({ armoredKey: privateKeyArmored });
    const publicKeyToCert = await pgp.readKey({ armoredKey: publicKeyToCertArmored });
    const dateTime = new Date();
    // UserId Packet.
    const userIdPkt = new pgp.UserIDPacket();
    const primaryUser = await publicKeyToCert.getPrimaryUser();
    // @ts-ignore
    userIdPkt.userID = primaryUser.user.userID.userID;
    // Signature packet.
    const signaturePacket = new pgp.SignaturePacket();
    signaturePacket.signatureType = pgp.enums.signature.certPositive;
    signaturePacket.publicKeyAlgorithm = pgp.enums.publicKey.ecdsa;
    signaturePacket.hashAlgorithm = pgp.enums.hash.sha256;
    // @ts-ignore
    signaturePacket.issuerFingerprint = await primaryUser.user.mainKey.keyPacket.getFingerprintBytes();
    // @ts-ignore
    signaturePacket.issuerKeyID = primaryUser.user.mainKey.keyPacket.keyID;
    // @ts-ignore
    signaturePacket.signingKeyID = primaryUser.user.mainKey.keyPacket.keyID;
    // @ts-ignore
    signaturePacket.signersUserID = primaryUser.user.userID.userID;
    // @ts-ignore
    signaturePacket.features = [1];
    notations.forEach(({ name, value }) => {
        signaturePacket.rawNotations.push({
            name: name,
            value: new Uint8Array(Buffer.from(value)),
            humanReadable: true,
            critical: false,
        });
    });
    // Prepare signing data.
    const keydataToSign = {};
    // @ts-ignore
    keydataToSign.key = publicKeyToCert.keyPacket;
    // @ts-ignore
    keydataToSign.userID = userIdPkt;
    // Sign the data (create certification).
    // @ts-ignore
    await signaturePacket.sign(certifyingKey.keyPacket, keydataToSign, dateTime);
    // Assemble packets together.
    const publicKeyToCertPkts = publicKeyToCert.toPacketList();
    const newKeyPktList = new pgp.PacketList();
    newKeyPktList.push(...publicKeyToCertPkts.slice(0, 3), signaturePacket, ...publicKeyToCertPkts.slice(3));
    // @ts-ignore
    const newPubKey = new pgp.PublicKey(newKeyPktList);
    return newPubKey.armor().replace(/\r\n/g, '\n');
}
exports.createSharedDataProof = createSharedDataProof;
/**
 * Creates a KeyShare Proof based on given algo.
 *
 * Creates an EdDSA KeyShare Proof by appending an ed25519 subkey (auth) to an armored gpg private key.
 * Creates an ECDSA KeyShare Proof by Append a secp256k1 subkey (auth) to a PGP keychain.
 *
 * @param privateArmor gpg private key in armor format
 * @param uValue u value from an Eddsa keyshare
 * @param algo algo to use, eddsa or ecdsa
 * @return {string} keyshare proof
 */
async function createShareProof(privateArmor, uValue, algo) {
    const privateKey = await openpgp_1.readKey({ armoredKey: privateArmor });
    const dateTime = new Date();
    // @ts-ignore - type inconsistency, this ctor supports a date param: https://docs.openpgpjs.org/SecretSubkeyPacket.html
    const secretSubkeyPacket = new pgp.SecretSubkeyPacket(dateTime);
    secretSubkeyPacket.algorithm = pgp.enums.publicKey[algo];
    // @ts-ignore - same as above
    secretSubkeyPacket.isEncrypted = false;
    let oid;
    let Q;
    if (algo === 'eddsa') {
        await sodium.ready;
        const subKeyVal = Buffer.from(sodium.crypto_scalarmult_ed25519_base_noclamp(Buffer.from(uValue, 'hex'), 'uint8array'));
        // Sub-key (encryption key) packet.
        oid = [0x2b, 0x06, 0x01, 0x04, 0x01, 0xda, 0x47, 0x0f, 0x01];
        // @ts-ignore
        oid.write = () => new Uint8Array(Buffer.from('092b06010401da470f01', 'hex'));
        Q = new Uint8Array([0x40, ...subKeyVal]);
    }
    else if (algo === 'ecdsa') {
        oid = [0x2b, 0x81, 0x04, 0x00, 0x0a];
        // @ts-ignore - same as above
        oid.write = () => new Uint8Array(Buffer.from('052b8104000a', 'hex'));
        Q = utxo_lib_1.ecc.pointFromScalar(new Uint8Array(Buffer.from(uValue, 'hex')), false);
    }
    secretSubkeyPacket.publicParams = {
        oid,
        Q,
    };
    // @ts-ignore - same as above
    await secretSubkeyPacket.computeFingerprintAndKeyID();
    // Sub-key signature packet.
    const subKeydataToSign = {
        key: privateKey.keyPacket,
        bind: secretSubkeyPacket,
    };
    const subkeySignaturePacket = new pgp.SignaturePacket();
    subkeySignaturePacket.signatureType = pgp.enums.signature.subkeyBinding;
    subkeySignaturePacket.publicKeyAlgorithm = pgp.enums.publicKey.ecdsa;
    subkeySignaturePacket.hashAlgorithm = pgp.enums.hash.sha256;
    subkeySignaturePacket.keyFlags = new Uint8Array([pgp.enums.keyFlags.authentication]);
    // Sign the subkey
    // @ts-ignore - sign supports arbitrary data for 2nd param: https://docs.openpgpjs.org/SignaturePacket.html
    await subkeySignaturePacket.sign(privateKey.keyPacket, subKeydataToSign, dateTime);
    // Assemble packets together.
    const newKeyPktList = new pgp.PacketList();
    const privateKeyPkts = privateKey.toPacketList();
    privateKeyPkts.forEach((packet) => newKeyPktList.push(packet));
    newKeyPktList.push(secretSubkeyPacket, subkeySignaturePacket);
    // @ts-ignore - supports packet list as ctor param: https://docs.openpgpjs.org/PrivateKey.html
    const newPubKey = new pgp.PrivateKey(newKeyPktList).toPublic();
    if (!(await verifyPrimaryUserWrapper(newPubKey, privateKey, true))[0].valid) {
        throw new Error('Incorrect signature');
    }
    return newPubKey.armor().replace(/\r\n/g, '\n');
}
exports.createShareProof = createShareProof;
/**
 * Encrypts string using gpg key
 * @DEPRECATED - should use encryptAndSignText instead for added security
 *
 * @param text string to encrypt
 * @param key encryption key
 * @return {string} encrypted string
 *
 * TODO(BG-47170): Delete once gpg signatures are fully supported
 */
async function encryptText(text, key) {
    const messageToEncrypt = await openpgp_1.createMessage({
        text,
    });
    return await openpgp_1.encrypt({
        message: messageToEncrypt,
        encryptionKeys: [key],
        format: 'armored',
        config: {
            rejectCurves: new Set(),
            showVersion: false,
            showComment: false,
        },
    });
}
exports.encryptText = encryptText;
/**
 * Encrypts and signs a string
 * @param text string to encrypt and sign
 * @param publicArmor public key to encrypt with
 * @param privateArmor private key to sign with
 */
async function encryptAndSignText(text, publicArmor, privateArmor) {
    const publicKey = await openpgp_1.readKey({ armoredKey: publicArmor });
    const privateKey = await openpgp_1.readPrivateKey({ armoredKey: privateArmor });
    const message = await openpgp_1.createMessage({ text });
    const signedMessage = await openpgp_1.encrypt({
        message,
        encryptionKeys: publicKey,
        signingKeys: privateKey,
        format: 'armored',
        config: {
            rejectCurves: new Set(),
            showVersion: false,
            showComment: false,
        },
    });
    return signedMessage;
}
exports.encryptAndSignText = encryptAndSignText;
/**
 * Reads a signed and encrypted message
 *
 * @param signed signed and encrypted message
 * @param publicArmor public key to verify signature
 * @param privateArmor private key to decrypt message
 */
async function readSignedMessage(signed, publicArmor, privateArmor) {
    const publicKey = await openpgp_1.readKey({ armoredKey: publicArmor });
    const privateKey = await openpgp_1.readPrivateKey({ armoredKey: privateArmor });
    const message = await openpgp_1.readMessage({ armoredMessage: signed });
    const decrypted = await openpgp_1.decrypt({
        message,
        verificationKeys: publicKey,
        decryptionKeys: privateKey,
        expectSigned: true,
        config: { rejectCurves: new Set() },
    });
    return decrypted.data;
}
exports.readSignedMessage = readSignedMessage;
/**
 * Generates a signature
 *
 * @param text string to generate a signature for
 * @param privateArmor private key as armored string
 * @return {string} armored signature string
 */
async function signText(text, privateArmor) {
    const privateKey = await openpgp_1.readPrivateKey({ armoredKey: privateArmor });
    const message = await openpgp_1.createMessage({ text });
    const signature = await openpgp_1.sign({
        message,
        signingKeys: privateKey,
        format: 'armored',
        detached: true,
    });
    return signature;
}
exports.signText = signText;
/**
 * Verifies signature was generated by the public key and matches the expected text
 *
 * @param text text that the signature was for
 * @param armoredSignature signed message as an armored string
 * @param publicArmor public key that generated the signature
 */
async function verifySignature(text, armoredSignature, publicArmor) {
    const publicKey = await openpgp_1.readKey({ armoredKey: publicArmor });
    const signature = await openpgp_1.readSignature({ armoredSignature });
    const message = await openpgp_1.createMessage({ text });
    const verificationResult = await openpgp_1.verify({
        message,
        signature,
        verificationKeys: publicKey,
    });
    if (verificationResult.signatures.length !== 1) {
        throw new Error('Invalid number of signatures');
    }
    try {
        await verificationResult.signatures[0].verified;
        return text === verificationResult.data;
    }
    catch {
        return false;
    }
}
exports.verifySignature = verifySignature;
/**
 * Generate a GPG key pair
 *
 * @param: keyCurve the curve to create a key with
 * @param: username name of the user (optional)
 * @param: email email of the user (optional)
 */
async function generateGPGKeyPair(keyCurve, username, email) {
    const randomHexString = crypto_1.default.randomBytes(12).toString('hex');
    username = username !== null && username !== void 0 ? username : randomHexString;
    email = email !== null && email !== void 0 ? email : `user-${randomHexString}@${randomHexString}.com`;
    // Allow generating secp256k1 key pairs
    pgp.config.rejectCurves = new Set();
    const gpgKey = await pgp.generateKey({
        userIDs: [
            {
                name: username,
                email,
            },
        ],
        curve: keyCurve,
    });
    return gpgKey;
}
exports.generateGPGKeyPair = generateGPGKeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3BlbmdwZ1V0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3V0aWxzL29wZW5ncGdVdGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsc0RBQXNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRXRELDZDQUErQjtBQUMvQixxQ0FXaUI7QUFDakIsMENBQTRCO0FBQzVCLDhDQUFtRDtBQUVuRCxvREFBNEI7QUFFNUIsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFPbEQ7Ozs7R0FJRztBQUNJLEtBQUssVUFBVSxpQkFBaUIsQ0FBQyxLQUFnQjtJQUN0RCxNQUFNLFNBQVMsR0FBRyxNQUFNLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUMvQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFO1FBQ25ELE1BQU0sSUFBSSxLQUFLLENBQUMsc0VBQXNFLENBQUMsQ0FBQztLQUN6RjtJQUVELE1BQU0saUJBQWlCLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxjQUF3QixDQUFDO0lBQ2pFLE9BQU8sTUFBTSxpQkFBTyxDQUFDLEVBQUUsVUFBVSxFQUFFLGlCQUFpQixFQUFFLENBQUMsQ0FBQztBQUMxRCxDQUFDO0FBUkQsOENBUUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0ksS0FBSyxVQUFVLHdCQUF3QixDQUM1QyxNQUFXLEVBQ1gsV0FBZ0IsRUFDaEIsVUFBbUI7SUFFbkIsSUFBSSxVQUFVLEVBQUU7UUFDZCxPQUFPLE1BQU0sTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztLQUN0RDtTQUFNO1FBQ0wsT0FBTyxNQUFNLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxFQUFFLElBQTRCLENBQUMsQ0FBQztLQUNwRjtBQUNILENBQUM7QUFW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S0FDaEIsQ0FBQyxDQUFDO0lBRUgsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQztBQXRCRCxnREFzQkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cblxuaW1wb3J0ICogYXMgcGdwIGZyb20gJ29wZW5wZ3AnO1xuaW1wb3J0IHtcbiAgY3JlYXRlTWVzc2FnZSxcbiAgZGVjcnlwdCxcbiAgZW5jcnlwdCxcbiAgS2V5LFxuICByZWFkS2V5LFxuICByZWFkTWVzc2FnZSxcbiAgcmVhZFByaXZhdGVLZXksXG4gIHJlYWRTaWduYXR1cmUsXG4gIHNpZ24sXG4gIHZlcmlmeSxcbn0gZnJvbSAnb3BlbnBncCc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBlY2MgYXMgc2VjcDI1NmsxIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbmNvbnN0IHNvZGl1bSA9IHJlcXVpcmUoJ2xpYnNvZGl1bS13cmFwcGVycy1zdW1vJyk7XG5cbmV4cG9ydCB0eXBlIEtleVZhbGlkaXR5RGljdCA9IHtcbiAga2V5SUQ6IHBncC5LZXlJRDtcbiAgdmFsaWQ6IGJvb2xlYW4gfCBudWxsO1xufVtdO1xuXG4vKipcbiAqIEZldGNoZXMgQml0R28ncyBwdWJpYyBncGcga2V5IHVzZWQgaW4gTVBDIGZsb3dzXG4gKiBAcGFyYW0ge0JpdEdvfSBiaXRnbyBCaXRHbyBvYmplY3RcbiAqIEByZXR1cm4ge0tleX0gcHVibGljIGdwZyBrZXlcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEJpdGdvR3BnUHViS2V5KGJpdGdvOiBCaXRHb0Jhc2UpOiBQcm9taXNlPEtleT4ge1xuICBjb25zdCBjb25zdGFudHMgPSBhd2FpdCBiaXRnby5mZXRjaENvbnN0YW50cygpO1xuICBpZiAoIWNvbnN0YW50cy5tcGMgfHwgIWNvbnN0YW50cy5tcGMuYml0Z29QdWJsaWNLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBjcmVhdGUgTVBDIGtleXMgLSBiaXRnb1B1YmxpY0tleSBpcyBtaXNzaW5nIGZyb20gY29uc3RhbnRzJyk7XG4gIH1cblxuICBjb25zdCBiaXRnb1B1YmxpY0tleVN0ciA9IGNvbnN0YW50cy5tcGMuYml0Z29QdWJsaWNLZXkgYXMgc3RyaW5nO1xuICByZXR1cm4gYXdhaXQgcmVhZEtleSh7IGFybW9yZWRLZXk6IGJpdGdvUHVibGljS2V5U3RyIH0pO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBwcmltYXJ5IHVzZXIgb24gYSBHUEcga2V5IHVzaW5nIGEgcmVmZXJlbmNlIGtleSByZXByZXNlbnRpbmcgdGhlIHVzZXIgdG8gYmUgY2hlY2tlZC5cbiAqIEFsbG93cyBhIHZlcmlmaWNhdGlvbiB3aXRob3V0IGEgZGF0ZSBjaGVjayBieSB3cmFwcGluZyB2ZXJpZnlQcmltYXJ5VXNlciBvZiBvcGVucGdwLlxuICogQHBhcmFtIHtLZXl9IHB1YktleSBncGcga2V5IHRvIGNoZWNrIHRoZSBwcmltYXJ5IHVzZXIgb2YuXG4gKiBAcGFyYW0ge0tleX0gcHJpbWFyeVVzZXIgZ3BnIGtleSBvZiB0aGUgdXNlciB0byBjaGVjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tEYXRlcyBJZiBmYWxzZSwgZGlzYWJsZSBkYXRlIGNoZWNrcyBpbiB0aGUgb3BlbnBncCBjYWxsIHRvIGNoZWNrIHRoZSBwcmltYXJ5IHVzZXIuXG4gKiBAcmV0dXJuIHtLZXlWYWxpZGl0eURpY3R9IGxpc3Qgb2YgdXNlcnMgY2hlY2tlZCBhbmQgd2hldGhlciBlYWNoIHBhc3NlZCBhcyBhIHByaW1hcnkgdXNlciBpbiBwdWJLZXkgb3Igbm90LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5UHJpbWFyeVVzZXJXcmFwcGVyKFxuICBwdWJLZXk6IEtleSxcbiAgcHJpbWFyeVVzZXI6IEtleSxcbiAgY2hlY2tEYXRlczogYm9vbGVhblxuKTogUHJvbWlzZTxLZXlWYWxpZGl0eURpY3Q+IHtcbiAgaWYgKGNoZWNrRGF0ZXMpIHtcbiAgICByZXR1cm4gYXdhaXQgcHViS2V5LnZlcmlmeVByaW1hcnlVc2VyKFtwcmltYXJ5VXNlcl0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhd2FpdCBwdWJLZXkudmVyaWZ5UHJpbWFyeVVzZXIoW3ByaW1hcnlVc2VyXSwgbnVsbCBhcyB1bmtub3duIGFzIHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaGVzIFRydXN0IHB1YiBrZXkgc3RyaW5nXG4gKiBAcGFyYW0gYml0Z29cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFRydXN0R3BnUHViS2V5KGJpdGdvOiBCaXRHb0Jhc2UpOiBQcm9taXNlPEtleT4ge1xuICBjb25zdCBjb25zdGFudHMgPSBhd2FpdCBiaXRnby5mZXRjaENvbnN0YW50cygpO1xuICBpZiAoIWNvbnN0YW50cy50cnVzdFB1YktleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGdldCB0cnVzdFB1YktleScpO1xuICB9XG4gIHJldHVybiByZWFkS2V5KHsgYXJtb3JlZEtleTogY29uc3RhbnRzLnRydXN0UHViS2V5IH0pO1xufVxuXG4vKipcbiAqIFZlcmlmeSBhbiBFZGRzYSBvciBFY2RzYSBLZXlTaGFyZSBQcm9vZi5cbiAqXG4gKiBAcGFyYW0gc2VuZGVyUHViS2V5IHB1YmxpYyBrZXkgb2YgdGhlIHNlbmRlciBvZiB0aGUgcHJpdmF0ZVNoYXJlUHJvb2ZcbiAqIEBwYXJhbSBwcml2YXRlU2hhcmVQcm9vZiB1IHZhbHVlIHByb29mXG4gKiBAcGFyYW0gdVZhbHVlIHUgdmFsdWUgZnJvbSBhbiBFZGRzYSBrZXlzaGFyZVxuICogQHBhcmFtIGFsZ29cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdVZhbHVlIHByb29mIGFjdHVhbGx5IHdhcyBzaWduZWQgYnkgc2VuZGVyIGFzIHBhcnQgb2YgdGhlaXIgc3Via2V5c1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyaWZ5U2hhcmVQcm9vZihcbiAgc2VuZGVyUHViS2V5OiBzdHJpbmcsXG4gIHByaXZhdGVTaGFyZVByb29mOiBzdHJpbmcsXG4gIHVWYWx1ZTogc3RyaW5nLFxuICBhbGdvOiAnZWRkc2EnIHwgJ2VjZHNhJ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IGRlY29kZWRQcm9vZiA9IGF3YWl0IHBncC5yZWFkS2V5KHsgYXJtb3JlZEtleTogcHJpdmF0ZVNoYXJlUHJvb2YgfSk7XG4gIGNvbnN0IHNlbmRlckdwZ0tleSA9IGF3YWl0IHBncC5yZWFkS2V5KHsgYXJtb3JlZEtleTogc2VuZGVyUHViS2V5IH0pO1xuICBpZiAoIShhd2FpdCB2ZXJpZnlQcmltYXJ5VXNlcldyYXBwZXIoZGVjb2RlZFByb29mLCBzZW5kZXJHcGdLZXksIHRydWUpKVswXS52YWxpZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm9vZlN1YmtleXMgPSBkZWNvZGVkUHJvb2YuZ2V0U3Via2V5cygpWzFdO1xuICBpZiAoYWxnbyA9PT0gJ2VkZHNhJykge1xuICAgIGNvbnN0IGRlY29kZWRVVmFsdWVQcm9vZiA9IEJ1ZmZlci5mcm9tKHByb29mU3Via2V5cy5rZXlQYWNrZXQucHVibGljUGFyYW1zWydRJ10uc2xpY2UoMSkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCByYXdVVmFsdWVQcm9vZiA9IEJ1ZmZlci5mcm9tKFxuICAgICAgc29kaXVtLmNyeXB0b19zY2FsYXJtdWx0X2VkMjU1MTlfYmFzZV9ub2NsYW1wKEJ1ZmZlci5mcm9tKHVWYWx1ZSwgJ2hleCcpKVxuICAgICkudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiBkZWNvZGVkVVZhbHVlUHJvb2YgPT09IHJhd1VWYWx1ZVByb29mO1xuICB9IGVsc2UgaWYgKGFsZ28gPT09ICdlY2RzYScpIHtcbiAgICBjb25zdCBkZWNvZGVkVVZhbHVlUHJvb2YgPSBCdWZmZXIuZnJvbShwcm9vZlN1YmtleXMua2V5UGFja2V0LnB1YmxpY1BhcmFtc1snUSddKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgcmF3VVZhbHVlUHJvb2YgPSBzZWNwMjU2azEucG9pbnRGcm9tU2NhbGFyKEJ1ZmZlci5mcm9tKHVWYWx1ZSwgJ2hleCcpLCBmYWxzZSk7XG4gICAgcmV0dXJuIHJhd1VWYWx1ZVByb29mICE9PSBudWxsICYmIGRlY29kZWRVVmFsdWVQcm9vZiA9PT0gQnVmZmVyLmZyb20ocmF3VVZhbHVlUHJvb2YpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWxnb3JpdGhtIHByb3ZpZGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBWZXJpZnkgYSBzaGFyZWQgZGF0YSBwcm9vZi5cbiAqXG4gKiBAcGFyYW0gc2VuZGVyUHViS2V5QXJtIHB1YmxpYyBrZXkgb2YgdGhlIHNpZ25lciBvZiB0aGUga2V5IHdpdGggcHJvb2YgZGF0YVxuICogQHBhcmFtIGtleVdpdGhOb3RhdGlvbiBzaWduZWQgcmVjaWV2ZXIga2V5IHdpdGggbm90YXRpb24gZGF0YVxuICogQHBhcmFtIGRhdGFUb1ZlcmlmeSBkYXRhIHRvIGJlIGNoZWNrZWQgYWdhaW5zdCBub3RhdGlvbiBkYXRhIGluIHRoZSBzaWduZWQga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHByb29mIGlzIHZhbGlkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlTaGFyZWREYXRhUHJvb2YoXG4gIHNlbmRlclB1YktleUFybTogc3RyaW5nLFxuICBrZXlXaXRoTm90YXRpb246IHN0cmluZyxcbiAgZGF0YVRvVmVyaWZ5OiB7IG5hbWU6IHN0cmluZzsgdmFsdWU6IHN0cmluZyB9W11cbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICBjb25zdCBzZW5kZXJQdWJLZXkgPSBhd2FpdCBwZ3AucmVhZEtleSh7IGFybW9yZWRLZXk6IHNlbmRlclB1YktleUFybSB9KTtcbiAgY29uc3Qgc2lnbmVkS2V5ID0gYXdhaXQgcGdwLnJlYWRLZXkoeyBhcm1vcmVkS2V5OiBrZXlXaXRoTm90YXRpb24gfSk7XG4gIGlmIChcbiAgICAhKGF3YWl0IHZlcmlmeVByaW1hcnlVc2VyV3JhcHBlcihzaWduZWRLZXksIHNlbmRlclB1YktleSwgdHJ1ZSkudGhlbigodmFsdWVzKSA9PlxuICAgICAgXy5zb21lKHZhbHVlcywgKHZhbHVlKSA9PiB2YWx1ZS52YWxpZClcbiAgICApKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJpbWFyeVVzZXIgPSBhd2FpdCBzaWduZWRLZXkuZ2V0UHJpbWFyeVVzZXIoKTtcbiAgY29uc3QgYW55SW52YWxpZFByb29mID0gXy5zb21lKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwcmltYXJ5VXNlci51c2VyLm90aGVyQ2VydGlmaWNhdGlvbnNbMF0ucmF3Tm90YXRpb25zLFxuICAgIChub3RhdGlvbikgPT4gZGF0YVRvVmVyaWZ5LmZpbmQoKGkpID0+IGkubmFtZSA9PT0gbm90YXRpb24ubmFtZSk/LnZhbHVlICE9PSBCdWZmZXIuZnJvbShub3RhdGlvbi52YWx1ZSkudG9TdHJpbmcoKVxuICApO1xuICByZXR1cm4gIWFueUludmFsaWRQcm9vZjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJvb2YgdGhyb3VnaCBhZGRpbmcgbm90YXRpb24gZGF0YSB0byBhIEdQRyBjZXJpdGlmeWluZyBzaWduYXR1cmUuXG4gKlxuICogQHBhcmFtIHByaXZhdGVLZXlBcm1vcmVkIGdwZyBwcml2YXRlIGtleSBpbiBhcm1vciBmb3JtYXQgb2YgdGhlIHNlbmRlclxuICogQHBhcmFtIHB1YmxpY0tleVRvQ2VydEFybW9yZWQgZ3BnIHB1YmxpYyBrZXkgaW4gYXJtb3IgZm9tcmF0IG9mIHRoZSByZWNpZXZlclxuICogQHBhcmFtIG5vdGF0aW9ucyBkYXRhIHRvIGJlIHByb29mZWRcbiAqIEByZXR1cm4ge3N0cmluZ30ga2V5c2hhcmUgcHJvb2ZcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNoYXJlZERhdGFQcm9vZihcbiAgcHJpdmF0ZUtleUFybW9yZWQ6IHN0cmluZyxcbiAgcHVibGljS2V5VG9DZXJ0QXJtb3JlZDogc3RyaW5nLFxuICBub3RhdGlvbnM6IHsgbmFtZTogc3RyaW5nOyB2YWx1ZTogc3RyaW5nIH1bXVxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgY2VydGlmeWluZ0tleSA9IGF3YWl0IHBncC5yZWFkS2V5KHsgYXJtb3JlZEtleTogcHJpdmF0ZUtleUFybW9yZWQgfSk7XG4gIGNvbnN0IHB1YmxpY0tleVRvQ2VydCA9IGF3YWl0IHBncC5yZWFkS2V5KHsgYXJtb3JlZEtleTogcHVibGljS2V5VG9DZXJ0QXJtb3JlZCB9KTtcbiAgY29uc3QgZGF0ZVRpbWUgPSBuZXcgRGF0ZSgpO1xuICAvLyBVc2VySWQgUGFja2V0LlxuICBjb25zdCB1c2VySWRQa3QgPSBuZXcgcGdwLlVzZXJJRFBhY2tldCgpO1xuICBjb25zdCBwcmltYXJ5VXNlciA9IGF3YWl0IHB1YmxpY0tleVRvQ2VydC5nZXRQcmltYXJ5VXNlcigpO1xuICAvLyBAdHMtaWdub3JlXG4gIHVzZXJJZFBrdC51c2VySUQgPSBwcmltYXJ5VXNlci51c2VyLnVzZXJJRC51c2VySUQ7XG4gIC8vIFNpZ25hdHVyZSBwYWNrZXQuXG4gIGNvbnN0IHNpZ25hdHVyZVBhY2tldCA9IG5ldyBwZ3AuU2lnbmF0dXJlUGFja2V0KCk7XG4gIHNpZ25hdHVyZVBhY2tldC5zaWduYXR1cmVUeXBlID0gcGdwLmVudW1zLnNpZ25hdHVyZS5jZXJ0UG9zaXRpdmU7XG4gIHNpZ25hdHVyZVBhY2tldC5wdWJsaWNLZXlBbGdvcml0aG0gPSBwZ3AuZW51bXMucHVibGljS2V5LmVjZHNhO1xuICBzaWduYXR1cmVQYWNrZXQuaGFzaEFsZ29yaXRobSA9IHBncC5lbnVtcy5oYXNoLnNoYTI1NjtcbiAgLy8gQHRzLWlnbm9yZVxuICBzaWduYXR1cmVQYWNrZXQuaXNzdWVyRmluZ2VycHJpbnQgPSBhd2FpdCBwcmltYXJ5VXNlci51c2VyLm1haW5LZXkua2V5UGFja2V0LmdldEZpbmdlcnByaW50Qnl0ZXMoKTtcbiAgLy8gQHRzLWlnbm9yZVxuICBzaWduYXR1cmVQYWNrZXQuaXNzdWVyS2V5SUQgPSBwcmltYXJ5VXNlci51c2VyLm1haW5LZXkua2V5UGFja2V0LmtleUlEO1xuICAvLyBAdHMtaWdub3JlXG4gIHNpZ25hdHVyZVBhY2tldC5zaWduaW5nS2V5SUQgPSBwcmltYXJ5VXNlci51c2VyLm1haW5LZXkua2V5UGFja2V0LmtleUlEO1xuICAvLyBAdHMtaWdub3JlXG4gIHNpZ25hdHVyZVBhY2tldC5zaWduZXJzVXNlcklEID0gcHJpbWFyeVVzZXIudXNlci51c2VySUQudXNlcklEO1xuICAvLyBAdHMtaWdub3JlXG4gIHNpZ25hdHVyZVBhY2tldC5mZWF0dXJlcyA9IFsxXTtcbiAgbm90YXRpb25zLmZvckVhY2goKHsgbmFtZSwgdmFsdWUgfSkgPT4ge1xuICAgIHNpZ25hdHVyZVBhY2tldC5yYXdOb3RhdGlvbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHZhbHVlKSksXG4gICAgICBodW1hblJlYWRhYmxlOiB0cnVlLFxuICAgICAgY3JpdGljYWw6IGZhbHNlLFxuICAgIH0pO1xuICB9KTtcblxuICAvLyBQcmVwYXJlIHNpZ25pbmcgZGF0YS5cbiAgY29uc3Qga2V5ZGF0YVRvU2lnbiA9IHt9O1xuICAvLyBAdHMtaWdub3JlXG4gIGtleWRhdGFUb1NpZ24ua2V5ID0gcHVibGljS2V5VG9DZXJ0LmtleVBhY2tldDtcbiAgLy8gQHRzLWlnbm9yZVxuICBrZXlkYXRhVG9TaWduLnVzZXJJRCA9IHVzZXJJZFBrdDtcblxuICAvLyBTaWduIHRoZSBkYXRhIChjcmVhdGUgY2VydGlmaWNhdGlvbikuXG4gIC8vIEB0cy1pZ25vcmVcbiAgYXdhaXQgc2lnbmF0dXJlUGFja2V0LnNpZ24oY2VydGlmeWluZ0tleS5rZXlQYWNrZXQsIGtleWRhdGFUb1NpZ24sIGRhdGVUaW1lKTtcblxuICAvLyBBc3NlbWJsZSBwYWNrZXRzIHRvZ2V0aGVyLlxuICBjb25zdCBwdWJsaWNLZXlUb0NlcnRQa3RzID0gcHVibGljS2V5VG9DZXJ0LnRvUGFja2V0TGlzdCgpO1xuICBjb25zdCBuZXdLZXlQa3RMaXN0ID0gbmV3IHBncC5QYWNrZXRMaXN0KCk7XG4gIG5ld0tleVBrdExpc3QucHVzaCguLi5wdWJsaWNLZXlUb0NlcnRQa3RzLnNsaWNlKDAsIDMpLCBzaWduYXR1cmVQYWNrZXQsIC4uLnB1YmxpY0tleVRvQ2VydFBrdHMuc2xpY2UoMykpO1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG5ld1B1YktleSA9IG5ldyBwZ3AuUHVibGljS2V5KG5ld0tleVBrdExpc3QpO1xuICByZXR1cm4gbmV3UHViS2V5LmFybW9yKCkucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgS2V5U2hhcmUgUHJvb2YgYmFzZWQgb24gZ2l2ZW4gYWxnby5cbiAqXG4gKiBDcmVhdGVzIGFuIEVkRFNBIEtleVNoYXJlIFByb29mIGJ5IGFwcGVuZGluZyBhbiBlZDI1NTE5IHN1YmtleSAoYXV0aCkgdG8gYW4gYXJtb3JlZCBncGcgcHJpdmF0ZSBrZXkuXG4gKiBDcmVhdGVzIGFuIEVDRFNBIEtleVNoYXJlIFByb29mIGJ5IEFwcGVuZCBhIHNlY3AyNTZrMSBzdWJrZXkgKGF1dGgpIHRvIGEgUEdQIGtleWNoYWluLlxuICpcbiAqIEBwYXJhbSBwcml2YXRlQXJtb3IgZ3BnIHByaXZhdGUga2V5IGluIGFybW9yIGZvcm1hdFxuICogQHBhcmFtIHVWYWx1ZSB1IHZhbHVlIGZyb20gYW4gRWRkc2Ega2V5c2hhcmVcbiAqIEBwYXJhbSBhbGdvIGFsZ28gdG8gdXNlLCBlZGRzYSBvciBlY2RzYVxuICogQHJldHVybiB7c3RyaW5nfSBrZXlzaGFyZSBwcm9vZlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlU2hhcmVQcm9vZihwcml2YXRlQXJtb3I6IHN0cmluZywgdVZhbHVlOiBzdHJpbmcsIGFsZ286IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSBhd2FpdCByZWFkS2V5KHsgYXJtb3JlZEtleTogcHJpdmF0ZUFybW9yIH0pO1xuICBjb25zdCBkYXRlVGltZSA9IG5ldyBEYXRlKCk7XG4gIC8vIEB0cy1pZ25vcmUgLSB0eXBlIGluY29uc2lzdGVuY3ksIHRoaXMgY3RvciBzdXBwb3J0cyBhIGRhdGUgcGFyYW06IGh0dHBzOi8vZG9jcy5vcGVucGdwanMub3JnL1NlY3JldFN1YmtleVBhY2tldC5odG1sXG4gIGNvbnN0IHNlY3JldFN1YmtleVBhY2tldCA9IG5ldyBwZ3AuU2VjcmV0U3Via2V5UGFja2V0KGRhdGVUaW1lKTtcbiAgc2VjcmV0U3Via2V5UGFja2V0LmFsZ29yaXRobSA9IHBncC5lbnVtcy5wdWJsaWNLZXlbYWxnb107XG4gIC8vIEB0cy1pZ25vcmUgLSBzYW1lIGFzIGFib3ZlXG4gIHNlY3JldFN1YmtleVBhY2tldC5pc0VuY3J5cHRlZCA9IGZhbHNlO1xuICBsZXQgb2lkO1xuICBsZXQgUTtcbiAgaWYgKGFsZ28gPT09ICdlZGRzYScpIHtcbiAgICBhd2FpdCBzb2RpdW0ucmVhZHk7XG4gICAgY29uc3Qgc3ViS2V5VmFsID0gQnVmZmVyLmZyb20oXG4gICAgICBzb2RpdW0uY3J5cHRvX3NjYWxhcm11bHRfZWQyNTUxOV9iYXNlX25vY2xhbXAoQnVmZmVyLmZyb20odVZhbHVlLCAnaGV4JyksICd1aW50OGFycmF5JylcbiAgICApO1xuICAgIC8vIFN1Yi1rZXkgKGVuY3J5cHRpb24ga2V5KSBwYWNrZXQuXG4gICAgb2lkID0gWzB4MmIsIDB4MDYsIDB4MDEsIDB4MDQsIDB4MDEsIDB4ZGEsIDB4NDcsIDB4MGYsIDB4MDFdO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBvaWQud3JpdGUgPSAoKSA9PiBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbSgnMDkyYjA2MDEwNDAxZGE0NzBmMDEnLCAnaGV4JykpO1xuICAgIFEgPSBuZXcgVWludDhBcnJheShbMHg0MCwgLi4uc3ViS2V5VmFsXSk7XG4gIH0gZWxzZSBpZiAoYWxnbyA9PT0gJ2VjZHNhJykge1xuICAgIG9pZCA9IFsweDJiLCAweDgxLCAweDA0LCAweDAwLCAweDBhXTtcbiAgICAvLyBAdHMtaWdub3JlIC0gc2FtZSBhcyBhYm92ZVxuICAgIG9pZC53cml0ZSA9ICgpID0+IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKCcwNTJiODEwNDAwMGEnLCAnaGV4JykpO1xuICAgIFEgPSBzZWNwMjU2azEucG9pbnRGcm9tU2NhbGFyKG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKHVWYWx1ZSwgJ2hleCcpKSwgZmFsc2UpO1xuICB9XG4gIHNlY3JldFN1YmtleVBhY2tldC5wdWJsaWNQYXJhbXMgPSB7XG4gICAgb2lkLFxuICAgIFEsXG4gIH07XG4gIC8vIEB0cy1pZ25vcmUgLSBzYW1lIGFzIGFib3ZlXG4gIGF3YWl0IHNlY3JldFN1YmtleVBhY2tldC5jb21wdXRlRmluZ2VycHJpbnRBbmRLZXlJRCgpO1xuXG4gIC8vIFN1Yi1rZXkgc2lnbmF0dXJlIHBhY2tldC5cbiAgY29uc3Qgc3ViS2V5ZGF0YVRvU2lnbiA9IHtcbiAgICBrZXk6IHByaXZhdGVLZXkua2V5UGFja2V0LFxuICAgIGJpbmQ6IHNlY3JldFN1YmtleVBhY2tldCxcbiAgfTtcbiAgY29uc3Qgc3Via2V5U2lnbmF0dXJlUGFja2V0ID0gbmV3IHBncC5TaWduYXR1cmVQYWNrZXQoKTtcbiAgc3Via2V5U2lnbmF0dXJlUGFja2V0LnNpZ25hdHVyZVR5cGUgPSBwZ3AuZW51bXMuc2lnbmF0dXJlLnN1YmtleUJpbmRpbmc7XG4gIHN1YmtleVNpZ25hdHVyZVBhY2tldC5wdWJsaWNLZXlBbGdvcml0aG0gPSBwZ3AuZW51bXMucHVibGljS2V5LmVjZHNhO1xuICBzdWJrZXlTaWduYXR1cmVQYWNrZXQuaGFzaEFsZ29yaXRobSA9IHBncC5lbnVtcy5oYXNoLnNoYTI1NjtcbiAgc3Via2V5U2lnbmF0dXJlUGFja2V0LmtleUZsYWdzID0gbmV3IFVpbnQ4QXJyYXkoW3BncC5lbnVtcy5rZXlGbGFncy5hdXRoZW50aWNhdGlvbl0pO1xuXG4gIC8vIFNpZ24gdGhlIHN1YmtleVxuICAvLyBAdHMtaWdub3JlIC0gc2lnbiBzdXBwb3J0cyBhcmJpdHJhcnkgZGF0YSBmb3IgMm5kIHBhcmFtOiBodHRwczovL2RvY3Mub3BlbnBncGpzLm9yZy9TaWduYXR1cmVQYWNrZXQuaHRtbFxuICBhd2FpdCBzdWJrZXlTaWduYXR1cmVQYWNrZXQuc2lnbihwcml2YXRlS2V5LmtleVBhY2tldCwgc3ViS2V5ZGF0YVRvU2lnbiwgZGF0ZVRpbWUpO1xuXG4gIC8vIEFzc2VtYmxlIHBhY2tldHMgdG9nZXRoZXIuXG4gIGNvbnN0IG5ld0tleVBrdExpc3QgPSBuZXcgcGdwLlBhY2tldExpc3QoKTtcbiAgY29uc3QgcHJpdmF0ZUtleVBrdHMgPSBwcml2YXRlS2V5LnRvUGFja2V0TGlzdCgpO1xuICBwcml2YXRlS2V5UGt0cy5mb3JFYWNoKChwYWNrZXQpID0+IG5ld0tleVBrdExpc3QucHVzaChwYWNrZXQpKTtcbiAgbmV3S2V5UGt0TGlzdC5wdXNoKHNlY3JldFN1YmtleVBhY2tldCwgc3Via2V5U2lnbmF0dXJlUGFja2V0KTtcbiAgLy8gQHRzLWlnbm9yZSAtIHN1cHBvcnRzIHBhY2tldCBsaXN0IGFzIGN0b3IgcGFyYW06IGh0dHBzOi8vZG9jcy5vcGVucGdwanMub3JnL1ByaXZhdGVLZXkuaHRtbFxuICBjb25zdCBuZXdQdWJLZXkgPSBuZXcgcGdwLlByaXZhdGVLZXkobmV3S2V5UGt0TGlzdCkudG9QdWJsaWMoKTtcblxuICBpZiAoIShhd2FpdCB2ZXJpZnlQcmltYXJ5VXNlcldyYXBwZXIobmV3UHViS2V5LCBwcml2YXRlS2V5LCB0cnVlKSlbMF0udmFsaWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBzaWduYXR1cmUnKTtcbiAgfVxuXG4gIHJldHVybiBuZXdQdWJLZXkuYXJtb3IoKS5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xufVxuXG4vKipcbiAqIEVuY3J5cHRzIHN0cmluZyB1c2luZyBncGcga2V5XG4gKiBAREVQUkVDQVRFRCAtIHNob3VsZCB1c2UgZW5jcnlwdEFuZFNpZ25UZXh0IGluc3RlYWQgZm9yIGFkZGVkIHNlY3VyaXR5XG4gKlxuICogQHBhcmFtIHRleHQgc3RyaW5nIHRvIGVuY3J5cHRcbiAqIEBwYXJhbSBrZXkgZW5jcnlwdGlvbiBrZXlcbiAqIEByZXR1cm4ge3N0cmluZ30gZW5jcnlwdGVkIHN0cmluZ1xuICpcbiAqIFRPRE8oQkctNDcxNzApOiBEZWxldGUgb25jZSBncGcgc2lnbmF0dXJlcyBhcmUgZnVsbHkgc3VwcG9ydGVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0VGV4dCh0ZXh0OiBzdHJpbmcsIGtleTogS2V5KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgbWVzc2FnZVRvRW5jcnlwdCA9IGF3YWl0IGNyZWF0ZU1lc3NhZ2Uoe1xuICAgIHRleHQsXG4gIH0pO1xuICByZXR1cm4gYXdhaXQgZW5jcnlwdCh7XG4gICAgbWVzc2FnZTogbWVzc2FnZVRvRW5jcnlwdCxcbiAgICBlbmNyeXB0aW9uS2V5czogW2tleV0sXG4gICAgZm9ybWF0OiAnYXJtb3JlZCcsXG4gICAgY29uZmlnOiB7XG4gICAgICByZWplY3RDdXJ2ZXM6IG5ldyBTZXQoKSxcbiAgICAgIHNob3dWZXJzaW9uOiBmYWxzZSxcbiAgICAgIHNob3dDb21tZW50OiBmYWxzZSxcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbmNyeXB0cyBhbmQgc2lnbnMgYSBzdHJpbmdcbiAqIEBwYXJhbSB0ZXh0IHN0cmluZyB0byBlbmNyeXB0IGFuZCBzaWduXG4gKiBAcGFyYW0gcHVibGljQXJtb3IgcHVibGljIGtleSB0byBlbmNyeXB0IHdpdGhcbiAqIEBwYXJhbSBwcml2YXRlQXJtb3IgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0QW5kU2lnblRleHQodGV4dDogc3RyaW5nLCBwdWJsaWNBcm1vcjogc3RyaW5nLCBwcml2YXRlQXJtb3I6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IHJlYWRLZXkoeyBhcm1vcmVkS2V5OiBwdWJsaWNBcm1vciB9KTtcbiAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IHJlYWRQcml2YXRlS2V5KHsgYXJtb3JlZEtleTogcHJpdmF0ZUFybW9yIH0pO1xuXG4gIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBjcmVhdGVNZXNzYWdlKHsgdGV4dCB9KTtcblxuICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgZW5jcnlwdCh7XG4gICAgbWVzc2FnZSxcbiAgICBlbmNyeXB0aW9uS2V5czogcHVibGljS2V5LFxuICAgIHNpZ25pbmdLZXlzOiBwcml2YXRlS2V5LFxuICAgIGZvcm1hdDogJ2FybW9yZWQnLFxuICAgIGNvbmZpZzoge1xuICAgICAgcmVqZWN0Q3VydmVzOiBuZXcgU2V0KCksXG4gICAgICBzaG93VmVyc2lvbjogZmFsc2UsXG4gICAgICBzaG93Q29tbWVudDogZmFsc2UsXG4gICAgfSxcbiAgfSk7XG5cbiAgcmV0dXJuIHNpZ25lZE1lc3NhZ2U7XG59XG5cbi8qKlxuICogUmVhZHMgYSBzaWduZWQgYW5kIGVuY3J5cHRlZCBtZXNzYWdlXG4gKlxuICogQHBhcmFtIHNpZ25lZCBzaWduZWQgYW5kIGVuY3J5cHRlZCBtZXNzYWdlXG4gKiBAcGFyYW0gcHVibGljQXJtb3IgcHVibGljIGtleSB0byB2ZXJpZnkgc2lnbmF0dXJlXG4gKiBAcGFyYW0gcHJpdmF0ZUFybW9yIHByaXZhdGUga2V5IHRvIGRlY3J5cHQgbWVzc2FnZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZFNpZ25lZE1lc3NhZ2Uoc2lnbmVkOiBzdHJpbmcsIHB1YmxpY0FybW9yOiBzdHJpbmcsIHByaXZhdGVBcm1vcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgcmVhZEtleSh7IGFybW9yZWRLZXk6IHB1YmxpY0FybW9yIH0pO1xuICBjb25zdCBwcml2YXRlS2V5ID0gYXdhaXQgcmVhZFByaXZhdGVLZXkoeyBhcm1vcmVkS2V5OiBwcml2YXRlQXJtb3IgfSk7XG5cbiAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IHJlYWRNZXNzYWdlKHsgYXJtb3JlZE1lc3NhZ2U6IHNpZ25lZCB9KTtcbiAgY29uc3QgZGVjcnlwdGVkID0gYXdhaXQgZGVjcnlwdCh7XG4gICAgbWVzc2FnZSxcbiAgICB2ZXJpZmljYXRpb25LZXlzOiBwdWJsaWNLZXksXG4gICAgZGVjcnlwdGlvbktleXM6IHByaXZhdGVLZXksXG4gICAgZXhwZWN0U2lnbmVkOiB0cnVlLFxuICAgIGNvbmZpZzogeyByZWplY3RDdXJ2ZXM6IG5ldyBTZXQoKSB9LFxuICB9KTtcblxuICByZXR1cm4gZGVjcnlwdGVkLmRhdGE7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc2lnbmF0dXJlXG4gKlxuICogQHBhcmFtIHRleHQgc3RyaW5nIHRvIGdlbmVyYXRlIGEgc2lnbmF0dXJlIGZvclxuICogQHBhcmFtIHByaXZhdGVBcm1vciBwcml2YXRlIGtleSBhcyBhcm1vcmVkIHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfSBhcm1vcmVkIHNpZ25hdHVyZSBzdHJpbmdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25UZXh0KHRleHQ6IHN0cmluZywgcHJpdmF0ZUFybW9yOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBwcml2YXRlS2V5ID0gYXdhaXQgcmVhZFByaXZhdGVLZXkoeyBhcm1vcmVkS2V5OiBwcml2YXRlQXJtb3IgfSk7XG4gIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBjcmVhdGVNZXNzYWdlKHsgdGV4dCB9KTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnbih7XG4gICAgbWVzc2FnZSxcbiAgICBzaWduaW5nS2V5czogcHJpdmF0ZUtleSxcbiAgICBmb3JtYXQ6ICdhcm1vcmVkJyxcbiAgICBkZXRhY2hlZDogdHJ1ZSxcbiAgfSk7XG5cbiAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyBzaWduYXR1cmUgd2FzIGdlbmVyYXRlZCBieSB0aGUgcHVibGljIGtleSBhbmQgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgdGV4dFxuICpcbiAqIEBwYXJhbSB0ZXh0IHRleHQgdGhhdCB0aGUgc2lnbmF0dXJlIHdhcyBmb3JcbiAqIEBwYXJhbSBhcm1vcmVkU2lnbmF0dXJlIHNpZ25lZCBtZXNzYWdlIGFzIGFuIGFybW9yZWQgc3RyaW5nXG4gKiBAcGFyYW0gcHVibGljQXJtb3IgcHVibGljIGtleSB0aGF0IGdlbmVyYXRlZCB0aGUgc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUodGV4dDogc3RyaW5nLCBhcm1vcmVkU2lnbmF0dXJlOiBzdHJpbmcsIHB1YmxpY0FybW9yOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgcmVhZEtleSh7IGFybW9yZWRLZXk6IHB1YmxpY0FybW9yIH0pO1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCByZWFkU2lnbmF0dXJlKHsgYXJtb3JlZFNpZ25hdHVyZSB9KTtcbiAgY29uc3QgbWVzc2FnZSA9IGF3YWl0IGNyZWF0ZU1lc3NhZ2UoeyB0ZXh0IH0pO1xuICBjb25zdCB2ZXJpZmljYXRpb25SZXN1bHQgPSBhd2FpdCB2ZXJpZnkoe1xuICAgIG1lc3NhZ2UsXG4gICAgc2lnbmF0dXJlLFxuICAgIHZlcmlmaWNhdGlvbktleXM6IHB1YmxpY0tleSxcbiAgfSk7XG5cbiAgaWYgKHZlcmlmaWNhdGlvblJlc3VsdC5zaWduYXR1cmVzLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2Ygc2lnbmF0dXJlcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCB2ZXJpZmljYXRpb25SZXN1bHQuc2lnbmF0dXJlc1swXS52ZXJpZmllZDtcbiAgICByZXR1cm4gdGV4dCA9PT0gdmVyaWZpY2F0aW9uUmVzdWx0LmRhdGE7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgR1BHIGtleSBwYWlyXG4gKlxuICogQHBhcmFtOiBrZXlDdXJ2ZSB0aGUgY3VydmUgdG8gY3JlYXRlIGEga2V5IHdpdGhcbiAqIEBwYXJhbTogdXNlcm5hbWUgbmFtZSBvZiB0aGUgdXNlciAob3B0aW9uYWwpXG4gKiBAcGFyYW06IGVtYWlsIGVtYWlsIG9mIHRoZSB1c2VyIChvcHRpb25hbClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlR1BHS2V5UGFpcihcbiAga2V5Q3VydmU6IHBncC5FbGxpcHRpY0N1cnZlTmFtZSxcbiAgdXNlcm5hbWU/OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIGVtYWlsPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4pOiBQcm9taXNlPHBncC5TZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+PiB7XG4gIGNvbnN0IHJhbmRvbUhleFN0cmluZyA9IGNyeXB0by5yYW5kb21CeXRlcygxMikudG9TdHJpbmcoJ2hleCcpO1xuICB1c2VybmFtZSA9IHVzZXJuYW1lID8/IHJhbmRvbUhleFN0cmluZztcbiAgZW1haWwgPSBlbWFpbCA/PyBgdXNlci0ke3JhbmRvbUhleFN0cmluZ31AJHtyYW5kb21IZXhTdHJpbmd9LmNvbWA7XG5cbiAgLy8gQWxsb3cgZ2VuZXJhdGluZyBzZWNwMjU2azEga2V5IHBhaXJzXG4gIHBncC5jb25maWcucmVqZWN0Q3VydmVzID0gbmV3IFNldCgpO1xuICBjb25zdCBncGdLZXkgPSBhd2FpdCBwZ3AuZ2VuZXJhdGVLZXkoe1xuICAgIHVzZXJJRHM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogdXNlcm5hbWUsXG4gICAgICAgIGVtYWlsLFxuICAgICAgfSxcbiAgICBdLFxuICAgIGN1cnZlOiBrZXlDdXJ2ZSxcbiAgfSk7XG5cbiAgcmV0dXJuIGdwZ0tleTtcbn1cbiJdfQ==