"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TssUtils = exports.EddsaUtils = void 0;
/**
 * @prettier
 */
const assert_1 = __importDefault(require("assert"));
const bs58 = __importStar(require("bs58"));
const openpgp = __importStar(require("openpgp"));
const tss_1 = __importDefault(require("../../../../account-lib/mpc/tss"));
const eddsa_1 = require("../../../tss/eddsa/eddsa");
const opengpgUtils_1 = require("../../opengpgUtils");
const tss_2 = require("../../../tss");
const baseTypes_1 = require("../baseTypes");
const baseTSSUtils_1 = __importDefault(require("../baseTSSUtils"));
const common_1 = require("../../../tss/common");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
/**
 * Utility functions for TSS work flows.
 */
class EddsaUtils extends baseTSSUtils_1.default {
    async verifyWalletSignatures(userGpgPub, backupGpgPub, bitgoKeychain, decryptedShare, verifierIndex) {
        assert_1.default(bitgoKeychain.commonKeychain);
        assert_1.default(bitgoKeychain.walletHSMGPGPublicKeySigs);
        const bitgoGpgKey = await opengpgUtils_1.getBitgoGpgPubKey(this.bitgo);
        const userKeyPub = await openpgp.readKey({ armoredKey: userGpgPub });
        const userKeyId = userKeyPub.keyPacket.getFingerprint();
        const backupKeyPub = await openpgp.readKey({ armoredKey: backupGpgPub });
        const backupKeyId = backupKeyPub.keyPacket.getFingerprint();
        const walletSignatures = await openpgp.readKeys({ armoredKeys: bitgoKeychain.walletHSMGPGPublicKeySigs });
        if (walletSignatures.length !== 2) {
            throw new Error('Invalid wallet signatures');
        }
        if (userKeyId !== walletSignatures[0].keyPacket.getFingerprint()) {
            throw new Error(`first wallet signature's fingerprint does not match passed user gpg key's fingerprint`);
        }
        if (backupKeyId !== walletSignatures[1].keyPacket.getFingerprint()) {
            throw new Error(`second wallet signature's fingerprint does not match passed backup gpg key's fingerprint`);
        }
        await eddsa_1.verifyWalletSignature({
            walletSignature: walletSignatures[0],
            commonKeychain: bitgoKeychain.commonKeychain,
            userKeyId,
            backupKeyId,
            bitgoPub: bitgoGpgKey,
            decryptedShare,
            verifierIndex,
        });
        await eddsa_1.verifyWalletSignature({
            walletSignature: walletSignatures[1],
            commonKeychain: bitgoKeychain.commonKeychain,
            userKeyId,
            backupKeyId,
            bitgoPub: bitgoGpgKey,
            decryptedShare,
            verifierIndex,
        });
    }
    /**
     * Creates a Keychain containing the User's TSS signing materials.
     * We need to have the passphrase be optional to allow for the client to store their backup key on their premises
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's TSS key share
     * @param backupKeyShare - backup's TSS key share
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param [passphrase] - optional wallet passphrase used to encrypt user's signing materials
     * @param [originalPasscodeEncryptionCode] - optional encryption code needed for wallet password reset for hot wallets
     */
    async createUserKeychain({ userGpgKey, backupGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode, }) {
        const MPC = await tss_1.default.initialize();
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Missing BitGo key shares');
        }
        const bitGoToUserShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'user');
        if (!bitGoToUserShare) {
            throw new Error('Missing BitGo to User key share');
        }
        const bitGoToUserPrivateShare = await this.decryptPrivateShare(bitGoToUserShare.privateShare, userGpgKey);
        await this.verifyWalletSignatures(userGpgKey.publicKey, backupGpgKey.publicKey, bitgoKeychain, bitGoToUserPrivateShare, 1);
        const bitgoToUser = {
            i: 1,
            j: 3,
            y: bitGoToUserShare.publicShare.slice(0, 64),
            v: bitGoToUserShare.vssProof,
            u: bitGoToUserPrivateShare.slice(0, 64),
            chaincode: bitGoToUserPrivateShare.slice(64),
        };
        // TODO(BG-47170): use tss.createCombinedKey helper when signatures are supported
        const userCombined = MPC.keyCombine(userKeyShare.uShare, [backupKeyShare.yShares[1], bitgoToUser]);
        const commonKeychain = userCombined.pShare.y + userCombined.pShare.chaincode;
        if (commonKeychain !== bitgoKeychain.commonKeychain) {
            throw new Error('Failed to create user keychain - commonKeychains do not match.');
        }
        const userSigningMaterial = {
            uShare: userKeyShare.uShare,
            bitgoYShare: bitgoToUser,
            backupYShare: backupKeyShare.yShares[1],
        };
        const userKeychainParams = {
            source: 'user',
            keyType: 'tss',
            commonKeychain: bitgoKeychain.commonKeychain,
            originalPasscodeEncryptionCode,
        };
        if (passphrase !== undefined) {
            userKeychainParams.encryptedPrv = this.bitgo.encrypt({
                input: JSON.stringify(userSigningMaterial),
                password: passphrase,
            });
        }
        return await this.baseCoin.keychains().add(userKeychainParams);
    }
    /**
     * Creates a Keychain containing the Backup party's TSS signing materials.
     * We need to have the passphrase be optional to allow for the client to store their backup key on their premises
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - User's TSS Keyshare
     * @param backupGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between backup and server
     * @param backupKeyShare - Backup's TSS Keyshare
     * @param bitgoKeychain - previously created BitGo keychain; must be compatible with user and backup key shares
     * @param [passphrase] - optional wallet passphrase used to encrypt user's signing materials
     */
    async createBackupKeychain({ userGpgKey, backupGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, }) {
        const MPC = await tss_1.default.initialize();
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Invalid bitgo keyshares');
        }
        const bitGoToBackupShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'backup');
        if (!bitGoToBackupShare) {
            throw new Error('Missing BitGo to User key share');
        }
        const bitGoToBackupPrivateShare = await this.decryptPrivateShare(bitGoToBackupShare.privateShare, backupGpgKey);
        await this.verifyWalletSignatures(userGpgKey.publicKey, backupGpgKey.publicKey, bitgoKeychain, bitGoToBackupPrivateShare, 2);
        const bitgoToBackup = {
            i: 2,
            j: 3,
            y: bitGoToBackupShare.publicShare.slice(0, 64),
            v: bitGoToBackupShare.vssProof,
            u: bitGoToBackupPrivateShare.slice(0, 64),
            chaincode: bitGoToBackupPrivateShare.slice(64),
        };
        // TODO(BG-47170): use tss.createCombinedKey helper when signatures are supported
        const backupCombined = MPC.keyCombine(backupKeyShare.uShare, [userKeyShare.yShares[2], bitgoToBackup]);
        const commonKeychain = backupCombined.pShare.y + backupCombined.pShare.chaincode;
        if (commonKeychain !== bitgoKeychain.commonKeychain) {
            throw new Error('Failed to create backup keychain - commonKeychains do not match.');
        }
        const backupSigningMaterial = {
            uShare: backupKeyShare.uShare,
            bitgoYShare: bitgoToBackup,
            userYShare: userKeyShare.yShares[2],
        };
        const prv = JSON.stringify(backupSigningMaterial);
        const params = {
            source: 'backup',
            keyType: 'tss',
            commonKeychain: bitgoKeychain.commonKeychain,
            prv: prv,
        };
        if (passphrase !== undefined) {
            params.encryptedPrv = this.bitgo.encrypt({ input: prv, password: passphrase });
        }
        return await this.baseCoin.keychains().createBackup(params);
    }
    /**
     * Creates a Keychain containing BitGo's TSS signing materials.
     *
     * @param userGpgKey - ephemeral GPG key to encrypt / decrypt sensitve data exchanged between user and server
     * @param userKeyShare - user's TSS key share
     * @param backupKeyShare - backup's TSS key share
     * @param enterprise - enterprise associated to the wallet
     */
    async createBitgoKeychain({ userGpgKey, backupGpgKey, userKeyShare, backupKeyShare, enterprise, }) {
        // TODO(BG-47170): use tss.encryptYShare helper when signatures are supported
        const userToBitgoPublicShare = Buffer.concat([
            Buffer.from(userKeyShare.uShare.y, 'hex'),
            Buffer.from(userKeyShare.uShare.chaincode, 'hex'),
        ]).toString('hex');
        const userToBitgoPrivateShare = Buffer.concat([
            Buffer.from(userKeyShare.yShares[3].u, 'hex'),
            Buffer.from(userKeyShare.yShares[3].chaincode, 'hex'),
        ]).toString('hex');
        const userToBitgoKeyShare = {
            publicShare: userToBitgoPublicShare,
            privateShare: userToBitgoPrivateShare,
            privateShareProof: await opengpgUtils_1.createShareProof(userGpgKey.privateKey, userToBitgoPrivateShare.slice(0, 64), 'eddsa'),
            vssProof: userKeyShare.yShares[3].v,
        };
        const backupToBitgoPublicShare = Buffer.concat([
            Buffer.from(backupKeyShare.uShare.y, 'hex'),
            Buffer.from(backupKeyShare.uShare.chaincode, 'hex'),
        ]).toString('hex');
        const backupToBitgoPrivateShare = Buffer.concat([
            Buffer.from(backupKeyShare.yShares[3].u, 'hex'),
            Buffer.from(backupKeyShare.yShares[3].chaincode, 'hex'),
        ]).toString('hex');
        const backupToBitgoKeyShare = {
            publicShare: backupToBitgoPublicShare,
            privateShare: backupToBitgoPrivateShare,
            privateShareProof: await opengpgUtils_1.createShareProof(backupGpgKey.privateKey, backupToBitgoPrivateShare.slice(0, 64), 'eddsa'),
            vssProof: backupKeyShare.yShares[3].v,
        };
        return await this.createBitgoKeychainInWP(userGpgKey, backupGpgKey, userToBitgoKeyShare, backupToBitgoKeyShare, 'tss', enterprise);
    }
    /**
     * Creates User, Backup, and BitGo TSS Keychains.
     *
     * @param params.passphrase - passphrase used to encrypt signing materials created for User and Backup
     */
    async createKeychains(params) {
        const MPC = await tss_1.default.initialize();
        const m = 2;
        const n = 3;
        const userKeyShare = MPC.keyShare(1, m, n);
        const backupKeyShare = MPC.keyShare(2, m, n);
        const userGpgKey = await opengpgUtils_1.generateGPGKeyPair('secp256k1');
        const backupGpgKey = await opengpgUtils_1.generateGPGKeyPair('secp256k1');
        const bitgoKeychain = await this.createBitgoKeychain({
            userGpgKey,
            userKeyShare,
            backupGpgKey,
            backupKeyShare,
            enterprise: params.enterprise,
        });
        const userKeychainPromise = this.createUserKeychain({
            userGpgKey,
            userKeyShare,
            backupGpgKey,
            backupKeyShare,
            bitgoKeychain,
            passphrase: params.passphrase,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
        });
        const backupKeychainPromise = this.createBackupKeychain({
            userGpgKey,
            userKeyShare,
            backupGpgKey,
            backupKeyShare,
            bitgoKeychain,
            passphrase: params.passphrase,
        });
        const [userKeychain, backupKeychain] = await Promise.all([userKeychainPromise, backupKeychainPromise]);
        // create wallet
        const keychains = {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
        return keychains;
    }
    async createCommitmentShareFromTxRequest(params) {
        var _a;
        const bitgoIndex = tss_2.ShareKeyPosition.BITGO;
        const { txRequest, prv } = params;
        const txRequestResolved = txRequest;
        const hdTree = await sdk_lib_mpc_1.Ed25519Bip32HdTree.initialize();
        const MPC = await tss_1.default.initialize(hdTree);
        const userSigningMaterial = JSON.parse(prv);
        if (!userSigningMaterial.backupYShare) {
            throw new Error('Invalid user key - missing backupYShare');
        }
        assert_1.default(txRequestResolved.transactions || txRequestResolved.unsignedTxs, 'Unable to find transactions in txRequest');
        const unsignedTx = txRequestResolved.apiVersion === 'full'
            ? txRequestResolved.transactions[0].unsignedTx
            : txRequestResolved.unsignedTxs[0];
        const signingKey = MPC.keyDerive(userSigningMaterial.uShare, [userSigningMaterial.bitgoYShare, userSigningMaterial.backupYShare], unsignedTx.derivationPath);
        const signablePayload = Buffer.from(unsignedTx.signableHex, 'hex');
        const userSignShare = await tss_2.createUserSignShare(signablePayload, signingKey.pShare);
        const commitment = (_a = userSignShare.rShares[bitgoIndex]) === null || _a === void 0 ? void 0 : _a.commitment;
        assert_1.default(commitment, 'Unable to find commitment in userSignShare');
        const userToBitgoCommitment = this.createUserToBitgoCommitmentShare(commitment);
        const signerShare = signingKey.yShares[bitgoIndex].u + signingKey.yShares[bitgoIndex].chaincode;
        const bitgoGpgKey = await opengpgUtils_1.getBitgoGpgPubKey(this.bitgo);
        const userToBitgoEncryptedSignerShare = await opengpgUtils_1.encryptText(signerShare, bitgoGpgKey);
        const encryptedSignerShare = this.createUserToBitgoEncryptedSignerShare(userToBitgoEncryptedSignerShare);
        const stringifiedRShare = JSON.stringify(userSignShare);
        const encryptedRShare = this.bitgo.encrypt({ input: stringifiedRShare, password: params.walletPassphrase });
        const encryptedUserToBitgoRShare = this.createUserToBitgoEncryptedRShare(encryptedRShare);
        return { userToBitgoCommitment, encryptedSignerShare, encryptedUserToBitgoRShare };
    }
    async createRShareFromTxRequest(params) {
        const { walletPassphrase, encryptedUserToBitgoRShare } = params;
        const decryptedRShare = this.bitgo.decrypt({
            input: encryptedUserToBitgoRShare.share,
            password: walletPassphrase,
        });
        const rShare = JSON.parse(decryptedRShare);
        assert_1.default(rShare.xShare, 'Unable to find xShare in decryptedRShare');
        assert_1.default(rShare.rShares, 'Unable to find rShares in decryptedRShare');
        return { rShare };
    }
    async createGShareFromTxRequest(params) {
        let txRequestResolved;
        const { txRequest, prv, bitgoToUserCommitment, bitgoToUserRShare, userToBitgoRShare } = params;
        if (typeof txRequest === 'string') {
            txRequestResolved = await tss_2.getTxRequest(this.bitgo, this.wallet.id(), txRequest);
        }
        else {
            txRequestResolved = txRequest;
        }
        const userSigningMaterial = JSON.parse(prv);
        if (!userSigningMaterial.backupYShare) {
            throw new Error('Invalid user key - missing backupYShare');
        }
        assert_1.default(txRequestResolved.transactions || txRequestResolved.unsignedTxs, 'Unable to find transactions in txRequest');
        const unsignedTx = txRequestResolved.apiVersion === 'full'
            ? txRequestResolved.transactions[0].unsignedTx
            : txRequestResolved.unsignedTxs[0];
        const signablePayload = Buffer.from(unsignedTx.signableHex, 'hex');
        const userToBitGoGShare = await tss_2.createUserToBitGoGShare(userToBitgoRShare, bitgoToUserRShare, userSigningMaterial.backupYShare, userSigningMaterial.bitgoYShare, signablePayload, bitgoToUserCommitment);
        return userToBitGoGShare;
    }
    async signEddsaTssUsingExternalSigner(txRequest, externalSignerCommitmentGenerator, externalSignerRShareGenerator, externalSignerGShareGenerator) {
        let txRequestResolved;
        let txRequestId;
        if (typeof txRequest === 'string') {
            txRequestResolved = await tss_2.getTxRequest(this.bitgo, this.wallet.id(), txRequest);
            txRequestId = txRequestResolved.txRequestId;
        }
        else {
            txRequestResolved = txRequest;
            txRequestId = txRequest.txRequestId;
        }
        const { apiVersion } = txRequestResolved;
        const { userToBitgoCommitment, encryptedSignerShare, encryptedUserToBitgoRShare } = await externalSignerCommitmentGenerator({ txRequest: txRequestResolved });
        const { commitmentShare: bitgoToUserCommitment } = await common_1.exchangeEddsaCommitments(this.bitgo, this.wallet.id(), txRequestId, userToBitgoCommitment, encryptedSignerShare, apiVersion);
        const { rShare } = await externalSignerRShareGenerator({
            txRequest: txRequestResolved,
            encryptedUserToBitgoRShare,
        });
        await tss_2.offerUserToBitgoRShare(this.bitgo, this.wallet.id(), txRequestId, rShare, encryptedSignerShare.share, apiVersion);
        const bitgoToUserRShare = await tss_2.getBitgoToUserRShare(this.bitgo, this.wallet.id(), txRequestId);
        const gSignShareTransactionParams = {
            txRequest: txRequestResolved,
            bitgoToUserRShare: bitgoToUserRShare,
            userToBitgoRShare: rShare,
            bitgoToUserCommitment,
        };
        const gShare = await externalSignerGShareGenerator(gSignShareTransactionParams);
        await tss_2.sendUserToBitgoGShare(this.bitgo, this.wallet.id(), txRequestId, gShare, apiVersion);
        return await tss_2.getTxRequest(this.bitgo, this.wallet.id(), txRequestId);
    }
    /**
     * Signs the transaction associated to the transaction request.
     *
     * @param txRequest - transaction request object or id
     * @param prv - decrypted private key
     * @param reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    async signTxRequest(params) {
        let txRequestResolved;
        let txRequestId;
        const { txRequest, prv } = params;
        if (typeof txRequest === 'string') {
            txRequestResolved = await tss_2.getTxRequest(this.bitgo, this.wallet.id(), txRequest);
            txRequestId = txRequestResolved.txRequestId;
        }
        else {
            txRequestResolved = txRequest;
            txRequestId = txRequest.txRequestId;
        }
        const hdTree = await sdk_lib_mpc_1.Ed25519Bip32HdTree.initialize();
        const MPC = await tss_1.default.initialize(hdTree);
        const userSigningMaterial = JSON.parse(prv);
        if (!userSigningMaterial.backupYShare) {
            throw new Error('Invalid user key - missing backupYShare');
        }
        const { apiVersion } = txRequestResolved;
        assert_1.default(txRequestResolved.transactions || txRequestResolved.unsignedTxs, 'Unable to find transactions in txRequest');
        const unsignedTx = apiVersion === 'full' ? txRequestResolved.transactions[0].unsignedTx : txRequestResolved.unsignedTxs[0];
        const signingKey = MPC.keyDerive(userSigningMaterial.uShare, [userSigningMaterial.bitgoYShare, userSigningMaterial.backupYShare], unsignedTx.derivationPath);
        const signablePayload = Buffer.from(unsignedTx.signableHex, 'hex');
        const userSignShare = await tss_2.createUserSignShare(signablePayload, signingKey.pShare);
        const bitgoIndex = tss_2.ShareKeyPosition.BITGO;
        const signerShare = signingKey.yShares[bitgoIndex].u + signingKey.yShares[bitgoIndex].chaincode;
        const bitgoGpgKey = await opengpgUtils_1.getBitgoGpgPubKey(this.bitgo);
        const userToBitgoEncryptedSignerShare = await opengpgUtils_1.encryptText(signerShare, bitgoGpgKey);
        const userGpgKey = await opengpgUtils_1.generateGPGKeyPair('secp256k1');
        const privateShareProof = await opengpgUtils_1.createShareProof(userGpgKey.privateKey, signingKey.yShares[bitgoIndex].u, 'eddsa');
        const vssProof = signingKey.yShares[bitgoIndex].v;
        const userPublicGpgKey = userGpgKey.publicKey;
        const publicShare = signingKey.yShares[bitgoIndex].y + signingKey.yShares[bitgoIndex].chaincode;
        const userToBitgoCommitment = userSignShare.rShares[bitgoIndex].commitment;
        assert_1.default(userToBitgoCommitment, 'Missing userToBitgoCommitment commitment');
        const commitmentShare = this.createUserToBitgoCommitmentShare(userToBitgoCommitment);
        const encryptedSignerShare = this.createUserToBitgoEncryptedSignerShare(userToBitgoEncryptedSignerShare);
        const { commitmentShare: bitgoToUserCommitment } = await common_1.exchangeEddsaCommitments(this.bitgo, this.wallet.id(), txRequestId, commitmentShare, encryptedSignerShare, apiVersion);
        await tss_2.offerUserToBitgoRShare(this.bitgo, this.wallet.id(), txRequestId, userSignShare, userToBitgoEncryptedSignerShare, apiVersion, vssProof, privateShareProof, userPublicGpgKey, publicShare);
        const bitgoToUserRShare = await tss_2.getBitgoToUserRShare(this.bitgo, this.wallet.id(), txRequestId);
        const userToBitGoGShare = await tss_2.createUserToBitGoGShare(userSignShare, bitgoToUserRShare, userSigningMaterial.backupYShare, userSigningMaterial.bitgoYShare, signablePayload, bitgoToUserCommitment);
        await tss_2.sendUserToBitgoGShare(this.bitgo, this.wallet.id(), txRequestId, userToBitGoGShare, apiVersion);
        return await tss_2.getTxRequest(this.bitgo, this.wallet.id(), txRequestId);
    }
    /**
     * Get the commonPub portion of the commonKeychain.
     *
     * @param {String} commonKeychain
     * @returns {string}
     */
    static getPublicKeyFromCommonKeychain(commonKeychain) {
        if (commonKeychain.length !== 128) {
            throw new Error(`Invalid commonKeychain length, expected 128, got ${commonKeychain.length}`);
        }
        const commonPubHexStr = commonKeychain.slice(0, 64);
        return bs58.encode(Buffer.from(commonPubHexStr, 'hex'));
    }
    createUserToBitgoCommitmentShare(commitment) {
        return {
            from: baseTypes_1.SignatureShareType.USER,
            to: baseTypes_1.SignatureShareType.BITGO,
            share: commitment,
            type: baseTypes_1.CommitmentType.COMMITMENT,
        };
    }
    createUserToBitgoEncryptedSignerShare(encryptedSignerShare) {
        return {
            from: baseTypes_1.SignatureShareType.USER,
            to: baseTypes_1.SignatureShareType.BITGO,
            share: encryptedSignerShare,
            type: baseTypes_1.EncryptedSignerShareType.ENCRYPTED_SIGNER_SHARE,
        };
    }
    createUserToBitgoEncryptedRShare(encryptedRShare) {
        return {
            from: baseTypes_1.SignatureShareType.USER,
            to: baseTypes_1.SignatureShareType.BITGO,
            share: encryptedRShare,
            type: baseTypes_1.EncryptedSignerShareType.ENCRYPTED_R_SHARE,
        };
    }
}
exports.EddsaUtils = EddsaUtils;
/**
 * @deprecated - use EddsaUtils
 */
exports.TssUtils = EddsaUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWRkc2EuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvYml0Z28vdXRpbHMvdHNzL2VkZHNhL2VkZHNhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILG9EQUE0QjtBQUM1QiwyQ0FBNkI7QUFDN0IsaURBQW1DO0FBQ25DLDBFQUEyRTtBQUUzRSxvREFBaUU7QUFDakUscURBQTBHO0FBQzFHLHNDQVNzQjtBQUN0Qiw0Q0FZc0I7QUFFdEIsbUVBQTJDO0FBRTNDLGdEQUErRDtBQUMvRCxvREFBd0Q7QUFFeEQ7O0dBRUc7QUFFSCxNQUFhLFVBQVcsU0FBUSxzQkFBc0I7SUFDcEQsS0FBSyxDQUFDLHNCQUFzQixDQUMxQixVQUFrQixFQUNsQixZQUFvQixFQUNwQixhQUF1QixFQUN2QixjQUFzQixFQUN0QixhQUFvQjtRQUVwQixnQkFBTSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUNyQyxnQkFBTSxDQUFDLGFBQWEsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1FBRWhELE1BQU0sV0FBVyxHQUFHLE1BQU0sZ0NBQWlCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXhELE1BQU0sVUFBVSxHQUFHLE1BQU0sT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQ3JFLE1BQU0sU0FBUyxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFLENBQUM7UUFFeEQsTUFBTSxZQUFZLEdBQUcsTUFBTSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxDQUFDLENBQUM7UUFDekUsTUFBTSxXQUFXLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUU1RCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sT0FBTyxDQUFDLFFB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QUFFLDhCQUFrQixDQUFDLEtBQUs7WUFDNUIsS0FBSyxFQUFFLGVBQWU7WUFDdEIsSUFBSSxFQUFFLG9DQUF3QixDQUFDLGlCQUFpQjtTQUNqRCxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBdm5CRCxnQ0F1bkJDO0FBQ0Q7O0dBRUc7QUFDVSxRQUFBLFFBQVEsR0FBRyxVQUFVLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgKiBhcyBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0ICogYXMgb3BlbnBncCBmcm9tICdvcGVucGdwJztcbmltcG9ydCBFZGRzYSwgeyBTaWduU2hhcmUsIEdTaGFyZSB9IGZyb20gJy4uLy4uLy4uLy4uL2FjY291bnQtbGliL21wYy90c3MnO1xuaW1wb3J0IHsgQWRkS2V5Y2hhaW5PcHRpb25zLCBLZXljaGFpbiwgQ3JlYXRlQmFja3VwT3B0aW9ucyB9IGZyb20gJy4uLy4uLy4uL2tleWNoYWluJztcbmltcG9ydCB7IHZlcmlmeVdhbGxldFNpZ25hdHVyZSB9IGZyb20gJy4uLy4uLy4uL3Rzcy9lZGRzYS9lZGRzYSc7XG5pbXBvcnQgeyBlbmNyeXB0VGV4dCwgZ2V0Qml0Z29HcGdQdWJLZXksIGNyZWF0ZVNoYXJlUHJvb2YsIGdlbmVyYXRlR1BHS2V5UGFpciB9IGZyb20gJy4uLy4uL29wZW5ncGdVdGlscyc7XG5pbXBvcnQge1xuICBjcmVhdGVVc2VyU2lnblNoYXJlLFxuICBjcmVhdGVVc2VyVG9CaXRHb0dTaGFyZSxcbiAgZ2V0Qml0Z29Ub1VzZXJSU2hhcmUsXG4gIGdldFR4UmVxdWVzdCxcbiAgb2ZmZXJVc2VyVG9CaXRnb1JTaGFyZSxcbiAgc2VuZFVzZXJUb0JpdGdvR1NoYXJlLFxuICBTaGFyZUtleVBvc2l0aW9uLFxuICBTaWduaW5nTWF0ZXJpYWwsXG59IGZyb20gJy4uLy4uLy4uL3Rzcyc7XG5pbXBvcnQge1xuICBDb21taXRtZW50U2hhcmVSZWNvcmQsXG4gIENvbW1pdG1lbnRUeXBlLFxuICBDdXN0b21Db21taXRtZW50R2VuZXJhdGluZ0Z1bmN0aW9uLFxuICBDdXN0b21HU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIEN1c3RvbVJTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgRW5jcnlwdGVkU2lnbmVyU2hhcmVSZWNvcmQsXG4gIEVuY3J5cHRlZFNpZ25lclNoYXJlVHlwZSxcbiAgU2lnbmF0dXJlU2hhcmVSZWNvcmQsXG4gIFNpZ25hdHVyZVNoYXJlVHlwZSxcbiAgVFNTUGFyYW1zLFxuICBUeFJlcXVlc3QsXG59IGZyb20gJy4uL2Jhc2VUeXBlcyc7XG5pbXBvcnQgeyBDcmVhdGVFZGRzYUJpdEdvS2V5Y2hhaW5QYXJhbXMsIENyZWF0ZUVkZHNhS2V5Y2hhaW5QYXJhbXMsIEtleVNoYXJlLCBZU2hhcmUgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBiYXNlVFNTVXRpbHMgZnJvbSAnLi4vYmFzZVRTU1V0aWxzJztcbmltcG9ydCB7IEtleWNoYWluc1RyaXBsZXQgfSBmcm9tICcuLi8uLi8uLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBleGNoYW5nZUVkZHNhQ29tbWl0bWVudHMgfSBmcm9tICcuLi8uLi8uLi90c3MvY29tbW9uJztcbmltcG9ydCB7IEVkMjU1MTlCaXAzMkhkVHJlZSB9IGZyb20gJ0BiaXRnby9zZGstbGliLW1wYyc7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIFRTUyB3b3JrIGZsb3dzLlxuICovXG5cbmV4cG9ydCBjbGFzcyBFZGRzYVV0aWxzIGV4dGVuZHMgYmFzZVRTU1V0aWxzPEtleVNoYXJlPiB7XG4gIGFzeW5jIHZlcmlmeVdhbGxldFNpZ25hdHVyZXMoXG4gICAgdXNlckdwZ1B1Yjogc3RyaW5nLFxuICAgIGJhY2t1cEdwZ1B1Yjogc3RyaW5nLFxuICAgIGJpdGdvS2V5Y2hhaW46IEtleWNoYWluLFxuICAgIGRlY3J5cHRlZFNoYXJlOiBzdHJpbmcsXG4gICAgdmVyaWZpZXJJbmRleDogMSB8IDJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXNzZXJ0KGJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4pO1xuICAgIGFzc2VydChiaXRnb0tleWNoYWluLndhbGxldEhTTUdQR1B1YmxpY0tleVNpZ3MpO1xuXG4gICAgY29uc3QgYml0Z29HcGdLZXkgPSBhd2FpdCBnZXRCaXRnb0dwZ1B1YktleSh0aGlzLmJpdGdvKTtcblxuICAgIGNvbnN0IHVzZXJLZXlQdWIgPSBhd2FpdCBvcGVucGdwLnJlYWRLZXkoeyBhcm1vcmVkS2V5OiB1c2VyR3BnUHViIH0pO1xuICAgIGNvbnN0IHVzZXJLZXlJZCA9IHVzZXJLZXlQdWIua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCk7XG5cbiAgICBjb25zdCBiYWNrdXBLZXlQdWIgPSBhd2FpdCBvcGVucGdwLnJlYWRLZXkoeyBhcm1vcmVkS2V5OiBiYWNrdXBHcGdQdWIgfSk7XG4gICAgY29uc3QgYmFja3VwS2V5SWQgPSBiYWNrdXBLZXlQdWIua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCk7XG5cbiAgICBjb25zdCB3YWxsZXRTaWduYXR1cmVzID0gYXdhaXQgb3BlbnBncC5yZWFkS2V5cyh7IGFybW9yZWRLZXlzOiBiaXRnb0tleWNoYWluLndhbGxldEhTTUdQR1B1YmxpY0tleVNpZ3MgfSk7XG4gICAgaWYgKHdhbGxldFNpZ25hdHVyZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgd2FsbGV0IHNpZ25hdHVyZXMnKTtcbiAgICB9XG5cbiAgICBpZiAodXNlcktleUlkICE9PSB3YWxsZXRTaWduYXR1cmVzWzBdLmtleVBhY2tldC5nZXRGaW5nZXJwcmludCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZpcnN0IHdhbGxldCBzaWduYXR1cmUncyBmaW5nZXJwcmludCBkb2VzIG5vdCBtYXRjaCBwYXNzZWQgdXNlciBncGcga2V5J3MgZmluZ2VycHJpbnRgKTtcbiAgICB9XG5cbiAgICBpZiAoYmFja3VwS2V5SWQgIT09IHdhbGxldFNpZ25hdHVyZXNbMV0ua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2Vjb25kIHdhbGxldCBzaWduYXR1cmUncyBmaW5nZXJwcmludCBkb2VzIG5vdCBtYXRjaCBwYXNzZWQgYmFja3VwIGdwZyBrZXkncyBmaW5nZXJwcmludGApO1xuICAgIH1cblxuICAgIGF3YWl0IHZlcmlmeVdhbGxldFNpZ25hdHVyZSh7XG4gICAgICB3YWxsZXRTaWduYXR1cmU6IHdhbGxldFNpZ25hdHVyZXNbMF0sXG4gICAgICBjb21tb25LZXljaGFpbjogYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpbixcbiAgICAgIHVzZXJLZXlJZCxcbiAgICAgIGJhY2t1cEtleUlkLFxuICAgICAgYml0Z29QdWI6IGJpdGdvR3BnS2V5LFxuICAgICAgZGVjcnlwdGVkU2hhcmUsXG4gICAgICB2ZXJpZmllckluZGV4LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdmVyaWZ5V2FsbGV0U2lnbmF0dXJlKHtcbiAgICAgIHdhbGxldFNpZ25hdHVyZTogd2FsbGV0U2lnbmF0dXJlc1sxXSxcbiAgICAgIGNvbW1vbktleWNoYWluOiBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluLFxuICAgICAgdXNlcktleUlkLFxuICAgICAgYmFja3VwS2V5SWQsXG4gICAgICBiaXRnb1B1YjogYml0Z29HcGdLZXksXG4gICAgICBkZWNyeXB0ZWRTaGFyZSxcbiAgICAgIHZlcmlmaWVySW5kZXgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIEtleWNoYWluIGNvbnRhaW5pbmcgdGhlIFVzZXIncyBUU1Mgc2lnbmluZyBtYXRlcmlhbHMuXG4gICAqIFdlIG5lZWQgdG8gaGF2ZSB0aGUgcGFzc3BocmFzZSBiZSBvcHRpb25hbCB0byBhbGxvdyBmb3IgdGhlIGNsaWVudCB0byBzdG9yZSB0aGVpciBiYWNrdXAga2V5IG9uIHRoZWlyIHByZW1pc2VzXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyR3BnS2V5IC0gZXBoZW1lcmFsIEdQRyBrZXkgdG8gZW5jcnlwdCAvIGRlY3J5cHQgc2Vuc2l0dmUgZGF0YSBleGNoYW5nZWQgYmV0d2VlbiB1c2VyIGFuZCBzZXJ2ZXJcbiAgICogQHBhcmFtIHVzZXJLZXlTaGFyZSAtIHVzZXIncyBUU1Mga2V5IHNoYXJlXG4gICAqIEBwYXJhbSBiYWNrdXBLZXlTaGFyZSAtIGJhY2t1cCdzIFRTUyBrZXkgc2hhcmVcbiAgICogQHBhcmFtIGJpdGdvS2V5Y2hhaW4gLSBwcmV2aW91c2x5IGNyZWF0ZWQgQml0R28ga2V5Y2hhaW47IG11c3QgYmUgY29tcGF0aWJsZSB3aXRoIHVzZXIgYW5kIGJhY2t1cCBrZXkgc2hhcmVzXG4gICAqIEBwYXJhbSBbcGFzc3BocmFzZV0gLSBvcHRpb25hbCB3YWxsZXQgcGFzc3BocmFzZSB1c2VkIHRvIGVuY3J5cHQgdXNlcidzIHNpZ25pbmcgbWF0ZXJpYWxzXG4gICAqIEBwYXJhbSBbb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlXSAtIG9wdGlvbmFsIGVuY3J5cHRpb24gY29kZSBuZWVkZWQgZm9yIHdhbGxldCBwYXNzd29yZCByZXNldCBmb3IgaG90IHdhbGxldHNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVVzZXJLZXljaGFpbih7XG4gICAgdXNlckdwZ0tleSxcbiAgICBiYWNrdXBHcGdLZXksXG4gICAgdXNlcktleVNoYXJlLFxuICAgIGJhY2t1cEtleVNoYXJlLFxuICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgcGFzc3BocmFzZSxcbiAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gIH06IENyZWF0ZUVkZHNhS2V5Y2hhaW5QYXJhbXMpOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgY29uc3QgTVBDID0gYXdhaXQgRWRkc2EuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IGJpdGdvS2V5U2hhcmVzID0gYml0Z29LZXljaGFpbi5rZXlTaGFyZXM7XG4gICAgaWYgKCFiaXRnb0tleVNoYXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEJpdEdvIGtleSBzaGFyZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBiaXRHb1RvVXNlclNoYXJlID0gYml0Z29LZXlTaGFyZXMuZmluZCgoa2V5U2hhcmUpID0+IGtleVNoYXJlLmZyb20gPT09ICdiaXRnbycgJiYga2V5U2hhcmUudG8gPT09ICd1c2VyJyk7XG4gICAgaWYgKCFiaXRHb1RvVXNlclNoYXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgQml0R28gdG8gVXNlciBrZXkgc2hhcmUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBiaXRHb1RvVXNlclByaXZhdGVTaGFyZSA9IGF3YWl0IHRoaXMuZGVjcnlwdFByaXZhdGVTaGFyZShiaXRHb1RvVXNlclNoYXJlLnByaXZhdGVTaGFyZSwgdXNlckdwZ0tleSk7XG5cbiAgICBhd2FpdCB0aGlzLnZlcmlmeVdhbGxldFNpZ25hdHVyZXMoXG4gICAgICB1c2VyR3BnS2V5LnB1YmxpY0tleSxcbiAgICAgIGJhY2t1cEdwZ0tleS5wdWJsaWNLZXksXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgICAgYml0R29Ub1VzZXJQcml2YXRlU2hhcmUsXG4gICAgICAxXG4gICAgKTtcblxuICAgIGNvbnN0IGJpdGdvVG9Vc2VyOiBZU2hhcmUgPSB7XG4gICAgICBpOiAxLFxuICAgICAgajogMyxcbiAgICAgIHk6IGJpdEdvVG9Vc2VyU2hhcmUucHVibGljU2hhcmUuc2xpY2UoMCwgNjQpLFxuICAgICAgdjogYml0R29Ub1VzZXJTaGFyZS52c3NQcm9vZixcbiAgICAgIHU6IGJpdEdvVG9Vc2VyUHJpdmF0ZVNoYXJlLnNsaWNlKDAsIDY0KSxcbiAgICAgIGNoYWluY29kZTogYml0R29Ub1VzZXJQcml2YXRlU2hhcmUuc2xpY2UoNjQpLFxuICAgIH07XG5cbiAgICAvLyBUT0RPKEJHLTQ3MTcwKTogdXNlIHRzcy5jcmVhdGVDb21iaW5lZEtleSBoZWxwZXIgd2hlbiBzaWduYXR1cmVzIGFyZSBzdXBwb3J0ZWRcbiAgICBjb25zdCB1c2VyQ29tYmluZWQgPSBNUEMua2V5Q29tYmluZSh1c2VyS2V5U2hhcmUudVNoYXJlLCBbYmFja3VwS2V5U2hhcmUueVNoYXJlc1sxXSwgYml0Z29Ub1VzZXJdKTtcbiAgICBjb25zdCBjb21tb25LZXljaGFpbiA9IHVzZXJDb21iaW5lZC5wU2hhcmUueSArIHVzZXJDb21iaW5lZC5wU2hhcmUuY2hhaW5jb2RlO1xuICAgIGlmIChjb21tb25LZXljaGFpbiAhPT0gYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHVzZXIga2V5Y2hhaW4gLSBjb21tb25LZXljaGFpbnMgZG8gbm90IG1hdGNoLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJTaWduaW5nTWF0ZXJpYWw6IFNpZ25pbmdNYXRlcmlhbCA9IHtcbiAgICAgIHVTaGFyZTogdXNlcktleVNoYXJlLnVTaGFyZSxcbiAgICAgIGJpdGdvWVNoYXJlOiBiaXRnb1RvVXNlcixcbiAgICAgIGJhY2t1cFlTaGFyZTogYmFja3VwS2V5U2hhcmUueVNoYXJlc1sxXSxcbiAgICB9O1xuXG4gICAgY29uc3QgdXNlcktleWNoYWluUGFyYW1zOiBBZGRLZXljaGFpbk9wdGlvbnMgPSB7XG4gICAgICBzb3VyY2U6ICd1c2VyJyxcbiAgICAgIGtleVR5cGU6ICd0c3MnLFxuICAgICAgY29tbW9uS2V5Y2hhaW46IGJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4sXG4gICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgfTtcbiAgICBpZiAocGFzc3BocmFzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1c2VyS2V5Y2hhaW5QYXJhbXMuZW5jcnlwdGVkUHJ2ID0gdGhpcy5iaXRnby5lbmNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IEpTT04uc3RyaW5naWZ5KHVzZXJTaWduaW5nTWF0ZXJpYWwpLFxuICAgICAgICBwYXNzd29yZDogcGFzc3BocmFzZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZCh1c2VyS2V5Y2hhaW5QYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBLZXljaGFpbiBjb250YWluaW5nIHRoZSBCYWNrdXAgcGFydHkncyBUU1Mgc2lnbmluZyBtYXRlcmlhbHMuXG4gICAqIFdlIG5lZWQgdG8gaGF2ZSB0aGUgcGFzc3BocmFzZSBiZSBvcHRpb25hbCB0byBhbGxvdyBmb3IgdGhlIGNsaWVudCB0byBzdG9yZSB0aGVpciBiYWNrdXAga2V5IG9uIHRoZWlyIHByZW1pc2VzXG4gICAqXG4gICAqIEBwYXJhbSB1c2VyR3BnS2V5IC0gZXBoZW1lcmFsIEdQRyBrZXkgdG8gZW5jcnlwdCAvIGRlY3J5cHQgc2Vuc2l0dmUgZGF0YSBleGNoYW5nZWQgYmV0d2VlbiB1c2VyIGFuZCBzZXJ2ZXJcbiAgICogQHBhcmFtIHVzZXJLZXlTaGFyZSAtIFVzZXIncyBUU1MgS2V5c2hhcmVcbiAgICogQHBhcmFtIGJhY2t1cEdwZ0tleSAtIGVwaGVtZXJhbCBHUEcga2V5IHRvIGVuY3J5cHQgLyBkZWNyeXB0IHNlbnNpdHZlIGRhdGEgZXhjaGFuZ2VkIGJldHdlZW4gYmFja3VwIGFuZCBzZXJ2ZXJcbiAgICogQHBhcmFtIGJhY2t1cEtleVNoYXJlIC0gQmFja3VwJ3MgVFNTIEtleXNoYXJlXG4gICAqIEBwYXJhbSBiaXRnb0tleWNoYWluIC0gcHJldmlvdXNseSBjcmVhdGVkIEJpdEdvIGtleWNoYWluOyBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCB1c2VyIGFuZCBiYWNrdXAga2V5IHNoYXJlc1xuICAgKiBAcGFyYW0gW3Bhc3NwaHJhc2VdIC0gb3B0aW9uYWwgd2FsbGV0IHBhc3NwaHJhc2UgdXNlZCB0byBlbmNyeXB0IHVzZXIncyBzaWduaW5nIG1hdGVyaWFsc1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlQmFja3VwS2V5Y2hhaW4oe1xuICAgIHVzZXJHcGdLZXksXG4gICAgYmFja3VwR3BnS2V5LFxuICAgIHVzZXJLZXlTaGFyZSxcbiAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICBiaXRnb0tleWNoYWluLFxuICAgIHBhc3NwaHJhc2UsXG4gIH06IENyZWF0ZUVkZHNhS2V5Y2hhaW5QYXJhbXMpOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgY29uc3QgTVBDID0gYXdhaXQgRWRkc2EuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IGJpdGdvS2V5U2hhcmVzID0gYml0Z29LZXljaGFpbi5rZXlTaGFyZXM7XG4gICAgaWYgKCFiaXRnb0tleVNoYXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJpdGdvIGtleXNoYXJlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdEdvVG9CYWNrdXBTaGFyZSA9IGJpdGdvS2V5U2hhcmVzLmZpbmQoKGtleVNoYXJlKSA9PiBrZXlTaGFyZS5mcm9tID09PSAnYml0Z28nICYmIGtleVNoYXJlLnRvID09PSAnYmFja3VwJyk7XG4gICAgaWYgKCFiaXRHb1RvQmFja3VwU2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBCaXRHbyB0byBVc2VyIGtleSBzaGFyZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdEdvVG9CYWNrdXBQcml2YXRlU2hhcmUgPSBhd2FpdCB0aGlzLmRlY3J5cHRQcml2YXRlU2hhcmUoYml0R29Ub0JhY2t1cFNoYXJlLnByaXZhdGVTaGFyZSwgYmFja3VwR3BnS2V5KTtcblxuICAgIGF3YWl0IHRoaXMudmVyaWZ5V2FsbGV0U2lnbmF0dXJlcyhcbiAgICAgIHVzZXJHcGdLZXkucHVibGljS2V5LFxuICAgICAgYmFja3VwR3BnS2V5LnB1YmxpY0tleSxcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICBiaXRHb1RvQmFja3VwUHJpdmF0ZVNoYXJlLFxuICAgICAgMlxuICAgICk7XG5cbiAgICBjb25zdCBiaXRnb1RvQmFja3VwOiBZU2hhcmUgPSB7XG4gICAgICBpOiAyLFxuICAgICAgajogMyxcbiAgICAgIHk6IGJpdEdvVG9CYWNrdXBTaGFyZS5wdWJsaWNTaGFyZS5zbGljZSgwLCA2NCksXG4gICAgICB2OiBiaXRHb1RvQmFja3VwU2hhcmUudnNzUHJvb2YsXG4gICAgICB1OiBiaXRHb1RvQmFja3VwUHJpdmF0ZVNoYXJlLnNsaWNlKDAsIDY0KSxcbiAgICAgIGNoYWluY29kZTogYml0R29Ub0JhY2t1cFByaXZhdGVTaGFyZS5zbGljZSg2NCksXG4gICAgfTtcblxuICAgIC8vIFRPRE8oQkctNDcxNzApOiB1c2UgdHNzLmNyZWF0ZUNvbWJpbmVkS2V5IGhlbHBlciB3aGVuIHNpZ25hdHVyZXMgYXJlIHN1cHBvcnRlZFxuICAgIGNvbnN0IGJhY2t1cENvbWJpbmVkID0gTVBDLmtleUNvbWJpbmUoYmFja3VwS2V5U2hhcmUudVNoYXJlLCBbdXNlcktleVNoYXJlLnlTaGFyZXNbMl0sIGJpdGdvVG9CYWNrdXBdKTtcbiAgICBjb25zdCBjb21tb25LZXljaGFpbiA9IGJhY2t1cENvbWJpbmVkLnBTaGFyZS55ICsgYmFja3VwQ29tYmluZWQucFNoYXJlLmNoYWluY29kZTtcbiAgICBpZiAoY29tbW9uS2V5Y2hhaW4gIT09IGJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBiYWNrdXAga2V5Y2hhaW4gLSBjb21tb25LZXljaGFpbnMgZG8gbm90IG1hdGNoLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhY2t1cFNpZ25pbmdNYXRlcmlhbDogU2lnbmluZ01hdGVyaWFsID0ge1xuICAgICAgdVNoYXJlOiBiYWNrdXBLZXlTaGFyZS51U2hhcmUsXG4gICAgICBiaXRnb1lTaGFyZTogYml0Z29Ub0JhY2t1cCxcbiAgICAgIHVzZXJZU2hhcmU6IHVzZXJLZXlTaGFyZS55U2hhcmVzWzJdLFxuICAgIH07XG4gICAgY29uc3QgcHJ2ID0gSlNPTi5zdHJpbmdpZnkoYmFja3VwU2lnbmluZ01hdGVyaWFsKTtcblxuICAgIGNvbnN0IHBhcmFtczogQ3JlYXRlQmFja3VwT3B0aW9ucyA9IHtcbiAgICAgIHNvdXJjZTogJ2JhY2t1cCcsXG4gICAgICBrZXlUeXBlOiAndHNzJyxcbiAgICAgIGNvbW1vbktleWNoYWluOiBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluLFxuICAgICAgcHJ2OiBwcnYsXG4gICAgfTtcblxuICAgIGlmIChwYXNzcGhyYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtcy5lbmNyeXB0ZWRQcnYgPSB0aGlzLmJpdGdvLmVuY3J5cHQoeyBpbnB1dDogcHJ2LCBwYXNzd29yZDogcGFzc3BocmFzZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKS5jcmVhdGVCYWNrdXAocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgS2V5Y2hhaW4gY29udGFpbmluZyBCaXRHbydzIFRTUyBzaWduaW5nIG1hdGVyaWFscy5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJHcGdLZXkgLSBlcGhlbWVyYWwgR1BHIGtleSB0byBlbmNyeXB0IC8gZGVjcnlwdCBzZW5zaXR2ZSBkYXRhIGV4Y2hhbmdlZCBiZXR3ZWVuIHVzZXIgYW5kIHNlcnZlclxuICAgKiBAcGFyYW0gdXNlcktleVNoYXJlIC0gdXNlcidzIFRTUyBrZXkgc2hhcmVcbiAgICogQHBhcmFtIGJhY2t1cEtleVNoYXJlIC0gYmFja3VwJ3MgVFNTIGtleSBzaGFyZVxuICAgKiBAcGFyYW0gZW50ZXJwcmlzZSAtIGVudGVycHJpc2UgYXNzb2NpYXRlZCB0byB0aGUgd2FsbGV0XG4gICAqL1xuICBhc3luYyBjcmVhdGVCaXRnb0tleWNoYWluKHtcbiAgICB1c2VyR3BnS2V5LFxuICAgIGJhY2t1cEdwZ0tleSxcbiAgICB1c2VyS2V5U2hhcmUsXG4gICAgYmFja3VwS2V5U2hhcmUsXG4gICAgZW50ZXJwcmlzZSxcbiAgfTogQ3JlYXRlRWRkc2FCaXRHb0tleWNoYWluUGFyYW1zKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIC8vIFRPRE8oQkctNDcxNzApOiB1c2UgdHNzLmVuY3J5cHRZU2hhcmUgaGVscGVyIHdoZW4gc2lnbmF0dXJlcyBhcmUgc3VwcG9ydGVkXG4gICAgY29uc3QgdXNlclRvQml0Z29QdWJsaWNTaGFyZSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgQnVmZmVyLmZyb20odXNlcktleVNoYXJlLnVTaGFyZS55LCAnaGV4JyksXG4gICAgICBCdWZmZXIuZnJvbSh1c2VyS2V5U2hhcmUudVNoYXJlLmNoYWluY29kZSwgJ2hleCcpLFxuICAgIF0pLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCB1c2VyVG9CaXRnb1ByaXZhdGVTaGFyZSA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgQnVmZmVyLmZyb20odXNlcktleVNoYXJlLnlTaGFyZXNbM10udSwgJ2hleCcpLFxuICAgICAgQnVmZmVyLmZyb20odXNlcktleVNoYXJlLnlTaGFyZXNbM10uY2hhaW5jb2RlLCAnaGV4JyksXG4gICAgXSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IHVzZXJUb0JpdGdvS2V5U2hhcmUgPSB7XG4gICAgICBwdWJsaWNTaGFyZTogdXNlclRvQml0Z29QdWJsaWNTaGFyZSxcbiAgICAgIHByaXZhdGVTaGFyZTogdXNlclRvQml0Z29Qcml2YXRlU2hhcmUsXG4gICAgICBwcml2YXRlU2hhcmVQcm9vZjogYXdhaXQgY3JlYXRlU2hhcmVQcm9vZih1c2VyR3BnS2V5LnByaXZhdGVLZXksIHVzZXJUb0JpdGdvUHJpdmF0ZVNoYXJlLnNsaWNlKDAsIDY0KSwgJ2VkZHNhJyksXG4gICAgICB2c3NQcm9vZjogdXNlcktleVNoYXJlLnlTaGFyZXNbM10udixcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwVG9CaXRnb1B1YmxpY1NoYXJlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbShiYWNrdXBLZXlTaGFyZS51U2hhcmUueSwgJ2hleCcpLFxuICAgICAgQnVmZmVyLmZyb20oYmFja3VwS2V5U2hhcmUudVNoYXJlLmNoYWluY29kZSwgJ2hleCcpLFxuICAgIF0pLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBiYWNrdXBUb0JpdGdvUHJpdmF0ZVNoYXJlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbShiYWNrdXBLZXlTaGFyZS55U2hhcmVzWzNdLnUsICdoZXgnKSxcbiAgICAgIEJ1ZmZlci5mcm9tKGJhY2t1cEtleVNoYXJlLnlTaGFyZXNbM10uY2hhaW5jb2RlLCAnaGV4JyksXG4gICAgXSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGJhY2t1cFRvQml0Z29LZXlTaGFyZSA9IHtcbiAgICAgIHB1YmxpY1NoYXJlOiBiYWNrdXBUb0JpdGdvUHVibGljU2hhcmUsXG4gICAgICBwcml2YXRlU2hhcmU6IGJhY2t1cFRvQml0Z29Qcml2YXRlU2hhcmUsXG4gICAgICBwcml2YXRlU2hhcmVQcm9vZjogYXdhaXQgY3JlYXRlU2hhcmVQcm9vZihcbiAgICAgICAgYmFja3VwR3BnS2V5LnByaXZhdGVLZXksXG4gICAgICAgIGJhY2t1cFRvQml0Z29Qcml2YXRlU2hhcmUuc2xpY2UoMCwgNjQpLFxuICAgICAgICAnZWRkc2EnXG4gICAgICApLFxuICAgICAgdnNzUHJvb2Y6IGJhY2t1cEtleVNoYXJlLnlTaGFyZXNbM10udixcbiAgICB9O1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuY3JlYXRlQml0Z29LZXljaGFpbkluV1AoXG4gICAgICB1c2VyR3BnS2V5LFxuICAgICAgYmFja3VwR3BnS2V5LFxuICAgICAgdXNlclRvQml0Z29LZXlTaGFyZSxcbiAgICAgIGJhY2t1cFRvQml0Z29LZXlTaGFyZSxcbiAgICAgICd0c3MnLFxuICAgICAgZW50ZXJwcmlzZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBVc2VyLCBCYWNrdXAsIGFuZCBCaXRHbyBUU1MgS2V5Y2hhaW5zLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zLnBhc3NwaHJhc2UgLSBwYXNzcGhyYXNlIHVzZWQgdG8gZW5jcnlwdCBzaWduaW5nIG1hdGVyaWFscyBjcmVhdGVkIGZvciBVc2VyIGFuZCBCYWNrdXBcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUtleWNoYWlucyhwYXJhbXM6IHtcbiAgICBwYXNzcGhyYXNlPzogc3RyaW5nO1xuICAgIGVudGVycHJpc2U/OiBzdHJpbmc7XG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxLZXljaGFpbnNUcmlwbGV0PiB7XG4gICAgY29uc3QgTVBDID0gYXdhaXQgRWRkc2EuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IG0gPSAyO1xuICAgIGNvbnN0IG4gPSAzO1xuXG4gICAgY29uc3QgdXNlcktleVNoYXJlID0gTVBDLmtleVNoYXJlKDEsIG0sIG4pO1xuICAgIGNvbnN0IGJhY2t1cEtleVNoYXJlID0gTVBDLmtleVNoYXJlKDIsIG0sIG4pO1xuXG4gICAgY29uc3QgdXNlckdwZ0tleSA9IGF3YWl0IGdlbmVyYXRlR1BHS2V5UGFpcignc2VjcDI1NmsxJyk7XG4gICAgY29uc3QgYmFja3VwR3BnS2V5ID0gYXdhaXQgZ2VuZXJhdGVHUEdLZXlQYWlyKCdzZWNwMjU2azEnKTtcblxuICAgIGNvbnN0IGJpdGdvS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmNyZWF0ZUJpdGdvS2V5Y2hhaW4oe1xuICAgICAgdXNlckdwZ0tleSxcbiAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgIGJhY2t1cEdwZ0tleSxcbiAgICAgIGJhY2t1cEtleVNoYXJlLFxuICAgICAgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsXG4gICAgfSk7XG4gICAgY29uc3QgdXNlcktleWNoYWluUHJvbWlzZSA9IHRoaXMuY3JlYXRlVXNlcktleWNoYWluKHtcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICBiYWNrdXBHcGdLZXksXG4gICAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICBwYXNzcGhyYXNlOiBwYXJhbXMucGFzc3BocmFzZSxcbiAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZTogcGFyYW1zLm9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICB9KTtcbiAgICBjb25zdCBiYWNrdXBLZXljaGFpblByb21pc2UgPSB0aGlzLmNyZWF0ZUJhY2t1cEtleWNoYWluKHtcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICBiYWNrdXBHcGdLZXksXG4gICAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICBwYXNzcGhyYXNlOiBwYXJhbXMucGFzc3BocmFzZSxcbiAgICB9KTtcbiAgICBjb25zdCBbdXNlcktleWNoYWluLCBiYWNrdXBLZXljaGFpbl0gPSBhd2FpdCBQcm9taXNlLmFsbChbdXNlcktleWNoYWluUHJvbWlzZSwgYmFja3VwS2V5Y2hhaW5Qcm9taXNlXSk7XG5cbiAgICAvLyBjcmVhdGUgd2FsbGV0XG4gICAgY29uc3Qga2V5Y2hhaW5zID0ge1xuICAgICAgdXNlcktleWNoYWluLFxuICAgICAgYmFja3VwS2V5Y2hhaW4sXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgIH07XG5cbiAgICByZXR1cm4ga2V5Y2hhaW5zO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQ29tbWl0bWVudFNoYXJlRnJvbVR4UmVxdWVzdChwYXJhbXM6IHtcbiAgICB0eFJlcXVlc3Q6IFR4UmVxdWVzdDtcbiAgICBwcnY6IHN0cmluZztcbiAgICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPHtcbiAgICB1c2VyVG9CaXRnb0NvbW1pdG1lbnQ6IENvbW1pdG1lbnRTaGFyZVJlY29yZDtcbiAgICBlbmNyeXB0ZWRTaWduZXJTaGFyZTogRW5jcnlwdGVkU2lnbmVyU2hhcmVSZWNvcmQ7XG4gICAgZW5jcnlwdGVkVXNlclRvQml0Z29SU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkO1xuICB9PiB7XG4gICAgY29uc3QgYml0Z29JbmRleCA9IFNoYXJlS2V5UG9zaXRpb24uQklUR087XG4gICAgY29uc3QgeyB0eFJlcXVlc3QsIHBydiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR4UmVxdWVzdFJlc29sdmVkOiBUeFJlcXVlc3QgPSB0eFJlcXVlc3Q7XG5cbiAgICBjb25zdCBoZFRyZWUgPSBhd2FpdCBFZDI1NTE5QmlwMzJIZFRyZWUuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IE1QQyA9IGF3YWl0IEVkZHNhLmluaXRpYWxpemUoaGRUcmVlKTtcblxuICAgIGNvbnN0IHVzZXJTaWduaW5nTWF0ZXJpYWw6IFNpZ25pbmdNYXRlcmlhbCA9IEpTT04ucGFyc2UocHJ2KTtcbiAgICBpZiAoIXVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwWVNoYXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXkgLSBtaXNzaW5nIGJhY2t1cFlTaGFyZScpO1xuICAgIH1cblxuICAgIGFzc2VydCh0eFJlcXVlc3RSZXNvbHZlZC50cmFuc2FjdGlvbnMgfHwgdHhSZXF1ZXN0UmVzb2x2ZWQudW5zaWduZWRUeHMsICdVbmFibGUgdG8gZmluZCB0cmFuc2FjdGlvbnMgaW4gdHhSZXF1ZXN0Jyk7XG4gICAgY29uc3QgdW5zaWduZWRUeCA9XG4gICAgICB0eFJlcXVlc3RSZXNvbHZlZC5hcGlWZXJzaW9uID09PSAnZnVsbCdcbiAgICAgICAgPyB0eFJlcXVlc3RSZXNvbHZlZC50cmFuc2FjdGlvbnMhWzBdLnVuc2lnbmVkVHhcbiAgICAgICAgOiB0eFJlcXVlc3RSZXNvbHZlZC51bnNpZ25lZFR4c1swXTtcblxuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBNUEMua2V5RGVyaXZlKFxuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbC51U2hhcmUsXG4gICAgICBbdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb1lTaGFyZSwgdXNlclNpZ25pbmdNYXRlcmlhbC5iYWNrdXBZU2hhcmVdLFxuICAgICAgdW5zaWduZWRUeC5kZXJpdmF0aW9uUGF0aFxuICAgICk7XG5cbiAgICBjb25zdCBzaWduYWJsZVBheWxvYWQgPSBCdWZmZXIuZnJvbSh1bnNpZ25lZFR4LnNpZ25hYmxlSGV4LCAnaGV4Jyk7XG5cbiAgICBjb25zdCB1c2VyU2lnblNoYXJlID0gYXdhaXQgY3JlYXRlVXNlclNpZ25TaGFyZShzaWduYWJsZVBheWxvYWQsIHNpZ25pbmdLZXkucFNoYXJlKTtcbiAgICBjb25zdCBjb21taXRtZW50ID0gdXNlclNpZ25TaGFyZS5yU2hhcmVzW2JpdGdvSW5kZXhdPy5jb21taXRtZW50O1xuICAgIGFzc2VydChjb21taXRtZW50LCAnVW5hYmxlIHRvIGZpbmQgY29tbWl0bWVudCBpbiB1c2VyU2lnblNoYXJlJyk7XG4gICAgY29uc3QgdXNlclRvQml0Z29Db21taXRtZW50ID0gdGhpcy5jcmVhdGVVc2VyVG9CaXRnb0NvbW1pdG1lbnRTaGFyZShjb21taXRtZW50KTtcblxuICAgIGNvbnN0IHNpZ25lclNoYXJlID0gc2lnbmluZ0tleS55U2hhcmVzW2JpdGdvSW5kZXhdLnUgKyBzaWduaW5nS2V5LnlTaGFyZXNbYml0Z29JbmRleF0uY2hhaW5jb2RlO1xuICAgIGNvbnN0IGJpdGdvR3BnS2V5ID0gYXdhaXQgZ2V0Qml0Z29HcGdQdWJLZXkodGhpcy5iaXRnbyk7XG4gICAgY29uc3QgdXNlclRvQml0Z29FbmNyeXB0ZWRTaWduZXJTaGFyZSA9IGF3YWl0IGVuY3J5cHRUZXh0KHNpZ25lclNoYXJlLCBiaXRnb0dwZ0tleSk7XG5cbiAgICBjb25zdCBlbmNyeXB0ZWRTaWduZXJTaGFyZSA9IHRoaXMuY3JlYXRlVXNlclRvQml0Z29FbmNyeXB0ZWRTaWduZXJTaGFyZSh1c2VyVG9CaXRnb0VuY3J5cHRlZFNpZ25lclNoYXJlKTtcbiAgICBjb25zdCBzdHJpbmdpZmllZFJTaGFyZSA9IEpTT04uc3RyaW5naWZ5KHVzZXJTaWduU2hhcmUpO1xuICAgIGNvbnN0IGVuY3J5cHRlZFJTaGFyZSA9IHRoaXMuYml0Z28uZW5jcnlwdCh7IGlucHV0OiBzdHJpbmdpZmllZFJTaGFyZSwgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFVzZXJUb0JpdGdvUlNoYXJlID0gdGhpcy5jcmVhdGVVc2VyVG9CaXRnb0VuY3J5cHRlZFJTaGFyZShlbmNyeXB0ZWRSU2hhcmUpO1xuXG4gICAgcmV0dXJuIHsgdXNlclRvQml0Z29Db21taXRtZW50LCBlbmNyeXB0ZWRTaWduZXJTaGFyZSwgZW5jcnlwdGVkVXNlclRvQml0Z29SU2hhcmUgfTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZVJTaGFyZUZyb21UeFJlcXVlc3QocGFyYW1zOiB7XG4gICAgdHhSZXF1ZXN0OiBUeFJlcXVlc3Q7XG4gICAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xuICAgIGVuY3J5cHRlZFVzZXJUb0JpdGdvUlNoYXJlOiBFbmNyeXB0ZWRTaWduZXJTaGFyZVJlY29yZDtcbiAgfSk6IFByb21pc2U8eyByU2hhcmU6IFNpZ25TaGFyZSB9PiB7XG4gICAgY29uc3QgeyB3YWxsZXRQYXNzcGhyYXNlLCBlbmNyeXB0ZWRVc2VyVG9CaXRnb1JTaGFyZSB9ID0gcGFyYW1zO1xuXG4gICAgY29uc3QgZGVjcnlwdGVkUlNoYXJlID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgIGlucHV0OiBlbmNyeXB0ZWRVc2VyVG9CaXRnb1JTaGFyZS5zaGFyZSxcbiAgICAgIHBhc3N3b3JkOiB3YWxsZXRQYXNzcGhyYXNlLFxuICAgIH0pO1xuICAgIGNvbnN0IHJTaGFyZSA9IEpTT04ucGFyc2UoZGVjcnlwdGVkUlNoYXJlKTtcbiAgICBhc3NlcnQoclNoYXJlLnhTaGFyZSwgJ1VuYWJsZSB0byBmaW5kIHhTaGFyZSBpbiBkZWNyeXB0ZWRSU2hhcmUnKTtcbiAgICBhc3NlcnQoclNoYXJlLnJTaGFyZXMsICdVbmFibGUgdG8gZmluZCByU2hhcmVzIGluIGRlY3J5cHRlZFJTaGFyZScpO1xuXG4gICAgcmV0dXJuIHsgclNoYXJlIH07XG4gIH1cblxuICBhc3luYyBjcmVhdGVHU2hhcmVGcm9tVHhSZXF1ZXN0KHBhcmFtczoge1xuICAgIHR4UmVxdWVzdDogc3RyaW5nIHwgVHhSZXF1ZXN0O1xuICAgIHBydjogc3RyaW5nO1xuICAgIGJpdGdvVG9Vc2VyUlNoYXJlOiBTaWduYXR1cmVTaGFyZVJlY29yZDtcbiAgICB1c2VyVG9CaXRnb1JTaGFyZTogU2lnblNoYXJlO1xuICAgIGJpdGdvVG9Vc2VyQ29tbWl0bWVudDogQ29tbWl0bWVudFNoYXJlUmVjb3JkO1xuICB9KTogUHJvbWlzZTxHU2hhcmU+IHtcbiAgICBsZXQgdHhSZXF1ZXN0UmVzb2x2ZWQ6IFR4UmVxdWVzdDtcblxuICAgIGNvbnN0IHsgdHhSZXF1ZXN0LCBwcnYsIGJpdGdvVG9Vc2VyQ29tbWl0bWVudCwgYml0Z29Ub1VzZXJSU2hhcmUsIHVzZXJUb0JpdGdvUlNoYXJlIH0gPSBwYXJhbXM7XG5cbiAgICBpZiAodHlwZW9mIHR4UmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHR4UmVxdWVzdFJlc29sdmVkID0gYXdhaXQgZ2V0VHhSZXF1ZXN0KHRoaXMuYml0Z28sIHRoaXMud2FsbGV0LmlkKCksIHR4UmVxdWVzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4UmVxdWVzdFJlc29sdmVkID0gdHhSZXF1ZXN0O1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJTaWduaW5nTWF0ZXJpYWw6IFNpZ25pbmdNYXRlcmlhbCA9IEpTT04ucGFyc2UocHJ2KTtcbiAgICBpZiAoIXVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwWVNoYXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXkgLSBtaXNzaW5nIGJhY2t1cFlTaGFyZScpO1xuICAgIH1cblxuICAgIGFzc2VydCh0eFJlcXVlc3RSZXNvbHZlZC50cmFuc2FjdGlvbnMgfHwgdHhSZXF1ZXN0UmVzb2x2ZWQudW5zaWduZWRUeHMsICdVbmFibGUgdG8gZmluZCB0cmFuc2FjdGlvbnMgaW4gdHhSZXF1ZXN0Jyk7XG4gICAgY29uc3QgdW5zaWduZWRUeCA9XG4gICAgICB0eFJlcXVlc3RSZXNvbHZlZC5hcGlWZXJzaW9uID09PSAnZnVsbCdcbiAgICAgICAgPyB0eFJlcXVlc3RSZXNvbHZlZC50cmFuc2FjdGlvbnMhWzBdLnVuc2lnbmVkVHhcbiAgICAgICAgOiB0eFJlcXVlc3RSZXNvbHZlZC51bnNpZ25lZFR4c1swXTtcblxuICAgIGNvbnN0IHNpZ25hYmxlUGF5bG9hZCA9IEJ1ZmZlci5mcm9tKHVuc2lnbmVkVHguc2lnbmFibGVIZXgsICdoZXgnKTtcblxuICAgIGNvbnN0IHVzZXJUb0JpdEdvR1NoYXJlID0gYXdhaXQgY3JlYXRlVXNlclRvQml0R29HU2hhcmUoXG4gICAgICB1c2VyVG9CaXRnb1JTaGFyZSxcbiAgICAgIGJpdGdvVG9Vc2VyUlNoYXJlLFxuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbC5iYWNrdXBZU2hhcmUsXG4gICAgICB1c2VyU2lnbmluZ01hdGVyaWFsLmJpdGdvWVNoYXJlLFxuICAgICAgc2lnbmFibGVQYXlsb2FkLFxuICAgICAgYml0Z29Ub1VzZXJDb21taXRtZW50XG4gICAgKTtcbiAgICByZXR1cm4gdXNlclRvQml0R29HU2hhcmU7XG4gIH1cblxuICBhc3luYyBzaWduRWRkc2FUc3NVc2luZ0V4dGVybmFsU2lnbmVyKFxuICAgIHR4UmVxdWVzdDogc3RyaW5nIHwgVHhSZXF1ZXN0LFxuICAgIGV4dGVybmFsU2lnbmVyQ29tbWl0bWVudEdlbmVyYXRvcjogQ3VzdG9tQ29tbWl0bWVudEdlbmVyYXRpbmdGdW5jdGlvbixcbiAgICBleHRlcm5hbFNpZ25lclJTaGFyZUdlbmVyYXRvcjogQ3VzdG9tUlNoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICAgIGV4dGVybmFsU2lnbmVyR1NoYXJlR2VuZXJhdG9yOiBDdXN0b21HU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb25cbiAgKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICBsZXQgdHhSZXF1ZXN0UmVzb2x2ZWQ6IFR4UmVxdWVzdDtcbiAgICBsZXQgdHhSZXF1ZXN0SWQ6IHN0cmluZztcbiAgICBpZiAodHlwZW9mIHR4UmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHR4UmVxdWVzdFJlc29sdmVkID0gYXdhaXQgZ2V0VHhSZXF1ZXN0KHRoaXMuYml0Z28sIHRoaXMud2FsbGV0LmlkKCksIHR4UmVxdWVzdCk7XG4gICAgICB0eFJlcXVlc3RJZCA9IHR4UmVxdWVzdFJlc29sdmVkLnR4UmVxdWVzdElkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eFJlcXVlc3RSZXNvbHZlZCA9IHR4UmVxdWVzdDtcbiAgICAgIHR4UmVxdWVzdElkID0gdHhSZXF1ZXN0LnR4UmVxdWVzdElkO1xuICAgIH1cblxuICAgIGNvbnN0IHsgYXBpVmVyc2lvbiB9ID0gdHhSZXF1ZXN0UmVzb2x2ZWQ7XG5cbiAgICBjb25zdCB7IHVzZXJUb0JpdGdvQ29tbWl0bWVudCwgZW5jcnlwdGVkU2lnbmVyU2hhcmUsIGVuY3J5cHRlZFVzZXJUb0JpdGdvUlNoYXJlIH0gPVxuICAgICAgYXdhaXQgZXh0ZXJuYWxTaWduZXJDb21taXRtZW50R2VuZXJhdG9yKHsgdHhSZXF1ZXN0OiB0eFJlcXVlc3RSZXNvbHZlZCB9KTtcblxuICAgIGNvbnN0IHsgY29tbWl0bWVudFNoYXJlOiBiaXRnb1RvVXNlckNvbW1pdG1lbnQgfSA9IGF3YWl0IGV4Y2hhbmdlRWRkc2FDb21taXRtZW50cyhcbiAgICAgIHRoaXMuYml0Z28sXG4gICAgICB0aGlzLndhbGxldC5pZCgpLFxuICAgICAgdHhSZXF1ZXN0SWQsXG4gICAgICB1c2VyVG9CaXRnb0NvbW1pdG1lbnQsXG4gICAgICBlbmNyeXB0ZWRTaWduZXJTaGFyZSxcbiAgICAgIGFwaVZlcnNpb25cbiAgICApO1xuXG4gICAgY29uc3QgeyByU2hhcmUgfSA9IGF3YWl0IGV4dGVybmFsU2lnbmVyUlNoYXJlR2VuZXJhdG9yKHtcbiAgICAgIHR4UmVxdWVzdDogdHhSZXF1ZXN0UmVzb2x2ZWQsXG4gICAgICBlbmNyeXB0ZWRVc2VyVG9CaXRnb1JTaGFyZSxcbiAgICB9KTtcblxuICAgIGF3YWl0IG9mZmVyVXNlclRvQml0Z29SU2hhcmUoXG4gICAgICB0aGlzLmJpdGdvLFxuICAgICAgdGhpcy53YWxsZXQuaWQoKSxcbiAgICAgIHR4UmVxdWVzdElkLFxuICAgICAgclNoYXJlLFxuICAgICAgZW5jcnlwdGVkU2lnbmVyU2hhcmUuc2hhcmUsXG4gICAgICBhcGlWZXJzaW9uXG4gICAgKTtcbiAgICBjb25zdCBiaXRnb1RvVXNlclJTaGFyZSA9IGF3YWl0IGdldEJpdGdvVG9Vc2VyUlNoYXJlKHRoaXMuYml0Z28sIHRoaXMud2FsbGV0LmlkKCksIHR4UmVxdWVzdElkKTtcbiAgICBjb25zdCBnU2lnblNoYXJlVHJhbnNhY3Rpb25QYXJhbXMgPSB7XG4gICAgICB0eFJlcXVlc3Q6IHR4UmVxdWVzdFJlc29sdmVkLFxuICAgICAgYml0Z29Ub1VzZXJSU2hhcmU6IGJpdGdvVG9Vc2VyUlNoYXJlLFxuICAgICAgdXNlclRvQml0Z29SU2hhcmU6IHJTaGFyZSxcbiAgICAgIGJpdGdvVG9Vc2VyQ29tbWl0bWVudCxcbiAgICB9O1xuICAgIGNvbnN0IGdTaGFyZSA9IGF3YWl0IGV4dGVybmFsU2lnbmVyR1NoYXJlR2VuZXJhdG9yKGdTaWduU2hhcmVUcmFuc2FjdGlvblBhcmFtcyk7XG4gICAgYXdhaXQgc2VuZFVzZXJUb0JpdGdvR1NoYXJlKHRoaXMuYml0Z28sIHRoaXMud2FsbGV0LmlkKCksIHR4UmVxdWVzdElkLCBnU2hhcmUsIGFwaVZlcnNpb24pO1xuICAgIHJldHVybiBhd2FpdCBnZXRUeFJlcXVlc3QodGhpcy5iaXRnbywgdGhpcy53YWxsZXQuaWQoKSwgdHhSZXF1ZXN0SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSB0cmFuc2FjdGlvbiBhc3NvY2lhdGVkIHRvIHRoZSB0cmFuc2FjdGlvbiByZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0gdHhSZXF1ZXN0IC0gdHJhbnNhY3Rpb24gcmVxdWVzdCBvYmplY3Qgb3IgaWRcbiAgICogQHBhcmFtIHBydiAtIGRlY3J5cHRlZCBwcml2YXRlIGtleVxuICAgKiBAcGFyYW0gcmVxSWQgLSByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFR4UmVxdWVzdD59IGZ1bGx5IHNpZ25lZCBUeFJlcXVlc3Qgb2JqZWN0XG4gICAqL1xuICBhc3luYyBzaWduVHhSZXF1ZXN0KHBhcmFtczogVFNTUGFyYW1zKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICBsZXQgdHhSZXF1ZXN0UmVzb2x2ZWQ6IFR4UmVxdWVzdDtcbiAgICBsZXQgdHhSZXF1ZXN0SWQ6IHN0cmluZztcblxuICAgIGNvbnN0IHsgdHhSZXF1ZXN0LCBwcnYgfSA9IHBhcmFtcztcblxuICAgIGlmICh0eXBlb2YgdHhSZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgdHhSZXF1ZXN0UmVzb2x2ZWQgPSBhd2FpdCBnZXRUeFJlcXVlc3QodGhpcy5iaXRnbywgdGhpcy53YWxsZXQuaWQoKSwgdHhSZXF1ZXN0KTtcbiAgICAgIHR4UmVxdWVzdElkID0gdHhSZXF1ZXN0UmVzb2x2ZWQudHhSZXF1ZXN0SWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4UmVxdWVzdFJlc29sdmVkID0gdHhSZXF1ZXN0O1xuICAgICAgdHhSZXF1ZXN0SWQgPSB0eFJlcXVlc3QudHhSZXF1ZXN0SWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaGRUcmVlID0gYXdhaXQgRWQyNTUxOUJpcDMySGRUcmVlLmluaXRpYWxpemUoKTtcbiAgICBjb25zdCBNUEMgPSBhd2FpdCBFZGRzYS5pbml0aWFsaXplKGhkVHJlZSk7XG5cbiAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsOiBTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKHBydik7XG4gICAgaWYgKCF1c2VyU2lnbmluZ01hdGVyaWFsLmJhY2t1cFlTaGFyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXIga2V5IC0gbWlzc2luZyBiYWNrdXBZU2hhcmUnKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IGFwaVZlcnNpb24gfSA9IHR4UmVxdWVzdFJlc29sdmVkO1xuICAgIGFzc2VydCh0eFJlcXVlc3RSZXNvbHZlZC50cmFuc2FjdGlvbnMgfHwgdHhSZXF1ZXN0UmVzb2x2ZWQudW5zaWduZWRUeHMsICdVbmFibGUgdG8gZmluZCB0cmFuc2FjdGlvbnMgaW4gdHhSZXF1ZXN0Jyk7XG4gICAgY29uc3QgdW5zaWduZWRUeCA9XG4gICAgICBhcGlWZXJzaW9uID09PSAnZnVsbCcgPyB0eFJlcXVlc3RSZXNvbHZlZC50cmFuc2FjdGlvbnMhWzBdLnVuc2lnbmVkVHggOiB0eFJlcXVlc3RSZXNvbHZlZC51bnNpZ25lZFR4c1swXTtcblxuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBNUEMua2V5RGVyaXZlKFxuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbC51U2hhcmUsXG4gICAgICBbdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb1lTaGFyZSwgdXNlclNpZ25pbmdNYXRlcmlhbC5iYWNrdXBZU2hhcmVdLFxuICAgICAgdW5zaWduZWRUeC5kZXJpdmF0aW9uUGF0aFxuICAgICk7XG5cbiAgICBjb25zdCBzaWduYWJsZVBheWxvYWQgPSBCdWZmZXIuZnJvbSh1bnNpZ25lZFR4LnNpZ25hYmxlSGV4LCAnaGV4Jyk7XG5cbiAgICBjb25zdCB1c2VyU2lnblNoYXJlID0gYXdhaXQgY3JlYXRlVXNlclNpZ25TaGFyZShzaWduYWJsZVBheWxvYWQsIHNpZ25pbmdLZXkucFNoYXJlKTtcblxuICAgIGNvbnN0IGJpdGdvSW5kZXggPSBTaGFyZUtleVBvc2l0aW9uLkJJVEdPO1xuICAgIGNvbnN0IHNpZ25lclNoYXJlID0gc2lnbmluZ0tleS55U2hhcmVzW2JpdGdvSW5kZXhdLnUgKyBzaWduaW5nS2V5LnlTaGFyZXNbYml0Z29JbmRleF0uY2hhaW5jb2RlO1xuICAgIGNvbnN0IGJpdGdvR3BnS2V5ID0gYXdhaXQgZ2V0Qml0Z29HcGdQdWJLZXkodGhpcy5iaXRnbyk7XG4gICAgY29uc3QgdXNlclRvQml0Z29FbmNyeXB0ZWRTaWduZXJTaGFyZSA9IGF3YWl0IGVuY3J5cHRUZXh0KHNpZ25lclNoYXJlLCBiaXRnb0dwZ0tleSk7XG5cbiAgICBjb25zdCB1c2VyR3BnS2V5ID0gYXdhaXQgZ2VuZXJhdGVHUEdLZXlQYWlyKCdzZWNwMjU2azEnKTtcbiAgICBjb25zdCBwcml2YXRlU2hhcmVQcm9vZiA9IGF3YWl0IGNyZWF0ZVNoYXJlUHJvb2YodXNlckdwZ0tleS5wcml2YXRlS2V5LCBzaWduaW5nS2V5LnlTaGFyZXNbYml0Z29JbmRleF0udSwgJ2VkZHNhJyk7XG4gICAgY29uc3QgdnNzUHJvb2YgPSBzaWduaW5nS2V5LnlTaGFyZXNbYml0Z29JbmRleF0udjtcbiAgICBjb25zdCB1c2VyUHVibGljR3BnS2V5ID0gdXNlckdwZ0tleS5wdWJsaWNLZXk7XG4gICAgY29uc3QgcHVibGljU2hhcmUgPSBzaWduaW5nS2V5LnlTaGFyZXNbYml0Z29JbmRleF0ueSArIHNpZ25pbmdLZXkueVNoYXJlc1tiaXRnb0luZGV4XS5jaGFpbmNvZGU7XG5cbiAgICBjb25zdCB1c2VyVG9CaXRnb0NvbW1pdG1lbnQgPSB1c2VyU2lnblNoYXJlLnJTaGFyZXNbYml0Z29JbmRleF0uY29tbWl0bWVudDtcbiAgICBhc3NlcnQodXNlclRvQml0Z29Db21taXRtZW50LCAnTWlzc2luZyB1c2VyVG9CaXRnb0NvbW1pdG1lbnQgY29tbWl0bWVudCcpO1xuXG4gICAgY29uc3QgY29tbWl0bWVudFNoYXJlID0gdGhpcy5jcmVhdGVVc2VyVG9CaXRnb0NvbW1pdG1lbnRTaGFyZSh1c2VyVG9CaXRnb0NvbW1pdG1lbnQpO1xuICAgIGNvbnN0IGVuY3J5cHRlZFNpZ25lclNoYXJlID0gdGhpcy5jcmVhdGVVc2VyVG9CaXRnb0VuY3J5cHRlZFNpZ25lclNoYXJlKHVzZXJUb0JpdGdvRW5jcnlwdGVkU2lnbmVyU2hhcmUpO1xuXG4gICAgY29uc3QgeyBjb21taXRtZW50U2hhcmU6IGJpdGdvVG9Vc2VyQ29tbWl0bWVudCB9ID0gYXdhaXQgZXhjaGFuZ2VFZGRzYUNvbW1pdG1lbnRzKFxuICAgICAgdGhpcy5iaXRnbyxcbiAgICAgIHRoaXMud2FsbGV0LmlkKCksXG4gICAgICB0eFJlcXVlc3RJZCxcbiAgICAgIGNvbW1pdG1lbnRTaGFyZSxcbiAgICAgIGVuY3J5cHRlZFNpZ25lclNoYXJlLFxuICAgICAgYXBpVmVyc2lvblxuICAgICk7XG5cbiAgICBhd2FpdCBvZmZlclVzZXJUb0JpdGdvUlNoYXJlKFxuICAgICAgdGhpcy5iaXRnbyxcbiAgICAgIHRoaXMud2FsbGV0LmlkKCksXG4gICAgICB0eFJlcXVlc3RJZCxcbiAgICAgIHVzZXJTaWduU2hhcmUsXG4gICAgICB1c2VyVG9CaXRnb0VuY3J5cHRlZFNpZ25lclNoYXJlLFxuICAgICAgYXBpVmVyc2lvbixcbiAgICAgIHZzc1Byb29mLFxuICAgICAgcHJpdmF0ZVNoYXJlUHJvb2YsXG4gICAgICB1c2VyUHVibGljR3BnS2V5LFxuICAgICAgcHVibGljU2hhcmVcbiAgICApO1xuXG4gICAgY29uc3QgYml0Z29Ub1VzZXJSU2hhcmUgPSBhd2FpdCBnZXRCaXRnb1RvVXNlclJTaGFyZSh0aGlzLmJpdGdvLCB0aGlzLndhbGxldC5pZCgpLCB0eFJlcXVlc3RJZCk7XG5cbiAgICBjb25zdCB1c2VyVG9CaXRHb0dTaGFyZSA9IGF3YWl0IGNyZWF0ZVVzZXJUb0JpdEdvR1NoYXJlKFxuICAgICAgdXNlclNpZ25TaGFyZSxcbiAgICAgIGJpdGdvVG9Vc2VyUlNoYXJlLFxuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbC5iYWNrdXBZU2hhcmUsXG4gICAgICB1c2VyU2lnbmluZ01hdGVyaWFsLmJpdGdvWVNoYXJlLFxuICAgICAgc2lnbmFibGVQYXlsb2FkLFxuICAgICAgYml0Z29Ub1VzZXJDb21taXRtZW50XG4gICAgKTtcblxuICAgIGF3YWl0IHNlbmRVc2VyVG9CaXRnb0dTaGFyZSh0aGlzLmJpdGdvLCB0aGlzLndhbGxldC5pZCgpLCB0eFJlcXVlc3RJZCwgdXNlclRvQml0R29HU2hhcmUsIGFwaVZlcnNpb24pO1xuXG4gICAgcmV0dXJuIGF3YWl0IGdldFR4UmVxdWVzdCh0aGlzLmJpdGdvLCB0aGlzLndhbGxldC5pZCgpLCB0eFJlcXVlc3RJZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb21tb25QdWIgcG9ydGlvbiBvZiB0aGUgY29tbW9uS2V5Y2hhaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tb25LZXljaGFpblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldFB1YmxpY0tleUZyb21Db21tb25LZXljaGFpbihjb21tb25LZXljaGFpbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoY29tbW9uS2V5Y2hhaW4ubGVuZ3RoICE9PSAxMjgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb21tb25LZXljaGFpbiBsZW5ndGgsIGV4cGVjdGVkIDEyOCwgZ290ICR7Y29tbW9uS2V5Y2hhaW4ubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25QdWJIZXhTdHIgPSBjb21tb25LZXljaGFpbi5zbGljZSgwLCA2NCk7XG4gICAgcmV0dXJuIGJzNTguZW5jb2RlKEJ1ZmZlci5mcm9tKGNvbW1vblB1YkhleFN0ciwgJ2hleCcpKTtcbiAgfVxuXG4gIGNyZWF0ZVVzZXJUb0JpdGdvQ29tbWl0bWVudFNoYXJlKGNvbW1pdG1lbnQ6IHN0cmluZyk6IENvbW1pdG1lbnRTaGFyZVJlY29yZCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IFNpZ25hdHVyZVNoYXJlVHlwZS5VU0VSLFxuICAgICAgdG86IFNpZ25hdHVyZVNoYXJlVHlwZS5CSVRHTyxcbiAgICAgIHNoYXJlOiBjb21taXRtZW50LFxuICAgICAgdHlwZTogQ29tbWl0bWVudFR5cGUuQ09NTUlUTUVOVCxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlVXNlclRvQml0Z29FbmNyeXB0ZWRTaWduZXJTaGFyZShlbmNyeXB0ZWRTaWduZXJTaGFyZTogc3RyaW5nKTogRW5jcnlwdGVkU2lnbmVyU2hhcmVSZWNvcmQge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiBTaWduYXR1cmVTaGFyZVR5cGUuVVNFUixcbiAgICAgIHRvOiBTaWduYXR1cmVTaGFyZVR5cGUuQklUR08sXG4gICAgICBzaGFyZTogZW5jcnlwdGVkU2lnbmVyU2hhcmUsXG4gICAgICB0eXBlOiBFbmNyeXB0ZWRTaWduZXJTaGFyZVR5cGUuRU5DUllQVEVEX1NJR05FUl9TSEFSRSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlVXNlclRvQml0Z29FbmNyeXB0ZWRSU2hhcmUoZW5jcnlwdGVkUlNoYXJlOiBzdHJpbmcpOiBFbmNyeXB0ZWRTaWduZXJTaGFyZVJlY29yZCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IFNpZ25hdHVyZVNoYXJlVHlwZS5VU0VSLFxuICAgICAgdG86IFNpZ25hdHVyZVNoYXJlVHlwZS5CSVRHTyxcbiAgICAgIHNoYXJlOiBlbmNyeXB0ZWRSU2hhcmUsXG4gICAgICB0eXBlOiBFbmNyeXB0ZWRTaWduZXJTaGFyZVR5cGUuRU5DUllQVEVEX1JfU0hBUkUsXG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCAtIHVzZSBFZGRzYVV0aWxzXG4gKi9cbmV4cG9ydCBjb25zdCBUc3NVdGlscyA9IEVkZHNhVXRpbHM7XG4iXX0=