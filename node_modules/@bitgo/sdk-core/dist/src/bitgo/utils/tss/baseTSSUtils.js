"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const openpgp_1 = require("openpgp");
const tss_1 = require("../../tss");
const mpcUtils_1 = require("../mpcUtils");
const _ = __importStar(require("lodash"));
/**
 * BaseTssUtil class which different signature schemes have to extend
 */
class BaseTssUtils extends mpcUtils_1.MpcUtils {
    constructor(bitgo, baseCoin, wallet) {
        super(bitgo, baseCoin);
        this._wallet = wallet;
    }
    get wallet() {
        if (_.isNil(this._wallet)) {
            throw new Error('Wallet not defined');
        }
        return this._wallet;
    }
    async createBitgoHeldBackupKeyShare(userGpgKey, enterprise) {
        const keyResponse = await this.bitgo
            .post(this.baseCoin.url('/krs/backupkeys'))
            .send({
            enterprise,
            userGPGPublicKey: userGpgKey.publicKey,
        })
            .result();
        if (!keyResponse || !keyResponse.keyShares) {
            throw new Error('Failed to get backup shares from BitGo.');
        }
        return {
            id: keyResponse.id,
            keyShares: keyResponse.keyShares,
        };
    }
    finalizeBitgoHeldBackupKeyShare(keyId, commonKeychain, userKeyShare, bitgoKeychain, userGpgKey, backupGpgKey) {
        throw new Error('Method not implemented.');
    }
    createUserKeychain(params) {
        throw new Error('Method not implemented.');
    }
    createBackupKeychain(params) {
        throw new Error('Method not implemented.');
    }
    createBitgoKeychain(params) {
        throw new Error('Method not implemented.');
    }
    createKeychains(params) {
        throw new Error('Method not implemented.');
    }
    signTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    signTxRequestForMessage(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Signs a transaction using TSS for EdDSA and through utilization of custom share generators
     *
     * @param {string | TxRequest} txRequest - transaction request with unsigned transaction
     * @param {CustomRShareGeneratingFunction} externalSignerRShareGenerator a function that creates R shares in the EdDSA TSS flow
     * @param {CustomGShareGeneratingFunction} externalSignerGShareGenerator a function that creates G shares in the EdDSA TSS flow
     * @returns {Promise<TxRequest>} - a signed tx request
     */
    signEddsaTssUsingExternalSigner(txRequest, externalSignerCommitmentGenerator, externalSignerRShareGenerator, externalSignerGShareGenerator) {
        throw new Error('Method not implemented.');
    }
    /**
     * Signs a transaction using TSS for ECDSA and through utilization of custom share generators
     *
     * @param {params: TSSParams | TSSParamsForMessage} params - params object that represents parameters to sign a transaction or a message.
     * @param {RequestType} requestType - the type of the request to sign (transaction or message).
     * @param {CustomPaillierModulusGetterFunction} externalSignerPaillierModulusGetter a function that creates Paillier Modulus shares in the ECDSA TSS flow.
     * @param {CustomKShareGeneratingFunction} externalSignerKShareGenerator a function that creates K shares in the ECDSA TSS flow.
     * @param {CustomMuDeltaShareGeneratingFunction} externalSignerMuDeltaShareGenerator a function that creates Mu and Delta shares in the ECDSA TSS flow.
     * @param {CustomSShareGeneratingFunction} externalSignerSShareGenerator a function that creates S shares in the ECDSA TSS flow.
     */
    signEcdsaTssUsingExternalSigner(params, requestType, externalSignerPaillierModulusGetter, externalSignerKShareGenerator, externalSignerMuDeltaShareGenerator, externalSignerSShareGenerator) {
        throw new Error('Method not implemented.');
    }
    /**
     * Create an Commitment (User to BitGo) share from an unsigned transaction and private user signing material
     * EDDSA only
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {string} params.walletPassphrase - wallet passphrase
     *
     * @returns {Promise<{ userToBitgoCommitment: CommitmentShareRecor, encryptedSignerShare: EncryptedSignerShareRecord }>} - Commitment Share and the Encrypted Signer Share to BitGo
     */
    createCommitmentShareFromTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Create an R (User to BitGo) share from an unsigned transaction and private user signing material
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {string} [params.walletPassphrase] - wallet passphrase
     * @param {EncryptedSignerShareRecord} [params.encryptedUserToBitgoRShare] - encrypted user to bitgo R share generated in the commitment phase
     * @returns {Promise<{ rShare: SignShare }>} - R Share to BitGo
     */
    createRShareFromTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Create a G (User to BitGo) share from an unsigned transaction and private user signing material
     *
     * @param {Object} params - params object
     * @param {TxRequest} params.txRequest - transaction request with unsigned transaction
     * @param {string} params.prv - user signing material
     * @param {SignatureShareRecord} params.bitgoToUserRShare - BitGo to User R Share
     * @param {SignShare} params.userToBitgoRShare - User to BitGo R Share
     * @param {CommitmentShareRecord} params.bitgoToUserCommitment - BitGo to User Commitment
     * @returns {Promise<GShare>} - GShare from User to BitGo
     */
    createGShareFromTxRequest(params) {
        throw new Error('Method not implemented.');
    }
    /**
     * Builds a tx request from params and verify it
     *
     * @param {PrebuildTransactionWithIntentOptions} params - parameters to build the tx
     * @param {TxRequestVersion} apiVersion lite or full
     * @param {boolean} preview boolean indicating if this is to preview a tx request, which will not initiate policy checks or pending approvals
     * @returns {Promise<TxRequest>} - a built tx request
     */
    async prebuildTxWithIntent(params, apiVersion = 'lite', preview) {
        const intentOptions = this.populateIntent(this.baseCoin, params);
        const whitelistedParams = {
            intent: {
                ...intentOptions,
            },
            apiVersion: apiVersion,
            preview,
        };
        const unsignedTx = (await this.bitgo
            .post(this.bitgo.url('/wallet/' + this.wallet.id() + '/txrequests', 2))
            .send(whitelistedParams)
            .result());
        return unsignedTx;
    }
    /**
     * Create a tx request from params for message signing
     *
     * @param params
     * @param apiVersion
     * @param preview
     */
    async createTxRequestWithIntentForMessageSigning(params, apiVersion = 'full', preview) {
        var _a, _b;
        const intentOptions = {
            custodianMessageId: params.custodianMessageId,
            intentType: params.intentType,
            sequenceId: params.sequenceId,
            comment: params.comment,
            memo: (_a = params.memo) === null || _a === void 0 ? void 0 : _a.value,
            isTss: params.isTss,
            messageRaw: params.messageRaw,
            messageEncoded: (_b = params.messageEncoded) !== null && _b !== void 0 ? _b : '',
        };
        return this.createTxRequestBase(intentOptions, apiVersion, preview);
    }
    /**
     * Create a tx request from params for type data signing
     *
     * @param params
     * @param apiVersion
     * @param preview
     */
    async createTxRequestWithIntentForTypedDataSigning(params, apiVersion = 'full', preview) {
        var _a, _b;
        const intentOptions = {
            custodianMessageId: params.custodianMessageId,
            intentType: params.intentType,
            sequenceId: params.sequenceId,
            comment: params.comment,
            memo: (_a = params.memo) === null || _a === void 0 ? void 0 : _a.value,
            isTss: params.isTss,
            messageRaw: params.typedDataRaw,
            messageEncoded: (_b = params.typedDataEncoded) !== null && _b !== void 0 ? _b : '',
        };
        return this.createTxRequestBase(intentOptions, apiVersion, preview);
    }
    /**
     * Calls Bitgo API to create tx request.
     *
     * @private
     */
    async createTxRequestBase(intentOptions, apiVersion, preview) {
        const whitelistedParams = {
            intent: {
                ...intentOptions,
            },
            apiVersion,
            preview,
        };
        return this.bitgo
            .post(this.bitgo.url(`/wallet/${this.wallet.id()}/txrequests`, 2))
            .send(whitelistedParams)
            .result();
    }
    /**
     * Call delete signature shares for a txRequest, the endpoint delete the signatures and return them
     *
     * @param {string} txRequestId tx id reference to delete signature shares
     * @returns {SignatureShareRecord[]}
     */
    async deleteSignatureShares(txRequestId) {
        return this.bitgo
            .del(this.bitgo.url(`/wallet/${this.wallet.id()}/txrequests/${txRequestId}/signatureshares`, 2))
            .send()
            .result();
    }
    /**
     * Initialize the send procedure once Bitgo has the User To Bitgo GShare
     *
     * @param {String} txRequestId - the txRequest Id
     * @returns {Promise<any>}
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async sendTxRequest(txRequestId) {
        return this.bitgo
            .post(this.baseCoin.url('/wallet/' + this.wallet.id() + '/tx/send'))
            .send({ txRequestId })
            .result();
    }
    /**
     * Delete signature shares, get the tx request without them from the db and sign it to finally send it.
     *
     * Note : This can be performed in order to reach latest network conditions required on pending approval flow.
     *
     * @param {String} txRequestId - the txRequest Id to make the requests.
     * @param {String} decryptedPrv - decrypted prv to sign the tx request.
     * @param {RequestTracer} reqId id tracer.
     * @returns {Promise<any>}
     */
    async recreateTxRequest(txRequestId, decryptedPrv, reqId) {
        await this.deleteSignatureShares(txRequestId);
        // after delete signatures shares get the tx without them
        const txRequest = await tss_1.getTxRequest(this.bitgo, this.wallet.id(), txRequestId);
        return await this.signTxRequest({ txRequest, prv: decryptedPrv, reqId });
    }
    /**
     * Gets the latest Tx Request by id
     *
     * @param {String} txRequestId - the txRequest Id
     * @returns {Promise<TxRequest>}
     */
    async getTxRequest(txRequestId) {
        return tss_1.getTxRequest(this.bitgo, this.wallet.id(), txRequestId);
    }
    /**
     * Checks whether the third party backup provider is valid/supported
     * @param backupProvider - the backup provider client selected
     */
    isValidThirdPartyBackupProvider(backupProvider) {
        // As of now, BitGo is the only supported KRS provider for TSS
        return !!(backupProvider && backupProvider === 'BitGoTrustAsKrs');
    }
    /**
     * It gets the appropriate BitGo GPG public key for key creation based on a
     * combination of coin and the feature flags on the user and their enterprise if set.
     * @param enterpriseId - enterprise under which user wants to create the wallet
     */
    async getBitgoGpgPubkeyBasedOnFeatureFlags(enterpriseId) {
        const response = await this.bitgo
            .get(this.baseCoin.url('/tss/pubkey'))
            .query({ enterpriseId })
            .result();
        const bitgoPublicKeyStr = response.publicKey;
        return openpgp_1.readKey({ armoredKey: bitgoPublicKeyStr });
    }
    /**
     * Returns supported TxRequest versions for this wallet
     */
    supportedTxRequestVersions() {
        var _a, _b, _c, _d;
        const walletType = (_a = this._wallet) === null || _a === void 0 ? void 0 : _a.type();
        const supportedWalletTypes = ['custodial', 'cold', 'hot'];
        if (!walletType || ((_b = this._wallet) === null || _b === void 0 ? void 0 : _b.multisigType()) !== 'tss' || !supportedWalletTypes.includes(walletType)) {
            return [];
        }
        else if (((_c = this._wallet) === null || _c === void 0 ? void 0 : _c.baseCoin.getMPCAlgorithm()) === 'ecdsa') {
            return ['full'];
        }
        else if (walletType === 'custodial' || walletType === 'cold') {
            return ['full'];
        }
        else if (((_d = this._wallet) === null || _d === void 0 ? void 0 : _d.baseCoin.getMPCAlgorithm()) === 'eddsa' && walletType === 'hot') {
            return ['lite', 'full'];
        }
        return [];
    }
    /**
     * Returns true if the txRequest is using apiVersion == full and is pending approval
     * @param txRequest
     * @returns boolean
     */
    isPendingApprovalTxRequestFull(txRequest) {
        const { apiVersion, state } = txRequest;
        return apiVersion === 'full' && 'pendingApproval' === state;
    }
}
exports.default = BaseTssUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZVRTU1V0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2JpdGdvL3V0aWxzL3Rzcy9iYXNlVFNTVXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EscUNBQTBEO0FBSTFELG1DQUF5QztBQUV6QywwQ0FBdUM7QUFDdkMsMENBQTRCO0FBOEI1Qjs7R0FFRztBQUNILE1BQXFCLFlBQXVCLFNBQVEsbUJBQVE7SUFHMUQsWUFBWSxLQUFnQixFQUFFLFFBQW1CLEVBQUUsTUFBZ0I7UUFDakUsS0FBSyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztRQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztJQUN4QixDQUFDO0lBRUQsSUFBSSxNQUFNO1FBQ1IsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN6QixNQUFNLElBQUksS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7U0FDdkM7UUFDRCxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7SUFDdEIsQ0FBQztJQUVELEtBQUssQ0FBQyw2QkFBNkIsQ0FDakMsVUFBcUMsRUFDckMsVUFBOEI7UUFFOUIsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSzthQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQzthQUMxQyxJQUFJLENBQUM7WUFDSixVQUFVO1lBQ1YsZ0JBQWdCLEVBQUUsVUFBVSxDQUFDLFNBQVM7U0FDdkMsQ0FBQzthQUNELE1BQU0sRUFBRSxDQUFDO1FBQ1osSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUU7WUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1NBQzVEO1FBQ0QsT0FBTztZQUNMLEVBQUUs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QixNQUFNLFVBQVUsR0FBRyxNQUFBLElBQUksQ0FBQyxPQUFPLDBDQUFFLElBQUksRUFBRSxDQUFDO1FBQ3hDLE1BQU0sb0JBQW9CLEdBQUcsQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzFELElBQUksQ0FBQyxVQUFVLElBQUksQ0FBQSxNQUFBLElBQUksQ0FBQyxPQUFPLDBDQUFFLFlBQVksRUFBRSxNQUFLLEtBQUssSUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUN2RyxPQUFPLEVBQUUsQ0FBQztTQUNYO2FBQU0sSUFBSSxDQUFBLE1BQUEsSUFBSSxDQUFDLE9BQU8sMENBQUUsUUFBUSxDQUFDLGVBQWUsRUFBRSxNQUFLLE9BQU8sRUFBRTtZQUMvRCxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakI7YUFBTSxJQUFJLFVBQVUsS0FBSyxXQUFXLElBQUksVUFBVSxLQUFLLE1BQU0sRUFBRTtZQUM5RCxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakI7YUFBTSxJQUFJLENBQUEsTUFBQSxJQUFJLENBQUMsT0FBTywwQ0FBRSxRQUFRLENBQUMsZUFBZSxFQUFFLE1BQUssT0FBTyxJQUFJLFVBQVUsS0FBSyxLQUFLLEVBQUU7WUFDdkYsT0FBTyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztTQUN6QjtRQUNELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw4QkFBOEIsQ0FBQyxTQUFvQjtRQUNqRCxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxHQUFHLFNBQVMsQ0FBQztRQUN4QyxPQUFPLFVBQVUsS0FBSyxNQUFNLElBQUksaUJBQWlCLEtBQUssS0FBSyxDQUFDO0lBQzlELENBQUM7Q0FDRjtBQWpZRCwrQkFpWUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJUmVxdWVzdFRyYWNlciB9IGZyb20gJy4uLy4uLy4uL2FwaSc7XG5pbXBvcnQgeyBLZXksIHJlYWRLZXksIFNlcmlhbGl6ZWRLZXlQYWlyIH0gZnJvbSAnb3BlbnBncCc7XG5pbXBvcnQgeyBJQmFzZUNvaW4sIEtleWNoYWluc1RyaXBsZXQgfSBmcm9tICcuLi8uLi9iYXNlQ29pbic7XG5pbXBvcnQgeyBCaXRHb0Jhc2UgfSBmcm9tICcuLi8uLi9iaXRnb0Jhc2UnO1xuaW1wb3J0IHsgS2V5Y2hhaW4gfSBmcm9tICcuLi8uLi9rZXljaGFpbic7XG5pbXBvcnQgeyBnZXRUeFJlcXVlc3QgfSBmcm9tICcuLi8uLi90c3MnO1xuaW1wb3J0IHsgSVdhbGxldCwgQmFja3VwUHJvdmlkZXIgfSBmcm9tICcuLi8uLi93YWxsZXQnO1xuaW1wb3J0IHsgTXBjVXRpbHMgfSBmcm9tICcuLi9tcGNVdGlscyc7XG5pbXBvcnQgKiBhcyBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQge1xuICBCaXRnb0dQR1B1YmxpY0tleSxcbiAgQml0Z29IZWxkQmFja3VwS2V5U2hhcmUsXG4gIEN1c3RvbUdTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgQ3VzdG9tUlNoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICBJVHNzVXRpbHMsXG4gIFByZWJ1aWxkVHJhbnNhY3Rpb25XaXRoSW50ZW50T3B0aW9ucyxcbiAgU2lnbmF0dXJlU2hhcmVSZWNvcmQsXG4gIFRTU1BhcmFtcyxcbiAgVHhSZXF1ZXN0LFxuICBUeFJlcXVlc3RWZXJzaW9uLFxuICBDcmVhdGVLZXljaGFpblBhcmFtc0Jhc2UsXG4gIEludGVudE9wdGlvbnNGb3JNZXNzYWdlLFxuICBQb3B1bGF0ZWRJbnRlbnRGb3JNZXNzYWdlU2lnbmluZyxcbiAgSW50ZW50T3B0aW9uc0ZvclR5cGVkRGF0YSxcbiAgUG9wdWxhdGVkSW50ZW50Rm9yVHlwZWREYXRhU2lnbmluZyxcbiAgQ3JlYXRlQml0R29LZXljaGFpblBhcmFtc0Jhc2UsXG4gIENvbW1pdG1lbnRTaGFyZVJlY29yZCxcbiAgRW5jcnlwdGVkU2lnbmVyU2hhcmVSZWNvcmQsXG4gIEN1c3RvbUNvbW1pdG1lbnRHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIFRTU1BhcmFtc0Zvck1lc3NhZ2UsXG4gIFJlcXVlc3RUeXBlLFxuICBDdXN0b21QYWlsbGllck1vZHVsdXNHZXR0ZXJGdW5jdGlvbixcbiAgQ3VzdG9tS1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICBDdXN0b21NdURlbHRhU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIEN1c3RvbVNTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbn0gZnJvbSAnLi9iYXNlVHlwZXMnO1xuaW1wb3J0IHsgR1NoYXJlLCBTaWduU2hhcmUgfSBmcm9tICcuLi8uLi8uLi9hY2NvdW50LWxpYi9tcGMvdHNzJztcblxuLyoqXG4gKiBCYXNlVHNzVXRpbCBjbGFzcyB3aGljaCBkaWZmZXJlbnQgc2lnbmF0dXJlIHNjaGVtZXMgaGF2ZSB0byBleHRlbmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVRzc1V0aWxzPEtleVNoYXJlPiBleHRlbmRzIE1wY1V0aWxzIGltcGxlbWVudHMgSVRzc1V0aWxzPEtleVNoYXJlPiB7XG4gIHByaXZhdGUgX3dhbGxldD86IElXYWxsZXQ7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgYmFzZUNvaW46IElCYXNlQ29pbiwgd2FsbGV0PzogSVdhbGxldCkge1xuICAgIHN1cGVyKGJpdGdvLCBiYXNlQ29pbik7XG4gICAgdGhpcy5fd2FsbGV0ID0gd2FsbGV0O1xuICB9XG5cbiAgZ2V0IHdhbGxldCgpOiBJV2FsbGV0IHtcbiAgICBpZiAoXy5pc05pbCh0aGlzLl93YWxsZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0O1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQml0Z29IZWxkQmFja3VwS2V5U2hhcmUoXG4gICAgdXNlckdwZ0tleTogU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICBlbnRlcnByaXNlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogUHJvbWlzZTxCaXRnb0hlbGRCYWNrdXBLZXlTaGFyZT4ge1xuICAgIGNvbnN0IGtleVJlc3BvbnNlID0gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy9rcnMvYmFja3Vwa2V5cycpKVxuICAgICAgLnNlbmQoe1xuICAgICAgICBlbnRlcnByaXNlLFxuICAgICAgICB1c2VyR1BHUHVibGljS2V5OiB1c2VyR3BnS2V5LnB1YmxpY0tleSxcbiAgICAgIH0pXG4gICAgICAucmVzdWx0KCk7XG4gICAgaWYgKCFrZXlSZXNwb25zZSB8fCAha2V5UmVzcG9uc2Uua2V5U2hhcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYmFja3VwIHNoYXJlcyBmcm9tIEJpdEdvLicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGtleVJlc3BvbnNlLmlkLFxuICAgICAga2V5U2hhcmVzOiBrZXlSZXNwb25zZS5rZXlTaGFyZXMsXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBmaW5hbGl6ZUJpdGdvSGVsZEJhY2t1cEtleVNoYXJlKFxuICAgIGtleUlkOiBzdHJpbmcsXG4gICAgY29tbW9uS2V5Y2hhaW46IHN0cmluZyxcbiAgICB1c2VyS2V5U2hhcmU6IEtleVNoYXJlLFxuICAgIGJpdGdvS2V5Y2hhaW46IEtleWNoYWluLFxuICAgIHVzZXJHcGdLZXk6IFNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgYmFja3VwR3BnS2V5OiBLZXlcbiAgKTogUHJvbWlzZTxCaXRnb0hlbGRCYWNrdXBLZXlTaGFyZT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGNyZWF0ZVVzZXJLZXljaGFpbihwYXJhbXM6IENyZWF0ZUtleWNoYWluUGFyYW1zQmFzZSk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBjcmVhdGVCYWNrdXBLZXljaGFpbihwYXJhbXM6IENyZWF0ZUtleWNoYWluUGFyYW1zQmFzZSk6IFByb21pc2U8S2V5Y2hhaW4+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBjcmVhdGVCaXRnb0tleWNoYWluKHBhcmFtczogQ3JlYXRlQml0R29LZXljaGFpblBhcmFtc0Jhc2UpOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgY3JlYXRlS2V5Y2hhaW5zKHBhcmFtczoge1xuICAgIHBhc3NwaHJhc2U6IHN0cmluZztcbiAgICBlbnRlcnByaXNlPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZT86IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpc1RoaXJkUGFydHlCYWNrdXA/OiBib29sZWFuO1xuICAgIGJhY2t1cFByb3ZpZGVyPzogQmFja3VwUHJvdmlkZXI7XG4gIH0pOiBQcm9taXNlPEtleWNoYWluc1RyaXBsZXQ+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBzaWduVHhSZXF1ZXN0KHBhcmFtczogVFNTUGFyYW1zKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBzaWduVHhSZXF1ZXN0Rm9yTWVzc2FnZShwYXJhbXM6IFRTU1BhcmFtcyk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIGEgdHJhbnNhY3Rpb24gdXNpbmcgVFNTIGZvciBFZERTQSBhbmQgdGhyb3VnaCB1dGlsaXphdGlvbiBvZiBjdXN0b20gc2hhcmUgZ2VuZXJhdG9yc1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFR4UmVxdWVzdH0gdHhSZXF1ZXN0IC0gdHJhbnNhY3Rpb24gcmVxdWVzdCB3aXRoIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7Q3VzdG9tUlNoYXJlR2VuZXJhdGluZ0Z1bmN0aW9ufSBleHRlcm5hbFNpZ25lclJTaGFyZUdlbmVyYXRvciBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBSIHNoYXJlcyBpbiB0aGUgRWREU0EgVFNTIGZsb3dcbiAgICogQHBhcmFtIHtDdXN0b21HU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb259IGV4dGVybmFsU2lnbmVyR1NoYXJlR2VuZXJhdG9yIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIEcgc2hhcmVzIGluIHRoZSBFZERTQSBUU1MgZmxvd1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fSAtIGEgc2lnbmVkIHR4IHJlcXVlc3RcbiAgICovXG4gIHNpZ25FZGRzYVRzc1VzaW5nRXh0ZXJuYWxTaWduZXIoXG4gICAgdHhSZXF1ZXN0OiBzdHJpbmcgfCBUeFJlcXVlc3QsXG4gICAgZXh0ZXJuYWxTaWduZXJDb21taXRtZW50R2VuZXJhdG9yOiBDdXN0b21Db21taXRtZW50R2VuZXJhdGluZ0Z1bmN0aW9uLFxuICAgIGV4dGVybmFsU2lnbmVyUlNoYXJlR2VuZXJhdG9yOiBDdXN0b21SU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gICAgZXh0ZXJuYWxTaWduZXJHU2hhcmVHZW5lcmF0b3I6IEN1c3RvbUdTaGFyZUdlbmVyYXRpbmdGdW5jdGlvblxuICApOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBhIHRyYW5zYWN0aW9uIHVzaW5nIFRTUyBmb3IgRUNEU0EgYW5kIHRocm91Z2ggdXRpbGl6YXRpb24gb2YgY3VzdG9tIHNoYXJlIGdlbmVyYXRvcnNcbiAgICpcbiAgICogQHBhcmFtIHtwYXJhbXM6IFRTU1BhcmFtcyB8IFRTU1BhcmFtc0Zvck1lc3NhZ2V9IHBhcmFtcyAtIHBhcmFtcyBvYmplY3QgdGhhdCByZXByZXNlbnRzIHBhcmFtZXRlcnMgdG8gc2lnbiBhIHRyYW5zYWN0aW9uIG9yIGEgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtSZXF1ZXN0VHlwZX0gcmVxdWVzdFR5cGUgLSB0aGUgdHlwZSBvZiB0aGUgcmVxdWVzdCB0byBzaWduICh0cmFuc2FjdGlvbiBvciBtZXNzYWdlKS5cbiAgICogQHBhcmFtIHtDdXN0b21QYWlsbGllck1vZHVsdXNHZXR0ZXJGdW5jdGlvbn0gZXh0ZXJuYWxTaWduZXJQYWlsbGllck1vZHVsdXNHZXR0ZXIgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgUGFpbGxpZXIgTW9kdWx1cyBzaGFyZXMgaW4gdGhlIEVDRFNBIFRTUyBmbG93LlxuICAgKiBAcGFyYW0ge0N1c3RvbUtTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbn0gZXh0ZXJuYWxTaWduZXJLU2hhcmVHZW5lcmF0b3IgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgSyBzaGFyZXMgaW4gdGhlIEVDRFNBIFRTUyBmbG93LlxuICAgKiBAcGFyYW0ge0N1c3RvbU11RGVsdGFTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbn0gZXh0ZXJuYWxTaWduZXJNdURlbHRhU2hhcmVHZW5lcmF0b3IgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgTXUgYW5kIERlbHRhIHNoYXJlcyBpbiB0aGUgRUNEU0EgVFNTIGZsb3cuXG4gICAqIEBwYXJhbSB7Q3VzdG9tU1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9ufSBleHRlcm5hbFNpZ25lclNTaGFyZUdlbmVyYXRvciBhIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBTIHNoYXJlcyBpbiB0aGUgRUNEU0EgVFNTIGZsb3cuXG4gICAqL1xuICBzaWduRWNkc2FUc3NVc2luZ0V4dGVybmFsU2lnbmVyKFxuICAgIHBhcmFtczogVFNTUGFyYW1zIHwgVFNTUGFyYW1zRm9yTWVzc2FnZSxcbiAgICByZXF1ZXN0VHlwZTogUmVxdWVzdFR5cGUsXG4gICAgZXh0ZXJuYWxTaWduZXJQYWlsbGllck1vZHVsdXNHZXR0ZXI6IEN1c3RvbVBhaWxsaWVyTW9kdWx1c0dldHRlckZ1bmN0aW9uLFxuICAgIGV4dGVybmFsU2lnbmVyS1NoYXJlR2VuZXJhdG9yOiBDdXN0b21LU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gICAgZXh0ZXJuYWxTaWduZXJNdURlbHRhU2hhcmVHZW5lcmF0b3I6IEN1c3RvbU11RGVsdGFTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgICBleHRlcm5hbFNpZ25lclNTaGFyZUdlbmVyYXRvcjogQ3VzdG9tU1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBDb21taXRtZW50IChVc2VyIHRvIEJpdEdvKSBzaGFyZSBmcm9tIGFuIHVuc2lnbmVkIHRyYW5zYWN0aW9uIGFuZCBwcml2YXRlIHVzZXIgc2lnbmluZyBtYXRlcmlhbFxuICAgKiBFRERTQSBvbmx5XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBwYXJhbXMgb2JqZWN0XG4gICAqIEBwYXJhbSB7VHhSZXF1ZXN0fSBwYXJhbXMudHhSZXF1ZXN0IC0gdHJhbnNhY3Rpb24gcmVxdWVzdCB3aXRoIHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucHJ2IC0gdXNlciBzaWduaW5nIG1hdGVyaWFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSAtIHdhbGxldCBwYXNzcGhyYXNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgdXNlclRvQml0Z29Db21taXRtZW50OiBDb21taXRtZW50U2hhcmVSZWNvciwgZW5jcnlwdGVkU2lnbmVyU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkIH0+fSAtIENvbW1pdG1lbnQgU2hhcmUgYW5kIHRoZSBFbmNyeXB0ZWQgU2lnbmVyIFNoYXJlIHRvIEJpdEdvXG4gICAqL1xuICBjcmVhdGVDb21taXRtZW50U2hhcmVGcm9tVHhSZXF1ZXN0KHBhcmFtczogeyB0eFJlcXVlc3Q6IFR4UmVxdWVzdDsgcHJ2OiBzdHJpbmc7IHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZyB9KTogUHJvbWlzZTx7XG4gICAgdXNlclRvQml0Z29Db21taXRtZW50OiBDb21taXRtZW50U2hhcmVSZWNvcmQ7XG4gICAgZW5jcnlwdGVkU2lnbmVyU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkO1xuICAgIGVuY3J5cHRlZFVzZXJUb0JpdGdvUlNoYXJlOiBFbmNyeXB0ZWRTaWduZXJTaGFyZVJlY29yZDtcbiAgfT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gUiAoVXNlciB0byBCaXRHbykgc2hhcmUgZnJvbSBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiBhbmQgcHJpdmF0ZSB1c2VyIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtcyBvYmplY3RcbiAgICogQHBhcmFtIHtUeFJlcXVlc3R9IHBhcmFtcy50eFJlcXVlc3QgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IHdpdGggdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcnYgLSB1c2VyIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMud2FsbGV0UGFzc3BocmFzZV0gLSB3YWxsZXQgcGFzc3BocmFzZVxuICAgKiBAcGFyYW0ge0VuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkfSBbcGFyYW1zLmVuY3J5cHRlZFVzZXJUb0JpdGdvUlNoYXJlXSAtIGVuY3J5cHRlZCB1c2VyIHRvIGJpdGdvIFIgc2hhcmUgZ2VuZXJhdGVkIGluIHRoZSBjb21taXRtZW50IHBoYXNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgclNoYXJlOiBTaWduU2hhcmUgfT59IC0gUiBTaGFyZSB0byBCaXRHb1xuICAgKi9cbiAgY3JlYXRlUlNoYXJlRnJvbVR4UmVxdWVzdChwYXJhbXM6IHtcbiAgICB0eFJlcXVlc3Q6IFR4UmVxdWVzdDtcbiAgICB3YWxsZXRQYXNzcGhyYXNlOiBzdHJpbmc7XG4gICAgZW5jcnlwdGVkVXNlclRvQml0Z29SU2hhcmU6IEVuY3J5cHRlZFNpZ25lclNoYXJlUmVjb3JkO1xuICB9KTogUHJvbWlzZTx7IHJTaGFyZTogU2lnblNoYXJlIH0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRyAoVXNlciB0byBCaXRHbykgc2hhcmUgZnJvbSBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvbiBhbmQgcHJpdmF0ZSB1c2VyIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIHBhcmFtcyBvYmplY3RcbiAgICogQHBhcmFtIHtUeFJlcXVlc3R9IHBhcmFtcy50eFJlcXVlc3QgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IHdpdGggdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcnYgLSB1c2VyIHNpZ25pbmcgbWF0ZXJpYWxcbiAgICogQHBhcmFtIHtTaWduYXR1cmVTaGFyZVJlY29yZH0gcGFyYW1zLmJpdGdvVG9Vc2VyUlNoYXJlIC0gQml0R28gdG8gVXNlciBSIFNoYXJlXG4gICAqIEBwYXJhbSB7U2lnblNoYXJlfSBwYXJhbXMudXNlclRvQml0Z29SU2hhcmUgLSBVc2VyIHRvIEJpdEdvIFIgU2hhcmVcbiAgICogQHBhcmFtIHtDb21taXRtZW50U2hhcmVSZWNvcmR9IHBhcmFtcy5iaXRnb1RvVXNlckNvbW1pdG1lbnQgLSBCaXRHbyB0byBVc2VyIENvbW1pdG1lbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8R1NoYXJlPn0gLSBHU2hhcmUgZnJvbSBVc2VyIHRvIEJpdEdvXG4gICAqL1xuICBjcmVhdGVHU2hhcmVGcm9tVHhSZXF1ZXN0KHBhcmFtczoge1xuICAgIHR4UmVxdWVzdDogVHhSZXF1ZXN0O1xuICAgIHBydjogc3RyaW5nO1xuICAgIGJpdGdvVG9Vc2VyUlNoYXJlOiBTaWduYXR1cmVTaGFyZVJlY29yZDtcbiAgICB1c2VyVG9CaXRnb1JTaGFyZTogU2lnblNoYXJlO1xuICAgIGJpdGdvVG9Vc2VyQ29tbWl0bWVudDogQ29tbWl0bWVudFNoYXJlUmVjb3JkO1xuICB9KTogUHJvbWlzZTxHU2hhcmU+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgdHggcmVxdWVzdCBmcm9tIHBhcmFtcyBhbmQgdmVyaWZ5IGl0XG4gICAqXG4gICAqIEBwYXJhbSB7UHJlYnVpbGRUcmFuc2FjdGlvbldpdGhJbnRlbnRPcHRpb25zfSBwYXJhbXMgLSBwYXJhbWV0ZXJzIHRvIGJ1aWxkIHRoZSB0eFxuICAgKiBAcGFyYW0ge1R4UmVxdWVzdFZlcnNpb259IGFwaVZlcnNpb24gbGl0ZSBvciBmdWxsXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlldyBib29sZWFuIGluZGljYXRpbmcgaWYgdGhpcyBpcyB0byBwcmV2aWV3IGEgdHggcmVxdWVzdCwgd2hpY2ggd2lsbCBub3QgaW5pdGlhdGUgcG9saWN5IGNoZWNrcyBvciBwZW5kaW5nIGFwcHJvdmFsc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fSAtIGEgYnVpbHQgdHggcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgcHJlYnVpbGRUeFdpdGhJbnRlbnQoXG4gICAgcGFyYW1zOiBQcmVidWlsZFRyYW5zYWN0aW9uV2l0aEludGVudE9wdGlvbnMsXG4gICAgYXBpVmVyc2lvbjogVHhSZXF1ZXN0VmVyc2lvbiA9ICdsaXRlJyxcbiAgICBwcmV2aWV3PzogYm9vbGVhblxuICApOiBQcm9taXNlPFR4UmVxdWVzdD4ge1xuICAgIGNvbnN0IGludGVudE9wdGlvbnMgPSB0aGlzLnBvcHVsYXRlSW50ZW50KHRoaXMuYmFzZUNvaW4sIHBhcmFtcyk7XG5cbiAgICBjb25zdCB3aGl0ZWxpc3RlZFBhcmFtcyA9IHtcbiAgICAgIGludGVudDoge1xuICAgICAgICAuLi5pbnRlbnRPcHRpb25zLFxuICAgICAgfSxcbiAgICAgIGFwaVZlcnNpb246IGFwaVZlcnNpb24sXG4gICAgICBwcmV2aWV3LFxuICAgIH07XG5cbiAgICBjb25zdCB1bnNpZ25lZFR4ID0gKGF3YWl0IHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYml0Z28udXJsKCcvd2FsbGV0LycgKyB0aGlzLndhbGxldC5pZCgpICsgJy90eHJlcXVlc3RzJywgMikpXG4gICAgICAuc2VuZCh3aGl0ZWxpc3RlZFBhcmFtcylcbiAgICAgIC5yZXN1bHQoKSkgYXMgVHhSZXF1ZXN0O1xuXG4gICAgcmV0dXJuIHVuc2lnbmVkVHg7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdHggcmVxdWVzdCBmcm9tIHBhcmFtcyBmb3IgbWVzc2FnZSBzaWduaW5nXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGFwaVZlcnNpb25cbiAgICogQHBhcmFtIHByZXZpZXdcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVR4UmVxdWVzdFdpdGhJbnRlbnRGb3JNZXNzYWdlU2lnbmluZyhcbiAgICBwYXJhbXM6IEludGVudE9wdGlvbnNGb3JNZXNzYWdlLFxuICAgIGFwaVZlcnNpb246IFR4UmVxdWVzdFZlcnNpb24gPSAnZnVsbCcsXG4gICAgcHJldmlldz86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICBjb25zdCBpbnRlbnRPcHRpb25zOiBQb3B1bGF0ZWRJbnRlbnRGb3JNZXNzYWdlU2lnbmluZyA9IHtcbiAgICAgIGN1c3RvZGlhbk1lc3NhZ2VJZDogcGFyYW1zLmN1c3RvZGlhbk1lc3NhZ2VJZCxcbiAgICAgIGludGVudFR5cGU6IHBhcmFtcy5pbnRlbnRUeXBlLFxuICAgICAgc2VxdWVuY2VJZDogcGFyYW1zLnNlcXVlbmNlSWQsXG4gICAgICBjb21tZW50OiBwYXJhbXMuY29tbWVudCxcbiAgICAgIG1lbW86IHBhcmFtcy5tZW1vPy52YWx1ZSxcbiAgICAgIGlzVHNzOiBwYXJhbXMuaXNUc3MsXG4gICAgICBtZXNzYWdlUmF3OiBwYXJhbXMubWVzc2FnZVJhdyxcbiAgICAgIG1lc3NhZ2VFbmNvZGVkOiBwYXJhbXMubWVzc2FnZUVuY29kZWQgPz8gJycsXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVR4UmVxdWVzdEJhc2UoaW50ZW50T3B0aW9ucywgYXBpVmVyc2lvbiwgcHJldmlldyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgdHggcmVxdWVzdCBmcm9tIHBhcmFtcyBmb3IgdHlwZSBkYXRhIHNpZ25pbmdcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gYXBpVmVyc2lvblxuICAgKiBAcGFyYW0gcHJldmlld1xuICAgKi9cbiAgYXN5bmMgY3JlYXRlVHhSZXF1ZXN0V2l0aEludGVudEZvclR5cGVkRGF0YVNpZ25pbmcoXG4gICAgcGFyYW1zOiBJbnRlbnRPcHRpb25zRm9yVHlwZWREYXRhLFxuICAgIGFwaVZlcnNpb246IFR4UmVxdWVzdFZlcnNpb24gPSAnZnVsbCcsXG4gICAgcHJldmlldz86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICBjb25zdCBpbnRlbnRPcHRpb25zOiBQb3B1bGF0ZWRJbnRlbnRGb3JUeXBlZERhdGFTaWduaW5nID0ge1xuICAgICAgY3VzdG9kaWFuTWVzc2FnZUlkOiBwYXJhbXMuY3VzdG9kaWFuTWVzc2FnZUlkLFxuICAgICAgaW50ZW50VHlwZTogcGFyYW1zLmludGVudFR5cGUsXG4gICAgICBzZXF1ZW5jZUlkOiBwYXJhbXMuc2VxdWVuY2VJZCxcbiAgICAgIGNvbW1lbnQ6IHBhcmFtcy5jb21tZW50LFxuICAgICAgbWVtbzogcGFyYW1zLm1lbW8/LnZhbHVlLFxuICAgICAgaXNUc3M6IHBhcmFtcy5pc1RzcyxcbiAgICAgIG1lc3NhZ2VSYXc6IHBhcmFtcy50eXBlZERhdGFSYXcsXG4gICAgICBtZXNzYWdlRW5jb2RlZDogcGFyYW1zLnR5cGVkRGF0YUVuY29kZWQgPz8gJycsXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVR4UmVxdWVzdEJhc2UoaW50ZW50T3B0aW9ucywgYXBpVmVyc2lvbiwgcHJldmlldyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgQml0Z28gQVBJIHRvIGNyZWF0ZSB0eCByZXF1ZXN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVUeFJlcXVlc3RCYXNlKFxuICAgIGludGVudE9wdGlvbnM6IFBvcHVsYXRlZEludGVudEZvclR5cGVkRGF0YVNpZ25pbmcgfCBQb3B1bGF0ZWRJbnRlbnRGb3JNZXNzYWdlU2lnbmluZyxcbiAgICBhcGlWZXJzaW9uOiBUeFJlcXVlc3RWZXJzaW9uLFxuICAgIHByZXZpZXc/OiBib29sZWFuXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgY29uc3Qgd2hpdGVsaXN0ZWRQYXJhbXMgPSB7XG4gICAgICBpbnRlbnQ6IHtcbiAgICAgICAgLi4uaW50ZW50T3B0aW9ucyxcbiAgICAgIH0sXG4gICAgICBhcGlWZXJzaW9uLFxuICAgICAgcHJldmlldyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuYml0Z29cbiAgICAgIC5wb3N0KHRoaXMuYml0Z28udXJsKGAvd2FsbGV0LyR7dGhpcy53YWxsZXQuaWQoKX0vdHhyZXF1ZXN0c2AsIDIpKVxuICAgICAgLnNlbmQod2hpdGVsaXN0ZWRQYXJhbXMpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBkZWxldGUgc2lnbmF0dXJlIHNoYXJlcyBmb3IgYSB0eFJlcXVlc3QsIHRoZSBlbmRwb2ludCBkZWxldGUgdGhlIHNpZ25hdHVyZXMgYW5kIHJldHVybiB0aGVtXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eFJlcXVlc3RJZCB0eCBpZCByZWZlcmVuY2UgdG8gZGVsZXRlIHNpZ25hdHVyZSBzaGFyZXNcbiAgICogQHJldHVybnMge1NpZ25hdHVyZVNoYXJlUmVjb3JkW119XG4gICAqL1xuICBhc3luYyBkZWxldGVTaWduYXR1cmVTaGFyZXModHhSZXF1ZXN0SWQ6IHN0cmluZyk6IFByb21pc2U8U2lnbmF0dXJlU2hhcmVSZWNvcmRbXT4ge1xuICAgIHJldHVybiB0aGlzLmJpdGdvXG4gICAgICAuZGVsKHRoaXMuYml0Z28udXJsKGAvd2FsbGV0LyR7dGhpcy53YWxsZXQuaWQoKX0vdHhyZXF1ZXN0cy8ke3R4UmVxdWVzdElkfS9zaWduYXR1cmVzaGFyZXNgLCAyKSlcbiAgICAgIC5zZW5kKClcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzZW5kIHByb2NlZHVyZSBvbmNlIEJpdGdvIGhhcyB0aGUgVXNlciBUbyBCaXRnbyBHU2hhcmVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR4UmVxdWVzdElkIC0gdGhlIHR4UmVxdWVzdCBJZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgYXN5bmMgc2VuZFR4UmVxdWVzdCh0eFJlcXVlc3RJZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5iaXRnb1xuICAgICAgLnBvc3QodGhpcy5iYXNlQ29pbi51cmwoJy93YWxsZXQvJyArIHRoaXMud2FsbGV0LmlkKCkgKyAnL3R4L3NlbmQnKSlcbiAgICAgIC5zZW5kKHsgdHhSZXF1ZXN0SWQgfSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgc2lnbmF0dXJlIHNoYXJlcywgZ2V0IHRoZSB0eCByZXF1ZXN0IHdpdGhvdXQgdGhlbSBmcm9tIHRoZSBkYiBhbmQgc2lnbiBpdCB0byBmaW5hbGx5IHNlbmQgaXQuXG4gICAqXG4gICAqIE5vdGUgOiBUaGlzIGNhbiBiZSBwZXJmb3JtZWQgaW4gb3JkZXIgdG8gcmVhY2ggbGF0ZXN0IG5ldHdvcmsgY29uZGl0aW9ucyByZXF1aXJlZCBvbiBwZW5kaW5nIGFwcHJvdmFsIGZsb3cuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eFJlcXVlc3RJZCAtIHRoZSB0eFJlcXVlc3QgSWQgdG8gbWFrZSB0aGUgcmVxdWVzdHMuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkZWNyeXB0ZWRQcnYgLSBkZWNyeXB0ZWQgcHJ2IHRvIHNpZ24gdGhlIHR4IHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7UmVxdWVzdFRyYWNlcn0gcmVxSWQgaWQgdHJhY2VyLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgKi9cbiAgYXN5bmMgcmVjcmVhdGVUeFJlcXVlc3QodHhSZXF1ZXN0SWQ6IHN0cmluZywgZGVjcnlwdGVkUHJ2OiBzdHJpbmcsIHJlcUlkOiBJUmVxdWVzdFRyYWNlcik6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgYXdhaXQgdGhpcy5kZWxldGVTaWduYXR1cmVTaGFyZXModHhSZXF1ZXN0SWQpO1xuICAgIC8vIGFmdGVyIGRlbGV0ZSBzaWduYXR1cmVzIHNoYXJlcyBnZXQgdGhlIHR4IHdpdGhvdXQgdGhlbVxuICAgIGNvbnN0IHR4UmVxdWVzdCA9IGF3YWl0IGdldFR4UmVxdWVzdCh0aGlzLmJpdGdvLCB0aGlzLndhbGxldC5pZCgpLCB0eFJlcXVlc3RJZCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnblR4UmVxdWVzdCh7IHR4UmVxdWVzdCwgcHJ2OiBkZWNyeXB0ZWRQcnYsIHJlcUlkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxhdGVzdCBUeCBSZXF1ZXN0IGJ5IGlkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eFJlcXVlc3RJZCAtIHRoZSB0eFJlcXVlc3QgSWRcbiAgICogQHJldHVybnMge1Byb21pc2U8VHhSZXF1ZXN0Pn1cbiAgICovXG4gIGFzeW5jIGdldFR4UmVxdWVzdCh0eFJlcXVlc3RJZDogc3RyaW5nKTogUHJvbWlzZTxUeFJlcXVlc3Q+IHtcbiAgICByZXR1cm4gZ2V0VHhSZXF1ZXN0KHRoaXMuYml0Z28sIHRoaXMud2FsbGV0LmlkKCksIHR4UmVxdWVzdElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdGhpcmQgcGFydHkgYmFja3VwIHByb3ZpZGVyIGlzIHZhbGlkL3N1cHBvcnRlZFxuICAgKiBAcGFyYW0gYmFja3VwUHJvdmlkZXIgLSB0aGUgYmFja3VwIHByb3ZpZGVyIGNsaWVudCBzZWxlY3RlZFxuICAgKi9cbiAgaXNWYWxpZFRoaXJkUGFydHlCYWNrdXBQcm92aWRlcihcbiAgICBiYWNrdXBQcm92aWRlcjogQmFja3VwUHJvdmlkZXIgfCBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogYmFja3VwUHJvdmlkZXIgaXMgQmFja3VwUHJvdmlkZXIge1xuICAgIC8vIEFzIG9mIG5vdywgQml0R28gaXMgdGhlIG9ubHkgc3VwcG9ydGVkIEtSUyBwcm92aWRlciBmb3IgVFNTXG4gICAgcmV0dXJuICEhKGJhY2t1cFByb3ZpZGVyICYmIGJhY2t1cFByb3ZpZGVyID09PSAnQml0R29UcnVzdEFzS3JzJyk7XG4gIH1cblxuICAvKipcbiAgICogSXQgZ2V0cyB0aGUgYXBwcm9wcmlhdGUgQml0R28gR1BHIHB1YmxpYyBrZXkgZm9yIGtleSBjcmVhdGlvbiBiYXNlZCBvbiBhXG4gICAqIGNvbWJpbmF0aW9uIG9mIGNvaW4gYW5kIHRoZSBmZWF0dXJlIGZsYWdzIG9uIHRoZSB1c2VyIGFuZCB0aGVpciBlbnRlcnByaXNlIGlmIHNldC5cbiAgICogQHBhcmFtIGVudGVycHJpc2VJZCAtIGVudGVycHJpc2UgdW5kZXIgd2hpY2ggdXNlciB3YW50cyB0byBjcmVhdGUgdGhlIHdhbGxldFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGdldEJpdGdvR3BnUHVia2V5QmFzZWRPbkZlYXR1cmVGbGFncyhlbnRlcnByaXNlSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCk6IFByb21pc2U8S2V5PiB7XG4gICAgY29uc3QgcmVzcG9uc2U6IEJpdGdvR1BHUHVibGljS2V5ID0gYXdhaXQgdGhpcy5iaXRnb1xuICAgICAgLmdldCh0aGlzLmJhc2VDb2luLnVybCgnL3Rzcy9wdWJrZXknKSlcbiAgICAgIC5xdWVyeSh7IGVudGVycHJpc2VJZCB9KVxuICAgICAgLnJlc3VsdCgpO1xuICAgIGNvbnN0IGJpdGdvUHVibGljS2V5U3RyID0gcmVzcG9uc2UucHVibGljS2V5IGFzIHN0cmluZztcbiAgICByZXR1cm4gcmVhZEtleSh7IGFybW9yZWRLZXk6IGJpdGdvUHVibGljS2V5U3RyIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3VwcG9ydGVkIFR4UmVxdWVzdCB2ZXJzaW9ucyBmb3IgdGhpcyB3YWxsZXRcbiAgICovXG4gIHB1YmxpYyBzdXBwb3J0ZWRUeFJlcXVlc3RWZXJzaW9ucygpOiBUeFJlcXVlc3RWZXJzaW9uW10ge1xuICAgIGNvbnN0IHdhbGxldFR5cGUgPSB0aGlzLl93YWxsZXQ/LnR5cGUoKTtcbiAgICBjb25zdCBzdXBwb3J0ZWRXYWxsZXRUeXBlcyA9IFsnY3VzdG9kaWFsJywgJ2NvbGQnLCAnaG90J107XG4gICAgaWYgKCF3YWxsZXRUeXBlIHx8IHRoaXMuX3dhbGxldD8ubXVsdGlzaWdUeXBlKCkgIT09ICd0c3MnIHx8ICFzdXBwb3J0ZWRXYWxsZXRUeXBlcy5pbmNsdWRlcyh3YWxsZXRUeXBlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fd2FsbGV0Py5iYXNlQ29pbi5nZXRNUENBbGdvcml0aG0oKSA9PT0gJ2VjZHNhJykge1xuICAgICAgcmV0dXJuIFsnZnVsbCddO1xuICAgIH0gZWxzZSBpZiAod2FsbGV0VHlwZSA9PT0gJ2N1c3RvZGlhbCcgfHwgd2FsbGV0VHlwZSA9PT0gJ2NvbGQnKSB7XG4gICAgICByZXR1cm4gWydmdWxsJ107XG4gICAgfSBlbHNlIGlmICh0aGlzLl93YWxsZXQ/LmJhc2VDb2luLmdldE1QQ0FsZ29yaXRobSgpID09PSAnZWRkc2EnICYmIHdhbGxldFR5cGUgPT09ICdob3QnKSB7XG4gICAgICByZXR1cm4gWydsaXRlJywgJ2Z1bGwnXTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHhSZXF1ZXN0IGlzIHVzaW5nIGFwaVZlcnNpb24gPT0gZnVsbCBhbmQgaXMgcGVuZGluZyBhcHByb3ZhbFxuICAgKiBAcGFyYW0gdHhSZXF1ZXN0XG4gICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICovXG4gIGlzUGVuZGluZ0FwcHJvdmFsVHhSZXF1ZXN0RnVsbCh0eFJlcXVlc3Q6IFR4UmVxdWVzdCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHsgYXBpVmVyc2lvbiwgc3RhdGUgfSA9IHR4UmVxdWVzdDtcbiAgICByZXR1cm4gYXBpVmVyc2lvbiA9PT0gJ2Z1bGwnICYmICdwZW5kaW5nQXBwcm92YWwnID09PSBzdGF0ZTtcbiAgfVxufVxuIl19