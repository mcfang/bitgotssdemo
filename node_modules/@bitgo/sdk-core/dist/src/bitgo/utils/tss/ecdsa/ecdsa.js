"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EcdsaUtils = void 0;
const assert_1 = __importDefault(require("assert"));
const buffer_1 = require("buffer");
const openpgp = __importStar(require("openpgp"));
const elliptic_1 = require("elliptic");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const tss_1 = require("../../../../account-lib/mpc/tss");
const ecdsa_1 = __importDefault(require("../../../tss/ecdsa"));
const baseTSSUtils_1 = __importDefault(require("../baseTSSUtils"));
const baseTypes_1 = require("../baseTypes");
const tss_2 = require("../../../tss");
const types_1 = require("../../../tss/ecdsa/types");
const opengpgUtils_1 = require("../../opengpgUtils");
const ecdsa_2 = require("../../../tss/ecdsa/ecdsa");
const ecdh_1 = require("../../../ecdh");
const common_1 = require("../../../tss/common");
const types_2 = require("../../../tss/types");
const encryptNShare = ecdsa_1.default.encryptNShare;
/** @inheritdoc */
class EcdsaUtils extends baseTSSUtils_1.default {
    constructor(bitgo, baseCoin, wallet) {
        super(bitgo, baseCoin, wallet);
        // We do not have full support for 3-party verification (w/ external source) of key shares and signature shares. There is no 3rd party key service support with this release.
        this.bitgoPublicGpgKey = undefined;
        this.setBitgoGpgPubKey(bitgo);
    }
    async setBitgoGpgPubKey(bitgo) {
        this.bitgoPublicGpgKey = await opengpgUtils_1.getBitgoGpgPubKey(bitgo);
    }
    async getBitgoPublicGpgKey() {
        if (!this.bitgoPublicGpgKey) {
            // retry getting bitgo's gpg key
            await this.setBitgoGpgPubKey(this.bitgo);
            if (!this.bitgoPublicGpgKey) {
                throw new Error("Failed to get Bitgo's gpg key");
            }
        }
        return this.bitgoPublicGpgKey;
    }
    /**
     * Gets the common public key from commonKeychain.
     *
     * @param {String} commonKeychain common key chain between n parties
     * @returns {string} encoded public key
     */
    static getPublicKeyFromCommonKeychain(commonKeychain) {
        if (commonKeychain.length !== 130) {
            throw new Error(`Invalid commonKeychain length, expected 130, got ${commonKeychain.length}`);
        }
        const commonPubHexStr = commonKeychain.slice(0, 66);
        return commonPubHexStr;
    }
    async finalizeBitgoHeldBackupKeyShare(keyId, commonKeychain, userKeyShare, bitgoKeychain, userGpgKey, thirdPartyBackupPublicGpgKey) {
        var _a;
        const encryptedUserToBackupShare = await encryptNShare(userKeyShare, 2, thirdPartyBackupPublicGpgKey.armor(), userGpgKey);
        const bitgoToBackupKeyShare = (_a = bitgoKeychain.keyShares) === null || _a === void 0 ? void 0 : _a.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'backup');
        const userPublicShare = buffer_1.Buffer.concat([
            buffer_1.Buffer.from(userKeyShare.nShares[2].y, 'hex'),
            buffer_1.Buffer.from(userKeyShare.nShares[2].chaincode, 'hex'),
        ]).toString('hex');
        assert_1.default(bitgoToBackupKeyShare);
        const keyResponse = await this.bitgo
            .put(this.baseCoin.url(`/krs/backupkeys/${keyId}`))
            .send({
            commonKeychain,
            keyShares: [
                {
                    from: 'user',
                    to: 'backup',
                    publicShare: userPublicShare,
                    privateShare: encryptedUserToBackupShare.encryptedPrivateShare,
                    privateShareProof: encryptedUserToBackupShare.privateShareProof,
                    vssProof: encryptedUserToBackupShare.vssProof,
                },
                bitgoToBackupKeyShare,
            ],
        })
            .result();
        if (!keyResponse || !keyResponse.commonKeychain) {
            throw new Error('Failed backup key verification.');
        }
        return {
            id: keyResponse.id,
            keyShares: keyResponse.keyShares,
            commonKeychain: keyResponse.commonKeychain,
        };
    }
    /** @inheritdoc */
    async createKeychains(params) {
        var _a;
        const MPC = new tss_1.Ecdsa();
        const m = 2;
        const n = 3;
        const userKeyShare = await MPC.keyShare(1, m, n);
        const userGpgKey = await opengpgUtils_1.generateGPGKeyPair('secp256k1');
        const isThirdPartyBackup = this.isValidThirdPartyBackupProvider(params.backupProvider);
        const backupKeyShare = await this.createBackupKeyShares(isThirdPartyBackup, userGpgKey, params.enterprise);
        const backupGpgKey = await this.getBackupGpgPubKey(isThirdPartyBackup);
        // Get the BitGo public key based on user/enterprise feature flags
        // If it doesn't work, use the default public key from the constants
        const bitgoPublicGpgKey = (_a = (await this.getBitgoGpgPubkeyBasedOnFeatureFlags(params.enterprise))) !== null && _a !== void 0 ? _a : this.bitgoPublicGpgKey;
        const bitgoKeychain = await this.createBitgoKeychain({
            userGpgKey,
            backupGpgKey,
            bitgoPublicGpgKey,
            userKeyShare,
            backupKeyShare,
            enterprise: params.enterprise,
            isThirdPartyBackup,
        });
        const userKeychainPromise = this.createUserKeychain({
            userGpgKey,
            backupGpgKey,
            bitgoPublicGpgKey,
            userKeyShare,
            backupKeyShare,
            bitgoKeychain,
            passphrase: params.passphrase,
            originalPasscodeEncryptionCode: params.originalPasscodeEncryptionCode,
            isThirdPartyBackup,
        });
        const backupKeychainPromise = this.createBackupKeychain({
            userGpgKey,
            backupGpgKey,
            bitgoPublicGpgKey,
            userKeyShare,
            backupKeyShare,
            bitgoKeychain,
            passphrase: params.passphrase,
            backupProvider: params.backupProvider,
        });
        const [userKeychain, backupKeychain] = await Promise.all([userKeychainPromise, backupKeychainPromise]);
        return {
            userKeychain,
            backupKeychain,
            bitgoKeychain,
        };
    }
    /**
     * If a third party backup is requested, it will create backup shares from
     * a third party (BitGo as of now), otherwise the key shares will be client generated
     */
    async createBackupKeyShares(isThirdPartyBackup = false, userGpgPubKey, enterprise) {
        let backupKeyShare;
        if (isThirdPartyBackup) {
            const bitgoHeldBackupKeyShares = await this.createBitgoHeldBackupKeyShare(userGpgPubKey, enterprise);
            backupKeyShare = {
                bitGoHeldKeyShares: bitgoHeldBackupKeyShares,
            };
        }
        else {
            const MPC = new tss_1.Ecdsa();
            const m = 2;
            const n = 3;
            backupKeyShare = {
                userHeldKeyShare: await MPC.keyShare(2, m, n),
            };
        }
        return backupKeyShare;
    }
    /**
     * Gets backup pub gpg key string
     * if a third party provided then get from trust
     * @param isThirdPartyBackup
     */
    async getBackupGpgPubKey(isThirdPartyBackup = false) {
        return isThirdPartyBackup ? opengpgUtils_1.getTrustGpgPubKey(this.bitgo) : opengpgUtils_1.generateGPGKeyPair('secp256k1');
    }
    createUserKeychain({ userGpgKey, backupGpgKey, bitgoPublicGpgKey, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode, isThirdPartyBackup = false, }) {
        var _a;
        if (!passphrase) {
            throw new Error('Please provide a wallet passphrase');
        }
        if (isThirdPartyBackup && ((_a = backupKeyShare.bitGoHeldKeyShares) === null || _a === void 0 ? void 0 : _a.keyShares)) {
            return this.createUserKeychainFromThirdPartyBackup(userGpgKey, bitgoPublicGpgKey, backupGpgKey, userKeyShare, backupKeyShare.bitGoHeldKeyShares.keyShares, bitgoKeychain, passphrase, originalPasscodeEncryptionCode);
        }
        assert_1.default(backupKeyShare.userHeldKeyShare);
        return this.createParticipantKeychain(userGpgKey, backupGpgKey, bitgoPublicGpgKey, 1, userKeyShare, backupKeyShare.userHeldKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode);
    }
    async createBackupKeychain({ userGpgKey, userKeyShare, backupGpgKey, backupKeyShare, bitgoKeychain, bitgoPublicGpgKey, passphrase, backupProvider, }) {
        var _a;
        if (this.isValidThirdPartyBackupProvider(backupProvider) && ((_a = backupKeyShare.bitGoHeldKeyShares) === null || _a === void 0 ? void 0 : _a.keyShares)) {
            assert_1.default(bitgoKeychain.commonKeychain);
            const finalizedBackupKeyShare = await this.finalizeBitgoHeldBackupKeyShare(backupKeyShare.bitGoHeldKeyShares.id, bitgoKeychain.commonKeychain, userKeyShare, bitgoKeychain, userGpgKey, backupGpgKey);
            if (finalizedBackupKeyShare.commonKeychain !== bitgoKeychain.commonKeychain) {
                throw new Error('Failed to create backup keychain - commonKeychains do not match');
            }
            const backupKeyParams = {
                source: 'backup',
                keyType: 'tss',
                commonKeychain: finalizedBackupKeyShare.commonKeychain,
                provider: backupProvider !== null && backupProvider !== void 0 ? backupProvider : 'BitGoTrustAsKrs',
            };
            const backupKeychain = await this.baseCoin.keychains().createBackup(backupKeyParams);
            backupKeychain.keyShares = finalizedBackupKeyShare.keyShares;
            return backupKeychain;
        }
        assert_1.default(backupKeyShare.userHeldKeyShare);
        assert_1.default(passphrase);
        return this.createParticipantKeychain(userGpgKey, backupGpgKey, bitgoPublicGpgKey, 2, userKeyShare, backupKeyShare.userHeldKeyShare, bitgoKeychain, passphrase);
    }
    /** @inheritdoc */
    async createBitgoKeychain({ userGpgKey, backupGpgKey, userKeyShare, backupKeyShare, enterprise, bitgoPublicGpgKey, isThirdPartyBackup = false, }) {
        const recipientIndex = 3;
        const userToBitgoShare = await encryptNShare(userKeyShare, recipientIndex, bitgoPublicGpgKey.armor(), userGpgKey);
        const backupToBitgoShare = await this.getBackupEncryptedNShare(backupKeyShare, recipientIndex, bitgoPublicGpgKey.armor(), backupGpgKey, isThirdPartyBackup);
        const createBitGoMPCParams = {
            keyType: 'tss',
            source: 'bitgo',
            keyShares: [
                {
                    from: 'user',
                    to: 'bitgo',
                    publicShare: userToBitgoShare.publicShare,
                    privateShare: userToBitgoShare.encryptedPrivateShare,
                    n: userToBitgoShare.n,
                    vssProof: userToBitgoShare.vssProof,
                    privateShareProof: userToBitgoShare.privateShareProof,
                },
                {
                    from: 'backup',
                    to: 'bitgo',
                    publicShare: backupToBitgoShare.publicShare,
                    privateShare: backupToBitgoShare.encryptedPrivateShare,
                    n: backupToBitgoShare.n,
                    vssProof: backupToBitgoShare.vssProof,
                    privateShareProof: backupToBitgoShare.privateShareProof,
                },
            ],
            userGPGPublicKey: userGpgKey.publicKey,
            backupGPGPublicKey: isThirdPartyBackup
                ? backupGpgKey.armor()
                : backupGpgKey.publicKey,
            enterprise: enterprise,
            algoUsed: 'ecdsa',
        };
        return await this.baseCoin.keychains().add(createBitGoMPCParams);
    }
    /**
     * This builds the relevant backup encryptedNShare based on whether the
     * backup key is user or third party generated
     * @param backupShare can either have key shares from the user or third party
     * @param recipientIndex index of the party receiving the backup shares
     * @param recipientGpgPublicArmor gpg armor of the party receiving the backup shares
     * @param backupGpgKey backup gpg key
     * @param isThirdPartyBackup whether the backup is generated by third party
     */
    async getBackupEncryptedNShare(backupShare, recipientIndex, recipientGpgPublicArmor, backupGpgKey, isThirdPartyBackup = false) {
        let backupToRecipientShare;
        if (isThirdPartyBackup) {
            if (!backupShare.bitGoHeldKeyShares) {
                throw new Error(`Missing third party backup key shares`);
            }
            const backupToRecipientApiShare = backupShare.bitGoHeldKeyShares.keyShares.find((keyShare) => keyShare.from === 'backup' && keyShare.to === ecdsa_2.getParticipantFromIndex(recipientIndex));
            if (!backupToRecipientApiShare) {
                throw new Error(`Missing backup to ${ecdsa_2.getParticipantFromIndex(recipientIndex)} key share`);
            }
            // Since backup is from a third party, it is already encrypted
            backupToRecipientShare = await ecdsa_2.buildNShareFromAPIKeyShare(backupToRecipientApiShare);
        }
        else {
            assert_1.default(backupShare.userHeldKeyShare);
            backupToRecipientShare = await encryptNShare(backupShare.userHeldKeyShare, recipientIndex, recipientGpgPublicArmor, backupGpgKey);
        }
        return backupToRecipientShare;
    }
    /**
     * This uses the backup key from a third party (bitgo in this case)
     * to create the user keychain via WP.
     */
    async createUserKeychainFromThirdPartyBackup(userGpgKey, bitgoPublicGpgKey, thirdPartyBackupPublicGpgKey, userKeyShare, thirdPartybackupKeyShares, bitgoKeychain, passphrase, originalPasscodeEncryptionCode) {
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Missing BitGo key shares');
        }
        if (!bitgoKeychain.commonKeychain) {
            throw new Error(`Missing common key chain: ${bitgoKeychain.commonKeychain}`);
        }
        const bitGoToUserShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === 'user');
        if (!bitGoToUserShare) {
            throw new Error('Missing BitGo to User key share');
        }
        const backupToUserShare = thirdPartybackupKeyShares.find((keyShare) => keyShare.from === 'backup' && keyShare.to === 'user');
        if (!backupToUserShare) {
            throw new Error('Missing Backup to User key share');
        }
        const backupToUserNShare = await ecdsa_2.buildNShareFromAPIKeyShare(backupToUserShare);
        const bitGoToUserNShare = await ecdsa_2.buildNShareFromAPIKeyShare(bitGoToUserShare);
        const encryptedNShares = [
            {
                nShare: backupToUserNShare,
                recipientPrivateArmor: userGpgKey.privateKey,
                senderPublicArmor: thirdPartyBackupPublicGpgKey.armor(),
                isbs58Encoded: false,
            },
            {
                nShare: bitGoToUserNShare,
                recipientPrivateArmor: userGpgKey.privateKey,
                senderPublicArmor: bitgoPublicGpgKey.armor(),
                isbs58Encoded: false,
            },
        ];
        const userCombinedKey = await ecdsa_1.default.createCombinedKey(userKeyShare, encryptedNShares, bitgoKeychain.commonKeychain);
        if (userCombinedKey.commonKeychain !== bitgoKeychain.commonKeychain) {
            throw new Error('Failed to create user keychain - commonKeychains do not match.');
        }
        const prv = JSON.stringify(userCombinedKey.signingMaterial);
        const userKeychainParams = {
            source: 'user',
            keyType: 'tss',
            commonKeychain: userCombinedKey.commonKeychain,
            prv: prv,
            encryptedPrv: this.bitgo.encrypt({
                input: prv,
                password: passphrase,
            }),
            originalPasscodeEncryptionCode,
        };
        const keychains = this.baseCoin.keychains();
        return await keychains.add(userKeychainParams);
    }
    /** @inheritdoc */
    async createParticipantKeychain(userGpgKey, userLocalBackupGpgKey, bitgoPublicGpgKey, recipientIndex, userKeyShare, backupKeyShare, bitgoKeychain, passphrase, originalPasscodeEncryptionCode) {
        const bitgoKeyShares = bitgoKeychain.keyShares;
        if (!bitgoKeyShares) {
            throw new Error('Missing BitGo key shares');
        }
        if (!bitgoKeychain.commonKeychain) {
            throw new Error(`Missing common key chain: ${bitgoKeychain.commonKeychain}`);
        }
        let recipient;
        let keyShare;
        let otherShare;
        let recipientGpgKey;
        let senderGpgKey;
        if (recipientIndex === 1) {
            keyShare = userKeyShare;
            otherShare = backupKeyShare;
            recipient = 'user';
            recipientGpgKey = userGpgKey;
            senderGpgKey = userLocalBackupGpgKey;
        }
        else if (recipientIndex === 2) {
            keyShare = backupKeyShare;
            otherShare = userKeyShare;
            recipient = 'backup';
            recipientGpgKey = userLocalBackupGpgKey;
            senderGpgKey = userGpgKey;
        }
        else {
            throw new Error('Invalid user index');
        }
        const bitGoToRecipientShare = bitgoKeyShares.find((keyShare) => keyShare.from === 'bitgo' && keyShare.to === recipient);
        if (!bitGoToRecipientShare) {
            throw new Error(`Missing BitGo to ${recipient} key share`);
        }
        const decryptedShare = await this.decryptPrivateShare(bitGoToRecipientShare.privateShare, recipientGpgKey);
        await this.verifyWalletSignatures(userGpgKey.publicKey, userLocalBackupGpgKey.publicKey, bitgoKeychain, decryptedShare, recipientIndex);
        const senderToRecipientShare = await encryptNShare(otherShare, recipientIndex, recipientGpgKey.publicKey, senderGpgKey);
        const encryptedNShares = [
            {
                // userToBackup or backupToUser
                nShare: senderToRecipientShare,
                recipientPrivateArmor: recipientGpgKey.privateKey,
                senderPublicArmor: senderGpgKey.publicKey,
            },
            {
                // bitgoToRecipient
                nShare: {
                    i: recipientIndex,
                    j: 3,
                    publicShare: bitGoToRecipientShare.publicShare,
                    encryptedPrivateShare: bitGoToRecipientShare.privateShare,
                    n: bitGoToRecipientShare.n,
                    vssProof: bitGoToRecipientShare.vssProof,
                    privateShareProof: bitGoToRecipientShare.privateShareProof,
                },
                recipientPrivateArmor: recipientGpgKey.privateKey,
                senderPublicArmor: bitgoPublicGpgKey.armor(),
                isbs58Encoded: false,
            },
        ];
        const recipientCombinedKey = await ecdsa_1.default.createCombinedKey(keyShare, encryptedNShares, bitgoKeychain.commonKeychain);
        const prv = JSON.stringify(recipientCombinedKey.signingMaterial);
        const recipientKeychainParams = {
            source: recipient,
            keyType: 'tss',
            commonKeychain: bitgoKeychain.commonKeychain,
            prv: prv,
            encryptedPrv: this.bitgo.encrypt({
                input: prv,
                password: passphrase,
            }),
            originalPasscodeEncryptionCode,
        };
        const keychains = this.baseCoin.keychains();
        return recipientIndex === 1
            ? await keychains.add(recipientKeychainParams)
            : await keychains.createBackup(recipientKeychainParams);
    }
    async createTssEcdsaStep1SigningMaterial(params) {
        const { challenges, derivationPath, prv } = params;
        const userSigningMaterial = JSON.parse(prv);
        if (userSigningMaterial.pShare.i !== 1) {
            throw new Error('Invalid user key');
        }
        if (!userSigningMaterial.backupNShare) {
            throw new Error('Invalid user key - missing backupNShare');
        }
        const MPC = new tss_1.Ecdsa();
        const signingKey = MPC.keyDerive(userSigningMaterial.pShare, [userSigningMaterial.bitgoNShare, userSigningMaterial.backupNShare], derivationPath);
        const bitgoIndex = types_2.ShareKeyPosition.BITGO;
        const userIndex = userSigningMaterial.pShare.i;
        const { ntilde: ntildea, h1: h1a, h2: h2a, p: pa } = challenges.enterpriseChallenge;
        const { ntilde: ntildeb, h1: h1b, h2: h2b, p: pb, n: nb } = challenges.bitgoChallenge;
        const userXShare = MPC.appendChallenge(signingKey.xShare, { ntilde: ntildea, h1: h1a, h2: h2a }, { p: pa });
        const bitgoYShare = MPC.appendChallenge({
            i: userIndex,
            j: bitgoIndex,
            n: nb,
        }, { ntilde: ntildeb, h1: h1b, h2: h2b }, { p: pb });
        const userSignShare = await ecdsa_1.default.createUserSignShare(userXShare, bitgoYShare);
        const u = signingKey.nShares[bitgoIndex].u;
        let chaincode = userSigningMaterial.bitgoNShare.chaincode;
        while (chaincode.length < 64) {
            chaincode = '0' + chaincode;
        }
        const signerShare = utxo_lib_1.bip32.fromPrivateKey(buffer_1.Buffer.from(u, 'hex'), buffer_1.Buffer.from(chaincode, 'hex')).toBase58();
        const bitgoGpgKey = await opengpgUtils_1.getBitgoGpgPubKey(this.bitgo);
        const encryptedSignerShare = (await openpgp.encrypt({
            message: await openpgp.createMessage({
                text: signerShare,
            }),
            config: {
                rejectCurves: new Set(),
            },
            encryptionKeys: [bitgoGpgKey],
        }));
        const userGpgKey = await opengpgUtils_1.generateGPGKeyPair('secp256k1');
        const privateShareProof = await opengpgUtils_1.createShareProof(userGpgKey.privateKey, signingKey.nShares[bitgoIndex].u, 'ecdsa');
        const vssProof = signingKey.nShares[bitgoIndex].v;
        const userPublicGpgKey = userGpgKey.publicKey;
        const publicShare = signingKey.nShares[bitgoIndex].y + signingKey.nShares[bitgoIndex].chaincode;
        return {
            privateShareProof: privateShareProof,
            vssProof: vssProof,
            publicShare: publicShare,
            encryptedSignerOffsetShare: encryptedSignerShare,
            userPublicGpgKey: userPublicGpgKey,
            kShare: userSignShare.kShare,
            wShare: params.walletPassphrase
                ? this.bitgo.encrypt({ input: JSON.stringify(userSignShare.wShare), password: params.walletPassphrase })
                : userSignShare.wShare,
        };
    }
    async createTssEcdsaStep2SigningMaterial(params) {
        // Append the BitGo challenge to the Ashare to be used in subsequent proofs
        const bitgoToUserAShareWithNtilde = {
            ...params.aShareFromBitgo,
            ...params.bitgoChallenge,
        };
        const userGammaAndMuShares = await ecdsa_1.default.createUserGammaAndMuShare(params.wShare, bitgoToUserAShareWithNtilde);
        const userOmicronAndDeltaShare = await ecdsa_1.default.createUserOmicronAndDeltaShare(userGammaAndMuShares.gShare);
        return {
            muDShare: {
                muShare: userGammaAndMuShares.muShare,
                dShare: userOmicronAndDeltaShare.dShare,
                i: userGammaAndMuShares.muShare.i,
            },
            oShare: params.walletPassphrase
                ? this.bitgo.encrypt({
                    input: JSON.stringify(userOmicronAndDeltaShare.oShare),
                    password: params.walletPassphrase,
                })
                : userOmicronAndDeltaShare.oShare,
        };
    }
    getOfflineSignerPaillierModulus(params) {
        assert_1.default(params.prv, 'Params to get paillier modulus are missing prv.');
        const userSigningMaterial = JSON.parse(params.prv);
        return { userPaillierModulus: userSigningMaterial.pShare.n };
    }
    async createOfflineKShare(params) {
        const { tssParams, prv, requestType, challenges } = params;
        assert_1.default(typeof tssParams.txRequest !== 'string', 'Invalid txRequest type');
        const txRequest = tssParams.txRequest;
        let derivationPath;
        if (requestType === baseTypes_1.RequestType.tx) {
            assert_1.default(txRequest.transactions || txRequest.unsignedTxs, 'Unable to find transactions in txRequest');
            const unsignedTx = txRequest.apiVersion === 'full' ? txRequest.transactions[0].unsignedTx : txRequest.unsignedTxs[0];
            derivationPath = unsignedTx.derivationPath;
        }
        else if (requestType === baseTypes_1.RequestType.message) {
            // TODO BG-67299 Message signing with derivation path
            derivationPath = '';
        }
        return this.createTssEcdsaStep1SigningMaterial({
            prv: prv,
            challenges: challenges,
            derivationPath: derivationPath,
            walletPassphrase: params.walletPassphrase,
        });
    }
    async createOfflineMuDeltaShare(params) {
        const decryptedWShare = this.bitgo.decrypt({ input: params.encryptedWShare, password: params.walletPassphrase });
        return await this.createTssEcdsaStep2SigningMaterial({
            aShareFromBitgo: params.aShareFromBitgo,
            bitgoChallenge: params.bitgoChallenge,
            wShare: JSON.parse(decryptedWShare),
            walletPassphrase: params.walletPassphrase,
        });
    }
    async createOfflineSShare(params) {
        const { tssParams, requestType, dShareFromBitgo, encryptedOShare, walletPassphrase } = params;
        assert_1.default(typeof tssParams.txRequest !== 'string', 'Invalid txRequest type');
        const txRequest = tssParams.txRequest;
        let signablePayload;
        if (requestType === baseTypes_1.RequestType.tx) {
            assert_1.default(txRequest.transactions || txRequest.unsignedTxs, 'Unable to find transactions in txRequest');
            const unsignedTx = txRequest.apiVersion === 'full' ? txRequest.transactions[0].unsignedTx : txRequest.unsignedTxs[0];
            signablePayload = buffer_1.Buffer.from(unsignedTx.signableHex, 'hex');
        }
        else if (requestType === baseTypes_1.RequestType.message) {
            signablePayload = params.tssParams.bufferToSign;
        }
        const decryptedOShare = this.bitgo.decrypt({ input: encryptedOShare, password: walletPassphrase });
        const { i, R, s, y } = await ecdsa_1.default.createUserSignatureShare(JSON.parse(decryptedOShare), dShareFromBitgo, signablePayload);
        // return only required SShare without bigints from VAShare
        return {
            i,
            R,
            s,
            y,
        };
    }
    async signEcdsaTssUsingExternalSigner(params, requestType, externalSignerPaillierModulusGetter, externalSignerKShareGenerator, externalSignerMuDeltaShareGenerator, externalSignerSShareGenerator) {
        var _a;
        const { txRequest } = params;
        const pendingEcdsaTssInitialization = (_a = this.wallet.coinSpecific()) === null || _a === void 0 ? void 0 : _a.pendingEcdsaTssInitialization;
        if (pendingEcdsaTssInitialization) {
            throw new Error('Wallet is not ready for TSS ECDSA signing. Please contact your enterprise admin to finish the enterprise TSS initialization.');
        }
        const txRequestObj = await tss_2.getTxRequest(this.bitgo, this.wallet.id(), txRequest);
        const { userPaillierModulus } = await externalSignerPaillierModulusGetter({ txRequest: txRequestObj });
        const { enterpriseChallenge, bitgoChallenge } = await this.getEcdsaSigningChallenges(txRequest, requestType, userPaillierModulus, 0);
        const step1SigningMaterial = await externalSignerKShareGenerator({
            tssParams: {
                ...params,
                txRequest: txRequestObj,
            },
            challenges: { enterpriseChallenge, bitgoChallenge },
            requestType: requestType,
        });
        // signing stage one with K share send to bitgo and receives A share
        const bitgoToUserAShare = (await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequestObj.txRequestId, requestType, types_1.SendShareType.KShare, step1SigningMaterial.kShare, step1SigningMaterial.encryptedSignerOffsetShare, step1SigningMaterial.vssProof, step1SigningMaterial.privateShareProof, step1SigningMaterial.publicShare, step1SigningMaterial.userPublicGpgKey)); // WP/HSM does not return the initial challenge
        const step2Return = await externalSignerMuDeltaShareGenerator({
            txRequest: txRequestObj,
            aShareFromBitgo: bitgoToUserAShare,
            bitgoChallenge: bitgoChallenge,
            encryptedWShare: step1SigningMaterial.wShare,
        });
        // signing stage two with muShare and dShare send to bitgo and receives D share
        const bitgoToUserDShare = (await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequestObj.txRequestId, requestType, types_1.SendShareType.MUShare, step2Return.muDShare));
        const userSShare = await externalSignerSShareGenerator({
            tssParams: {
                ...params,
                txRequest: txRequestObj,
            },
            dShareFromBitgo: bitgoToUserDShare,
            requestType: requestType,
            encryptedOShare: step2Return.oShare,
        });
        // signing stage three with SShare send to bitgo and receives SShare
        await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequestObj.txRequestId, requestType, types_1.SendShareType.SShare, userSShare);
        return await tss_2.getTxRequest(this.bitgo, this.wallet.id(), txRequestObj.txRequestId);
    }
    /**
     * Gets signing key, txRequestResolved and txRequestId
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param { string} params.reqId - request id
     * @returns {Promise<TxRequest>}
     */
    async signRequestBase(params, requestType) {
        var _a;
        const pendingEcdsaTssInitialization = (_a = this.wallet.coinSpecific()) === null || _a === void 0 ? void 0 : _a.pendingEcdsaTssInitialization;
        if (pendingEcdsaTssInitialization) {
            throw new Error('Wallet is not ready for TSS ECDSA signing. Please contact your enterprise admin to finish the enterprise TSS initialization.');
        }
        const userSigningMaterial = JSON.parse(params.prv);
        if (userSigningMaterial.pShare.i !== 1) {
            throw new Error('Invalid user key');
        }
        if (!userSigningMaterial.backupNShare) {
            throw new Error('Invalid user key - missing backupNShare');
        }
        const txRequest = typeof params.txRequest === 'string'
            ? await tss_2.getTxRequest(this.bitgo, this.wallet.id(), params.txRequest)
            : params.txRequest;
        let signablePayload = new buffer_1.Buffer('');
        let derivationPath = '';
        if (requestType === baseTypes_1.RequestType.tx) {
            assert_1.default(txRequest.transactions || txRequest.unsignedTxs, 'Unable to find transactions in txRequest');
            const unsignedTx = txRequest.apiVersion === 'full' ? txRequest.transactions[0].unsignedTx : txRequest.unsignedTxs[0];
            signablePayload = buffer_1.Buffer.from(unsignedTx.signableHex, 'hex');
            derivationPath = unsignedTx.derivationPath;
        }
        else if (requestType === baseTypes_1.RequestType.message) {
            signablePayload = params.bufferToSign;
            // TODO BG-67299 Message signing with derivation path
        }
        const paillierModulus = this.getOfflineSignerPaillierModulus({ prv: params.prv });
        const challenges = await this.getEcdsaSigningChallenges(txRequest.txRequestId, requestType, paillierModulus.userPaillierModulus, 0);
        const step1Return = await this.createTssEcdsaStep1SigningMaterial({
            prv: params.prv,
            challenges: challenges,
            derivationPath: derivationPath,
        });
        // signing stage one with K share send to bitgo and receives A share
        const bitgoToUserAShare = (await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequest.txRequestId, requestType, types_1.SendShareType.KShare, step1Return.kShare, step1Return.encryptedSignerOffsetShare, step1Return.vssProof, step1Return.privateShareProof, step1Return.publicShare, step1Return.userPublicGpgKey)); // WP/HSM does not return the initial challenge
        const step2Return = await this.createTssEcdsaStep2SigningMaterial({
            aShareFromBitgo: bitgoToUserAShare,
            bitgoChallenge: challenges.bitgoChallenge,
            wShare: step1Return.wShare,
        });
        // signing stage two with muShare and dShare send to bitgo and receives D share
        const bitgoToUserDShare = (await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequest.txRequestId, requestType, types_1.SendShareType.MUShare, step2Return.muDShare));
        const userSShare = await ecdsa_1.default.createUserSignatureShare(step2Return.oShare, bitgoToUserDShare, signablePayload, params.hash);
        // signing stage three with SShare send to bitgo and receives SShare
        await ecdsa_1.default.sendShareToBitgo(this.bitgo, this.wallet.id(), txRequest.txRequestId, requestType, types_1.SendShareType.SShare, userSShare);
        return await tss_2.getTxRequest(this.bitgo, this.wallet.id(), txRequest.txRequestId);
    }
    /**
     * Signs the transaction associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    async signTxRequest(params) {
        return this.signRequestBase(params, baseTypes_1.RequestType.tx);
    }
    /**
     * Signs the message associated to the transaction request.
     * @param {string | TxRequest} params.txRequest - transaction request object or id
     * @param {string} params.prv - decrypted private key
     * @param {string} params.reqId - request id
     * @returns {Promise<TxRequest>} fully signed TxRequest object
     */
    async signTxRequestForMessage(params) {
        if (!params.messageRaw) {
            throw new Error('Raw message required to sign message');
        }
        return this.signRequestBase(params, baseTypes_1.RequestType.message);
    }
    /**
     * Get the challenge values for enterprise and BitGo in ECDSA signing
     * Only returns the challenges if they are verified by the user's enterprise admin's ecdh key
     * @param {string} txRequestId - transaction request id
     * @param {RequestType} requestType -  (0 for tx, 1 for message)
     * @param {string} walletPaillierModulus - paillier pubkey $n$
     * @param {number} index - index of the requestType
     */
    async getEcdsaSigningChallenges(txRequestId, requestType, walletPaillierModulus, index = 0) {
        const enterpriseId = this.wallet.toJSON().enterprise;
        if (!enterpriseId) {
            throw new Error('Wallet must be an enterprise wallet.');
        }
        // create BitGo range proof and paillier proof challenge
        const createBitgoChallengeResponse = await common_1.getTxRequestChallenge(this.bitgo, this.wallet.id(), txRequestId, index.toString(), requestType, walletPaillierModulus);
        const bitgoToEnterprisePaillierChallenge = { p: createBitgoChallengeResponse.p };
        const enterpriseToBitgoPaillierChallenge = sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({
            p: await sdk_lib_mpc_1.EcdsaPaillierProof.generateP(sdk_lib_mpc_1.hexToBigInt(createBitgoChallengeResponse.n)),
        });
        // TODO(BG-78764): once the paillier proofs are complete, reduce challenge creation to one API call
        const walletChallenges = await this.wallet.getChallengesForEcdsaSigning();
        const challengeVerifierUserId = walletChallenges.createdBy;
        const adminSigningKeyResponse = await this.bitgo.getSigningKeyForUser(enterpriseId, challengeVerifierUserId);
        const pubkeyOfAdminEcdhKeyHex = adminSigningKeyResponse.derivedPubkey;
        // Verify enterprise's challenge is signed by the respective admins ecdh keychain
        const enterpriseRawChallenge = {
            ntilde: walletChallenges.enterpriseChallenge.ntilde,
            h1: walletChallenges.enterpriseChallenge.h1,
            h2: walletChallenges.enterpriseChallenge.h2,
        };
        const adminSignatureOnEntChallenge = walletChallenges.enterpriseChallenge.verifiers.adminSignature;
        if (!ecdh_1.verifyEcdhSignature(EcdsaUtils.getMessageToSignFromChallenge(enterpriseRawChallenge), adminSignatureOnEntChallenge, buffer_1.Buffer.from(pubkeyOfAdminEcdhKeyHex, 'hex'))) {
            throw new Error(`Admin signature for enterprise challenge is not valid. Please contact your enterprise admin.`);
        }
        // Verify that the BitGo challenge's ZK proofs have been verified by the admin
        const bitgoChallenge = {
            ntilde: walletChallenges.bitgoChallenge.ntilde,
            h1: walletChallenges.bitgoChallenge.h1,
            h2: walletChallenges.bitgoChallenge.h2,
            p: bitgoToEnterprisePaillierChallenge.p,
            n: createBitgoChallengeResponse.n,
        };
        const adminVerificationSignatureForBitGoChallenge = walletChallenges.bitgoChallenge.verifiers.adminSignature;
        if (!ecdh_1.verifyEcdhSignature(EcdsaUtils.getMessageToSignFromChallenge(bitgoChallenge), adminVerificationSignatureForBitGoChallenge, buffer_1.Buffer.from(pubkeyOfAdminEcdhKeyHex, 'hex'))) {
            throw new Error(`Admin signature for BitGo's challenge is not valid. Please contact your enterprise admin.`);
        }
        return {
            enterpriseChallenge: {
                ...enterpriseRawChallenge,
                p: enterpriseToBitgoPaillierChallenge.p,
            },
            bitgoChallenge,
        };
    }
    /**
     * Verifies the u-value proofs and GPG keys used in generating a TSS ECDSA wallet.
     * @param userGpgPub The user's public GPG key for encryption between user/server
     * @param backupGpgPub The backup's public GPG key for encryption between backup/server
     * @param bitgoKeychain previously created BitGo keychain; must be compatible with user and backup key shares
     * @param decryptedShare The decrypted bitgo-to-user/backup private share retrieved from the keychain
     * @param verifierIndex The index of the party to verify: 1 = user, 2 = backup
     */
    async verifyWalletSignatures(userGpgPub, backupGpgPub, bitgoKeychain, decryptedShare, verifierIndex) {
        assert_1.default(bitgoKeychain.commonKeychain);
        assert_1.default(bitgoKeychain.walletHSMGPGPublicKeySigs);
        const bitgoGpgKey = await opengpgUtils_1.getBitgoGpgPubKey(this.bitgo);
        const userKeyPub = await openpgp.readKey({ armoredKey: userGpgPub });
        const userKeyId = userKeyPub.keyPacket.getFingerprint();
        const backupKeyPub = await openpgp.readKey({ armoredKey: backupGpgPub });
        const backupKeyId = backupKeyPub.keyPacket.getFingerprint();
        const walletSignatures = await openpgp.readKeys({ armoredKeys: bitgoKeychain.walletHSMGPGPublicKeySigs });
        if (walletSignatures.length !== 2) {
            throw new Error('Invalid wallet signatures');
        }
        if (userKeyId !== walletSignatures[0].keyPacket.getFingerprint()) {
            throw new Error(`first wallet signature's fingerprint does not match passed user gpg key's fingerprint`);
        }
        if (backupKeyId !== walletSignatures[1].keyPacket.getFingerprint()) {
            throw new Error(`second wallet signature's fingerprint does not match passed backup gpg key's fingerprint`);
        }
        await ecdsa_2.verifyWalletSignature({
            walletSignature: walletSignatures[0],
            commonKeychain: bitgoKeychain.commonKeychain,
            userKeyId,
            backupKeyId,
            bitgoPub: bitgoGpgKey,
            decryptedShare,
            verifierIndex,
        });
        await ecdsa_2.verifyWalletSignature({
            walletSignature: walletSignatures[1],
            commonKeychain: bitgoKeychain.commonKeychain,
            userKeyId,
            backupKeyId,
            bitgoPub: bitgoGpgKey,
            decryptedShare,
            verifierIndex,
        });
    }
    /**
     * Signs a challenge with the provided v1 ecdh key at a derived path
     * @param challenge challenge to sign
     * @param ecdhXprv xprv of the ecdh key
     * @param derivationPath the derived path at which the ecdh key will sign
     */
    static signChallenge(challenge, ecdhXprv, derivationPath) {
        const messageToSign = this.getMessageToSignFromChallenge(challenge);
        return ecdh_1.signMessageWithDerivedEcdhKey(messageToSign, ecdhXprv, derivationPath);
    }
    /**
     * Converts challenge to a common message format which can be signed.
     * @param challenge
     */
    static getMessageToSignFromChallenge(challenge) {
        return challenge.ntilde.concat(challenge.h1).concat(challenge.h2);
    }
    /**
     Verifies ZK proofs of BitGo's challenges for both nitro and institutional HSMs
     which are fetched from the WP API.
     */
    static async verifyBitGoChallenges(bitgoChallenges) {
        // Verify institutional hsm challenge proof
        const instChallengeVerified = await this.verifyBitGoChallenge({
            ntilde: bitgoChallenges.bitgoInstitutionalHsm.ntilde,
            h1: bitgoChallenges.bitgoInstitutionalHsm.h1,
            h2: bitgoChallenges.bitgoInstitutionalHsm.h2,
            ntildeProof: bitgoChallenges.bitgoInstitutionalHsm.ntildeProof,
        });
        // Verify nitro hsm challenge proof
        const nitroChallengeVerified = await this.verifyBitGoChallenge({
            ntilde: bitgoChallenges.bitgoNitroHsm.ntilde,
            h1: bitgoChallenges.bitgoNitroHsm.h1,
            h2: bitgoChallenges.bitgoNitroHsm.h2,
            ntildeProof: bitgoChallenges.bitgoNitroHsm.ntildeProof,
        });
        return instChallengeVerified && nitroChallengeVerified;
    }
    /**
     * Verifies ZK proof for a single BitGo challenge
     * @param bitgoChallenge
     */
    static async verifyBitGoChallenge(bitgoChallenge) {
        const deserializedInstChallenge = sdk_lib_mpc_1.EcdsaTypes.deserializeNtildeWithProofs(bitgoChallenge);
        const ntildeProofH1WrtH2Verified = await sdk_lib_mpc_1.EcdsaRangeProof.verifyNtildeProof({
            ntilde: deserializedInstChallenge.ntilde,
            h1: deserializedInstChallenge.h1,
            h2: deserializedInstChallenge.h2,
        }, deserializedInstChallenge.ntildeProof.h1WrtH2);
        const ntildeProofH2WrtH1Verified = await sdk_lib_mpc_1.EcdsaRangeProof.verifyNtildeProof({
            ntilde: deserializedInstChallenge.ntilde,
            h1: deserializedInstChallenge.h2,
            h2: deserializedInstChallenge.h1,
        }, deserializedInstChallenge.ntildeProof.h2WrtH1);
        return ntildeProofH1WrtH2Verified && ntildeProofH2WrtH1Verified;
    }
    /**
     * Gets the bitgo challenges for both nitro and institutional HSMs from WP API.
     * @param bitgo
     */
    static async getBitGoChallenges(bitgo) {
        const res = await bitgo.get(bitgo.url('/tss/ecdsa/challenges', 2)).send().result();
        if (!res.bitgoNitroHsm ||
            !res.bitgoNitroHsm.ntilde ||
            !res.bitgoNitroHsm.h1 ||
            !res.bitgoNitroHsm.h2 ||
            !res.bitgoNitroHsm.ntildeProof ||
            !res.bitgoInstitutionalHsm ||
            !res.bitgoInstitutionalHsm.ntilde ||
            !res.bitgoInstitutionalHsm.h1 ||
            !res.bitgoInstitutionalHsm.h2 ||
            !res.bitgoInstitutionalHsm.ntildeProof) {
            throw new Error('Expected BitGo challenge proof to be present. Contact support@bitgo.com.');
        }
        return res;
    }
    /**
     * Gets BitGo's proofs from API and signs them if the proofs are valid.
     * @param bitgo
     * @param enterpriseId
     * @param userPassword
     */
    static async getVerifyAndSignBitGoChallenges(bitgo, enterpriseId, userPassword) {
        // Fetch BitGo's challenge and verify
        const bitgoChallengesWithProofs = await EcdsaUtils.getBitGoChallenges(bitgo);
        if (!(await EcdsaUtils.verifyBitGoChallenges(bitgoChallengesWithProofs))) {
            throw new Error(`Failed to verify BitGo's challenge needed to enable ECDSA signing. Please contact support@bitgo.com`);
        }
        return await EcdsaUtils.signBitgoChallenges(bitgo, enterpriseId, userPassword, bitgoChallengesWithProofs);
    }
    /**
     * Sign Bitgo's proofs, verification of proofs is left to the caller
     * @param bitgo
     * @param enterpriseId
     * @param userPassword
     * @param bitgoChallengesWithProofs Optionally provide Bitgo Challaenge & Proofs instead of fetching from API
     */
    static async signBitgoChallenges(bitgo, enterpriseId, userPassword, bitgoChallengesWithProofs) {
        // fetch challenge & proof if none are provided
        const challengesWithProofs = bitgoChallengesWithProofs
            ? bitgoChallengesWithProofs
            : await EcdsaUtils.getBitGoChallenges(bitgo);
        // Fetch user's ecdh public keychain needed for signing the challenges
        const ecdhKeypair = await bitgo.getEcdhKeypairPrivate(userPassword, enterpriseId);
        const signedBitGoInstChallenge = EcdsaUtils.signChallenge(challengesWithProofs.bitgoInstitutionalHsm, ecdhKeypair.xprv, ecdhKeypair.derivationPath);
        const signedBitGoNitroChallenge = EcdsaUtils.signChallenge(challengesWithProofs.bitgoNitroHsm, ecdhKeypair.xprv, ecdhKeypair.derivationPath);
        return {
            bitgoInstHsmAdminSignature: signedBitGoInstChallenge,
            bitgoNitroHsmAdminSignature: signedBitGoNitroChallenge,
        };
    }
    /**
     * This is needed to enable ecdsa signing on the enterprise.
     * It receives the enterprise challenge and signatures of verified bitgo proofs
     * and uploads them on the enterprise.
     * @param bitgo
     * @param entId - enterprise id to enable ecdsa signing on
     * @param userPassword - enterprise admin's login pw
     * @param bitgoInstChallengeProofSignature - signature on bitgo's institutional HSM challenge after verification
     * @param bitgoNitroChallengeProofSignature - signature on bitgo's nitro HSM challenge after verification
     * @param challenge - optionally use the challenge for enterprise challenge
     */
    static async initiateChallengesForEnterprise(bitgo, entId, userPassword, bitgoInstChallengeProofSignature, bitgoNitroChallengeProofSignature, challenge) {
        // Fetch user's ecdh public keychain needed for signing the challenges
        const ecdhKeypair = await bitgo.getEcdhKeypairPrivate(userPassword, entId);
        // Generate and sign enterprise challenge
        const entChallengeWithProof = challenge !== null && challenge !== void 0 ? challenge : (await sdk_lib_mpc_1.EcdsaRangeProof.generateNtilde(sdk_lib_mpc_1.minModulusBitLength));
        const serializedEntChallengeWithProof = sdk_lib_mpc_1.EcdsaTypes.serializeNtildeWithProofs(entChallengeWithProof);
        const signedEnterpriseChallenge = EcdsaUtils.signChallenge(serializedEntChallengeWithProof, ecdhKeypair.xprv, ecdhKeypair.derivationPath);
        await this.uploadChallengesToEnterprise(bitgo, entId, serializedEntChallengeWithProof, signedEnterpriseChallenge.toString('hex'), bitgoInstChallengeProofSignature.toString('hex'), bitgoNitroChallengeProofSignature.toString('hex'));
    }
    /**
     * Uploads the signed challenges and their proofs on the enterprise.
     * This initiates ecdsa signing for the enterprise users.
     * @param bitgo
     * @param entId - enterprise to enable ecdsa signing on
     * @param entChallenge - client side generated ent challenge with ZK proofs
     * @param entChallengeSignature - signature on enterprise challenge
     * @param bitgoIntChallengeSignature - signature on BitGo's institutional HSM challenge
     * @param bitgoNitroChallengeSignature - signature on BitGo's nitro HSM challenge
     */
    static async uploadChallengesToEnterprise(bitgo, entId, entChallenge, entChallengeSignature, bitgoIntChallengeSignature, bitgoNitroChallengeSignature) {
        const body = {
            enterprise: {
                ntilde: entChallenge.ntilde,
                h1: entChallenge.h1,
                h2: entChallenge.h2,
                verifiers: {
                    adminSignature: entChallengeSignature,
                },
            },
            bitgoInstitutionalHsm: {
                verifiers: {
                    adminSignature: bitgoIntChallengeSignature,
                },
            },
            bitgoNitroHsm: {
                verifiers: {
                    adminSignature: bitgoNitroChallengeSignature,
                },
            },
        };
        if ('ntildeProof' in entChallenge) {
            body.enterprise['ntildeProof'] = entChallenge.ntildeProof;
        }
        await bitgo
            .put(bitgo.url(`/enterprise/${entId}/tssconfig/ecdsa/challenge`, 2))
            .send(body)
            .result();
    }
    /**
     * util function that checks that a commonKeychain is valid and can ultimately resolve to a valid public key
     * @param commonKeychain - a user uploaded commonKeychain string
     * @throws if the commonKeychain is invalid length or invalid format
     */
    static validateCommonKeychainPublicKey(commonKeychain) {
        const pub = EcdsaUtils.getPublicKeyFromCommonKeychain(commonKeychain);
        const secp256k1 = new elliptic_1.ec('secp256k1');
        const key = secp256k1.keyFromPublic(pub, 'hex');
        return key.getPublic().encode('hex', false).slice(2);
    }
}
exports.EcdsaUtils = EcdsaUtils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNkc2EuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvYml0Z28vdXRpbHMvdHNzL2VjZHNhL2VjZHNhLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvREFBNEI7QUFDNUIsbUNBQWdDO0FBRWhDLGlEQUFtQztBQUNuQyx1Q0FBOEI7QUFFOUIsb0RBQXVIO0FBQ3ZILDhDQUF3QztBQUV4Qyx5REFBK0Q7QUFFL0QsK0RBQW9FO0FBRXBFLG1FQUEyQztBQVMzQyw0Q0FZc0I7QUFDdEIsc0NBQTRDO0FBQzVDLG9EQUFrSDtBQUNsSCxxREFBZ0g7QUFHaEgsb0RBQXNIO0FBQ3RILHdDQUFtRjtBQUNuRixnREFBNEQ7QUFDNUQsOENBSzRCO0FBRTVCLE1BQU0sYUFBYSxHQUFHLGVBQVksQ0FBQyxhQUFhLENBQUM7QUFFakQsa0JBQWtCO0FBQ2xCLE1BQWEsVUFBVyxTQUFRLHNCQUFzQjtJQUlwRCxZQUFZLEtBQWdCLEVBQUUsUUFBbUIsRUFBRSxNQUFnQjtRQUNqRSxLQUFLLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUpqQyw2S0FBNks7UUFDckssc0JBQWlCLEdBQTRCLFNBQVMsQ0FBQztRQUk3RCxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVPLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLO1FBQ25DLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLGdDQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRCxLQUFLLENBQUMsb0JBQW9CO1FBQ3hCLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDM0IsZ0NBQWdDO1lBQ2hDLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN6QyxJQUFJLENBQUMs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QkFDckIsU0FBUyxFQUFFO29CQUNULGNBQWMsRUFBRSwwQkFBMEI7aUJBQzNDO2FBQ0Y7WUFDRCxhQUFhLEVBQUU7Z0JBQ2IsU0FBUyxFQUFFO29CQUNULGNBQWMsRUFBRSw0QkFBNEI7aUJBQzdDO2FBQ0Y7U0FDRixDQUFDO1FBQ0YsSUFBSSxhQUFhLElBQUksWUFBWSxFQUFFO1lBQ2pDLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQztTQUMzRDtRQUNELE1BQU0sS0FBSzthQUNSLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGVBQWUsS0FBSyw0QkFBNEIsRUFBRSxDQUFDLENBQUMsQ0FBQzthQUNuRSxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ1YsTUFBTSxFQUFFLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUVILE1BQU0sQ0FBQywrQkFBK0IsQ0FBQyxjQUFzQjtRQUMzRCxNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMsOEJBQThCLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDdEUsTUFBTSxTQUFTLEdBQUcsSUFBSSxhQUFFLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdEMsTUFBTSxHQUFHLEdBQUcsU0FBUyxDQUFDLGFBQWEsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDaEQsT0FBTyxHQUFHLENBQUMsU0FBUyxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkQsQ0FBQztDQUNGO0FBaDFDRCxnQ0FnMUNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IEtleSwgU2VyaWFsaXplZEtleVBhaXIgfSBmcm9tICdvcGVucGdwJztcbmltcG9ydCAqIGFzIG9wZW5wZ3AgZnJvbSAnb3BlbnBncCc7XG5pbXBvcnQgeyBlYyB9IGZyb20gJ2VsbGlwdGljJztcblxuaW1wb3J0IHsgRWNkc2FQYWlsbGllclByb29mLCBFY2RzYVJhbmdlUHJvb2YsIEVjZHNhVHlwZXMsIGhleFRvQmlnSW50LCBtaW5Nb2R1bHVzQml0TGVuZ3RoIH0gZnJvbSAnQGJpdGdvL3Nkay1saWItbXBjJztcbmltcG9ydCB7IGJpcDMyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcblxuaW1wb3J0IHsgRUNEU0EsIEVjZHNhIH0gZnJvbSAnLi4vLi4vLi4vLi4vYWNjb3VudC1saWIvbXBjL3Rzcyc7XG5pbXBvcnQgeyBBZGRLZXljaGFpbk9wdGlvbnMsIEFwaUtleVNoYXJlLCBDcmVhdGVCYWNrdXBPcHRpb25zLCBLZXljaGFpbiwgS2V5VHlwZSB9IGZyb20gJy4uLy4uLy4uL2tleWNoYWluJztcbmltcG9ydCBFQ0RTQU1ldGhvZHMsIHsgRUNEU0FNZXRob2RUeXBlcyB9IGZyb20gJy4uLy4uLy4uL3Rzcy9lY2RzYSc7XG5pbXBvcnQgeyBJQmFzZUNvaW4sIEtleWNoYWluc1RyaXBsZXQgfSBmcm9tICcuLi8uLi8uLi9iYXNlQ29pbic7XG5pbXBvcnQgYmFzZVRTU1V0aWxzIGZyb20gJy4uL2Jhc2VUU1NVdGlscyc7XG5pbXBvcnQge1xuICBCaXRHb1Byb29mU2lnbmF0dXJlcyxcbiAgQ3JlYXRlRWNkc2FCaXRHb0tleWNoYWluUGFyYW1zLFxuICBDcmVhdGVFY2RzYUtleWNoYWluUGFyYW1zLFxuICBEZWNyeXB0YWJsZU5TaGFyZSxcbiAgR2V0Qml0R29DaGFsbGVuZ2VzQXBpLFxuICBLZXlTaGFyZSxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBCYWNrdXBHcGdLZXksXG4gIEJhY2t1cEtleVNoYXJlLFxuICBCaXRnb0hlbGRCYWNrdXBLZXlTaGFyZSxcbiAgQ3VzdG9tS1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uLFxuICBDdXN0b21NdURlbHRhU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIEN1c3RvbVBhaWxsaWVyTW9kdWx1c0dldHRlckZ1bmN0aW9uLFxuICBDdXN0b21TU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gIFJlcXVlc3RUeXBlLFxuICBUU1NQYXJhbXMsXG4gIFRTU1BhcmFtc0Zvck1lc3NhZ2UsXG4gIFR4UmVxdWVzdCxcbn0gZnJvbSAnLi4vYmFzZVR5cGVzJztcbmltcG9ydCB7IGdldFR4UmVxdWVzdCB9IGZyb20gJy4uLy4uLy4uL3Rzcyc7XG5pbXBvcnQgeyBBU2hhcmUsIERTaGFyZSwgRW5jcnlwdGVkTlNoYXJlLCBPU2hhcmUsIFNlbmRTaGFyZVR5cGUsIFNTaGFyZSwgV1NoYXJlIH0gZnJvbSAnLi4vLi4vLi4vdHNzL2VjZHNhL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZVNoYXJlUHJvb2YsIGdlbmVyYXRlR1BHS2V5UGFpciwgZ2V0Qml0Z29HcGdQdWJLZXksIGdldFRydXN0R3BnUHViS2V5IH0gZnJvbSAnLi4vLi4vb3BlbmdwZ1V0aWxzJztcbmltcG9ydCB7IEJpdEdvQmFzZSB9IGZyb20gJy4uLy4uLy4uL2JpdGdvQmFzZSc7XG5pbXBvcnQgeyBCYWNrdXBQcm92aWRlciwgSVdhbGxldCB9IGZyb20gJy4uLy4uLy4uL3dhbGxldCc7XG5pbXBvcnQgeyBidWlsZE5TaGFyZUZyb21BUElLZXlTaGFyZSwgZ2V0UGFydGljaXBhbnRGcm9tSW5kZXgsIHZlcmlmeVdhbGxldFNpZ25hdHVyZSB9IGZyb20gJy4uLy4uLy4uL3Rzcy9lY2RzYS9lY2RzYSc7XG5pbXBvcnQgeyBzaWduTWVzc2FnZVdpdGhEZXJpdmVkRWNkaEtleSwgdmVyaWZ5RWNkaFNpZ25hdHVyZSB9IGZyb20gJy4uLy4uLy4uL2VjZGgnO1xuaW1wb3J0IHsgZ2V0VHhSZXF1ZXN0Q2hhbGxlbmdlIH0gZnJvbSAnLi4vLi4vLi4vdHNzL2NvbW1vbic7XG5pbXBvcnQge1xuICBTaGFyZUtleVBvc2l0aW9uLFxuICBUc3NFY2RzYVN0ZXAxUmV0dXJuTWVzc2FnZSxcbiAgVHNzRWNkc2FTdGVwMlJldHVybk1lc3NhZ2UsXG4gIFR4UmVxdWVzdENoYWxsZW5nZVJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi8uLi90c3MvdHlwZXMnO1xuXG5jb25zdCBlbmNyeXB0TlNoYXJlID0gRUNEU0FNZXRob2RzLmVuY3J5cHROU2hhcmU7XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuZXhwb3J0IGNsYXNzIEVjZHNhVXRpbHMgZXh0ZW5kcyBiYXNlVFNTVXRpbHM8S2V5U2hhcmU+IHtcbiAgLy8gV2UgZG8gbm90IGhhdmUgZnVsbCBzdXBwb3J0IGZvciAzLXBhcnR5IHZlcmlmaWNhdGlvbiAody8gZXh0ZXJuYWwgc291cmNlKSBvZiBrZXkgc2hhcmVzIGFuZCBzaWduYXR1cmUgc2hhcmVzLiBUaGVyZSBpcyBubyAzcmQgcGFydHkga2V5IHNlcnZpY2Ugc3VwcG9ydCB3aXRoIHRoaXMgcmVsZWFzZS5cbiAgcHJpdmF0ZSBiaXRnb1B1YmxpY0dwZ0tleTogb3BlbnBncC5LZXkgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgYmFzZUNvaW46IElCYXNlQ29pbiwgd2FsbGV0PzogSVdhbGxldCkge1xuICAgIHN1cGVyKGJpdGdvLCBiYXNlQ29pbiwgd2FsbGV0KTtcbiAgICB0aGlzLnNldEJpdGdvR3BnUHViS2V5KGJpdGdvKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2V0Qml0Z29HcGdQdWJLZXkoYml0Z28pIHtcbiAgICB0aGlzLmJpdGdvUHVibGljR3BnS2V5ID0gYXdhaXQgZ2V0Qml0Z29HcGdQdWJLZXkoYml0Z28pO1xuICB9XG5cbiAgYXN5bmMgZ2V0Qml0Z29QdWJsaWNHcGdLZXkoKTogUHJvbWlzZTxvcGVucGdwLktleT4ge1xuICAgIGlmICghdGhpcy5iaXRnb1B1YmxpY0dwZ0tleSkge1xuICAgICAgLy8gcmV0cnkgZ2V0dGluZyBiaXRnbydzIGdwZyBrZXlcbiAgICAgIGF3YWl0IHRoaXMuc2V0Qml0Z29HcGdQdWJLZXkodGhpcy5iaXRnbyk7XG4gICAgICBpZiAoIXRoaXMuYml0Z29QdWJsaWNHcGdLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBCaXRnbydzIGdwZyBrZXlcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYml0Z29QdWJsaWNHcGdLZXk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29tbW9uIHB1YmxpYyBrZXkgZnJvbSBjb21tb25LZXljaGFpbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1vbktleWNoYWluIGNvbW1vbiBrZXkgY2hhaW4gYmV0d2VlbiBuIHBhcnRpZXNcbiAgICogQHJldHVybnMge3N0cmluZ30gZW5jb2RlZCBwdWJsaWMga2V5XG4gICAqL1xuICBzdGF0aWMgZ2V0UHVibGljS2V5RnJvbUNvbW1vbktleWNoYWluKGNvbW1vbktleWNoYWluOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChjb21tb25LZXljaGFpbi5sZW5ndGggIT09IDEzMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbW1vbktleWNoYWluIGxlbmd0aCwgZXhwZWN0ZWQgMTMwLCBnb3QgJHtjb21tb25LZXljaGFpbi5sZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vblB1YkhleFN0ciA9IGNvbW1vbktleWNoYWluLnNsaWNlKDAsIDY2KTtcbiAgICByZXR1cm4gY29tbW9uUHViSGV4U3RyO1xuICB9XG5cbiAgYXN5bmMgZmluYWxpemVCaXRnb0hlbGRCYWNrdXBLZXlTaGFyZShcbiAgICBrZXlJZDogc3RyaW5nLFxuICAgIGNvbW1vbktleWNoYWluOiBzdHJpbmcsXG4gICAgdXNlcktleVNoYXJlOiBLZXlTaGFyZSxcbiAgICBiaXRnb0tleWNoYWluOiBLZXljaGFpbixcbiAgICB1c2VyR3BnS2V5OiBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgIHRoaXJkUGFydHlCYWNrdXBQdWJsaWNHcGdLZXk6IEtleVxuICApOiBQcm9taXNlPEJpdGdvSGVsZEJhY2t1cEtleVNoYXJlPiB7XG4gICAgY29uc3QgZW5jcnlwdGVkVXNlclRvQmFja3VwU2hhcmUgPSBhd2FpdCBlbmNyeXB0TlNoYXJlKFxuICAgICAgdXNlcktleVNoYXJlLFxuICAgICAgMixcbiAgICAgIHRoaXJkUGFydHlCYWNrdXBQdWJsaWNHcGdLZXkuYXJtb3IoKSxcbiAgICAgIHVzZXJHcGdLZXlcbiAgICApO1xuICAgIGNvbnN0IGJpdGdvVG9CYWNrdXBLZXlTaGFyZSA9IGJpdGdvS2V5Y2hhaW4ua2V5U2hhcmVzPy5maW5kKFxuICAgICAgKGtleVNoYXJlKSA9PiBrZXlTaGFyZS5mcm9tID09PSAnYml0Z28nICYmIGtleVNoYXJlLnRvID09PSAnYmFja3VwJ1xuICAgICk7XG4gICAgY29uc3QgdXNlclB1YmxpY1NoYXJlID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbSh1c2VyS2V5U2hhcmUublNoYXJlc1syXS55LCAnaGV4JyksXG4gICAgICBCdWZmZXIuZnJvbSh1c2VyS2V5U2hhcmUublNoYXJlc1syXS5jaGFpbmNvZGUsICdoZXgnKSxcbiAgICBdKS50b1N0cmluZygnaGV4Jyk7XG4gICAgYXNzZXJ0KGJpdGdvVG9CYWNrdXBLZXlTaGFyZSk7XG4gICAgY29uc3Qga2V5UmVzcG9uc2UgPSBhd2FpdCB0aGlzLmJpdGdvXG4gICAgICAucHV0KHRoaXMuYmFzZUNvaW4udXJsKGAva3JzL2JhY2t1cGtleXMvJHtrZXlJZH1gKSlcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgIGtleVNoYXJlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZyb206ICd1c2VyJyxcbiAgICAgICAgICAgIHRvOiAnYmFja3VwJyxcbiAgICAgICAgICAgIHB1YmxpY1NoYXJlOiB1c2VyUHVibGljU2hhcmUsXG4gICAgICAgICAgICBwcml2YXRlU2hhcmU6IGVuY3J5cHRlZFVzZXJUb0JhY2t1cFNoYXJlLmVuY3J5cHRlZFByaXZhdGVTaGFyZSxcbiAgICAgICAgICAgIHByaXZhdGVTaGFyZVByb29mOiBlbmNyeXB0ZWRVc2VyVG9CYWNrdXBTaGFyZS5wcml2YXRlU2hhcmVQcm9vZixcbiAgICAgICAgICAgIHZzc1Byb29mOiBlbmNyeXB0ZWRVc2VyVG9CYWNrdXBTaGFyZS52c3NQcm9vZixcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJpdGdvVG9CYWNrdXBLZXlTaGFyZSxcbiAgICAgICAgXSxcbiAgICAgIH0pXG4gICAgICAucmVzdWx0KCk7XG4gICAgaWYgKCFrZXlSZXNwb25zZSB8fCAha2V5UmVzcG9uc2UuY29tbW9uS2V5Y2hhaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIGJhY2t1cCBrZXkgdmVyaWZpY2F0aW9uLicpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGtleVJlc3BvbnNlLmlkLFxuICAgICAga2V5U2hhcmVzOiBrZXlSZXNwb25zZS5rZXlTaGFyZXMsXG4gICAgICBjb21tb25LZXljaGFpbjoga2V5UmVzcG9uc2UuY29tbW9uS2V5Y2hhaW4sXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBhc3luYyBjcmVhdGVLZXljaGFpbnMocGFyYW1zOiB7XG4gICAgcGFzc3BocmFzZTogc3RyaW5nO1xuICAgIGVudGVycHJpc2U/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGJhY2t1cFByb3ZpZGVyPzogQmFja3VwUHJvdmlkZXI7XG4gIH0pOiBQcm9taXNlPEtleWNoYWluc1RyaXBsZXQ+IHtcbiAgICBjb25zdCBNUEMgPSBuZXcgRWNkc2EoKTtcbiAgICBjb25zdCBtID0gMjtcbiAgICBjb25zdCBuID0gMztcblxuICAgIGNvbnN0IHVzZXJLZXlTaGFyZSA9IGF3YWl0IE1QQy5rZXlTaGFyZSgxLCBtLCBuKTtcbiAgICBjb25zdCB1c2VyR3BnS2V5ID0gYXdhaXQgZ2VuZXJhdGVHUEdLZXlQYWlyKCdzZWNwMjU2azEnKTtcbiAgICBjb25zdCBpc1RoaXJkUGFydHlCYWNrdXAgPSB0aGlzLmlzVmFsaWRUaGlyZFBhcnR5QmFja3VwUHJvdmlkZXIocGFyYW1zLmJhY2t1cFByb3ZpZGVyKTtcbiAgICBjb25zdCBiYWNrdXBLZXlTaGFyZSA9IGF3YWl0IHRoaXMuY3JlYXRlQmFja3VwS2V5U2hhcmVzKGlzVGhpcmRQYXJ0eUJhY2t1cCwgdXNlckdwZ0tleSwgcGFyYW1zLmVudGVycHJpc2UpO1xuICAgIGNvbnN0IGJhY2t1cEdwZ0tleSA9IGF3YWl0IHRoaXMuZ2V0QmFja3VwR3BnUHViS2V5KGlzVGhpcmRQYXJ0eUJhY2t1cCk7XG5cbiAgICAvLyBHZXQgdGhlIEJpdEdvIHB1YmxpYyBrZXkgYmFzZWQgb24gdXNlci9lbnRlcnByaXNlIGZlYXR1cmUgZmxhZ3NcbiAgICAvLyBJZiBpdCBkb2Vzbid0IHdvcmssIHVzZSB0aGUgZGVmYXVsdCBwdWJsaWMga2V5IGZyb20gdGhlIGNvbnN0YW50c1xuICAgIGNvbnN0IGJpdGdvUHVibGljR3BnS2V5ID1cbiAgICAgIChhd2FpdCB0aGlzLmdldEJpdGdvR3BnUHVia2V5QmFzZWRPbkZlYXR1cmVGbGFncyhwYXJhbXMuZW50ZXJwcmlzZSkpID8/IHRoaXMuYml0Z29QdWJsaWNHcGdLZXk7XG5cbiAgICBjb25zdCBiaXRnb0tleWNoYWluID0gYXdhaXQgdGhpcy5jcmVhdGVCaXRnb0tleWNoYWluKHtcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICBiYWNrdXBHcGdLZXksXG4gICAgICBiaXRnb1B1YmxpY0dwZ0tleSxcbiAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgIGJhY2t1cEtleVNoYXJlLFxuICAgICAgZW50ZXJwcmlzZTogcGFyYW1zLmVudGVycHJpc2UsXG4gICAgICBpc1RoaXJkUGFydHlCYWNrdXAsXG4gICAgfSk7XG4gICAgY29uc3QgdXNlcktleWNoYWluUHJvbWlzZSA9IHRoaXMuY3JlYXRlVXNlcktleWNoYWluKHtcbiAgICAgIHVzZXJHcGdLZXksXG4gICAgICBiYWNrdXBHcGdLZXksXG4gICAgICBiaXRnb1B1YmxpY0dwZ0tleSxcbiAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgIGJhY2t1cEtleVNoYXJlLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHBhc3NwaHJhc2U6IHBhcmFtcy5wYXNzcGhyYXNlLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlOiBwYXJhbXMub3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgICAgaXNUaGlyZFBhcnR5QmFja3VwLFxuICAgIH0pO1xuICAgIGNvbnN0IGJhY2t1cEtleWNoYWluUHJvbWlzZSA9IHRoaXMuY3JlYXRlQmFja3VwS2V5Y2hhaW4oe1xuICAgICAgdXNlckdwZ0tleSxcbiAgICAgIGJhY2t1cEdwZ0tleSxcbiAgICAgIGJpdGdvUHVibGljR3BnS2V5LFxuICAgICAgdXNlcktleVNoYXJlLFxuICAgICAgYmFja3VwS2V5U2hhcmUsXG4gICAgICBiaXRnb0tleWNoYWluLFxuICAgICAgcGFzc3BocmFzZTogcGFyYW1zLnBhc3NwaHJhc2UsXG4gICAgICBiYWNrdXBQcm92aWRlcjogcGFyYW1zLmJhY2t1cFByb3ZpZGVyLFxuICAgIH0pO1xuXG4gICAgY29uc3QgW3VzZXJLZXljaGFpbiwgYmFja3VwS2V5Y2hhaW5dID0gYXdhaXQgUHJvbWlzZS5hbGwoW3VzZXJLZXljaGFpblByb21pc2UsIGJhY2t1cEtleWNoYWluUHJvbWlzZV0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZXJLZXljaGFpbixcbiAgICAgIGJhY2t1cEtleWNoYWluLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgdGhpcmQgcGFydHkgYmFja3VwIGlzIHJlcXVlc3RlZCwgaXQgd2lsbCBjcmVhdGUgYmFja3VwIHNoYXJlcyBmcm9tXG4gICAqIGEgdGhpcmQgcGFydHkgKEJpdEdvIGFzIG9mIG5vdyksIG90aGVyd2lzZSB0aGUga2V5IHNoYXJlcyB3aWxsIGJlIGNsaWVudCBnZW5lcmF0ZWRcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUJhY2t1cEtleVNoYXJlcyhcbiAgICBpc1RoaXJkUGFydHlCYWNrdXAgPSBmYWxzZSxcbiAgICB1c2VyR3BnUHViS2V5OiBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgIGVudGVycHJpc2U6IHN0cmluZyB8IHVuZGVmaW5lZFxuICApOiBQcm9taXNlPEJhY2t1cEtleVNoYXJlPiB7XG4gICAgbGV0IGJhY2t1cEtleVNoYXJlOiBCYWNrdXBLZXlTaGFyZTtcbiAgICBpZiAoaXNUaGlyZFBhcnR5QmFja3VwKSB7XG4gICAgICBjb25zdCBiaXRnb0hlbGRCYWNrdXBLZXlTaGFyZXMgPSBhd2FpdCB0aGlzLmNyZWF0ZUJpdGdvSGVsZEJhY2t1cEtleVNoYXJlKHVzZXJHcGdQdWJLZXksIGVudGVycHJpc2UpO1xuICAgICAgYmFja3VwS2V5U2hhcmUgPSB7XG4gICAgICAgIGJpdEdvSGVsZEtleVNoYXJlczogYml0Z29IZWxkQmFja3VwS2V5U2hhcmVzLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG4gICAgICBjb25zdCBtID0gMjtcbiAgICAgIGNvbnN0IG4gPSAzO1xuICAgICAgYmFja3VwS2V5U2hhcmUgPSB7XG4gICAgICAgIHVzZXJIZWxkS2V5U2hhcmU6IGF3YWl0IE1QQy5rZXlTaGFyZSgyLCBtLCBuKSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBiYWNrdXBLZXlTaGFyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGJhY2t1cCBwdWIgZ3BnIGtleSBzdHJpbmdcbiAgICogaWYgYSB0aGlyZCBwYXJ0eSBwcm92aWRlZCB0aGVuIGdldCBmcm9tIHRydXN0XG4gICAqIEBwYXJhbSBpc1RoaXJkUGFydHlCYWNrdXBcbiAgICovXG4gIGFzeW5jIGdldEJhY2t1cEdwZ1B1YktleShpc1RoaXJkUGFydHlCYWNrdXAgPSBmYWxzZSk6IFByb21pc2U8QmFja3VwR3BnS2V5PiB7XG4gICAgcmV0dXJuIGlzVGhpcmRQYXJ0eUJhY2t1cCA/IGdldFRydXN0R3BnUHViS2V5KHRoaXMuYml0Z28pIDogZ2VuZXJhdGVHUEdLZXlQYWlyKCdzZWNwMjU2azEnKTtcbiAgfVxuXG4gIGNyZWF0ZVVzZXJLZXljaGFpbih7XG4gICAgdXNlckdwZ0tleSxcbiAgICBiYWNrdXBHcGdLZXksXG4gICAgYml0Z29QdWJsaWNHcGdLZXksXG4gICAgdXNlcktleVNoYXJlLFxuICAgIGJhY2t1cEtleVNoYXJlLFxuICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgcGFzc3BocmFzZSxcbiAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGUsXG4gICAgaXNUaGlyZFBhcnR5QmFja3VwID0gZmFsc2UsXG4gIH06IENyZWF0ZUVjZHNhS2V5Y2hhaW5QYXJhbXMpOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgaWYgKCFwYXNzcGhyYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICB9XG4gICAgaWYgKGlzVGhpcmRQYXJ0eUJhY2t1cCAmJiBiYWNrdXBLZXlTaGFyZS5iaXRHb0hlbGRLZXlTaGFyZXM/LmtleVNoYXJlcykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXNlcktleWNoYWluRnJvbVRoaXJkUGFydHlCYWNrdXAoXG4gICAgICAgIHVzZXJHcGdLZXksXG4gICAgICAgIGJpdGdvUHVibGljR3BnS2V5LFxuICAgICAgICBiYWNrdXBHcGdLZXkgYXMgS2V5LFxuICAgICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICAgIGJhY2t1cEtleVNoYXJlLmJpdEdvSGVsZEtleVNoYXJlcy5rZXlTaGFyZXMsXG4gICAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICAgIHBhc3NwaHJhc2UsXG4gICAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZVxuICAgICAgKTtcbiAgICB9XG4gICAgYXNzZXJ0KGJhY2t1cEtleVNoYXJlLnVzZXJIZWxkS2V5U2hhcmUpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnRpY2lwYW50S2V5Y2hhaW4oXG4gICAgICB1c2VyR3BnS2V5LFxuICAgICAgYmFja3VwR3BnS2V5IGFzIFNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgICBiaXRnb1B1YmxpY0dwZ0tleSxcbiAgICAgIDEsXG4gICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICBiYWNrdXBLZXlTaGFyZS51c2VySGVsZEtleVNoYXJlLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHBhc3NwaHJhc2UsXG4gICAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGVcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQmFja3VwS2V5Y2hhaW4oe1xuICAgIHVzZXJHcGdLZXksXG4gICAgdXNlcktleVNoYXJlLFxuICAgIGJhY2t1cEdwZ0tleSxcbiAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICBiaXRnb0tleWNoYWluLFxuICAgIGJpdGdvUHVibGljR3BnS2V5LFxuICAgIHBhc3NwaHJhc2UsXG4gICAgYmFja3VwUHJvdmlkZXIsXG4gIH06IENyZWF0ZUVjZHNhS2V5Y2hhaW5QYXJhbXMpOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZFRoaXJkUGFydHlCYWNrdXBQcm92aWRlcihiYWNrdXBQcm92aWRlcikgJiYgYmFja3VwS2V5U2hhcmUuYml0R29IZWxkS2V5U2hhcmVzPy5rZXlTaGFyZXMpIHtcbiAgICAgIGFzc2VydChiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluKTtcbiAgICAgIGNvbnN0IGZpbmFsaXplZEJhY2t1cEtleVNoYXJlID0gYXdhaXQgdGhpcy5maW5hbGl6ZUJpdGdvSGVsZEJhY2t1cEtleVNoYXJlKFxuICAgICAgICBiYWNrdXBLZXlTaGFyZS5iaXRHb0hlbGRLZXlTaGFyZXMuaWQsXG4gICAgICAgIGJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4sXG4gICAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgICAgdXNlckdwZ0tleSxcbiAgICAgICAgYmFja3VwR3BnS2V5IGFzIEtleVxuICAgICAgKTtcbiAgICAgIGlmIChmaW5hbGl6ZWRCYWNrdXBLZXlTaGFyZS5jb21tb25LZXljaGFpbiAhPT0gYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYmFja3VwIGtleWNoYWluIC0gY29tbW9uS2V5Y2hhaW5zIGRvIG5vdCBtYXRjaCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFja3VwS2V5UGFyYW1zOiBDcmVhdGVCYWNrdXBPcHRpb25zID0ge1xuICAgICAgICBzb3VyY2U6ICdiYWNrdXAnLFxuICAgICAgICBrZXlUeXBlOiAndHNzJyxcbiAgICAgICAgY29tbW9uS2V5Y2hhaW46IGZpbmFsaXplZEJhY2t1cEtleVNoYXJlLmNvbW1vbktleWNoYWluLFxuICAgICAgICBwcm92aWRlcjogYmFja3VwUHJvdmlkZXIgPz8gJ0JpdEdvVHJ1c3RBc0tycycsXG4gICAgICB9O1xuICAgICAgY29uc3QgYmFja3VwS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmNyZWF0ZUJhY2t1cChiYWNrdXBLZXlQYXJhbXMpO1xuICAgICAgYmFja3VwS2V5Y2hhaW4ua2V5U2hhcmVzID0gZmluYWxpemVkQmFja3VwS2V5U2hhcmUua2V5U2hhcmVzO1xuICAgICAgcmV0dXJuIGJhY2t1cEtleWNoYWluO1xuICAgIH1cbiAgICBhc3NlcnQoYmFja3VwS2V5U2hhcmUudXNlckhlbGRLZXlTaGFyZSk7XG4gICAgYXNzZXJ0KHBhc3NwaHJhc2UpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnRpY2lwYW50S2V5Y2hhaW4oXG4gICAgICB1c2VyR3BnS2V5LFxuICAgICAgYmFja3VwR3BnS2V5IGFzIFNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgICBiaXRnb1B1YmxpY0dwZ0tleSxcbiAgICAgIDIsXG4gICAgICB1c2VyS2V5U2hhcmUsXG4gICAgICBiYWNrdXBLZXlTaGFyZS51c2VySGVsZEtleVNoYXJlLFxuICAgICAgYml0Z29LZXljaGFpbixcbiAgICAgIHBhc3NwaHJhc2VcbiAgICApO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGFzeW5jIGNyZWF0ZUJpdGdvS2V5Y2hhaW4oe1xuICAgIHVzZXJHcGdLZXksXG4gICAgYmFja3VwR3BnS2V5LFxuICAgIHVzZXJLZXlTaGFyZSxcbiAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICBlbnRlcnByaXNlLFxuICAgIGJpdGdvUHVibGljR3BnS2V5LFxuICAgIGlzVGhpcmRQYXJ0eUJhY2t1cCA9IGZhbHNlLFxuICB9OiBDcmVhdGVFY2RzYUJpdEdvS2V5Y2hhaW5QYXJhbXMpOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgY29uc3QgcmVjaXBpZW50SW5kZXggPSAzO1xuICAgIGNvbnN0IHVzZXJUb0JpdGdvU2hhcmUgPSBhd2FpdCBlbmNyeXB0TlNoYXJlKHVzZXJLZXlTaGFyZSwgcmVjaXBpZW50SW5kZXgsIGJpdGdvUHVibGljR3BnS2V5LmFybW9yKCksIHVzZXJHcGdLZXkpO1xuXG4gICAgY29uc3QgYmFja3VwVG9CaXRnb1NoYXJlID0gYXdhaXQgdGhpcy5nZXRCYWNrdXBFbmNyeXB0ZWROU2hhcmUoXG4gICAgICBiYWNrdXBLZXlTaGFyZSxcbiAgICAgIHJlY2lwaWVudEluZGV4LFxuICAgICAgYml0Z29QdWJsaWNHcGdLZXkuYXJtb3IoKSxcbiAgICAgIGJhY2t1cEdwZ0tleSBhcyBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+LFxuICAgICAgaXNUaGlyZFBhcnR5QmFja3VwXG4gICAgKTtcblxuICAgIGNvbnN0IGNyZWF0ZUJpdEdvTVBDUGFyYW1zOiBBZGRLZXljaGFpbk9wdGlvbnMgPSB7XG4gICAgICBrZXlUeXBlOiAndHNzJyBhcyBLZXlUeXBlLFxuICAgICAgc291cmNlOiAnYml0Z28nLFxuICAgICAga2V5U2hhcmVzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBmcm9tOiAndXNlcicsXG4gICAgICAgICAgdG86ICdiaXRnbycsXG4gICAgICAgICAgcHVibGljU2hhcmU6IHVzZXJUb0JpdGdvU2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgICAgcHJpdmF0ZVNoYXJlOiB1c2VyVG9CaXRnb1NoYXJlLmVuY3J5cHRlZFByaXZhdGVTaGFyZSxcbiAgICAgICAgICBuOiB1c2VyVG9CaXRnb1NoYXJlLm4sXG4gICAgICAgICAgdnNzUHJvb2Y6IHVzZXJUb0JpdGdvU2hhcmUudnNzUHJvb2YsXG4gICAgICAgICAgcHJpdmF0ZVNoYXJlUHJvb2Y6IHVzZXJUb0JpdGdvU2hhcmUucHJpdmF0ZVNoYXJlUHJvb2YsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBmcm9tOiAnYmFja3VwJyxcbiAgICAgICAgICB0bzogJ2JpdGdvJyxcbiAgICAgICAgICBwdWJsaWNTaGFyZTogYmFja3VwVG9CaXRnb1NoYXJlLnB1YmxpY1NoYXJlLFxuICAgICAgICAgIHByaXZhdGVTaGFyZTogYmFja3VwVG9CaXRnb1NoYXJlLmVuY3J5cHRlZFByaXZhdGVTaGFyZSxcbiAgICAgICAgICBuOiBiYWNrdXBUb0JpdGdvU2hhcmUubixcbiAgICAgICAgICB2c3NQcm9vZjogYmFja3VwVG9CaXRnb1NoYXJlLnZzc1Byb29mLFxuICAgICAgICAgIHByaXZhdGVTaGFyZVByb29mOiBiYWNrdXBUb0JpdGdvU2hhcmUucHJpdmF0ZVNoYXJlUHJvb2YsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgdXNlckdQR1B1YmxpY0tleTogdXNlckdwZ0tleS5wdWJsaWNLZXksXG4gICAgICBiYWNrdXBHUEdQdWJsaWNLZXk6IGlzVGhpcmRQYXJ0eUJhY2t1cFxuICAgICAgICA/IChiYWNrdXBHcGdLZXkgYXMgS2V5KS5hcm1vcigpXG4gICAgICAgIDogKGJhY2t1cEdwZ0tleSBhcyBTZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+KS5wdWJsaWNLZXksXG4gICAgICBlbnRlcnByaXNlOiBlbnRlcnByaXNlLFxuICAgICAgYWxnb1VzZWQ6ICdlY2RzYScsXG4gICAgfTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpLmFkZChjcmVhdGVCaXRHb01QQ1BhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBidWlsZHMgdGhlIHJlbGV2YW50IGJhY2t1cCBlbmNyeXB0ZWROU2hhcmUgYmFzZWQgb24gd2hldGhlciB0aGVcbiAgICogYmFja3VwIGtleSBpcyB1c2VyIG9yIHRoaXJkIHBhcnR5IGdlbmVyYXRlZFxuICAgKiBAcGFyYW0gYmFja3VwU2hhcmUgY2FuIGVpdGhlciBoYXZlIGtleSBzaGFyZXMgZnJvbSB0aGUgdXNlciBvciB0aGlyZCBwYXJ0eVxuICAgKiBAcGFyYW0gcmVjaXBpZW50SW5kZXggaW5kZXggb2YgdGhlIHBhcnR5IHJlY2VpdmluZyB0aGUgYmFja3VwIHNoYXJlc1xuICAgKiBAcGFyYW0gcmVjaXBpZW50R3BnUHVibGljQXJtb3IgZ3BnIGFybW9yIG9mIHRoZSBwYXJ0eSByZWNlaXZpbmcgdGhlIGJhY2t1cCBzaGFyZXNcbiAgICogQHBhcmFtIGJhY2t1cEdwZ0tleSBiYWNrdXAgZ3BnIGtleVxuICAgKiBAcGFyYW0gaXNUaGlyZFBhcnR5QmFja3VwIHdoZXRoZXIgdGhlIGJhY2t1cCBpcyBnZW5lcmF0ZWQgYnkgdGhpcmQgcGFydHlcbiAgICovXG4gIGFzeW5jIGdldEJhY2t1cEVuY3J5cHRlZE5TaGFyZShcbiAgICBiYWNrdXBTaGFyZTogQmFja3VwS2V5U2hhcmUsXG4gICAgcmVjaXBpZW50SW5kZXg6IG51bWJlcixcbiAgICByZWNpcGllbnRHcGdQdWJsaWNBcm1vcjogc3RyaW5nLFxuICAgIGJhY2t1cEdwZ0tleTogU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICBpc1RoaXJkUGFydHlCYWNrdXAgPSBmYWxzZVxuICApOiBQcm9taXNlPEVuY3J5cHRlZE5TaGFyZT4ge1xuICAgIGxldCBiYWNrdXBUb1JlY2lwaWVudFNoYXJlOiBFbmNyeXB0ZWROU2hhcmU7XG4gICAgaWYgKGlzVGhpcmRQYXJ0eUJhY2t1cCkge1xuICAgICAgaWYgKCFiYWNrdXBTaGFyZS5iaXRHb0hlbGRLZXlTaGFyZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHRoaXJkIHBhcnR5IGJhY2t1cCBrZXkgc2hhcmVzYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBiYWNrdXBUb1JlY2lwaWVudEFwaVNoYXJlID0gYmFja3VwU2hhcmUuYml0R29IZWxkS2V5U2hhcmVzLmtleVNoYXJlcy5maW5kKFxuICAgICAgICAoa2V5U2hhcmUpID0+IGtleVNoYXJlLmZyb20gPT09ICdiYWNrdXAnICYmIGtleVNoYXJlLnRvID09PSBnZXRQYXJ0aWNpcGFudEZyb21JbmRleChyZWNpcGllbnRJbmRleClcbiAgICAgICk7XG4gICAgICBpZiAoIWJhY2t1cFRvUmVjaXBpZW50QXBpU2hhcmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGJhY2t1cCB0byAke2dldFBhcnRpY2lwYW50RnJvbUluZGV4KHJlY2lwaWVudEluZGV4KX0ga2V5IHNoYXJlYCk7XG4gICAgICB9XG4gICAgICAvLyBTaW5jZSBiYWNrdXAgaXMgZnJvbSBhIHRoaXJkIHBhcnR5LCBpdCBpcyBhbHJlYWR5IGVuY3J5cHRlZFxuICAgICAgYmFja3VwVG9SZWNpcGllbnRTaGFyZSA9IGF3YWl0IGJ1aWxkTlNoYXJlRnJvbUFQSUtleVNoYXJlKGJhY2t1cFRvUmVjaXBpZW50QXBpU2hhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoYmFja3VwU2hhcmUudXNlckhlbGRLZXlTaGFyZSk7XG4gICAgICBiYWNrdXBUb1JlY2lwaWVudFNoYXJlID0gYXdhaXQgZW5jcnlwdE5TaGFyZShcbiAgICAgICAgYmFja3VwU2hhcmUudXNlckhlbGRLZXlTaGFyZSxcbiAgICAgICAgcmVjaXBpZW50SW5kZXgsXG4gICAgICAgIHJlY2lwaWVudEdwZ1B1YmxpY0FybW9yLFxuICAgICAgICBiYWNrdXBHcGdLZXlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBiYWNrdXBUb1JlY2lwaWVudFNoYXJlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgdXNlcyB0aGUgYmFja3VwIGtleSBmcm9tIGEgdGhpcmQgcGFydHkgKGJpdGdvIGluIHRoaXMgY2FzZSlcbiAgICogdG8gY3JlYXRlIHRoZSB1c2VyIGtleWNoYWluIHZpYSBXUC5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZVVzZXJLZXljaGFpbkZyb21UaGlyZFBhcnR5QmFja3VwKFxuICAgIHVzZXJHcGdLZXk6IG9wZW5wZ3AuU2VyaWFsaXplZEtleVBhaXI8c3RyaW5nPixcbiAgICBiaXRnb1B1YmxpY0dwZ0tleTogS2V5LFxuICAgIHRoaXJkUGFydHlCYWNrdXBQdWJsaWNHcGdLZXk6IEtleSxcbiAgICB1c2VyS2V5U2hhcmU6IEtleVNoYXJlLFxuICAgIHRoaXJkUGFydHliYWNrdXBLZXlTaGFyZXM6IEFwaUtleVNoYXJlW10sXG4gICAgYml0Z29LZXljaGFpbjogS2V5Y2hhaW4sXG4gICAgcGFzc3BocmFzZTogc3RyaW5nLFxuICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZT86IHN0cmluZ1xuICApOiBQcm9taXNlPEtleWNoYWluPiB7XG4gICAgY29uc3QgYml0Z29LZXlTaGFyZXMgPSBiaXRnb0tleWNoYWluLmtleVNoYXJlcztcbiAgICBpZiAoIWJpdGdvS2V5U2hhcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgQml0R28ga2V5IHNoYXJlcycpO1xuICAgIH1cbiAgICBpZiAoIWJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBjb21tb24ga2V5IGNoYWluOiAke2JpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW59YCk7XG4gICAgfVxuXG4gICAgY29uc3QgYml0R29Ub1VzZXJTaGFyZSA9IGJpdGdvS2V5U2hhcmVzLmZpbmQoKGtleVNoYXJlKSA9PiBrZXlTaGFyZS5mcm9tID09PSAnYml0Z28nICYmIGtleVNoYXJlLnRvID09PSAndXNlcicpO1xuICAgIGlmICghYml0R29Ub1VzZXJTaGFyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEJpdEdvIHRvIFVzZXIga2V5IHNoYXJlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFja3VwVG9Vc2VyU2hhcmUgPSB0aGlyZFBhcnR5YmFja3VwS2V5U2hhcmVzLmZpbmQoXG4gICAgICAoa2V5U2hhcmUpID0+IGtleVNoYXJlLmZyb20gPT09ICdiYWNrdXAnICYmIGtleVNoYXJlLnRvID09PSAndXNlcidcbiAgICApO1xuICAgIGlmICghYmFja3VwVG9Vc2VyU2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBCYWNrdXAgdG8gVXNlciBrZXkgc2hhcmUnKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYWNrdXBUb1VzZXJOU2hhcmUgPSBhd2FpdCBidWlsZE5TaGFyZUZyb21BUElLZXlTaGFyZShiYWNrdXBUb1VzZXJTaGFyZSk7XG4gICAgY29uc3QgYml0R29Ub1VzZXJOU2hhcmUgPSBhd2FpdCBidWlsZE5TaGFyZUZyb21BUElLZXlTaGFyZShiaXRHb1RvVXNlclNoYXJlKTtcbiAgICBjb25zdCBlbmNyeXB0ZWROU2hhcmVzOiBEZWNyeXB0YWJsZU5TaGFyZVtdID0gW1xuICAgICAge1xuICAgICAgICBuU2hhcmU6IGJhY2t1cFRvVXNlck5TaGFyZSxcbiAgICAgICAgcmVjaXBpZW50UHJpdmF0ZUFybW9yOiB1c2VyR3BnS2V5LnByaXZhdGVLZXksXG4gICAgICAgIHNlbmRlclB1YmxpY0FybW9yOiB0aGlyZFBhcnR5QmFja3VwUHVibGljR3BnS2V5LmFybW9yKCksXG4gICAgICAgIGlzYnM1OEVuY29kZWQ6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgblNoYXJlOiBiaXRHb1RvVXNlck5TaGFyZSxcbiAgICAgICAgcmVjaXBpZW50UHJpdmF0ZUFybW9yOiB1c2VyR3BnS2V5LnByaXZhdGVLZXksXG4gICAgICAgIHNlbmRlclB1YmxpY0FybW9yOiBiaXRnb1B1YmxpY0dwZ0tleS5hcm1vcigpLFxuICAgICAgICBpc2JzNThFbmNvZGVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IHVzZXJDb21iaW5lZEtleSA9IGF3YWl0IEVDRFNBTWV0aG9kcy5jcmVhdGVDb21iaW5lZEtleShcbiAgICAgIHVzZXJLZXlTaGFyZSxcbiAgICAgIGVuY3J5cHRlZE5TaGFyZXMsXG4gICAgICBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluXG4gICAgKTtcbiAgICBpZiAodXNlckNvbWJpbmVkS2V5LmNvbW1vbktleWNoYWluICE9PSBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgdXNlciBrZXljaGFpbiAtIGNvbW1vbktleWNoYWlucyBkbyBub3QgbWF0Y2guJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJ2ID0gSlNPTi5zdHJpbmdpZnkodXNlckNvbWJpbmVkS2V5LnNpZ25pbmdNYXRlcmlhbCk7XG4gICAgY29uc3QgdXNlcktleWNoYWluUGFyYW1zID0ge1xuICAgICAgc291cmNlOiAndXNlcicsXG4gICAgICBrZXlUeXBlOiAndHNzJyBhcyBLZXlUeXBlLFxuICAgICAgY29tbW9uS2V5Y2hhaW46IHVzZXJDb21iaW5lZEtleS5jb21tb25LZXljaGFpbixcbiAgICAgIHBydjogcHJ2LFxuICAgICAgZW5jcnlwdGVkUHJ2OiB0aGlzLmJpdGdvLmVuY3J5cHQoe1xuICAgICAgICBpbnB1dDogcHJ2LFxuICAgICAgICBwYXNzd29yZDogcGFzc3BocmFzZSxcbiAgICAgIH0pLFxuICAgICAgb3JpZ2luYWxQYXNzY29kZUVuY3J5cHRpb25Db2RlLFxuICAgIH07XG5cbiAgICBjb25zdCBrZXljaGFpbnMgPSB0aGlzLmJhc2VDb2luLmtleWNoYWlucygpO1xuICAgIHJldHVybiBhd2FpdCBrZXljaGFpbnMuYWRkKHVzZXJLZXljaGFpblBhcmFtcyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgYXN5bmMgY3JlYXRlUGFydGljaXBhbnRLZXljaGFpbihcbiAgICB1c2VyR3BnS2V5OiBvcGVucGdwLlNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgdXNlckxvY2FsQmFja3VwR3BnS2V5OiBvcGVucGdwLlNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz4sXG4gICAgYml0Z29QdWJsaWNHcGdLZXk6IEtleSxcbiAgICByZWNpcGllbnRJbmRleDogbnVtYmVyLFxuICAgIHVzZXJLZXlTaGFyZTogS2V5U2hhcmUsXG4gICAgYmFja3VwS2V5U2hhcmU6IEtleVNoYXJlLFxuICAgIGJpdGdvS2V5Y2hhaW46IEtleWNoYWluLFxuICAgIHBhc3NwaHJhc2U6IHN0cmluZyxcbiAgICBvcmlnaW5hbFBhc3Njb2RlRW5jcnlwdGlvbkNvZGU/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxLZXljaGFpbj4ge1xuICAgIGNvbnN0IGJpdGdvS2V5U2hhcmVzID0gYml0Z29LZXljaGFpbi5rZXlTaGFyZXM7XG4gICAgaWYgKCFiaXRnb0tleVNoYXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEJpdEdvIGtleSBzaGFyZXMnKTtcbiAgICB9XG4gICAgaWYgKCFiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgY29tbW9uIGtleSBjaGFpbjogJHtiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWlufWApO1xuICAgIH1cblxuICAgIGxldCByZWNpcGllbnQ6IHN0cmluZztcbiAgICBsZXQga2V5U2hhcmU6IEtleVNoYXJlO1xuICAgIGxldCBvdGhlclNoYXJlOiBLZXlTaGFyZTtcbiAgICBsZXQgcmVjaXBpZW50R3BnS2V5OiBvcGVucGdwLlNlcmlhbGl6ZWRLZXlQYWlyPHN0cmluZz47XG4gICAgbGV0IHNlbmRlckdwZ0tleTogb3BlbnBncC5TZXJpYWxpemVkS2V5UGFpcjxzdHJpbmc+O1xuICAgIGlmIChyZWNpcGllbnRJbmRleCA9PT0gMSkge1xuICAgICAga2V5U2hhcmUgPSB1c2VyS2V5U2hhcmU7XG4gICAgICBvdGhlclNoYXJlID0gYmFja3VwS2V5U2hhcmU7XG4gICAgICByZWNpcGllbnQgPSAndXNlcic7XG4gICAgICByZWNpcGllbnRHcGdLZXkgPSB1c2VyR3BnS2V5O1xuICAgICAgc2VuZGVyR3BnS2V5ID0gdXNlckxvY2FsQmFja3VwR3BnS2V5O1xuICAgIH0gZWxzZSBpZiAocmVjaXBpZW50SW5kZXggPT09IDIpIHtcbiAgICAgIGtleVNoYXJlID0gYmFja3VwS2V5U2hhcmU7XG4gICAgICBvdGhlclNoYXJlID0gdXNlcktleVNoYXJlO1xuICAgICAgcmVjaXBpZW50ID0gJ2JhY2t1cCc7XG4gICAgICByZWNpcGllbnRHcGdLZXkgPSB1c2VyTG9jYWxCYWNrdXBHcGdLZXk7XG4gICAgICBzZW5kZXJHcGdLZXkgPSB1c2VyR3BnS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBpbmRleCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdEdvVG9SZWNpcGllbnRTaGFyZSA9IGJpdGdvS2V5U2hhcmVzLmZpbmQoXG4gICAgICAoa2V5U2hhcmUpID0+IGtleVNoYXJlLmZyb20gPT09ICdiaXRnbycgJiYga2V5U2hhcmUudG8gPT09IHJlY2lwaWVudFxuICAgICk7XG4gICAgaWYgKCFiaXRHb1RvUmVjaXBpZW50U2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBCaXRHbyB0byAke3JlY2lwaWVudH0ga2V5IHNoYXJlYCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVjcnlwdGVkU2hhcmUgPSBhd2FpdCB0aGlzLmRlY3J5cHRQcml2YXRlU2hhcmUoYml0R29Ub1JlY2lwaWVudFNoYXJlLnByaXZhdGVTaGFyZSwgcmVjaXBpZW50R3BnS2V5KTtcblxuICAgIGF3YWl0IHRoaXMudmVyaWZ5V2FsbGV0U2lnbmF0dXJlcyhcbiAgICAgIHVzZXJHcGdLZXkucHVibGljS2V5LFxuICAgICAgdXNlckxvY2FsQmFja3VwR3BnS2V5LnB1YmxpY0tleSxcbiAgICAgIGJpdGdvS2V5Y2hhaW4sXG4gICAgICBkZWNyeXB0ZWRTaGFyZSxcbiAgICAgIHJlY2lwaWVudEluZGV4XG4gICAgKTtcblxuICAgIGNvbnN0IHNlbmRlclRvUmVjaXBpZW50U2hhcmUgPSBhd2FpdCBlbmNyeXB0TlNoYXJlKFxuICAgICAgb3RoZXJTaGFyZSxcbiAgICAgIHJlY2lwaWVudEluZGV4LFxuICAgICAgcmVjaXBpZW50R3BnS2V5LnB1YmxpY0tleSxcbiAgICAgIHNlbmRlckdwZ0tleVxuICAgICk7XG4gICAgY29uc3QgZW5jcnlwdGVkTlNoYXJlczogRGVjcnlwdGFibGVOU2hhcmVbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgLy8gdXNlclRvQmFja3VwIG9yIGJhY2t1cFRvVXNlclxuICAgICAgICBuU2hhcmU6IHNlbmRlclRvUmVjaXBpZW50U2hhcmUsXG4gICAgICAgIHJlY2lwaWVudFByaXZhdGVBcm1vcjogcmVjaXBpZW50R3BnS2V5LnByaXZhdGVLZXksXG4gICAgICAgIHNlbmRlclB1YmxpY0FybW9yOiBzZW5kZXJHcGdLZXkucHVibGljS2V5LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gYml0Z29Ub1JlY2lwaWVudFxuICAgICAgICBuU2hhcmU6IHtcbiAgICAgICAgICBpOiByZWNpcGllbnRJbmRleCxcbiAgICAgICAgICBqOiAzLFxuICAgICAgICAgIHB1YmxpY1NoYXJlOiBiaXRHb1RvUmVjaXBpZW50U2hhcmUucHVibGljU2hhcmUsXG4gICAgICAgICAgZW5jcnlwdGVkUHJpdmF0ZVNoYXJlOiBiaXRHb1RvUmVjaXBpZW50U2hhcmUucHJpdmF0ZVNoYXJlLFxuICAgICAgICAgIG46IGJpdEdvVG9SZWNpcGllbnRTaGFyZS5uISxcbiAgICAgICAgICB2c3NQcm9vZjogYml0R29Ub1JlY2lwaWVudFNoYXJlLnZzc1Byb29mLFxuICAgICAgICAgIHByaXZhdGVTaGFyZVByb29mOiBiaXRHb1RvUmVjaXBpZW50U2hhcmUucHJpdmF0ZVNoYXJlUHJvb2YsXG4gICAgICAgIH0sXG4gICAgICAgIHJlY2lwaWVudFByaXZhdGVBcm1vcjogcmVjaXBpZW50R3BnS2V5LnByaXZhdGVLZXksXG4gICAgICAgIHNlbmRlclB1YmxpY0FybW9yOiBiaXRnb1B1YmxpY0dwZ0tleS5hcm1vcigpLFxuICAgICAgICBpc2JzNThFbmNvZGVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIGNvbnN0IHJlY2lwaWVudENvbWJpbmVkS2V5ID0gYXdhaXQgRUNEU0FNZXRob2RzLmNyZWF0ZUNvbWJpbmVkS2V5KFxuICAgICAga2V5U2hhcmUsXG4gICAgICBlbmNyeXB0ZWROU2hhcmVzLFxuICAgICAgYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpblxuICAgICk7XG5cbiAgICBjb25zdCBwcnYgPSBKU09OLnN0cmluZ2lmeShyZWNpcGllbnRDb21iaW5lZEtleS5zaWduaW5nTWF0ZXJpYWwpO1xuICAgIGNvbnN0IHJlY2lwaWVudEtleWNoYWluUGFyYW1zID0ge1xuICAgICAgc291cmNlOiByZWNpcGllbnQsXG4gICAgICBrZXlUeXBlOiAndHNzJyBhcyBLZXlUeXBlLFxuICAgICAgY29tbW9uS2V5Y2hhaW46IGJpdGdvS2V5Y2hhaW4uY29tbW9uS2V5Y2hhaW4sXG4gICAgICBwcnY6IHBydixcbiAgICAgIGVuY3J5cHRlZFBydjogdGhpcy5iaXRnby5lbmNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IHBydixcbiAgICAgICAgcGFzc3dvcmQ6IHBhc3NwaHJhc2UsXG4gICAgICB9KSxcbiAgICAgIG9yaWdpbmFsUGFzc2NvZGVFbmNyeXB0aW9uQ29kZSxcbiAgICB9O1xuXG4gICAgY29uc3Qga2V5Y2hhaW5zID0gdGhpcy5iYXNlQ29pbi5rZXljaGFpbnMoKTtcbiAgICByZXR1cm4gcmVjaXBpZW50SW5kZXggPT09IDFcbiAgICAgID8gYXdhaXQga2V5Y2hhaW5zLmFkZChyZWNpcGllbnRLZXljaGFpblBhcmFtcylcbiAgICAgIDogYXdhaXQga2V5Y2hhaW5zLmNyZWF0ZUJhY2t1cChyZWNpcGllbnRLZXljaGFpblBhcmFtcyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVRzc0VjZHNhU3RlcDFTaWduaW5nTWF0ZXJpYWwocGFyYW1zOiB7XG4gICAgY2hhbGxlbmdlczoge1xuICAgICAgZW50ZXJwcmlzZUNoYWxsZW5nZTogRWNkc2FUeXBlcy5TZXJpYWxpemVkRWNkc2FDaGFsbGVuZ2VzO1xuICAgICAgYml0Z29DaGFsbGVuZ2U6IFR4UmVxdWVzdENoYWxsZW5nZVJlc3BvbnNlO1xuICAgIH07XG4gICAgcHJ2OiBzdHJpbmc7XG4gICAgZGVyaXZhdGlvblBhdGg6IHN0cmluZztcbiAgICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxUc3NFY2RzYVN0ZXAxUmV0dXJuTWVzc2FnZT4ge1xuICAgIGNvbnN0IHsgY2hhbGxlbmdlcywgZGVyaXZhdGlvblBhdGgsIHBydiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHVzZXJTaWduaW5nTWF0ZXJpYWw6IEVDRFNBTWV0aG9kVHlwZXMuU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZShwcnYpO1xuICAgIGlmICh1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZS5pICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXknKTtcbiAgICB9XG4gICAgaWYgKCF1c2VyU2lnbmluZ01hdGVyaWFsLmJhY2t1cE5TaGFyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXIga2V5IC0gbWlzc2luZyBiYWNrdXBOU2hhcmUnKTtcbiAgICB9XG4gICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG4gICAgY29uc3Qgc2lnbmluZ0tleSA9IE1QQy5rZXlEZXJpdmUoXG4gICAgICB1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZSxcbiAgICAgIFt1c2VyU2lnbmluZ01hdGVyaWFsLmJpdGdvTlNoYXJlLCB1c2VyU2lnbmluZ01hdGVyaWFsLmJhY2t1cE5TaGFyZV0sXG4gICAgICBkZXJpdmF0aW9uUGF0aFxuICAgICk7XG5cbiAgICBjb25zdCBiaXRnb0luZGV4ID0gU2hhcmVLZXlQb3NpdGlvbi5CSVRHTztcbiAgICBjb25zdCB1c2VySW5kZXggPSB1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZS5pO1xuXG4gICAgY29uc3QgeyBudGlsZGU6IG50aWxkZWEsIGgxOiBoMWEsIGgyOiBoMmEsIHA6IHBhIH0gPSBjaGFsbGVuZ2VzLmVudGVycHJpc2VDaGFsbGVuZ2U7XG4gICAgY29uc3QgeyBudGlsZGU6IG50aWxkZWIsIGgxOiBoMWIsIGgyOiBoMmIsIHA6IHBiLCBuOiBuYiB9ID0gY2hhbGxlbmdlcy5iaXRnb0NoYWxsZW5nZTtcbiAgICBjb25zdCB1c2VyWFNoYXJlID0gTVBDLmFwcGVuZENoYWxsZW5nZShzaWduaW5nS2V5LnhTaGFyZSwgeyBudGlsZGU6IG50aWxkZWEsIGgxOiBoMWEsIGgyOiBoMmEgfSwgeyBwOiBwYSB9KTtcbiAgICBjb25zdCBiaXRnb1lTaGFyZSA9IE1QQy5hcHBlbmRDaGFsbGVuZ2UoXG4gICAgICB7XG4gICAgICAgIGk6IHVzZXJJbmRleCxcbiAgICAgICAgajogYml0Z29JbmRleCxcbiAgICAgICAgbjogbmIsXG4gICAgICB9LFxuICAgICAgeyBudGlsZGU6IG50aWxkZWIsIGgxOiBoMWIsIGgyOiBoMmIgfSxcbiAgICAgIHsgcDogcGIgfVxuICAgICk7XG5cbiAgICBjb25zdCB1c2VyU2lnblNoYXJlID0gYXdhaXQgRUNEU0FNZXRob2RzLmNyZWF0ZVVzZXJTaWduU2hhcmUodXNlclhTaGFyZSwgYml0Z29ZU2hhcmUpO1xuICAgIGNvbnN0IHUgPSBzaWduaW5nS2V5Lm5TaGFyZXNbYml0Z29JbmRleF0udTtcblxuICAgIGxldCBjaGFpbmNvZGUgPSB1c2VyU2lnbmluZ01hdGVyaWFsLmJpdGdvTlNoYXJlLmNoYWluY29kZTtcbiAgICB3aGlsZSAoY2hhaW5jb2RlLmxlbmd0aCA8IDY0KSB7XG4gICAgICBjaGFpbmNvZGUgPSAnMCcgKyBjaGFpbmNvZGU7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lclNoYXJlID0gYmlwMzIuZnJvbVByaXZhdGVLZXkoQnVmZmVyLmZyb20odSwgJ2hleCcpLCBCdWZmZXIuZnJvbShjaGFpbmNvZGUsICdoZXgnKSkudG9CYXNlNTgoKTtcbiAgICBjb25zdCBiaXRnb0dwZ0tleSA9IGF3YWl0IGdldEJpdGdvR3BnUHViS2V5KHRoaXMuYml0Z28pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFNpZ25lclNoYXJlID0gKGF3YWl0IG9wZW5wZ3AuZW5jcnlwdCh7XG4gICAgICBtZXNzYWdlOiBhd2FpdCBvcGVucGdwLmNyZWF0ZU1lc3NhZ2Uoe1xuICAgICAgICB0ZXh0OiBzaWduZXJTaGFyZSxcbiAgICAgIH0pLFxuICAgICAgY29uZmlnOiB7XG4gICAgICAgIHJlamVjdEN1cnZlczogbmV3IFNldCgpLFxuICAgICAgfSxcbiAgICAgIGVuY3J5cHRpb25LZXlzOiBbYml0Z29HcGdLZXldLFxuICAgIH0pKSBhcyBzdHJpbmc7XG4gICAgY29uc3QgdXNlckdwZ0tleSA9IGF3YWl0IGdlbmVyYXRlR1BHS2V5UGFpcignc2VjcDI1NmsxJyk7XG4gICAgY29uc3QgcHJpdmF0ZVNoYXJlUHJvb2YgPSBhd2FpdCBjcmVhdGVTaGFyZVByb29mKHVzZXJHcGdLZXkucHJpdmF0ZUtleSwgc2lnbmluZ0tleS5uU2hhcmVzW2JpdGdvSW5kZXhdLnUsICdlY2RzYScpO1xuICAgIGNvbnN0IHZzc1Byb29mID0gc2lnbmluZ0tleS5uU2hhcmVzW2JpdGdvSW5kZXhdLnY7XG4gICAgY29uc3QgdXNlclB1YmxpY0dwZ0tleSA9IHVzZXJHcGdLZXkucHVibGljS2V5O1xuICAgIGNvbnN0IHB1YmxpY1NoYXJlID0gc2lnbmluZ0tleS5uU2hhcmVzW2JpdGdvSW5kZXhdLnkgKyBzaWduaW5nS2V5Lm5TaGFyZXNbYml0Z29JbmRleF0uY2hhaW5jb2RlO1xuICAgIHJldHVybiB7XG4gICAgICBwcml2YXRlU2hhcmVQcm9vZjogcHJpdmF0ZVNoYXJlUHJvb2YsXG4gICAgICB2c3NQcm9vZjogdnNzUHJvb2YsXG4gICAgICBwdWJsaWNTaGFyZTogcHVibGljU2hhcmUsXG4gICAgICBlbmNyeXB0ZWRTaWduZXJPZmZzZXRTaGFyZTogZW5jcnlwdGVkU2lnbmVyU2hhcmUsXG4gICAgICB1c2VyUHVibGljR3BnS2V5OiB1c2VyUHVibGljR3BnS2V5LFxuICAgICAga1NoYXJlOiB1c2VyU2lnblNoYXJlLmtTaGFyZSxcbiAgICAgIHdTaGFyZTogcGFyYW1zLndhbGxldFBhc3NwaHJhc2VcbiAgICAgICAgPyB0aGlzLmJpdGdvLmVuY3J5cHQoeyBpbnB1dDogSlNPTi5zdHJpbmdpZnkodXNlclNpZ25TaGFyZS53U2hhcmUpLCBwYXNzd29yZDogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgfSlcbiAgICAgICAgOiB1c2VyU2lnblNoYXJlLndTaGFyZSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjcmVhdGVUc3NFY2RzYVN0ZXAyU2lnbmluZ01hdGVyaWFsKHBhcmFtczoge1xuICAgIGJpdGdvQ2hhbGxlbmdlOiBUeFJlcXVlc3RDaGFsbGVuZ2VSZXNwb25zZTtcbiAgICB3U2hhcmU6IFdTaGFyZTtcbiAgICBhU2hhcmVGcm9tQml0Z286IE9taXQ8QVNoYXJlLCAnaDEnIHwgJ2gyJyB8ICdudGlsZGUnPjtcbiAgICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxUc3NFY2RzYVN0ZXAyUmV0dXJuTWVzc2FnZT4ge1xuICAgIC8vIEFwcGVuZCB0aGUgQml0R28gY2hhbGxlbmdlIHRvIHRoZSBBc2hhcmUgdG8gYmUgdXNlZCBpbiBzdWJzZXF1ZW50IHByb29mc1xuICAgIGNvbnN0IGJpdGdvVG9Vc2VyQVNoYXJlV2l0aE50aWxkZTogQVNoYXJlID0ge1xuICAgICAgLi4ucGFyYW1zLmFTaGFyZUZyb21CaXRnbyxcbiAgICAgIC4uLnBhcmFtcy5iaXRnb0NoYWxsZW5nZSxcbiAgICB9O1xuICAgIGNvbnN0IHVzZXJHYW1tYUFuZE11U2hhcmVzID0gYXdhaXQgRUNEU0FNZXRob2RzLmNyZWF0ZVVzZXJHYW1tYUFuZE11U2hhcmUoXG4gICAgICBwYXJhbXMud1NoYXJlLFxuICAgICAgYml0Z29Ub1VzZXJBU2hhcmVXaXRoTnRpbGRlXG4gICAgKTtcbiAgICBjb25zdCB1c2VyT21pY3JvbkFuZERlbHRhU2hhcmUgPSBhd2FpdCBFQ0RTQU1ldGhvZHMuY3JlYXRlVXNlck9taWNyb25BbmREZWx0YVNoYXJlKFxuICAgICAgdXNlckdhbW1hQW5kTXVTaGFyZXMuZ1NoYXJlIGFzIEVDRFNBLkdTaGFyZVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG11RFNoYXJlOiB7XG4gICAgICAgIG11U2hhcmU6IHVzZXJHYW1tYUFuZE11U2hhcmVzLm11U2hhcmUsXG4gICAgICAgIGRTaGFyZTogdXNlck9taWNyb25BbmREZWx0YVNoYXJlLmRTaGFyZSxcbiAgICAgICAgaTogdXNlckdhbW1hQW5kTXVTaGFyZXMubXVTaGFyZS5pLFxuICAgICAgfSxcbiAgICAgIG9TaGFyZTogcGFyYW1zLndhbGxldFBhc3NwaHJhc2VcbiAgICAgICAgPyB0aGlzLmJpdGdvLmVuY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IEpTT04uc3RyaW5naWZ5KHVzZXJPbWljcm9uQW5kRGVsdGFTaGFyZS5vU2hhcmUpLFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICAgIH0pXG4gICAgICAgIDogdXNlck9taWNyb25BbmREZWx0YVNoYXJlLm9TaGFyZSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0T2ZmbGluZVNpZ25lclBhaWxsaWVyTW9kdWx1cyhwYXJhbXM6IHsgcHJ2OiBzdHJpbmcgfSk6IHsgdXNlclBhaWxsaWVyTW9kdWx1czogc3RyaW5nIH0ge1xuICAgIGFzc2VydChwYXJhbXMucHJ2LCAnUGFyYW1zIHRvIGdldCBwYWlsbGllciBtb2R1bHVzIGFyZSBtaXNzaW5nIHBydi4nKTtcbiAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsOiBFQ0RTQU1ldGhvZFR5cGVzLlNpZ25pbmdNYXRlcmlhbCA9IEpTT04ucGFyc2UocGFyYW1zLnBydik7XG4gICAgcmV0dXJuIHsgdXNlclBhaWxsaWVyTW9kdWx1czogdXNlclNpZ25pbmdNYXRlcmlhbC5wU2hhcmUubiB9O1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlT2ZmbGluZUtTaGFyZShwYXJhbXM6IHtcbiAgICB0c3NQYXJhbXM6IFRTU1BhcmFtcyB8IFRTU1BhcmFtc0Zvck1lc3NhZ2U7XG4gICAgY2hhbGxlbmdlczoge1xuICAgICAgZW50ZXJwcmlzZUNoYWxsZW5nZTogRWNkc2FUeXBlcy5TZXJpYWxpemVkRWNkc2FDaGFsbGVuZ2VzO1xuICAgICAgYml0Z29DaGFsbGVuZ2U6IFR4UmVxdWVzdENoYWxsZW5nZVJlc3BvbnNlO1xuICAgIH07XG4gICAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlO1xuICAgIHBydjogc3RyaW5nO1xuICAgIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbiAgfSk6IFByb21pc2U8VHNzRWNkc2FTdGVwMVJldHVybk1lc3NhZ2U+IHtcbiAgICBjb25zdCB7IHRzc1BhcmFtcywgcHJ2LCByZXF1ZXN0VHlwZSwgY2hhbGxlbmdlcyB9ID0gcGFyYW1zO1xuICAgIGFzc2VydCh0eXBlb2YgdHNzUGFyYW1zLnR4UmVxdWVzdCAhPT0gJ3N0cmluZycsICdJbnZhbGlkIHR4UmVxdWVzdCB0eXBlJyk7XG4gICAgY29uc3QgdHhSZXF1ZXN0OiBUeFJlcXVlc3QgPSB0c3NQYXJhbXMudHhSZXF1ZXN0O1xuICAgIGxldCBkZXJpdmF0aW9uUGF0aDtcblxuICAgIGlmIChyZXF1ZXN0VHlwZSA9PT0gUmVxdWVzdFR5cGUudHgpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgdHhSZXF1ZXN0LnRyYW5zYWN0aW9ucyB8fCAodHhSZXF1ZXN0IGFzIFR4UmVxdWVzdCkudW5zaWduZWRUeHMsXG4gICAgICAgICdVbmFibGUgdG8gZmluZCB0cmFuc2FjdGlvbnMgaW4gdHhSZXF1ZXN0J1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHVuc2lnbmVkVHggPVxuICAgICAgICB0eFJlcXVlc3QuYXBpVmVyc2lvbiA9PT0gJ2Z1bGwnID8gdHhSZXF1ZXN0LnRyYW5zYWN0aW9ucyFbMF0udW5zaWduZWRUeCA6IHR4UmVxdWVzdC51bnNpZ25lZFR4c1swXTtcbiAgICAgIGRlcml2YXRpb25QYXRoID0gdW5zaWduZWRUeC5kZXJpdmF0aW9uUGF0aDtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3RUeXBlID09PSBSZXF1ZXN0VHlwZS5tZXNzYWdlKSB7XG4gICAgICAvLyBUT0RPIEJHLTY3Mjk5IE1lc3NhZ2Ugc2lnbmluZyB3aXRoIGRlcml2YXRpb24gcGF0aFxuICAgICAgZGVyaXZhdGlvblBhdGggPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlVHNzRWNkc2FTdGVwMVNpZ25pbmdNYXRlcmlhbCh7XG4gICAgICBwcnY6IHBydixcbiAgICAgIGNoYWxsZW5nZXM6IGNoYWxsZW5nZXMsXG4gICAgICBkZXJpdmF0aW9uUGF0aDogZGVyaXZhdGlvblBhdGgsXG4gICAgICB3YWxsZXRQYXNzcGhyYXNlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNyZWF0ZU9mZmxpbmVNdURlbHRhU2hhcmUocGFyYW1zOiB7XG4gICAgYVNoYXJlRnJvbUJpdGdvOiBPbWl0PEFTaGFyZSwgJ250aWxkZScgfCAnaDEnIHwgJ2gyJz47XG4gICAgYml0Z29DaGFsbGVuZ2U6IFR4UmVxdWVzdENoYWxsZW5nZVJlc3BvbnNlO1xuICAgIGVuY3J5cHRlZFdTaGFyZTogc3RyaW5nO1xuICAgIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbiAgfSk6IFByb21pc2U8VHNzRWNkc2FTdGVwMlJldHVybk1lc3NhZ2U+IHtcbiAgICBjb25zdCBkZWNyeXB0ZWRXU2hhcmUgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogcGFyYW1zLmVuY3J5cHRlZFdTaGFyZSwgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIH0pO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNyZWF0ZVRzc0VjZHNhU3RlcDJTaWduaW5nTWF0ZXJpYWwoe1xuICAgICAgYVNoYXJlRnJvbUJpdGdvOiBwYXJhbXMuYVNoYXJlRnJvbUJpdGdvLFxuICAgICAgYml0Z29DaGFsbGVuZ2U6IHBhcmFtcy5iaXRnb0NoYWxsZW5nZSxcbiAgICAgIHdTaGFyZTogSlNPTi5wYXJzZShkZWNyeXB0ZWRXU2hhcmUpLFxuICAgICAgd2FsbGV0UGFzc3BocmFzZTogcGFyYW1zLndhbGxldFBhc3NwaHJhc2UsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVPZmZsaW5lU1NoYXJlKHBhcmFtczoge1xuICAgIHRzc1BhcmFtczogVFNTUGFyYW1zIHwgVFNTUGFyYW1zRm9yTWVzc2FnZTtcbiAgICBkU2hhcmVGcm9tQml0Z286IERTaGFyZTtcbiAgICByZXF1ZXN0VHlwZTogUmVxdWVzdFR5cGU7XG4gICAgZW5jcnlwdGVkT1NoYXJlOiBzdHJpbmc7XG4gICAgd2FsbGV0UGFzc3BocmFzZTogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxTU2hhcmU+IHtcbiAgICBjb25zdCB7IHRzc1BhcmFtcywgcmVxdWVzdFR5cGUsIGRTaGFyZUZyb21CaXRnbywgZW5jcnlwdGVkT1NoYXJlLCB3YWxsZXRQYXNzcGhyYXNlIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHR5cGVvZiB0c3NQYXJhbXMudHhSZXF1ZXN0ICE9PSAnc3RyaW5nJywgJ0ludmFsaWQgdHhSZXF1ZXN0IHR5cGUnKTtcbiAgICBjb25zdCB0eFJlcXVlc3Q6IFR4UmVxdWVzdCA9IHRzc1BhcmFtcy50eFJlcXVlc3Q7XG4gICAgbGV0IHNpZ25hYmxlUGF5bG9hZDtcbiAgICBpZiAocmVxdWVzdFR5cGUgPT09IFJlcXVlc3RUeXBlLnR4KSB7XG4gICAgICBhc3NlcnQodHhSZXF1ZXN0LnRyYW5zYWN0aW9ucyB8fCB0eFJlcXVlc3QudW5zaWduZWRUeHMsICdVbmFibGUgdG8gZmluZCB0cmFuc2FjdGlvbnMgaW4gdHhSZXF1ZXN0Jyk7XG4gICAgICBjb25zdCB1bnNpZ25lZFR4ID1cbiAgICAgICAgdHhSZXF1ZXN0LmFwaVZlcnNpb24gPT09ICdmdWxsJyA/IHR4UmVxdWVzdC50cmFuc2FjdGlvbnMhWzBdLnVuc2lnbmVkVHggOiB0eFJlcXVlc3QudW5zaWduZWRUeHNbMF07XG4gICAgICBzaWduYWJsZVBheWxvYWQgPSBCdWZmZXIuZnJvbSh1bnNpZ25lZFR4LnNpZ25hYmxlSGV4LCAnaGV4Jyk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0VHlwZSA9PT0gUmVxdWVzdFR5cGUubWVzc2FnZSkge1xuICAgICAgc2lnbmFibGVQYXlsb2FkID0gKHBhcmFtcy50c3NQYXJhbXMgYXMgVFNTUGFyYW1zRm9yTWVzc2FnZSkuYnVmZmVyVG9TaWduO1xuICAgIH1cbiAgICBjb25zdCBkZWNyeXB0ZWRPU2hhcmUgPSB0aGlzLmJpdGdvLmRlY3J5cHQoeyBpbnB1dDogZW5jcnlwdGVkT1NoYXJlLCBwYXNzd29yZDogd2FsbGV0UGFzc3BocmFzZSB9KTtcbiAgICBjb25zdCB7IGksIFIsIHMsIHkgfSA9IGF3YWl0IEVDRFNBTWV0aG9kcy5jcmVhdGVVc2VyU2lnbmF0dXJlU2hhcmUoXG4gICAgICBKU09OLnBhcnNlKGRlY3J5cHRlZE9TaGFyZSksXG4gICAgICBkU2hhcmVGcm9tQml0Z28sXG4gICAgICBzaWduYWJsZVBheWxvYWRcbiAgICApO1xuICAgIC8vIHJldHVybiBvbmx5IHJlcXVpcmVkIFNTaGFyZSB3aXRob3V0IGJpZ2ludHMgZnJvbSBWQVNoYXJlXG4gICAgcmV0dXJuIHtcbiAgICAgIGksXG4gICAgICBSLFxuICAgICAgcyxcbiAgICAgIHksXG4gICAgfTtcbiAgfVxuICBhc3luYyBzaWduRWNkc2FUc3NVc2luZ0V4dGVybmFsU2lnbmVyKFxuICAgIHBhcmFtczogVFNTUGFyYW1zIHwgVFNTUGFyYW1zRm9yTWVzc2FnZSxcbiAgICByZXF1ZXN0VHlwZTogUmVxdWVzdFR5cGUsXG4gICAgZXh0ZXJuYWxTaWduZXJQYWlsbGllck1vZHVsdXNHZXR0ZXI6IEN1c3RvbVBhaWxsaWVyTW9kdWx1c0dldHRlckZ1bmN0aW9uLFxuICAgIGV4dGVybmFsU2lnbmVyS1NoYXJlR2VuZXJhdG9yOiBDdXN0b21LU2hhcmVHZW5lcmF0aW5nRnVuY3Rpb24sXG4gICAgZXh0ZXJuYWxTaWduZXJNdURlbHRhU2hhcmVHZW5lcmF0b3I6IEN1c3RvbU11RGVsdGFTaGFyZUdlbmVyYXRpbmdGdW5jdGlvbixcbiAgICBleHRlcm5hbFNpZ25lclNTaGFyZUdlbmVyYXRvcjogQ3VzdG9tU1NoYXJlR2VuZXJhdGluZ0Z1bmN0aW9uXG4gICk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgY29uc3QgeyB0eFJlcXVlc3QgfSA9IHBhcmFtcztcbiAgICBjb25zdCBwZW5kaW5nRWNkc2FUc3NJbml0aWFsaXphdGlvbiA9IHRoaXMud2FsbGV0LmNvaW5TcGVjaWZpYygpPy5wZW5kaW5nRWNkc2FUc3NJbml0aWFsaXphdGlvbjtcbiAgICBpZiAocGVuZGluZ0VjZHNhVHNzSW5pdGlhbGl6YXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1dhbGxldCBpcyBub3QgcmVhZHkgZm9yIFRTUyBFQ0RTQSBzaWduaW5nLiBQbGVhc2UgY29udGFjdCB5b3VyIGVudGVycHJpc2UgYWRtaW4gdG8gZmluaXNoIHRoZSBlbnRlcnByaXNlIFRTUyBpbml0aWFsaXphdGlvbi4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0eFJlcXVlc3RPYmo6IFR4UmVxdWVzdCA9IGF3YWl0IGdldFR4UmVxdWVzdCh0aGlzLmJpdGdvLCB0aGlzLndhbGxldC5pZCgpLCB0eFJlcXVlc3QgYXMgc3RyaW5nKTtcbiAgICBjb25zdCB7IHVzZXJQYWlsbGllck1vZHVsdXMgfSA9IGF3YWl0IGV4dGVybmFsU2lnbmVyUGFpbGxpZXJNb2R1bHVzR2V0dGVyKHsgdHhSZXF1ZXN0OiB0eFJlcXVlc3RPYmogfSk7XG4gICAgY29uc3QgeyBlbnRlcnByaXNlQ2hhbGxlbmdlLCBiaXRnb0NoYWxsZW5nZSB9ID0gYXdhaXQgdGhpcy5nZXRFY2RzYVNpZ25pbmdDaGFsbGVuZ2VzKFxuICAgICAgdHhSZXF1ZXN0IGFzIHN0cmluZyxcbiAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgdXNlclBhaWxsaWVyTW9kdWx1cyxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbnN0IHN0ZXAxU2lnbmluZ01hdGVyaWFsID0gYXdhaXQgZXh0ZXJuYWxTaWduZXJLU2hhcmVHZW5lcmF0b3Ioe1xuICAgICAgdHNzUGFyYW1zOiB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgdHhSZXF1ZXN0OiB0eFJlcXVlc3RPYmosXG4gICAgICB9LFxuICAgICAgY2hhbGxlbmdlczogeyBlbnRlcnByaXNlQ2hhbGxlbmdlLCBiaXRnb0NoYWxsZW5nZSB9LFxuICAgICAgcmVxdWVzdFR5cGU6IHJlcXVlc3RUeXBlLFxuICAgIH0pO1xuICAgIC8vIHNpZ25pbmcgc3RhZ2Ugb25lIHdpdGggSyBzaGFyZSBzZW5kIHRvIGJpdGdvIGFuZCByZWNlaXZlcyBBIHNoYXJlXG4gICAgY29uc3QgYml0Z29Ub1VzZXJBU2hhcmUgPSAoYXdhaXQgRUNEU0FNZXRob2RzLnNlbmRTaGFyZVRvQml0Z28oXG4gICAgICB0aGlzLmJpdGdvLFxuICAgICAgdGhpcy53YWxsZXQuaWQoKSxcbiAgICAgIHR4UmVxdWVzdE9iai50eFJlcXVlc3RJZCxcbiAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgU2VuZFNoYXJlVHlwZS5LU2hhcmUsXG4gICAgICBzdGVwMVNpZ25pbmdNYXRlcmlhbC5rU2hhcmUsXG4gICAgICBzdGVwMVNpZ25pbmdNYXRlcmlhbC5lbmNyeXB0ZWRTaWduZXJPZmZzZXRTaGFyZSxcbiAgICAgIHN0ZXAxU2lnbmluZ01hdGVyaWFsLnZzc1Byb29mLFxuICAgICAgc3RlcDFTaWduaW5nTWF0ZXJpYWwucHJpdmF0ZVNoYXJlUHJvb2YsXG4gICAgICBzdGVwMVNpZ25pbmdNYXRlcmlhbC5wdWJsaWNTaGFyZSxcbiAgICAgIHN0ZXAxU2lnbmluZ01hdGVyaWFsLnVzZXJQdWJsaWNHcGdLZXlcbiAgICApKSBhcyBPbWl0PEFTaGFyZSwgJ250aWxkZScgfCAnaDEnIHwgJ2gyJz47IC8vIFdQL0hTTSBkb2VzIG5vdCByZXR1cm4gdGhlIGluaXRpYWwgY2hhbGxlbmdlXG4gICAgY29uc3Qgc3RlcDJSZXR1cm4gPSBhd2FpdCBleHRlcm5hbFNpZ25lck11RGVsdGFTaGFyZUdlbmVyYXRvcih7XG4gICAgICB0eFJlcXVlc3Q6IHR4UmVxdWVzdE9iaixcbiAgICAgIGFTaGFyZUZyb21CaXRnbzogYml0Z29Ub1VzZXJBU2hhcmUsXG4gICAgICBiaXRnb0NoYWxsZW5nZTogYml0Z29DaGFsbGVuZ2UsXG4gICAgICBlbmNyeXB0ZWRXU2hhcmU6IHN0ZXAxU2lnbmluZ01hdGVyaWFsLndTaGFyZSBhcyBzdHJpbmcsXG4gICAgfSk7XG4gICAgLy8gc2lnbmluZyBzdGFnZSB0d28gd2l0aCBtdVNoYXJlIGFuZCBkU2hhcmUgc2VuZCB0byBiaXRnbyBhbmQgcmVjZWl2ZXMgRCBzaGFyZVxuICAgIGNvbnN0IGJpdGdvVG9Vc2VyRFNoYXJlID0gKGF3YWl0IEVDRFNBTWV0aG9kcy5zZW5kU2hhcmVUb0JpdGdvKFxuICAgICAgdGhpcy5iaXRnbyxcbiAgICAgIHRoaXMud2FsbGV0LmlkKCksXG4gICAgICB0eFJlcXVlc3RPYmoudHhSZXF1ZXN0SWQsXG4gICAgICByZXF1ZXN0VHlwZSxcbiAgICAgIFNlbmRTaGFyZVR5cGUuTVVTaGFyZSxcbiAgICAgIHN0ZXAyUmV0dXJuLm11RFNoYXJlXG4gICAgKSkgYXMgRFNoYXJlO1xuICAgIGNvbnN0IHVzZXJTU2hhcmUgPSBhd2FpdCBleHRlcm5hbFNpZ25lclNTaGFyZUdlbmVyYXRvcih7XG4gICAgICB0c3NQYXJhbXM6IHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICB0eFJlcXVlc3Q6IHR4UmVxdWVzdE9iaixcbiAgICAgIH0sXG4gICAgICBkU2hhcmVGcm9tQml0Z286IGJpdGdvVG9Vc2VyRFNoYXJlLFxuICAgICAgcmVxdWVzdFR5cGU6IHJlcXVlc3RUeXBlLFxuICAgICAgZW5jcnlwdGVkT1NoYXJlOiBzdGVwMlJldHVybi5vU2hhcmUgYXMgc3RyaW5nLFxuICAgIH0pO1xuICAgIC8vIHNpZ25pbmcgc3RhZ2UgdGhyZWUgd2l0aCBTU2hhcmUgc2VuZCB0byBiaXRnbyBhbmQgcmVjZWl2ZXMgU1NoYXJlXG4gICAgYXdhaXQgRUNEU0FNZXRob2RzLnNlbmRTaGFyZVRvQml0Z28oXG4gICAgICB0aGlzLmJpdGdvLFxuICAgICAgdGhpcy53YWxsZXQuaWQoKSxcbiAgICAgIHR4UmVxdWVzdE9iai50eFJlcXVlc3RJZCxcbiAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgU2VuZFNoYXJlVHlwZS5TU2hhcmUsXG4gICAgICB1c2VyU1NoYXJlXG4gICAgKTtcbiAgICByZXR1cm4gYXdhaXQgZ2V0VHhSZXF1ZXN0KHRoaXMuYml0Z28sIHRoaXMud2FsbGV0LmlkKCksIHR4UmVxdWVzdE9iai50eFJlcXVlc3RJZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBzaWduaW5nIGtleSwgdHhSZXF1ZXN0UmVzb2x2ZWQgYW5kIHR4UmVxdWVzdElkXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVHhSZXF1ZXN0fSBwYXJhbXMudHhSZXF1ZXN0IC0gdHJhbnNhY3Rpb24gcmVxdWVzdCBvYmplY3Qgb3IgaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcnYgLSBkZWNyeXB0ZWQgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIHsgc3RyaW5nfSBwYXJhbXMucmVxSWQgLSByZXF1ZXN0IGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFR4UmVxdWVzdD59XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNpZ25SZXF1ZXN0QmFzZShwYXJhbXM6IFRTU1BhcmFtcyB8IFRTU1BhcmFtc0Zvck1lc3NhZ2UsIHJlcXVlc3RUeXBlOiBSZXF1ZXN0VHlwZSk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgY29uc3QgcGVuZGluZ0VjZHNhVHNzSW5pdGlhbGl6YXRpb24gPSB0aGlzLndhbGxldC5jb2luU3BlY2lmaWMoKT8ucGVuZGluZ0VjZHNhVHNzSW5pdGlhbGl6YXRpb247XG4gICAgaWYgKHBlbmRpbmdFY2RzYVRzc0luaXRpYWxpemF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdXYWxsZXQgaXMgbm90IHJlYWR5IGZvciBUU1MgRUNEU0Egc2lnbmluZy4gUGxlYXNlIGNvbnRhY3QgeW91ciBlbnRlcnByaXNlIGFkbWluIHRvIGZpbmlzaCB0aGUgZW50ZXJwcmlzZSBUU1MgaW5pdGlhbGl6YXRpb24uJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdXNlclNpZ25pbmdNYXRlcmlhbDogRUNEU0FNZXRob2RUeXBlcy5TaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKHBhcmFtcy5wcnYpO1xuICAgIGlmICh1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZS5pICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXknKTtcbiAgICB9XG4gICAgaWYgKCF1c2VyU2lnbmluZ01hdGVyaWFsLmJhY2t1cE5TaGFyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVzZXIga2V5IC0gbWlzc2luZyBiYWNrdXBOU2hhcmUnKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eFJlcXVlc3Q6IFR4UmVxdWVzdCA9XG4gICAgICB0eXBlb2YgcGFyYW1zLnR4UmVxdWVzdCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhd2FpdCBnZXRUeFJlcXVlc3QodGhpcy5iaXRnbywgdGhpcy53YWxsZXQuaWQoKSwgcGFyYW1zLnR4UmVxdWVzdClcbiAgICAgICAgOiBwYXJhbXMudHhSZXF1ZXN0O1xuXG4gICAgbGV0IHNpZ25hYmxlUGF5bG9hZCA9IG5ldyBCdWZmZXIoJycpO1xuICAgIGxldCBkZXJpdmF0aW9uUGF0aCA9ICcnO1xuXG4gICAgaWYgKHJlcXVlc3RUeXBlID09PSBSZXF1ZXN0VHlwZS50eCkge1xuICAgICAgYXNzZXJ0KHR4UmVxdWVzdC50cmFuc2FjdGlvbnMgfHwgdHhSZXF1ZXN0LnVuc2lnbmVkVHhzLCAnVW5hYmxlIHRvIGZpbmQgdHJhbnNhY3Rpb25zIGluIHR4UmVxdWVzdCcpO1xuICAgICAgY29uc3QgdW5zaWduZWRUeCA9XG4gICAgICAgIHR4UmVxdWVzdC5hcGlWZXJzaW9uID09PSAnZnVsbCcgPyB0eFJlcXVlc3QudHJhbnNhY3Rpb25zIVswXS51bnNpZ25lZFR4IDogdHhSZXF1ZXN0LnVuc2lnbmVkVHhzWzBdO1xuICAgICAgc2lnbmFibGVQYXlsb2FkID0gQnVmZmVyLmZyb20odW5zaWduZWRUeC5zaWduYWJsZUhleCwgJ2hleCcpO1xuICAgICAgZGVyaXZhdGlvblBhdGggPSB1bnNpZ25lZFR4LmRlcml2YXRpb25QYXRoO1xuICAgIH0gZWxzZSBpZiAocmVxdWVzdFR5cGUgPT09IFJlcXVlc3RUeXBlLm1lc3NhZ2UpIHtcbiAgICAgIHNpZ25hYmxlUGF5bG9hZCA9IChwYXJhbXMgYXMgVFNTUGFyYW1zRm9yTWVzc2FnZSkuYnVmZmVyVG9TaWduO1xuICAgICAgLy8gVE9ETyBCRy02NzI5OSBNZXNzYWdlIHNpZ25pbmcgd2l0aCBkZXJpdmF0aW9uIHBhdGhcbiAgICB9XG4gICAgY29uc3QgcGFpbGxpZXJNb2R1bHVzID0gdGhpcy5nZXRPZmZsaW5lU2lnbmVyUGFpbGxpZXJNb2R1bHVzKHsgcHJ2OiBwYXJhbXMucHJ2IH0pO1xuICAgIGNvbnN0IGNoYWxsZW5nZXMgPSBhd2FpdCB0aGlzLmdldEVjZHNhU2lnbmluZ0NoYWxsZW5nZXMoXG4gICAgICB0eFJlcXVlc3QudHhSZXF1ZXN0SWQsXG4gICAgICByZXF1ZXN0VHlwZSxcbiAgICAgIHBhaWxsaWVyTW9kdWx1cy51c2VyUGFpbGxpZXJNb2R1bHVzLFxuICAgICAgMFxuICAgICk7XG5cbiAgICBjb25zdCBzdGVwMVJldHVybiA9IGF3YWl0IHRoaXMuY3JlYXRlVHNzRWNkc2FTdGVwMVNpZ25pbmdNYXRlcmlhbCh7XG4gICAgICBwcnY6IHBhcmFtcy5wcnYsXG4gICAgICBjaGFsbGVuZ2VzOiBjaGFsbGVuZ2VzLFxuICAgICAgZGVyaXZhdGlvblBhdGg6IGRlcml2YXRpb25QYXRoLFxuICAgIH0pO1xuXG4gICAgLy8gc2lnbmluZyBzdGFnZSBvbmUgd2l0aCBLIHNoYXJlIHNlbmQgdG8gYml0Z28gYW5kIHJlY2VpdmVzIEEgc2hhcmVcbiAgICBjb25zdCBiaXRnb1RvVXNlckFTaGFyZSA9IChhd2FpdCBFQ0RTQU1ldGhvZHMuc2VuZFNoYXJlVG9CaXRnbyhcbiAgICAgIHRoaXMuYml0Z28sXG4gICAgICB0aGlzLndhbGxldC5pZCgpLFxuICAgICAgdHhSZXF1ZXN0LnR4UmVxdWVzdElkLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICBTZW5kU2hhcmVUeXBlLktTaGFyZSxcbiAgICAgIHN0ZXAxUmV0dXJuLmtTaGFyZSxcbiAgICAgIHN0ZXAxUmV0dXJuLmVuY3J5cHRlZFNpZ25lck9mZnNldFNoYXJlLFxuICAgICAgc3RlcDFSZXR1cm4udnNzUHJvb2YsXG4gICAgICBzdGVwMVJldHVybi5wcml2YXRlU2hhcmVQcm9vZixcbiAgICAgIHN0ZXAxUmV0dXJuLnB1YmxpY1NoYXJlLFxuICAgICAgc3RlcDFSZXR1cm4udXNlclB1YmxpY0dwZ0tleVxuICAgICkpIGFzIE9taXQ8QVNoYXJlLCAnbnRpbGRlJyB8ICdoMScgfCAnaDInPjsgLy8gV1AvSFNNIGRvZXMgbm90IHJldHVybiB0aGUgaW5pdGlhbCBjaGFsbGVuZ2VcblxuICAgIGNvbnN0IHN0ZXAyUmV0dXJuID0gYXdhaXQgdGhpcy5jcmVhdGVUc3NFY2RzYVN0ZXAyU2lnbmluZ01hdGVyaWFsKHtcbiAgICAgIGFTaGFyZUZyb21CaXRnbzogYml0Z29Ub1VzZXJBU2hhcmUsXG4gICAgICBiaXRnb0NoYWxsZW5nZTogY2hhbGxlbmdlcy5iaXRnb0NoYWxsZW5nZSxcbiAgICAgIHdTaGFyZTogc3RlcDFSZXR1cm4ud1NoYXJlIGFzIFdTaGFyZSxcbiAgICB9KTtcblxuICAgIC8vIHNpZ25pbmcgc3RhZ2UgdHdvIHdpdGggbXVTaGFyZSBhbmQgZFNoYXJlIHNlbmQgdG8gYml0Z28gYW5kIHJlY2VpdmVzIEQgc2hhcmVcbiAgICBjb25zdCBiaXRnb1RvVXNlckRTaGFyZSA9IChhd2FpdCBFQ0RTQU1ldGhvZHMuc2VuZFNoYXJlVG9CaXRnbyhcbiAgICAgIHRoaXMuYml0Z28sXG4gICAgICB0aGlzLndhbGxldC5pZCgpLFxuICAgICAgdHhSZXF1ZXN0LnR4UmVxdWVzdElkLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICBTZW5kU2hhcmVUeXBlLk1VU2hhcmUsXG4gICAgICBzdGVwMlJldHVybi5tdURTaGFyZVxuICAgICkpIGFzIERTaGFyZTtcblxuICAgIGNvbnN0IHVzZXJTU2hhcmUgPSBhd2FpdCBFQ0RTQU1ldGhvZHMuY3JlYXRlVXNlclNpZ25hdHVyZVNoYXJlKFxuICAgICAgc3RlcDJSZXR1cm4ub1NoYXJlIGFzIE9TaGFyZSxcbiAgICAgIGJpdGdvVG9Vc2VyRFNoYXJlLFxuICAgICAgc2lnbmFibGVQYXlsb2FkLFxuICAgICAgcGFyYW1zLmhhc2hcbiAgICApO1xuXG4gICAgLy8gc2lnbmluZyBzdGFnZSB0aHJlZSB3aXRoIFNTaGFyZSBzZW5kIHRvIGJpdGdvIGFuZCByZWNlaXZlcyBTU2hhcmVcbiAgICBhd2FpdCBFQ0RTQU1ldGhvZHMuc2VuZFNoYXJlVG9CaXRnbyhcbiAgICAgIHRoaXMuYml0Z28sXG4gICAgICB0aGlzLndhbGxldC5pZCgpLFxuICAgICAgdHhSZXF1ZXN0LnR4UmVxdWVzdElkLFxuICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICBTZW5kU2hhcmVUeXBlLlNTaGFyZSxcbiAgICAgIHVzZXJTU2hhcmVcbiAgICApO1xuICAgIHJldHVybiBhd2FpdCBnZXRUeFJlcXVlc3QodGhpcy5iaXRnbywgdGhpcy53YWxsZXQuaWQoKSwgdHhSZXF1ZXN0LnR4UmVxdWVzdElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyB0aGUgdHJhbnNhY3Rpb24gYXNzb2NpYXRlZCB0byB0aGUgdHJhbnNhY3Rpb24gcmVxdWVzdC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBUeFJlcXVlc3R9IHBhcmFtcy50eFJlcXVlc3QgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IG9iamVjdCBvciBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnBydiAtIGRlY3J5cHRlZCBwcml2YXRlIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnJlcUlkIC0gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUeFJlcXVlc3Q+fSBmdWxseSBzaWduZWQgVHhSZXF1ZXN0IG9iamVjdFxuICAgKi9cbiAgYXN5bmMgc2lnblR4UmVxdWVzdChwYXJhbXM6IFRTU1BhcmFtcyk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgcmV0dXJuIHRoaXMuc2lnblJlcXVlc3RCYXNlKHBhcmFtcywgUmVxdWVzdFR5cGUudHgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBtZXNzYWdlIGFzc29jaWF0ZWQgdG8gdGhlIHRyYW5zYWN0aW9uIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVHhSZXF1ZXN0fSBwYXJhbXMudHhSZXF1ZXN0IC0gdHJhbnNhY3Rpb24gcmVxdWVzdCBvYmplY3Qgb3IgaWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5wcnYgLSBkZWNyeXB0ZWQgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5yZXFJZCAtIHJlcXVlc3QgaWRcbiAgICogQHJldHVybnMge1Byb21pc2U8VHhSZXF1ZXN0Pn0gZnVsbHkgc2lnbmVkIFR4UmVxdWVzdCBvYmplY3RcbiAgICovXG4gIGFzeW5jIHNpZ25UeFJlcXVlc3RGb3JNZXNzYWdlKHBhcmFtczogVFNTUGFyYW1zRm9yTWVzc2FnZSk6IFByb21pc2U8VHhSZXF1ZXN0PiB7XG4gICAgaWYgKCFwYXJhbXMubWVzc2FnZVJhdykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYXcgbWVzc2FnZSByZXF1aXJlZCB0byBzaWduIG1lc3NhZ2UnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2lnblJlcXVlc3RCYXNlKHBhcmFtcywgUmVxdWVzdFR5cGUubWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjaGFsbGVuZ2UgdmFsdWVzIGZvciBlbnRlcnByaXNlIGFuZCBCaXRHbyBpbiBFQ0RTQSBzaWduaW5nXG4gICAqIE9ubHkgcmV0dXJucyB0aGUgY2hhbGxlbmdlcyBpZiB0aGV5IGFyZSB2ZXJpZmllZCBieSB0aGUgdXNlcidzIGVudGVycHJpc2UgYWRtaW4ncyBlY2RoIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHhSZXF1ZXN0SWQgLSB0cmFuc2FjdGlvbiByZXF1ZXN0IGlkXG4gICAqIEBwYXJhbSB7UmVxdWVzdFR5cGV9IHJlcXVlc3RUeXBlIC0gICgwIGZvciB0eCwgMSBmb3IgbWVzc2FnZSlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldFBhaWxsaWVyTW9kdWx1cyAtIHBhaWxsaWVyIHB1YmtleSAkbiRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gaW5kZXggb2YgdGhlIHJlcXVlc3RUeXBlXG4gICAqL1xuICBhc3luYyBnZXRFY2RzYVNpZ25pbmdDaGFsbGVuZ2VzKFxuICAgIHR4UmVxdWVzdElkOiBzdHJpbmcsXG4gICAgcmVxdWVzdFR5cGU6IFJlcXVlc3RUeXBlLFxuICAgIHdhbGxldFBhaWxsaWVyTW9kdWx1czogc3RyaW5nLFxuICAgIGluZGV4ID0gMFxuICApOiBQcm9taXNlPHtcbiAgICBlbnRlcnByaXNlQ2hhbGxlbmdlOiBFY2RzYVR5cGVzLlNlcmlhbGl6ZWRFY2RzYUNoYWxsZW5nZXM7XG4gICAgYml0Z29DaGFsbGVuZ2U6IFR4UmVxdWVzdENoYWxsZW5nZVJlc3BvbnNlO1xuICB9PiB7XG4gICAgY29uc3QgZW50ZXJwcmlzZUlkID0gdGhpcy53YWxsZXQudG9KU09OKCkuZW50ZXJwcmlzZTtcbiAgICBpZiAoIWVudGVycHJpc2VJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXYWxsZXQgbXVzdCBiZSBhbiBlbnRlcnByaXNlIHdhbGxldC4nKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgQml0R28gcmFuZ2UgcHJvb2YgYW5kIHBhaWxsaWVyIHByb29mIGNoYWxsZW5nZVxuICAgIGNvbnN0IGNyZWF0ZUJpdGdvQ2hhbGxlbmdlUmVzcG9uc2UgPSBhd2FpdCBnZXRUeFJlcXVlc3RDaGFsbGVuZ2UoXG4gICAgICB0aGlzLmJpdGdvLFxuICAgICAgdGhpcy53YWxsZXQuaWQoKSxcbiAgICAgIHR4UmVxdWVzdElkLFxuICAgICAgaW5kZXgudG9TdHJpbmcoKSxcbiAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgd2FsbGV0UGFpbGxpZXJNb2R1bHVzXG4gICAgKTtcblxuICAgIGNvbnN0IGJpdGdvVG9FbnRlcnByaXNlUGFpbGxpZXJDaGFsbGVuZ2UgPSB7IHA6IGNyZWF0ZUJpdGdvQ2hhbGxlbmdlUmVzcG9uc2UucCB9O1xuICAgIGNvbnN0IGVudGVycHJpc2VUb0JpdGdvUGFpbGxpZXJDaGFsbGVuZ2UgPSBFY2RzYVR5cGVzLnNlcmlhbGl6ZVBhaWxsaWVyQ2hhbGxlbmdlKHtcbiAgICAgIHA6IGF3YWl0IEVjZHNhUGFpbGxpZXJQcm9vZi5nZW5lcmF0ZVAoaGV4VG9CaWdJbnQoY3JlYXRlQml0Z29DaGFsbGVuZ2VSZXNwb25zZS5uKSksXG4gICAgfSk7XG5cbiAgICAvLyBUT0RPKEJHLTc4NzY0KTogb25jZSB0aGUgcGFpbGxpZXIgcHJvb2ZzIGFyZSBjb21wbGV0ZSwgcmVkdWNlIGNoYWxsZW5nZSBjcmVhdGlvbiB0byBvbmUgQVBJIGNhbGxcbiAgICBjb25zdCB3YWxsZXRDaGFsbGVuZ2VzID0gYXdhaXQgdGhpcy53YWxsZXQuZ2V0Q2hhbGxlbmdlc0ZvckVjZHNhU2lnbmluZygpO1xuXG4gICAgY29uc3QgY2hhbGxlbmdlVmVyaWZpZXJVc2VySWQgPSB3YWxsZXRDaGFsbGVuZ2VzLmNyZWF0ZWRCeTtcbiAgICBjb25zdCBhZG1pblNpZ25pbmdLZXlSZXNwb25zZSA9IGF3YWl0IHRoaXMuYml0Z28uZ2V0U2lnbmluZ0tleUZvclVzZXIoZW50ZXJwcmlzZUlkLCBjaGFsbGVuZ2VWZXJpZmllclVzZXJJZCk7XG4gICAgY29uc3QgcHVia2V5T2ZBZG1pbkVjZGhLZXlIZXggPSBhZG1pblNpZ25pbmdLZXlSZXNwb25zZS5kZXJpdmVkUHVia2V5O1xuXG4gICAgLy8gVmVyaWZ5IGVudGVycHJpc2UncyBjaGFsbGVuZ2UgaXMgc2lnbmVkIGJ5IHRoZSByZXNwZWN0aXZlIGFkbWlucyBlY2RoIGtleWNoYWluXG4gICAgY29uc3QgZW50ZXJwcmlzZVJhd0NoYWxsZW5nZSA9IHtcbiAgICAgIG50aWxkZTogd2FsbGV0Q2hhbGxlbmdlcy5lbnRlcnByaXNlQ2hhbGxlbmdlLm50aWxkZSxcbiAgICAgIGgxOiB3YWxsZXRDaGFsbGVuZ2VzLmVudGVycHJpc2VDaGFsbGVuZ2UuaDEsXG4gICAgICBoMjogd2FsbGV0Q2hhbGxlbmdlcy5lbnRlcnByaXNlQ2hhbGxlbmdlLmgyLFxuICAgIH07XG4gICAgY29uc3QgYWRtaW5TaWduYXR1cmVPbkVudENoYWxsZW5nZTogc3RyaW5nID0gd2FsbGV0Q2hhbGxlbmdlcy5lbnRlcnByaXNlQ2hhbGxlbmdlLnZlcmlmaWVycy5hZG1pblNpZ25hdHVyZTtcbiAgICBpZiAoXG4gICAgICAhdmVyaWZ5RWNkaFNpZ25hdHVyZShcbiAgICAgICAgRWNkc2FVdGlscy5nZXRNZXNzYWdlVG9TaWduRnJvbUNoYWxsZW5nZShlbnRlcnByaXNlUmF3Q2hhbGxlbmdlKSxcbiAgICAgICAgYWRtaW5TaWduYXR1cmVPbkVudENoYWxsZW5nZSxcbiAgICAgICAgQnVmZmVyLmZyb20ocHVia2V5T2ZBZG1pbkVjZGhLZXlIZXgsICdoZXgnKVxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZG1pbiBzaWduYXR1cmUgZm9yIGVudGVycHJpc2UgY2hhbGxlbmdlIGlzIG5vdCB2YWxpZC4gUGxlYXNlIGNvbnRhY3QgeW91ciBlbnRlcnByaXNlIGFkbWluLmApO1xuICAgIH1cblxuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBCaXRHbyBjaGFsbGVuZ2UncyBaSyBwcm9vZnMgaGF2ZSBiZWVuIHZlcmlmaWVkIGJ5IHRoZSBhZG1pblxuICAgIGNvbnN0IGJpdGdvQ2hhbGxlbmdlOiBUeFJlcXVlc3RDaGFsbGVuZ2VSZXNwb25zZSA9IHtcbiAgICAgIG50aWxkZTogd2FsbGV0Q2hhbGxlbmdlcy5iaXRnb0NoYWxsZW5nZS5udGlsZGUsXG4gICAgICBoMTogd2FsbGV0Q2hhbGxlbmdlcy5iaXRnb0NoYWxsZW5nZS5oMSxcbiAgICAgIGgyOiB3YWxsZXRDaGFsbGVuZ2VzLmJpdGdvQ2hhbGxlbmdlLmgyLFxuICAgICAgcDogYml0Z29Ub0VudGVycHJpc2VQYWlsbGllckNoYWxsZW5nZS5wLFxuICAgICAgbjogY3JlYXRlQml0Z29DaGFsbGVuZ2VSZXNwb25zZS5uLFxuICAgIH07XG4gICAgY29uc3QgYWRtaW5WZXJpZmljYXRpb25TaWduYXR1cmVGb3JCaXRHb0NoYWxsZW5nZSA9IHdhbGxldENoYWxsZW5nZXMuYml0Z29DaGFsbGVuZ2UudmVyaWZpZXJzLmFkbWluU2lnbmF0dXJlO1xuICAgIGlmIChcbiAgICAgICF2ZXJpZnlFY2RoU2lnbmF0dXJlKFxuICAgICAgICBFY2RzYVV0aWxzLmdldE1lc3NhZ2VUb1NpZ25Gcm9tQ2hhbGxlbmdlKGJpdGdvQ2hhbGxlbmdlKSxcbiAgICAgICAgYWRtaW5WZXJpZmljYXRpb25TaWduYXR1cmVGb3JCaXRHb0NoYWxsZW5nZSxcbiAgICAgICAgQnVmZmVyLmZyb20ocHVia2V5T2ZBZG1pbkVjZGhLZXlIZXgsICdoZXgnKVxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZG1pbiBzaWduYXR1cmUgZm9yIEJpdEdvJ3MgY2hhbGxlbmdlIGlzIG5vdCB2YWxpZC4gUGxlYXNlIGNvbnRhY3QgeW91ciBlbnRlcnByaXNlIGFkbWluLmApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbnRlcnByaXNlQ2hhbGxlbmdlOiB7XG4gICAgICAgIC4uLmVudGVycHJpc2VSYXdDaGFsbGVuZ2UsXG4gICAgICAgIHA6IGVudGVycHJpc2VUb0JpdGdvUGFpbGxpZXJDaGFsbGVuZ2UucCxcbiAgICAgIH0sXG4gICAgICBiaXRnb0NoYWxsZW5nZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIHRoZSB1LXZhbHVlIHByb29mcyBhbmQgR1BHIGtleXMgdXNlZCBpbiBnZW5lcmF0aW5nIGEgVFNTIEVDRFNBIHdhbGxldC5cbiAgICogQHBhcmFtIHVzZXJHcGdQdWIgVGhlIHVzZXIncyBwdWJsaWMgR1BHIGtleSBmb3IgZW5jcnlwdGlvbiBiZXR3ZWVuIHVzZXIvc2VydmVyXG4gICAqIEBwYXJhbSBiYWNrdXBHcGdQdWIgVGhlIGJhY2t1cCdzIHB1YmxpYyBHUEcga2V5IGZvciBlbmNyeXB0aW9uIGJldHdlZW4gYmFja3VwL3NlcnZlclxuICAgKiBAcGFyYW0gYml0Z29LZXljaGFpbiBwcmV2aW91c2x5IGNyZWF0ZWQgQml0R28ga2V5Y2hhaW47IG11c3QgYmUgY29tcGF0aWJsZSB3aXRoIHVzZXIgYW5kIGJhY2t1cCBrZXkgc2hhcmVzXG4gICAqIEBwYXJhbSBkZWNyeXB0ZWRTaGFyZSBUaGUgZGVjcnlwdGVkIGJpdGdvLXRvLXVzZXIvYmFja3VwIHByaXZhdGUgc2hhcmUgcmV0cmlldmVkIGZyb20gdGhlIGtleWNoYWluXG4gICAqIEBwYXJhbSB2ZXJpZmllckluZGV4IFRoZSBpbmRleCBvZiB0aGUgcGFydHkgdG8gdmVyaWZ5OiAxID0gdXNlciwgMiA9IGJhY2t1cFxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5V2FsbGV0U2lnbmF0dXJlcyhcbiAgICB1c2VyR3BnUHViOiBzdHJpbmcsXG4gICAgYmFja3VwR3BnUHViOiBzdHJpbmcsXG4gICAgYml0Z29LZXljaGFpbjogS2V5Y2hhaW4sXG4gICAgZGVjcnlwdGVkU2hhcmU6IHN0cmluZyxcbiAgICB2ZXJpZmllckluZGV4OiAxIHwgMlxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhc3NlcnQoYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpbik7XG4gICAgYXNzZXJ0KGJpdGdvS2V5Y2hhaW4ud2FsbGV0SFNNR1BHUHVibGljS2V5U2lncyk7XG5cbiAgICBjb25zdCBiaXRnb0dwZ0tleSA9IGF3YWl0IGdldEJpdGdvR3BnUHViS2V5KHRoaXMuYml0Z28pO1xuICAgIGNvbnN0IHVzZXJLZXlQdWIgPSBhd2FpdCBvcGVucGdwLnJlYWRLZXkoeyBhcm1vcmVkS2V5OiB1c2VyR3BnUHViIH0pO1xuICAgIGNvbnN0IHVzZXJLZXlJZCA9IHVzZXJLZXlQdWIua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCk7XG4gICAgY29uc3QgYmFja3VwS2V5UHViID0gYXdhaXQgb3BlbnBncC5yZWFkS2V5KHsgYXJtb3JlZEtleTogYmFja3VwR3BnUHViIH0pO1xuICAgIGNvbnN0IGJhY2t1cEtleUlkID0gYmFja3VwS2V5UHViLmtleVBhY2tldC5nZXRGaW5nZXJwcmludCgpO1xuXG4gICAgY29uc3Qgd2FsbGV0U2lnbmF0dXJlcyA9IGF3YWl0IG9wZW5wZ3AucmVhZEtleXMoeyBhcm1vcmVkS2V5czogYml0Z29LZXljaGFpbi53YWxsZXRIU01HUEdQdWJsaWNLZXlTaWdzIH0pO1xuICAgIGlmICh3YWxsZXRTaWduYXR1cmVzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdhbGxldCBzaWduYXR1cmVzJyk7XG4gICAgfVxuICAgIGlmICh1c2VyS2V5SWQgIT09IHdhbGxldFNpZ25hdHVyZXNbMF0ua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZmlyc3Qgd2FsbGV0IHNpZ25hdHVyZSdzIGZpbmdlcnByaW50IGRvZXMgbm90IG1hdGNoIHBhc3NlZCB1c2VyIGdwZyBrZXkncyBmaW5nZXJwcmludGApO1xuICAgIH1cbiAgICBpZiAoYmFja3VwS2V5SWQgIT09IHdhbGxldFNpZ25hdHVyZXNbMV0ua2V5UGFja2V0LmdldEZpbmdlcnByaW50KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2Vjb25kIHdhbGxldCBzaWduYXR1cmUncyBmaW5nZXJwcmludCBkb2VzIG5vdCBtYXRjaCBwYXNzZWQgYmFja3VwIGdwZyBrZXkncyBmaW5nZXJwcmludGApO1xuICAgIH1cblxuICAgIGF3YWl0IHZlcmlmeVdhbGxldFNpZ25hdHVyZSh7XG4gICAgICB3YWxsZXRTaWduYXR1cmU6IHdhbGxldFNpZ25hdHVyZXNbMF0sXG4gICAgICBjb21tb25LZXljaGFpbjogYml0Z29LZXljaGFpbi5jb21tb25LZXljaGFpbixcbiAgICAgIHVzZXJLZXlJZCxcbiAgICAgIGJhY2t1cEtleUlkLFxuICAgICAgYml0Z29QdWI6IGJpdGdvR3BnS2V5LFxuICAgICAgZGVjcnlwdGVkU2hhcmUsXG4gICAgICB2ZXJpZmllckluZGV4LFxuICAgIH0pO1xuXG4gICAgYXdhaXQgdmVyaWZ5V2FsbGV0U2lnbmF0dXJlKHtcbiAgICAgIHdhbGxldFNpZ25hdHVyZTogd2FsbGV0U2lnbmF0dXJlc1sxXSxcbiAgICAgIGNvbW1vbktleWNoYWluOiBiaXRnb0tleWNoYWluLmNvbW1vbktleWNoYWluLFxuICAgICAgdXNlcktleUlkLFxuICAgICAgYmFja3VwS2V5SWQsXG4gICAgICBiaXRnb1B1YjogYml0Z29HcGdLZXksXG4gICAgICBkZWNyeXB0ZWRTaGFyZSxcbiAgICAgIHZlcmlmaWVySW5kZXgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbnMgYSBjaGFsbGVuZ2Ugd2l0aCB0aGUgcHJvdmlkZWQgdjEgZWNkaCBrZXkgYXQgYSBkZXJpdmVkIHBhdGhcbiAgICogQHBhcmFtIGNoYWxsZW5nZSBjaGFsbGVuZ2UgdG8gc2lnblxuICAgKiBAcGFyYW0gZWNkaFhwcnYgeHBydiBvZiB0aGUgZWNkaCBrZXlcbiAgICogQHBhcmFtIGRlcml2YXRpb25QYXRoIHRoZSBkZXJpdmVkIHBhdGggYXQgd2hpY2ggdGhlIGVjZGgga2V5IHdpbGwgc2lnblxuICAgKi9cbiAgc3RhdGljIHNpZ25DaGFsbGVuZ2UoY2hhbGxlbmdlOiBFY2RzYVR5cGVzLlNlcmlhbGl6ZWROdGlsZGUsIGVjZGhYcHJ2OiBzdHJpbmcsIGRlcml2YXRpb25QYXRoOiBzdHJpbmcpOiBCdWZmZXIge1xuICAgIGNvbnN0IG1lc3NhZ2VUb1NpZ24gPSB0aGlzLmdldE1lc3NhZ2VUb1NpZ25Gcm9tQ2hhbGxlbmdlKGNoYWxsZW5nZSk7XG4gICAgcmV0dXJuIHNpZ25NZXNzYWdlV2l0aERlcml2ZWRFY2RoS2V5KG1lc3NhZ2VUb1NpZ24sIGVjZGhYcHJ2LCBkZXJpdmF0aW9uUGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgY2hhbGxlbmdlIHRvIGEgY29tbW9uIG1lc3NhZ2UgZm9ybWF0IHdoaWNoIGNhbiBiZSBzaWduZWQuXG4gICAqIEBwYXJhbSBjaGFsbGVuZ2VcbiAgICovXG4gIHN0YXRpYyBnZXRNZXNzYWdlVG9TaWduRnJvbUNoYWxsZW5nZShjaGFsbGVuZ2U6IEVjZHNhVHlwZXMuU2VyaWFsaXplZE50aWxkZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGNoYWxsZW5nZS5udGlsZGUuY29uY2F0KGNoYWxsZW5nZS5oMSkuY29uY2F0KGNoYWxsZW5nZS5oMik7XG4gIH1cblxuICAvKipcbiAgIFZlcmlmaWVzIFpLIHByb29mcyBvZiBCaXRHbydzIGNoYWxsZW5nZXMgZm9yIGJvdGggbml0cm8gYW5kIGluc3RpdHV0aW9uYWwgSFNNc1xuICAgd2hpY2ggYXJlIGZldGNoZWQgZnJvbSB0aGUgV1AgQVBJLlxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHZlcmlmeUJpdEdvQ2hhbGxlbmdlcyhiaXRnb0NoYWxsZW5nZXM6IEdldEJpdEdvQ2hhbGxlbmdlc0FwaSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIC8vIFZlcmlmeSBpbnN0aXR1dGlvbmFsIGhzbSBjaGFsbGVuZ2UgcHJvb2ZcbiAgICBjb25zdCBpbnN0Q2hhbGxlbmdlVmVyaWZpZWQgPSBhd2FpdCB0aGlzLnZlcmlmeUJpdEdvQ2hhbGxlbmdlKHtcbiAgICAgIG50aWxkZTogYml0Z29DaGFsbGVuZ2VzLmJpdGdvSW5zdGl0dXRpb25hbEhzbS5udGlsZGUsXG4gICAgICBoMTogYml0Z29DaGFsbGVuZ2VzLmJpdGdvSW5zdGl0dXRpb25hbEhzbS5oMSxcbiAgICAgIGgyOiBiaXRnb0NoYWxsZW5nZXMuYml0Z29JbnN0aXR1dGlvbmFsSHNtLmgyLFxuICAgICAgbnRpbGRlUHJvb2Y6IGJpdGdvQ2hhbGxlbmdlcy5iaXRnb0luc3RpdHV0aW9uYWxIc20ubnRpbGRlUHJvb2YsXG4gICAgfSk7XG5cbiAgICAvLyBWZXJpZnkgbml0cm8gaHNtIGNoYWxsZW5nZSBwcm9vZlxuICAgIGNvbnN0IG5pdHJvQ2hhbGxlbmdlVmVyaWZpZWQgPSBhd2FpdCB0aGlzLnZlcmlmeUJpdEdvQ2hhbGxlbmdlKHtcbiAgICAgIG50aWxkZTogYml0Z29DaGFsbGVuZ2VzLmJpdGdvTml0cm9Ic20ubnRpbGRlLFxuICAgICAgaDE6IGJpdGdvQ2hhbGxlbmdlcy5iaXRnb05pdHJvSHNtLmgxLFxuICAgICAgaDI6IGJpdGdvQ2hhbGxlbmdlcy5iaXRnb05pdHJvSHNtLmgyLFxuICAgICAgbnRpbGRlUHJvb2Y6IGJpdGdvQ2hhbGxlbmdlcy5iaXRnb05pdHJvSHNtLm50aWxkZVByb29mLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGluc3RDaGFsbGVuZ2VWZXJpZmllZCAmJiBuaXRyb0NoYWxsZW5nZVZlcmlmaWVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIFpLIHByb29mIGZvciBhIHNpbmdsZSBCaXRHbyBjaGFsbGVuZ2VcbiAgICogQHBhcmFtIGJpdGdvQ2hhbGxlbmdlXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgdmVyaWZ5Qml0R29DaGFsbGVuZ2UoYml0Z29DaGFsbGVuZ2U6IEVjZHNhVHlwZXMuU2VyaWFsaXplZE50aWxkZVdpdGhQcm9vZnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBkZXNlcmlhbGl6ZWRJbnN0Q2hhbGxlbmdlID0gRWNkc2FUeXBlcy5kZXNlcmlhbGl6ZU50aWxkZVdpdGhQcm9vZnMoYml0Z29DaGFsbGVuZ2UpO1xuICAgIGNvbnN0IG50aWxkZVByb29mSDFXcnRIMlZlcmlmaWVkID0gYXdhaXQgRWNkc2FSYW5nZVByb29mLnZlcmlmeU50aWxkZVByb29mKFxuICAgICAge1xuICAgICAgICBudGlsZGU6IGRlc2VyaWFsaXplZEluc3RDaGFsbGVuZ2UubnRpbGRlLFxuICAgICAgICBoMTogZGVzZXJpYWxpemVkSW5zdENoYWxsZW5nZS5oMSxcbiAgICAgICAgaDI6IGRlc2VyaWFsaXplZEluc3RDaGFsbGVuZ2UuaDIsXG4gICAgICB9LFxuICAgICAgZGVzZXJpYWxpemVkSW5zdENoYWxsZW5nZS5udGlsZGVQcm9vZi5oMVdydEgyXG4gICAgKTtcbiAgICBjb25zdCBudGlsZGVQcm9vZkgyV3J0SDFWZXJpZmllZCA9IGF3YWl0IEVjZHNhUmFuZ2VQcm9vZi52ZXJpZnlOdGlsZGVQcm9vZihcbiAgICAgIHtcbiAgICAgICAgbnRpbGRlOiBkZXNlcmlhbGl6ZWRJbnN0Q2hhbGxlbmdlLm50aWxkZSxcbiAgICAgICAgaDE6IGRlc2VyaWFsaXplZEluc3RDaGFsbGVuZ2UuaDIsXG4gICAgICAgIGgyOiBkZXNlcmlhbGl6ZWRJbnN0Q2hhbGxlbmdlLmgxLFxuICAgICAgfSxcbiAgICAgIGRlc2VyaWFsaXplZEluc3RDaGFsbGVuZ2UubnRpbGRlUHJvb2YuaDJXcnRIMVxuICAgICk7XG4gICAgcmV0dXJuIG50aWxkZVByb29mSDFXcnRIMlZlcmlmaWVkICYmIG50aWxkZVByb29mSDJXcnRIMVZlcmlmaWVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGJpdGdvIGNoYWxsZW5nZXMgZm9yIGJvdGggbml0cm8gYW5kIGluc3RpdHV0aW9uYWwgSFNNcyBmcm9tIFdQIEFQSS5cbiAgICogQHBhcmFtIGJpdGdvXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZ2V0Qml0R29DaGFsbGVuZ2VzKGJpdGdvOiBCaXRHb0Jhc2UpOiBQcm9taXNlPEdldEJpdEdvQ2hhbGxlbmdlc0FwaT4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGJpdGdvLmdldChiaXRnby51cmwoJy90c3MvZWNkc2EvY2hhbGxlbmdlcycsIDIpKS5zZW5kKCkucmVzdWx0KCk7XG4gICAgaWYgKFxuICAgICAgIXJlcy5iaXRnb05pdHJvSHNtIHx8XG4gICAgICAhcmVzLmJpdGdvTml0cm9Ic20ubnRpbGRlIHx8XG4gICAgICAhcmVzLmJpdGdvTml0cm9Ic20uaDEgfHxcbiAgICAgICFyZXMuYml0Z29OaXRyb0hzbS5oMiB8fFxuICAgICAgIXJlcy5iaXRnb05pdHJvSHNtLm50aWxkZVByb29mIHx8XG4gICAgICAhcmVzLmJpdGdvSW5zdGl0dXRpb25hbEhzbSB8fFxuICAgICAgIXJlcy5iaXRnb0luc3RpdHV0aW9uYWxIc20ubnRpbGRlIHx8XG4gICAgICAhcmVzLmJpdGdvSW5zdGl0dXRpb25hbEhzbS5oMSB8fFxuICAgICAgIXJlcy5iaXRnb0luc3RpdHV0aW9uYWxIc20uaDIgfHxcbiAgICAgICFyZXMuYml0Z29JbnN0aXR1dGlvbmFsSHNtLm50aWxkZVByb29mXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIEJpdEdvIGNoYWxsZW5nZSBwcm9vZiB0byBiZSBwcmVzZW50LiBDb250YWN0IHN1cHBvcnRAYml0Z28uY29tLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgQml0R28ncyBwcm9vZnMgZnJvbSBBUEkgYW5kIHNpZ25zIHRoZW0gaWYgdGhlIHByb29mcyBhcmUgdmFsaWQuXG4gICAqIEBwYXJhbSBiaXRnb1xuICAgKiBAcGFyYW0gZW50ZXJwcmlzZUlkXG4gICAqIEBwYXJhbSB1c2VyUGFzc3dvcmRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBnZXRWZXJpZnlBbmRTaWduQml0R29DaGFsbGVuZ2VzKFxuICAgIGJpdGdvOiBCaXRHb0Jhc2UsXG4gICAgZW50ZXJwcmlzZUlkOiBzdHJpbmcsXG4gICAgdXNlclBhc3N3b3JkOiBzdHJpbmdcbiAgKTogUHJvbWlzZTxCaXRHb1Byb29mU2lnbmF0dXJlcz4ge1xuICAgIC8vIEZldGNoIEJpdEdvJ3MgY2hhbGxlbmdlIGFuZCB2ZXJpZnlcbiAgICBjb25zdCBiaXRnb0NoYWxsZW5nZXNXaXRoUHJvb2ZzID0gYXdhaXQgRWNkc2FVdGlscy5nZXRCaXRHb0NoYWxsZW5nZXMoYml0Z28pO1xuICAgIGlmICghKGF3YWl0IEVjZHNhVXRpbHMudmVyaWZ5Qml0R29DaGFsbGVuZ2VzKGJpdGdvQ2hhbGxlbmdlc1dpdGhQcm9vZnMpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHZlcmlmeSBCaXRHbydzIGNoYWxsZW5nZSBuZWVkZWQgdG8gZW5hYmxlIEVDRFNBIHNpZ25pbmcuIFBsZWFzZSBjb250YWN0IHN1cHBvcnRAYml0Z28uY29tYFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IEVjZHNhVXRpbHMuc2lnbkJpdGdvQ2hhbGxlbmdlcyhiaXRnbywgZW50ZXJwcmlzZUlkLCB1c2VyUGFzc3dvcmQsIGJpdGdvQ2hhbGxlbmdlc1dpdGhQcm9vZnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gQml0Z28ncyBwcm9vZnMsIHZlcmlmaWNhdGlvbiBvZiBwcm9vZnMgaXMgbGVmdCB0byB0aGUgY2FsbGVyXG4gICAqIEBwYXJhbSBiaXRnb1xuICAgKiBAcGFyYW0gZW50ZXJwcmlzZUlkXG4gICAqIEBwYXJhbSB1c2VyUGFzc3dvcmRcbiAgICogQHBhcmFtIGJpdGdvQ2hhbGxlbmdlc1dpdGhQcm9vZnMgT3B0aW9uYWxseSBwcm92aWRlIEJpdGdvIENoYWxsYWVuZ2UgJiBQcm9vZnMgaW5zdGVhZCBvZiBmZXRjaGluZyBmcm9tIEFQSVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHNpZ25CaXRnb0NoYWxsZW5nZXMoXG4gICAgYml0Z286IEJpdEdvQmFzZSxcbiAgICBlbnRlcnByaXNlSWQ6IHN0cmluZyxcbiAgICB1c2VyUGFzc3dvcmQ6IHN0cmluZyxcbiAgICBiaXRnb0NoYWxsZW5nZXNXaXRoUHJvb2ZzPzogR2V0Qml0R29DaGFsbGVuZ2VzQXBpXG4gICk6IFByb21pc2U8Qml0R29Qcm9vZlNpZ25hdHVyZXM+IHtcbiAgICAvLyBmZXRjaCBjaGFsbGVuZ2UgJiBwcm9vZiBpZiBub25lIGFyZSBwcm92aWRlZFxuICAgIGNvbnN0IGNoYWxsZW5nZXNXaXRoUHJvb2ZzID0gYml0Z29DaGFsbGVuZ2VzV2l0aFByb29mc1xuICAgICAgPyBiaXRnb0NoYWxsZW5nZXNXaXRoUHJvb2ZzXG4gICAgICA6IGF3YWl0IEVjZHNhVXRpbHMuZ2V0Qml0R29DaGFsbGVuZ2VzKGJpdGdvKTtcblxuICAgIC8vIEZldGNoIHVzZXIncyBlY2RoIHB1YmxpYyBrZXljaGFpbiBuZWVkZWQgZm9yIHNpZ25pbmcgdGhlIGNoYWxsZW5nZXNcbiAgICBjb25zdCBlY2RoS2V5cGFpciA9IGF3YWl0IGJpdGdvLmdldEVjZGhLZXlwYWlyUHJpdmF0ZSh1c2VyUGFzc3dvcmQsIGVudGVycHJpc2VJZCk7XG5cbiAgICBjb25zdCBzaWduZWRCaXRHb0luc3RDaGFsbGVuZ2UgPSBFY2RzYVV0aWxzLnNpZ25DaGFsbGVuZ2UoXG4gICAgICBjaGFsbGVuZ2VzV2l0aFByb29mcy5iaXRnb0luc3RpdHV0aW9uYWxIc20sXG4gICAgICBlY2RoS2V5cGFpci54cHJ2LFxuICAgICAgZWNkaEtleXBhaXIuZGVyaXZhdGlvblBhdGhcbiAgICApO1xuICAgIGNvbnN0IHNpZ25lZEJpdEdvTml0cm9DaGFsbGVuZ2UgPSBFY2RzYVV0aWxzLnNpZ25DaGFsbGVuZ2UoXG4gICAgICBjaGFsbGVuZ2VzV2l0aFByb29mcy5iaXRnb05pdHJvSHNtLFxuICAgICAgZWNkaEtleXBhaXIueHBydixcbiAgICAgIGVjZGhLZXlwYWlyLmRlcml2YXRpb25QYXRoXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgYml0Z29JbnN0SHNtQWRtaW5TaWduYXR1cmU6IHNpZ25lZEJpdEdvSW5zdENoYWxsZW5nZSxcbiAgICAgIGJpdGdvTml0cm9Ic21BZG1pblNpZ25hdHVyZTogc2lnbmVkQml0R29OaXRyb0NoYWxsZW5nZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbmVlZGVkIHRvIGVuYWJsZSBlY2RzYSBzaWduaW5nIG9uIHRoZSBlbnRlcnByaXNlLlxuICAgKiBJdCByZWNlaXZlcyB0aGUgZW50ZXJwcmlzZSBjaGFsbGVuZ2UgYW5kIHNpZ25hdHVyZXMgb2YgdmVyaWZpZWQgYml0Z28gcHJvb2ZzXG4gICAqIGFuZCB1cGxvYWRzIHRoZW0gb24gdGhlIGVudGVycHJpc2UuXG4gICAqIEBwYXJhbSBiaXRnb1xuICAgKiBAcGFyYW0gZW50SWQgLSBlbnRlcnByaXNlIGlkIHRvIGVuYWJsZSBlY2RzYSBzaWduaW5nIG9uXG4gICAqIEBwYXJhbSB1c2VyUGFzc3dvcmQgLSBlbnRlcnByaXNlIGFkbWluJ3MgbG9naW4gcHdcbiAgICogQHBhcmFtIGJpdGdvSW5zdENoYWxsZW5nZVByb29mU2lnbmF0dXJlIC0gc2lnbmF0dXJlIG9uIGJpdGdvJ3MgaW5zdGl0dXRpb25hbCBIU00gY2hhbGxlbmdlIGFmdGVyIHZlcmlmaWNhdGlvblxuICAgKiBAcGFyYW0gYml0Z29OaXRyb0NoYWxsZW5nZVByb29mU2lnbmF0dXJlIC0gc2lnbmF0dXJlIG9uIGJpdGdvJ3Mgbml0cm8gSFNNIGNoYWxsZW5nZSBhZnRlciB2ZXJpZmljYXRpb25cbiAgICogQHBhcmFtIGNoYWxsZW5nZSAtIG9wdGlvbmFsbHkgdXNlIHRoZSBjaGFsbGVuZ2UgZm9yIGVudGVycHJpc2UgY2hhbGxlbmdlXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgaW5pdGlhdGVDaGFsbGVuZ2VzRm9yRW50ZXJwcmlzZShcbiAgICBiaXRnbzogQml0R29CYXNlLFxuICAgIGVudElkOiBzdHJpbmcsXG4gICAgdXNlclBhc3N3b3JkOiBzdHJpbmcsXG4gICAgYml0Z29JbnN0Q2hhbGxlbmdlUHJvb2ZTaWduYXR1cmU6IEJ1ZmZlcixcbiAgICBiaXRnb05pdHJvQ2hhbGxlbmdlUHJvb2ZTaWduYXR1cmU6IEJ1ZmZlcixcbiAgICBjaGFsbGVuZ2U/OiBFY2RzYVR5cGVzLkRlc2VyaWFsaXplZE50aWxkZVdpdGhQcm9vZnNcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gRmV0Y2ggdXNlcidzIGVjZGggcHVibGljIGtleWNoYWluIG5lZWRlZCBmb3Igc2lnbmluZyB0aGUgY2hhbGxlbmdlc1xuICAgIGNvbnN0IGVjZGhLZXlwYWlyID0gYXdhaXQgYml0Z28uZ2V0RWNkaEtleXBhaXJQcml2YXRlKHVzZXJQYXNzd29yZCwgZW50SWQpO1xuXG4gICAgLy8gR2VuZXJhdGUgYW5kIHNpZ24gZW50ZXJwcmlzZSBjaGFsbGVuZ2VcbiAgICBjb25zdCBlbnRDaGFsbGVuZ2VXaXRoUHJvb2YgPSBjaGFsbGVuZ2UgPz8gKGF3YWl0IEVjZHNhUmFuZ2VQcm9vZi5nZW5lcmF0ZU50aWxkZShtaW5Nb2R1bHVzQml0TGVuZ3RoKSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEVudENoYWxsZW5nZVdpdGhQcm9vZiA9IEVjZHNhVHlwZXMuc2VyaWFsaXplTnRpbGRlV2l0aFByb29mcyhlbnRDaGFsbGVuZ2VXaXRoUHJvb2YpO1xuICAgIGNvbnN0IHNpZ25lZEVudGVycHJpc2VDaGFsbGVuZ2UgPSBFY2RzYVV0aWxzLnNpZ25DaGFsbGVuZ2UoXG4gICAgICBzZXJpYWxpemVkRW50Q2hhbGxlbmdlV2l0aFByb29mLFxuICAgICAgZWNkaEtleXBhaXIueHBydixcbiAgICAgIGVjZGhLZXlwYWlyLmRlcml2YXRpb25QYXRoXG4gICAgKTtcblxuICAgIGF3YWl0IHRoaXMudXBsb2FkQ2hhbGxlbmdlc1RvRW50ZXJwcmlzZShcbiAgICAgIGJpdGdvLFxuICAgICAgZW50SWQsXG4gICAgICBzZXJpYWxpemVkRW50Q2hhbGxlbmdlV2l0aFByb29mLFxuICAgICAgc2lnbmVkRW50ZXJwcmlzZUNoYWxsZW5nZS50b1N0cmluZygnaGV4JyksXG4gICAgICBiaXRnb0luc3RDaGFsbGVuZ2VQcm9vZlNpZ25hdHVyZS50b1N0cmluZygnaGV4JyksXG4gICAgICBiaXRnb05pdHJvQ2hhbGxlbmdlUHJvb2ZTaWduYXR1cmUudG9TdHJpbmcoJ2hleCcpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGxvYWRzIHRoZSBzaWduZWQgY2hhbGxlbmdlcyBhbmQgdGhlaXIgcHJvb2ZzIG9uIHRoZSBlbnRlcnByaXNlLlxuICAgKiBUaGlzIGluaXRpYXRlcyBlY2RzYSBzaWduaW5nIGZvciB0aGUgZW50ZXJwcmlzZSB1c2Vycy5cbiAgICogQHBhcmFtIGJpdGdvXG4gICAqIEBwYXJhbSBlbnRJZCAtIGVudGVycHJpc2UgdG8gZW5hYmxlIGVjZHNhIHNpZ25pbmcgb25cbiAgICogQHBhcmFtIGVudENoYWxsZW5nZSAtIGNsaWVudCBzaWRlIGdlbmVyYXRlZCBlbnQgY2hhbGxlbmdlIHdpdGggWksgcHJvb2ZzXG4gICAqIEBwYXJhbSBlbnRDaGFsbGVuZ2VTaWduYXR1cmUgLSBzaWduYXR1cmUgb24gZW50ZXJwcmlzZSBjaGFsbGVuZ2VcbiAgICogQHBhcmFtIGJpdGdvSW50Q2hhbGxlbmdlU2lnbmF0dXJlIC0gc2lnbmF0dXJlIG9uIEJpdEdvJ3MgaW5zdGl0dXRpb25hbCBIU00gY2hhbGxlbmdlXG4gICAqIEBwYXJhbSBiaXRnb05pdHJvQ2hhbGxlbmdlU2lnbmF0dXJlIC0gc2lnbmF0dXJlIG9uIEJpdEdvJ3Mgbml0cm8gSFNNIGNoYWxsZW5nZVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHVwbG9hZENoYWxsZW5nZXNUb0VudGVycHJpc2UoXG4gICAgYml0Z286IEJpdEdvQmFzZSxcbiAgICBlbnRJZDogc3RyaW5nLFxuICAgIGVudENoYWxsZW5nZTogRWNkc2FUeXBlcy5TZXJpYWxpemVkTnRpbGRlIHwgRWNkc2FUeXBlcy5TZXJpYWxpemVkTnRpbGRlV2l0aFByb29mcyxcbiAgICBlbnRDaGFsbGVuZ2VTaWduYXR1cmU6IHN0cmluZyxcbiAgICBiaXRnb0ludENoYWxsZW5nZVNpZ25hdHVyZTogc3RyaW5nLFxuICAgIGJpdGdvTml0cm9DaGFsbGVuZ2VTaWduYXR1cmU6IHN0cmluZ1xuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgZW50ZXJwcmlzZToge1xuICAgICAgICBudGlsZGU6IGVudENoYWxsZW5nZS5udGlsZGUsXG4gICAgICAgIGgxOiBlbnRDaGFsbGVuZ2UuaDEsXG4gICAgICAgIGgyOiBlbnRDaGFsbGVuZ2UuaDIsXG4gICAgICAgIHZlcmlmaWVyczoge1xuICAgICAgICAgIGFkbWluU2lnbmF0dXJlOiBlbnRDaGFsbGVuZ2VTaWduYXR1cmUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYml0Z29JbnN0aXR1dGlvbmFsSHNtOiB7XG4gICAgICAgIHZlcmlmaWVyczoge1xuICAgICAgICAgIGFkbWluU2lnbmF0dXJlOiBiaXRnb0ludENoYWxsZW5nZVNpZ25hdHVyZSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBiaXRnb05pdHJvSHNtOiB7XG4gICAgICAgIHZlcmlmaWVyczoge1xuICAgICAgICAgIGFkbWluU2lnbmF0dXJlOiBiaXRnb05pdHJvQ2hhbGxlbmdlU2lnbmF0dXJlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICAgIGlmICgnbnRpbGRlUHJvb2YnIGluIGVudENoYWxsZW5nZSkge1xuICAgICAgYm9keS5lbnRlcnByaXNlWydudGlsZGVQcm9vZiddID0gZW50Q2hhbGxlbmdlLm50aWxkZVByb29mO1xuICAgIH1cbiAgICBhd2FpdCBiaXRnb1xuICAgICAgLnB1dChiaXRnby51cmwoYC9lbnRlcnByaXNlLyR7ZW50SWR9L3Rzc2NvbmZpZy9lY2RzYS9jaGFsbGVuZ2VgLCAyKSlcbiAgICAgIC5zZW5kKGJvZHkpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogdXRpbCBmdW5jdGlvbiB0aGF0IGNoZWNrcyB0aGF0IGEgY29tbW9uS2V5Y2hhaW4gaXMgdmFsaWQgYW5kIGNhbiB1bHRpbWF0ZWx5IHJlc29sdmUgdG8gYSB2YWxpZCBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBjb21tb25LZXljaGFpbiAtIGEgdXNlciB1cGxvYWRlZCBjb21tb25LZXljaGFpbiBzdHJpbmdcbiAgICogQHRocm93cyBpZiB0aGUgY29tbW9uS2V5Y2hhaW4gaXMgaW52YWxpZCBsZW5ndGggb3IgaW52YWxpZCBmb3JtYXRcbiAgICovXG5cbiAgc3RhdGljIHZhbGlkYXRlQ29tbW9uS2V5Y2hhaW5QdWJsaWNLZXkoY29tbW9uS2V5Y2hhaW46IHN0cmluZykge1xuICAgIGNvbnN0IHB1YiA9IEVjZHNhVXRpbHMuZ2V0UHVibGljS2V5RnJvbUNvbW1vbktleWNoYWluKGNvbW1vbktleWNoYWluKTtcbiAgICBjb25zdCBzZWNwMjU2azEgPSBuZXcgZWMoJ3NlY3AyNTZrMScpO1xuICAgIGNvbnN0IGtleSA9IHNlY3AyNTZrMS5rZXlGcm9tUHVibGljKHB1YiwgJ2hleCcpO1xuICAgIHJldHVybiBrZXkuZ2V0UHVibGljKCkuZW5jb2RlKCdoZXgnLCBmYWxzZSkuc2xpY2UoMik7XG4gIH1cbn1cbiJdfQ==