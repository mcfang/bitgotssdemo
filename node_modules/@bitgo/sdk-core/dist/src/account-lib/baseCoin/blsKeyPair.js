"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlsKeyPair = void 0;
const assert_1 = __importDefault(require("assert"));
const crypto_1 = require("crypto");
const BLS = __importStar(require("@bitgo/bls-dkg"));
const errors_1 = require("./errors");
const iface_1 = require("./iface");
const crypto_2 = require("../util/crypto");
const DEFAULT_SIGNATURE_THRESHOLD = 2;
const DEFAULT_SIGNATURE_PARTICIPANTS = 3;
/**
 * Base class for BLS keypairs.
 */
class BlsKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random polynomial.
     *
     * @param {KeyPairOptions} source Either a dkg options, a public and secret shares, or a private key
     */
    constructor(source) {
        if (!source) {
            this.createShares(DEFAULT_SIGNATURE_THRESHOLD, DEFAULT_SIGNATURE_PARTICIPANTS);
        }
        else if (iface_1.isDkg(source)) {
            this.createShares(source.threshold, source.participants);
        }
        else if (iface_1.isBlsKey(source)) {
            assert_1.default(source.secretShares.every(crypto_2.isValidBLSPrivateKey), 'Invalid private keys');
            assert_1.default(crypto_2.isValidBLSPublicKey(source.publicShare), 'Invalid public key');
            this.keyPair = source;
        }
        else if (iface_1.isPrivateKey(source)) {
            this.keyPair = {
                prv: source.prv,
                publicShare: '',
                secretShares: [],
                seed: '',
                chaincode: '',
            };
        }
        else {
            throw new Error('Invalid key pair options');
        }
    }
    createShares(threshold, participants) {
        if (participants < threshold) {
            throw new Error('Participants should be greater than threshold');
        }
        const polynomial = BLS.generatePolynomial(threshold);
        const keySecretShares = BLS.secretShares(polynomial, participants);
        const keyPublicShare = BLS.publicShare(polynomial);
        this.keyPair = {
            seed: crypto_2.bigIntToHex(polynomial[0], 64),
            chaincode: crypto_1.randomBytes(32).toString('hex'),
            secretShares: keySecretShares.map((secretShare) => crypto_2.bigIntToHex(secretShare, 64)),
            publicShare: crypto_2.bigIntToHex(keyPublicShare),
        };
    }
    /**
     * Note - this is not possible using BLS. BLS does not support prvkey derived key gen
     *
     * @param {string[]} prv a hexadecimal private key
     */
    recordKeysFromPrivateKey(prv) {
        throw new errors_1.NotImplementedError('Private key derivation is not supported in bls');
    }
    /**
     * Note - this is not possible using BLS. BLS does not support pubkey derived key gen
     *
     * @param {string} pub - An extended, compressed, or uncompressed public key
     */
    recordKeysFromPublicKey(pub) {
        throw new errors_1.NotImplementedError('Public key derivation is not supported in bls');
    }
    getAddress(format) {
        throw new errors_1.NotImplementedError('getAddress not implemented');
    }
    getKeys() {
        throw new errors_1.NotImplementedError('getKeys not implemented');
    }
    /**
     * Signs bytes using the key pair
     *
     * @param msg The message bytes to sign
     * @return signature of the bytes using this keypair
     */
    async sign(msg) {
        if (this.keyPair.prv) {
            const signedMessage = await BLS.sign(msg, BigInt('0x' + this.keyPair.prv));
            return '0x' + crypto_2.bigIntToHex(signedMessage);
        }
        throw new Error('Missing private key');
    }
    static keyDerive(seed, pk, chaincode, path) {
        const seedBI = BigInt('0x' + seed);
        const pkBI = BigInt('0x' + pk);
        const chaincodeBI = BigInt('0x' + chaincode);
        const childKey = BLS.privateDerive(seedBI, pkBI, chaincodeBI, path);
        const childChaincode = crypto_2.bigIntToHex(childKey.chaincode);
        const entropy = BigInt('0x' + crypto_1.randomBytes(32).toString('hex'));
        const secretShares = BLS.secretShares([childKey.sk, entropy], DEFAULT_SIGNATURE_PARTICIPANTS);
        const publicShare = BLS.publicShare([childKey.sk]);
        return {
            seed,
            chaincode: childChaincode,
            secretShares: secretShares.map((secretShare) => crypto_2.bigIntToHex(secretShare)),
            publicShare: crypto_2.bigIntToHex(publicShare),
        };
    }
    /**
     * Aggregates the secret shares of different key pairs into one private key
     *
     * @param prvKeys an array of secret shares
     * @returns a private key
     */
    static aggregatePrvkeys(prvKeys) {
        assert_1.default(prvKeys.every(crypto_2.isValidBLSPrivateKey), 'Invalid private keys');
        try {
            const secretShares = prvKeys.map((secretShare) => BigInt('0x' + secretShare));
            const prv = BLS.mergeSecretShares(secretShares);
            return crypto_2.bigIntToHex(prv);
        }
        catch (e) {
            throw new Error('Error aggregating prvkeys: ' + e);
        }
    }
    /**
     * Aggregates the public shares of different key pairs into a common public key
     *
     * @param pubKeys an array of public shares
     * @returns a common public key
     */
    static aggregatePubkeys(pubKeys) {
        try {
            const publicShares = pubKeys.map((publicShare) => BigInt('0x' + publicShare));
            const commonPubKey = BLS.mergePublicShares(publicShares);
            return crypto_2.bigIntToHex(commonPubKey);
        }
        catch (e) {
            throw new Error('Error aggregating pubkeys: ' + e);
        }
    }
    static aggregateChaincodes(chaincodeContributions) {
        try {
            const chaincodes = chaincodeContributions.map((chaincode) => BigInt('0x' + chaincode));
            const commonChaincode = BLS.mergeChaincodes(chaincodes);
            return crypto_2.bigIntToHex(commonChaincode, 64);
        }
        catch (e) {
            throw new Error('Error aggregating chaincodes: ' + e);
        }
    }
    /**
     * Aggregates the message signed by different key pairs into one sign
     *
     * @param signatures the message signed by different key pairs. The signer id is relevant to ensure a valid signature.
     * @example <caption> E.g., the message is signed by user and wallet, then signatures would be:</caption>
     * {
     *   1: BigInt(messageSignedWithUserPrv),
     *   3: BigInt(messageSignedWithWalletPrv),
     * }
     * @returns a signature combining all the provided signed messages
     */
    static aggregateSignatures(signatures) {
        try {
            const signature = BLS.mergeSignatures(signatures);
            return '0x' + crypto_2.bigIntToHex(signature);
        }
        catch (e) {
            throw new Error('Error aggregating signatures: ' + e);
        }
    }
    /**
     * Verifies the signature for this key pair
     * @param pub The public key with which to verify the signature
     * @param msg The message to verify the signature with
     * @param signature the signature to verify
     * @return true if the signature is valid, else false
     */
    static async verifySignature(pub, msg, signature) {
        assert_1.default(crypto_2.isValidBLSPublicKey(pub), `Invalid public key: ${pub}`);
        return await BLS.verify(BigInt(signature), msg, BigInt('0x' + pub));
    }
}
exports.BlsKeyPair = BlsKeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxzS2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hY2NvdW50LWxpYi9iYXNlQ29pbi9ibHNLZXlQYWlyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvREFBNEI7QUFDNUIsbUNBQXFDO0FBQ3JDLG9EQUFzQztBQUd0QyxxQ0FBK0M7QUFDL0MsbUNBQWlGO0FBQ2pGLDJDQUF3RjtBQUV4RixNQUFNLDJCQUEyQixHQUFHLENBQUMsQ0FBQztBQUN0QyxNQUFNLDhCQUE4QixHQUFHLENBQUMsQ0FBQztBQUV6Qzs7R0FFRztBQUNILE1BQXNCLFVBQVU7SUFHOUI7Ozs7T0FJRztJQUNILFlBQXNCLE1BQXVCO1FBQzNDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxJQUFJLENBQUMsWUFBWSxDQUFDLDJCQUEyQixFQUFFLDhCQUE4QixDQUFDLENBQUM7U0FDaEY7YUFBTSxJQUFJLGFBQUssQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQzFEO2FBQU0sSUFBSSxnQkFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzNCLGdCQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsNkJBQW9CLENBQUMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ2hGLGdCQUFNLENBQUMsNEJBQW1CLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxFQUFFLG9CQUFvQixDQUFDLENBQUM7WUFDdEUsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7U0FDdkI7YUFBTSxJQUFJLG9CQUFZLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDL0IsSUFBSSxDQUFDLE9BQU8sR0FBRztnQkFDYixHQUFHLEVBQUUsTUFBTSxDQUFDLEdBQUc7Z0JBQ2YsV0FBVyxF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QU1HO0lBQ0ksTUFBTSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsR0FBVyxFQUFFLEdBQVcsRUFBRSxTQUFpQjtRQUM3RSxnQkFBTSxDQUFDLDRCQUFtQixDQUFDLEdBQUcsQ0FBQyxFQUFFLHVCQUF1QixHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBQy9ELE9BQU8sTUFBTSxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUUsTUFBTSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7Q0FDRjtBQWhMRCxnQ0FnTEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgKiBhcyBCTFMgZnJvbSAnQGJpdGdvL2Jscy1ka2cnO1xuaW1wb3J0IHsgQmFzZUtleVBhaXIgfSBmcm9tICcuL2Jhc2VLZXlQYWlyJztcbmltcG9ydCB7IEFkZHJlc3NGb3JtYXQgfSBmcm9tICcuL2VudW0nO1xuaW1wb3J0IHsgTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IEJsc0tleXMsIEtleVBhaXJPcHRpb25zLCBpc0RrZywgaXNCbHNLZXksIGlzUHJpdmF0ZUtleSB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgaXNWYWxpZEJMU1B1YmxpY0tleSwgaXNWYWxpZEJMU1ByaXZhdGVLZXksIGJpZ0ludFRvSGV4IH0gZnJvbSAnLi4vdXRpbC9jcnlwdG8nO1xuXG5jb25zdCBERUZBVUxUX1NJR05BVFVSRV9USFJFU0hPTEQgPSAyO1xuY29uc3QgREVGQVVMVF9TSUdOQVRVUkVfUEFSVElDSVBBTlRTID0gMztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBCTFMga2V5cGFpcnMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCbHNLZXlQYWlyIGltcGxlbWVudHMgQmFzZUtleVBhaXIge1xuICBwcm90ZWN0ZWQga2V5UGFpcjogQmxzS2V5cztcblxuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLiBCeSBkZWZhdWx0LCBjcmVhdGVzIGEga2V5IHBhaXIgd2l0aCBhIHJhbmRvbSBwb2x5bm9taWFsLlxuICAgKlxuICAgKiBAcGFyYW0ge0tleVBhaXJPcHRpb25zfSBzb3VyY2UgRWl0aGVyIGEgZGtnIG9wdGlvbnMsIGEgcHVibGljIGFuZCBzZWNyZXQgc2hhcmVzLCBvciBhIHByaXZhdGUga2V5XG4gICAqL1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3Ioc291cmNlPzogS2V5UGFpck9wdGlvbnMpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgdGhpcy5jcmVhdGVTaGFyZXMoREVGQVVMVF9TSUdOQVRVUkVfVEhSRVNIT0xELCBERUZBVUxUX1NJR05BVFVSRV9QQVJUSUNJUEFOVFMpO1xuICAgIH0gZWxzZSBpZiAoaXNEa2coc291cmNlKSkge1xuICAgICAgdGhpcy5jcmVhdGVTaGFyZXMoc291cmNlLnRocmVzaG9sZCwgc291cmNlLnBhcnRpY2lwYW50cyk7XG4gICAgfSBlbHNlIGlmIChpc0Jsc0tleShzb3VyY2UpKSB7XG4gICAgICBhc3NlcnQoc291cmNlLnNlY3JldFNoYXJlcy5ldmVyeShpc1ZhbGlkQkxTUHJpdmF0ZUtleSksICdJbnZhbGlkIHByaXZhdGUga2V5cycpO1xuICAgICAgYXNzZXJ0KGlzVmFsaWRCTFNQdWJsaWNLZXkoc291cmNlLnB1YmxpY1NoYXJlKSwgJ0ludmFsaWQgcHVibGljIGtleScpO1xuICAgICAgdGhpcy5rZXlQYWlyID0gc291cmNlO1xuICAgIH0gZWxzZSBpZiAoaXNQcml2YXRlS2V5KHNvdXJjZSkpIHtcbiAgICAgIHRoaXMua2V5UGFpciA9IHtcbiAgICAgICAgcHJ2OiBzb3VyY2UucHJ2LFxuICAgICAgICBwdWJsaWNTaGFyZTogJycsXG4gICAgICAgIHNlY3JldFNoYXJlczogW10sXG4gICAgICAgIHNlZWQ6ICcnLFxuICAgICAgICBjaGFpbmNvZGU6ICcnLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYWlyIG9wdGlvbnMnKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGVTaGFyZXModGhyZXNob2xkOiBudW1iZXIsIHBhcnRpY2lwYW50czogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKHBhcnRpY2lwYW50cyA8IHRocmVzaG9sZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0aWNpcGFudHMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB0aHJlc2hvbGQnKTtcbiAgICB9XG4gICAgY29uc3QgcG9seW5vbWlhbCA9IEJMUy5nZW5lcmF0ZVBvbHlub21pYWwodGhyZXNob2xkKTtcbiAgICBjb25zdCBrZXlTZWNyZXRTaGFyZXMgPSBCTFMuc2VjcmV0U2hhcmVzKHBvbHlub21pYWwsIHBhcnRpY2lwYW50cyk7XG4gICAgY29uc3Qga2V5UHVibGljU2hhcmUgPSBCTFMucHVibGljU2hhcmUocG9seW5vbWlhbCk7XG4gICAgdGhpcy5rZXlQYWlyID0ge1xuICAgICAgc2VlZDogYmlnSW50VG9IZXgocG9seW5vbWlhbFswXSwgNjQpLFxuICAgICAgY2hhaW5jb2RlOiByYW5kb21CeXRlcygzMikudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgc2VjcmV0U2hhcmVzOiBrZXlTZWNyZXRTaGFyZXMubWFwKChzZWNyZXRTaGFyZSkgPT4gYmlnSW50VG9IZXgoc2VjcmV0U2hhcmUsIDY0KSksXG4gICAgICBwdWJsaWNTaGFyZTogYmlnSW50VG9IZXgoa2V5UHVibGljU2hhcmUpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTm90ZSAtIHRoaXMgaXMgbm90IHBvc3NpYmxlIHVzaW5nIEJMUy4gQkxTIGRvZXMgbm90IHN1cHBvcnQgcHJ2a2V5IGRlcml2ZWQga2V5IGdlblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwcnYgYSBoZXhhZGVjaW1hbCBwcml2YXRlIGtleVxuICAgKi9cbiAgcmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5KHBydjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ1ByaXZhdGUga2V5IGRlcml2YXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiBibHMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RlIC0gdGhpcyBpcyBub3QgcG9zc2libGUgdXNpbmcgQkxTLiBCTFMgZG9lcyBub3Qgc3VwcG9ydCBwdWJrZXkgZGVyaXZlZCBrZXkgZ2VuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWIgLSBBbiBleHRlbmRlZCwgY29tcHJlc3NlZCwgb3IgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlcbiAgICovXG4gIHJlY29yZEtleXNGcm9tUHVibGljS2V5KHB1Yjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ1B1YmxpYyBrZXkgZGVyaXZhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIGJscycpO1xuICB9XG5cbiAgZ2V0QWRkcmVzcyhmb3JtYXQ/OiBBZGRyZXNzRm9ybWF0KTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignZ2V0QWRkcmVzcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIGdldEtleXMoKTogYW55IHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignZ2V0S2V5cyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWducyBieXRlcyB1c2luZyB0aGUga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIG1zZyBUaGUgbWVzc2FnZSBieXRlcyB0byBzaWduXG4gICAqIEByZXR1cm4gc2lnbmF0dXJlIG9mIHRoZSBieXRlcyB1c2luZyB0aGlzIGtleXBhaXJcbiAgICovXG4gIGFzeW5jIHNpZ24obXNnOiBCdWZmZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICh0aGlzLmtleVBhaXIucHJ2KSB7XG4gICAgICBjb25zdCBzaWduZWRNZXNzYWdlID0gYXdhaXQgQkxTLnNpZ24obXNnLCBCaWdJbnQoJzB4JyArIHRoaXMua2V5UGFpci5wcnYpKTtcbiAgICAgIHJldHVybiAnMHgnICsgYmlnSW50VG9IZXgoc2lnbmVkTWVzc2FnZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlIGtleScpO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBrZXlEZXJpdmUoc2VlZDogc3RyaW5nLCBwazogc3RyaW5nLCBjaGFpbmNvZGU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogQmxzS2V5cyB7XG4gICAgY29uc3Qgc2VlZEJJID0gQmlnSW50KCcweCcgKyBzZWVkKTtcbiAgICBjb25zdCBwa0JJID0gQmlnSW50KCcweCcgKyBwayk7XG4gICAgY29uc3QgY2hhaW5jb2RlQkkgPSBCaWdJbnQoJzB4JyArIGNoYWluY29kZSk7XG4gICAgY29uc3QgY2hpbGRLZXkgPSBCTFMucHJpdmF0ZURlcml2ZShzZWVkQkksIHBrQkksIGNoYWluY29kZUJJLCBwYXRoKTtcbiAgICBjb25zdCBjaGlsZENoYWluY29kZSA9IGJpZ0ludFRvSGV4KGNoaWxkS2V5LmNoYWluY29kZSk7XG4gICAgY29uc3QgZW50cm9weSA9IEJpZ0ludCgnMHgnICsgcmFuZG9tQnl0ZXMoMzIpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgY29uc3Qgc2VjcmV0U2hhcmVzID0gQkxTLnNlY3JldFNoYXJlcyhbY2hpbGRLZXkuc2ssIGVudHJvcHldLCBERUZBVUxUX1NJR05BVFVSRV9QQVJUSUNJUEFOVFMpO1xuICAgIGNvbnN0IHB1YmxpY1NoYXJlID0gQkxTLnB1YmxpY1NoYXJlKFtjaGlsZEtleS5za10pO1xuICAgIHJldHVybiB7XG4gICAgICBzZWVkLFxuICAgICAgY2hhaW5jb2RlOiBjaGlsZENoYWluY29kZSxcbiAgICAgIHNlY3JldFNoYXJlczogc2VjcmV0U2hhcmVzLm1hcCgoc2VjcmV0U2hhcmUpID0+IGJpZ0ludFRvSGV4KHNlY3JldFNoYXJlKSksXG4gICAgICBwdWJsaWNTaGFyZTogYmlnSW50VG9IZXgocHVibGljU2hhcmUpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQWdncmVnYXRlcyB0aGUgc2VjcmV0IHNoYXJlcyBvZiBkaWZmZXJlbnQga2V5IHBhaXJzIGludG8gb25lIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBwcnZLZXlzIGFuIGFycmF5IG9mIHNlY3JldCBzaGFyZXNcbiAgICogQHJldHVybnMgYSBwcml2YXRlIGtleVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhZ2dyZWdhdGVQcnZrZXlzKHBydktleXM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICBhc3NlcnQocHJ2S2V5cy5ldmVyeShpc1ZhbGlkQkxTUHJpdmF0ZUtleSksICdJbnZhbGlkIHByaXZhdGUga2V5cycpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZWNyZXRTaGFyZXMgPSBwcnZLZXlzLm1hcCgoc2VjcmV0U2hhcmUpID0+IEJpZ0ludCgnMHgnICsgc2VjcmV0U2hhcmUpKTtcbiAgICAgIGNvbnN0IHBydiA9IEJMUy5tZXJnZVNlY3JldFNoYXJlcyhzZWNyZXRTaGFyZXMpO1xuICAgICAgcmV0dXJuIGJpZ0ludFRvSGV4KHBydik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZ2dyZWdhdGluZyBwcnZrZXlzOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFnZ3JlZ2F0ZXMgdGhlIHB1YmxpYyBzaGFyZXMgb2YgZGlmZmVyZW50IGtleSBwYWlycyBpbnRvIGEgY29tbW9uIHB1YmxpYyBrZXlcbiAgICpcbiAgICogQHBhcmFtIHB1YktleXMgYW4gYXJyYXkgb2YgcHVibGljIHNoYXJlc1xuICAgKiBAcmV0dXJucyBhIGNvbW1vbiBwdWJsaWMga2V5XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFnZ3JlZ2F0ZVB1YmtleXMocHViS2V5czogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwdWJsaWNTaGFyZXMgPSBwdWJLZXlzLm1hcCgocHVibGljU2hhcmUpID0+IEJpZ0ludCgnMHgnICsgcHVibGljU2hhcmUpKTtcbiAgICAgIGNvbnN0IGNvbW1vblB1YktleSA9IEJMUy5tZXJnZVB1YmxpY1NoYXJlcyhwdWJsaWNTaGFyZXMpO1xuICAgICAgcmV0dXJuIGJpZ0ludFRvSGV4KGNvbW1vblB1YktleSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZ2dyZWdhdGluZyBwdWJrZXlzOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhZ2dyZWdhdGVDaGFpbmNvZGVzKGNoYWluY29kZUNvbnRyaWJ1dGlvbnM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2hhaW5jb2RlcyA9IGNoYWluY29kZUNvbnRyaWJ1dGlvbnMubWFwKChjaGFpbmNvZGUpID0+IEJpZ0ludCgnMHgnICsgY2hhaW5jb2RlKSk7XG4gICAgICBjb25zdCBjb21tb25DaGFpbmNvZGUgPSBCTFMubWVyZ2VDaGFpbmNvZGVzKGNoYWluY29kZXMpO1xuICAgICAgcmV0dXJuIGJpZ0ludFRvSGV4KGNvbW1vbkNoYWluY29kZSwgNjQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWdncmVnYXRpbmcgY2hhaW5jb2RlczogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZ2dyZWdhdGVzIHRoZSBtZXNzYWdlIHNpZ25lZCBieSBkaWZmZXJlbnQga2V5IHBhaXJzIGludG8gb25lIHNpZ25cbiAgICpcbiAgICogQHBhcmFtIHNpZ25hdHVyZXMgdGhlIG1lc3NhZ2Ugc2lnbmVkIGJ5IGRpZmZlcmVudCBrZXkgcGFpcnMuIFRoZSBzaWduZXIgaWQgaXMgcmVsZXZhbnQgdG8gZW5zdXJlIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj4gRS5nLiwgdGhlIG1lc3NhZ2UgaXMgc2lnbmVkIGJ5IHVzZXIgYW5kIHdhbGxldCwgdGhlbiBzaWduYXR1cmVzIHdvdWxkIGJlOjwvY2FwdGlvbj5cbiAgICoge1xuICAgKiAgIDE6IEJpZ0ludChtZXNzYWdlU2lnbmVkV2l0aFVzZXJQcnYpLFxuICAgKiAgIDM6IEJpZ0ludChtZXNzYWdlU2lnbmVkV2l0aFdhbGxldFBydiksXG4gICAqIH1cbiAgICogQHJldHVybnMgYSBzaWduYXR1cmUgY29tYmluaW5nIGFsbCB0aGUgcHJvdmlkZWQgc2lnbmVkIG1lc3NhZ2VzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFnZ3JlZ2F0ZVNpZ25hdHVyZXMoc2lnbmF0dXJlczogeyBbbjogbnVtYmVyXTogYmlnaW50IH0pOiBzdHJpbmcge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBCTFMubWVyZ2VTaWduYXR1cmVzKHNpZ25hdHVyZXMpO1xuICAgICAgcmV0dXJuICcweCcgKyBiaWdJbnRUb0hleChzaWduYXR1cmUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWdncmVnYXRpbmcgc2lnbmF0dXJlczogJyArIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgc2lnbmF0dXJlIGZvciB0aGlzIGtleSBwYWlyXG4gICAqIEBwYXJhbSBwdWIgVGhlIHB1YmxpYyBrZXkgd2l0aCB3aGljaCB0byB2ZXJpZnkgdGhlIHNpZ25hdHVyZVxuICAgKiBAcGFyYW0gbXNnIFRoZSBtZXNzYWdlIHRvIHZlcmlmeSB0aGUgc2lnbmF0dXJlIHdpdGhcbiAgICogQHBhcmFtIHNpZ25hdHVyZSB0aGUgc2lnbmF0dXJlIHRvIHZlcmlmeVxuICAgKiBAcmV0dXJuIHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyB2YWxpZCwgZWxzZSBmYWxzZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyB2ZXJpZnlTaWduYXR1cmUocHViOiBzdHJpbmcsIG1zZzogQnVmZmVyLCBzaWduYXR1cmU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGFzc2VydChpc1ZhbGlkQkxTUHVibGljS2V5KHB1YiksIGBJbnZhbGlkIHB1YmxpYyBrZXk6ICR7cHVifWApO1xuICAgIHJldHVybiBhd2FpdCBCTFMudmVyaWZ5KEJpZ0ludChzaWduYXR1cmUpLCBtc2csIEJpZ0ludCgnMHgnICsgcHViKSk7XG4gIH1cbn1cbiJdfQ==