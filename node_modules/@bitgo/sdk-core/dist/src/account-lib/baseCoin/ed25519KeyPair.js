"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519KeyPair = void 0;
const nacl = __importStar(require("tweetnacl"));
const crypto_1 = require("../util/crypto");
const ed25519KeyDeriver_1 = require("../util/ed25519KeyDeriver");
const iface_1 = require("./iface");
const DEFAULT_SEED_SIZE_BYTES = 32;
class Ed25519KeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param {KeyPairOptions} source Either a master seed, a private key, or a public key
     */
    constructor(source) {
        let naclKeyPair;
        if (!source) {
            const seed = nacl.randomBytes(DEFAULT_SEED_SIZE_BYTES);
            naclKeyPair = nacl.sign.keyPair.fromSeed(seed);
            this.setKeyPair(naclKeyPair);
        }
        else if (iface_1.isSeed(source)) {
            naclKeyPair = nacl.sign.keyPair.fromSeed(source.seed);
            this.setKeyPair(naclKeyPair);
        }
        else if (iface_1.isPrivateKey(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if (iface_1.isPublicKey(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
    }
    getKeyPair(naclKeyPair) {
        return {
            prv: crypto_1.toHex(naclKeyPair.secretKey.slice(0, 32)),
            pub: crypto_1.toHex(naclKeyPair.publicKey),
        };
    }
    setKeyPair(naclKeyPair) {
        this.keyPair = this.getKeyPair(naclKeyPair);
    }
    /** @inheritdoc */
    recordKeysFromPrivateKey(prv) {
        if (crypto_1.isValidEd25519Seed(prv)) {
            const decodedPrv = crypto_1.toUint8Array(prv);
            const naclKeyPair = nacl.sign.keyPair.fromSeed(decodedPrv);
            this.setKeyPair(naclKeyPair);
        }
        else if (crypto_1.isValidEd25519SecretKey(prv)) {
            const decodedPrv = crypto_1.toUint8Array(prv);
            const naclKeyPair = nacl.sign.keyPair.fromSecretKey(decodedPrv);
            this.setKeyPair(naclKeyPair);
        }
        else {
            this.keyPair = this.recordKeysFromPrivateKeyInProtocolFormat(prv);
        }
    }
    /** @inheritdoc */
    recordKeysFromPublicKey(pub) {
        if (crypto_1.isValidEd25519PublicKey(pub)) {
            this.keyPair = { pub };
        }
        else {
            this.keyPair = this.recordKeysFromPublicKeyInProtocolFormat(pub);
        }
    }
    /**
     * Generates a signature for an arbitrary string with the current private key using the ed25519 public-key signature
     * system.
     *
     * @param {string} message to produce a signature for
     * @returns {Uint8Array} The signature produced for the message
     * @throws if there is no private key
     */
    signMessage(message) {
        var _a;
        const messageToSign = crypto_1.toUint8Array(Buffer.from(message).toString('hex'));
        const prv = (_a = this.keyPair) === null || _a === void 0 ? void 0 : _a.prv;
        if (!prv) {
            throw new Error('Missing private key');
        }
        return nacl.sign.detached(messageToSign, nacl.sign.keyPair.fromSeed(crypto_1.toUint8Array(prv)).secretKey);
    }
    /**
     * Verifies a message signature using the current public key.
     *
     * @param {string} message signed
     * @param {Uint8Array} signature to verify
     * @returns {boolean} True if the message was signed with the current key pair
     */
    verifySignature(message, signature) {
        var _a;
        let messageToVerify;
        if (typeof message === 'string') {
            messageToVerify = crypto_1.toUint8Array(Buffer.from(message).toString('hex'));
        }
        else {
            messageToVerify = message;
        }
        if (!((_a = this.keyPair) === null || _a === void 0 ? void 0 : _a.pub)) {
            return false;
        }
        const publicKey = crypto_1.toUint8Array(this.keyPair.pub);
        return nacl.sign.detached.verify(messageToVerify, signature, publicKey);
    }
    /**
     * Derives a hardened child key pair using this key pair's secret key
     * as the seed.
     *
     * @param path derivation path
     */
    deriveHardened(path) {
        var _a;
        if (!((_a = this.keyPair) === null || _a === void 0 ? void 0 : _a.prv)) {
            throw new Error('need private key to derive hardened keypair');
        }
        const seed = ed25519KeyDeriver_1.Ed25519KeyDeriver.derivePath(path, this.keyPair.prv).key;
        const derivedKeyPair = nacl.sign.keyPair.fromSeed(seed);
        return this.getKeyPair(derivedKeyPair);
    }
}
exports.Ed25519KeyPair = Ed25519KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWQyNTUxOUtleVBhaXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYWNjb3VudC1saWIvYmFzZUNvaW4vZWQyNTUxOUtleVBhaXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdEQUFrQztBQUNsQywyQ0FNd0I7QUFDeEIsaUVBQThEO0FBRzlELG1DQUF5RjtBQUV6RixNQUFNLHVCQUF1QixHQUFHLEVBQUUsQ0FBQztBQUVuQyxNQUFzQixjQUFjO0lBSWxDOzs7O09BSUc7SUFDSCxZQUFzQixNQUF1QjtRQUMzQyxJQUFJLFdBQVcsQ0FBQztRQUNoQixJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ1gsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ3ZELFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDL0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUM5QjthQUFNLElBQUksY0FBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3pCLFdBQVcsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3RELElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDOUI7YUFBTSxJQUFJLG9CQUFZLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDL0IsSUFBSSxDQUFDLHdCQUF3QixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksbUJBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsdUJBQXVCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzFDO2FBQU07WUFDTCxNQUFNLElBQUksS0FB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LFNBQVMsR0FBRyxxQkFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDakQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUMxRSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxjQUFjLENBQUMsSUFBWTs7UUFDekIsSUFBSSxDQUFDLENBQUEsTUFBQSxJQUFJLENBQUMsT0FBTywwQ0FBRSxHQUFHLENBQUEsRUFBRTtZQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7U0FDaEU7UUFFRCxNQUFNLElBQUksR0FBRyxxQ0FBaUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ3RFLE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV4RCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDekMsQ0FBQztDQUNGO0FBOUhELHdDQThIQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG5hY2wgZnJvbSAndHdlZXRuYWNsJztcbmltcG9ydCB7XG4gIGlzVmFsaWRFZDI1NTE5UHVibGljS2V5LFxuICBpc1ZhbGlkRWQyNTUxOVNlY3JldEtleSxcbiAgaXNWYWxpZEVkMjU1MTlTZWVkLFxuICB0b0hleCxcbiAgdG9VaW50OEFycmF5LFxufSBmcm9tICcuLi91dGlsL2NyeXB0byc7XG5pbXBvcnQgeyBFZDI1NTE5S2V5RGVyaXZlciB9IGZyb20gJy4uL3V0aWwvZWQyNTUxOUtleURlcml2ZXInO1xuaW1wb3J0IHsgQmFzZUtleVBhaXIgfSBmcm9tICcuL2Jhc2VLZXlQYWlyJztcbmltcG9ydCB7IEFkZHJlc3NGb3JtYXQsIERvdEFkZHJlc3NGb3JtYXQgfSBmcm9tICcuL2VudW0nO1xuaW1wb3J0IHsgaXNQcml2YXRlS2V5LCBpc1B1YmxpY0tleSwgaXNTZWVkLCBEZWZhdWx0S2V5cywgS2V5UGFpck9wdGlvbnMgfSBmcm9tICcuL2lmYWNlJztcblxuY29uc3QgREVGQVVMVF9TRUVEX1NJWkVfQllURVMgPSAzMjtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEVkMjU1MTlLZXlQYWlyIGltcGxlbWVudHMgQmFzZUtleVBhaXIge1xuICBwcm90ZWN0ZWQga2V5UGFpcjogRGVmYXVsdEtleXM7XG4gIHByb3RlY3RlZCBzb3VyY2U/OiBLZXlQYWlyT3B0aW9ucztcblxuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLiBCeSBkZWZhdWx0LCBjcmVhdGVzIGEga2V5IHBhaXIgd2l0aCBhIHJhbmRvbSBtYXN0ZXIgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlQYWlyT3B0aW9uc30gc291cmNlIEVpdGhlciBhIG1hc3RlciBzZWVkLCBhIHByaXZhdGUga2V5LCBvciBhIHB1YmxpYyBrZXlcbiAgICovXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihzb3VyY2U/OiBLZXlQYWlyT3B0aW9ucykge1xuICAgIGxldCBuYWNsS2V5UGFpcjtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgY29uc3Qgc2VlZCA9IG5hY2wucmFuZG9tQnl0ZXMoREVGQVVMVF9TRUVEX1NJWkVfQllURVMpO1xuICAgICAgbmFjbEtleVBhaXIgPSBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZChzZWVkKTtcbiAgICAgIHRoaXMuc2V0S2V5UGFpcihuYWNsS2V5UGFpcik7XG4gICAgfSBlbHNlIGlmIChpc1NlZWQoc291cmNlKSkge1xuICAgICAgbmFjbEtleVBhaXIgPSBuYWNsLnNpZ24ua2V5UGFpci5mcm9tU2VlZChzb3VyY2Uuc2VlZCk7XG4gICAgICB0aGlzLnNldEtleVBhaXIobmFjbEtleVBhaXIpO1xuICAgIH0gZWxzZSBpZiAoaXNQcml2YXRlS2V5KHNvdXJjZSkpIHtcbiAgICAgIHRoaXMucmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5KHNvdXJjZS5wcnYpO1xuICAgIH0gZWxzZSBpZiAoaXNQdWJsaWNLZXkoc291cmNlKSkge1xuICAgICAgdGhpcy5yZWNvcmRLZXlzRnJvbVB1YmxpY0tleShzb3VyY2UucHViKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYWlyIG9wdGlvbnMnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEtleVBhaXIobmFjbEtleVBhaXI6IG5hY2wuU2lnbktleVBhaXIpOiBEZWZhdWx0S2V5cyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBydjogdG9IZXgobmFjbEtleVBhaXIuc2VjcmV0S2V5LnNsaWNlKDAsIDMyKSksXG4gICAgICBwdWI6IHRvSGV4KG5hY2xLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0S2V5UGFpcihuYWNsS2V5UGFpcjogbmFjbC5TaWduS2V5UGFpcik6IHZvaWQge1xuICAgIHRoaXMua2V5UGFpciA9IHRoaXMuZ2V0S2V5UGFpcihuYWNsS2V5UGFpcik7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5KHBydjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKGlzVmFsaWRFZDI1NTE5U2VlZChwcnYpKSB7XG4gICAgICBjb25zdCBkZWNvZGVkUHJ2ID0gdG9VaW50OEFycmF5KHBydik7XG4gICAgICBjb25zdCBuYWNsS2V5UGFpciA9IG5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWVkKGRlY29kZWRQcnYpO1xuICAgICAgdGhpcy5zZXRLZXlQYWlyKG5hY2xLZXlQYWlyKTtcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFZDI1NTE5U2VjcmV0S2V5KHBydikpIHtcbiAgICAgIGNvbnN0IGRlY29kZWRQcnYgPSB0b1VpbnQ4QXJyYXkocHJ2KTtcbiAgICAgIGNvbnN0IG5hY2xLZXlQYWlyID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlY3JldEtleShkZWNvZGVkUHJ2KTtcbiAgICAgIHRoaXMuc2V0S2V5UGFpcihuYWNsS2V5UGFpcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5UGFpciA9IHRoaXMucmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5SW5Qcm90b2NvbEZvcm1hdChwcnYpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICByZWNvcmRLZXlzRnJvbVB1YmxpY0tleShwdWI6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShwdWIpKSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSB7IHB1YiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleVBhaXIgPSB0aGlzLnJlY29yZEtleXNGcm9tUHVibGljS2V5SW5Qcm90b2NvbEZvcm1hdChwdWIpO1xuICAgIH1cbiAgfVxuXG4gIGFic3RyYWN0IHJlY29yZEtleXNGcm9tUHJpdmF0ZUtleUluUHJvdG9jb2xGb3JtYXQocHJ2OiBzdHJpbmcpOiBEZWZhdWx0S2V5cztcblxuICBhYnN0cmFjdCByZWNvcmRLZXlzRnJvbVB1YmxpY0tleUluUHJvdG9jb2xGb3JtYXQocHViOiBzdHJpbmcpOiBEZWZhdWx0S2V5cztcblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgYWJzdHJhY3QgZ2V0QWRkcmVzcyhmb3JtYXQ/OiBBZGRyZXNzRm9ybWF0IHwgRG90QWRkcmVzc0Zvcm1hdCk6IHN0cmluZztcblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgYWJzdHJhY3QgZ2V0S2V5cygpOiBhbnk7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHNpZ25hdHVyZSBmb3IgYW4gYXJiaXRyYXJ5IHN0cmluZyB3aXRoIHRoZSBjdXJyZW50IHByaXZhdGUga2V5IHVzaW5nIHRoZSBlZDI1NTE5IHB1YmxpYy1rZXkgc2lnbmF0dXJlXG4gICAqIHN5c3RlbS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdG8gcHJvZHVjZSBhIHNpZ25hdHVyZSBmb3JcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFRoZSBzaWduYXR1cmUgcHJvZHVjZWQgZm9yIHRoZSBtZXNzYWdlXG4gICAqIEB0aHJvd3MgaWYgdGhlcmUgaXMgbm8gcHJpdmF0ZSBrZXlcbiAgICovXG4gIHNpZ25NZXNzYWdlKG1lc3NhZ2U6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICAgIGNvbnN0IG1lc3NhZ2VUb1NpZ24gPSB0b1VpbnQ4QXJyYXkoQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICBjb25zdCBwcnYgPSB0aGlzLmtleVBhaXI/LnBydjtcbiAgICBpZiAoIXBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIHJldHVybiBuYWNsLnNpZ24uZGV0YWNoZWQobWVzc2FnZVRvU2lnbiwgbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQodG9VaW50OEFycmF5KHBydikpLnNlY3JldEtleSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZpZXMgYSBtZXNzYWdlIHNpZ25hdHVyZSB1c2luZyB0aGUgY3VycmVudCBwdWJsaWMga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBzaWduZWRcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBzaWduYXR1cmUgdG8gdmVyaWZ5XG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBtZXNzYWdlIHdhcyBzaWduZWQgd2l0aCB0aGUgY3VycmVudCBrZXkgcGFpclxuICAgKi9cbiAgdmVyaWZ5U2lnbmF0dXJlKG1lc3NhZ2U6IFVpbnQ4QXJyYXkgfCBzdHJpbmcsIHNpZ25hdHVyZTogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICAgIGxldCBtZXNzYWdlVG9WZXJpZnk7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgbWVzc2FnZVRvVmVyaWZ5ID0gdG9VaW50OEFycmF5KEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCdoZXgnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VUb1ZlcmlmeSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5rZXlQYWlyPy5wdWIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0gdG9VaW50OEFycmF5KHRoaXMua2V5UGFpci5wdWIpO1xuICAgIHJldHVybiBuYWNsLnNpZ24uZGV0YWNoZWQudmVyaWZ5KG1lc3NhZ2VUb1ZlcmlmeSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZXMgYSBoYXJkZW5lZCBjaGlsZCBrZXkgcGFpciB1c2luZyB0aGlzIGtleSBwYWlyJ3Mgc2VjcmV0IGtleVxuICAgKiBhcyB0aGUgc2VlZC5cbiAgICpcbiAgICogQHBhcmFtIHBhdGggZGVyaXZhdGlvbiBwYXRoXG4gICAqL1xuICBkZXJpdmVIYXJkZW5lZChwYXRoOiBzdHJpbmcpOiBEZWZhdWx0S2V5cyB7XG4gICAgaWYgKCF0aGlzLmtleVBhaXI/LnBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkIHByaXZhdGUga2V5IHRvIGRlcml2ZSBoYXJkZW5lZCBrZXlwYWlyJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VlZCA9IEVkMjU1MTlLZXlEZXJpdmVyLmRlcml2ZVBhdGgocGF0aCwgdGhpcy5rZXlQYWlyLnBydikua2V5O1xuICAgIGNvbnN0IGRlcml2ZWRLZXlQYWlyID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQoc2VlZCk7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRLZXlQYWlyKGRlcml2ZWRLZXlQYWlyKTtcbiAgfVxufVxuIl19