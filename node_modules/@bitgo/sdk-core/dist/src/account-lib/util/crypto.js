"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toUint8Array = exports.isBase58 = exports.toHex = exports.isValidBLSPublicKey = exports.isValidBLSPrivateKey = exports.isValidEd25519PublicKey = exports.isValidEd25519SecretKey = exports.isValidEd25519Seed = exports.isValidPrv = exports.isValidPub = exports.isValidXprv = exports.isValidXpub = exports.rawPrvToExtendedKeys = exports.xprvToRawPrv = exports.xpubToCompressedPub = exports.xpubToUncompressedPub = exports.bigIntToHex = exports.hexToBigInt = exports.convertBigIntArrToHexArr = exports.convertHexArrToBigIntArr = void 0;
const utxo_lib_1 = require("@bitgo/utxo-lib");
const nacl = __importStar(require("tweetnacl"));
const hex = __importStar(require("@stablelib/hex"));
const bls = __importStar(require("noble-bls12-381"));
const strip_hex_prefix_1 = __importDefault(require("strip-hex-prefix"));
const bs58_1 = __importDefault(require("bs58"));
/**
 * @deprecated - use @bitgo/sdk-lib-mpc instead
 */
var sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
Object.defineProperty(exports, "convertHexArrToBigIntArr", { enumerable: true, get: function () { return sdk_lib_mpc_1.convertHexArrToBigIntArr; } });
Object.defineProperty(exports, "convertBigIntArrToHexArr", { enumerable: true, get: function () { return sdk_lib_mpc_1.convertBigIntArrToHexArr; } });
Object.defineProperty(exports, "hexToBigInt", { enumerable: true, get: function () { return sdk_lib_mpc_1.hexToBigInt; } });
Object.defineProperty(exports, "bigIntToHex", { enumerable: true, get: function () { return sdk_lib_mpc_1.bigIntToHex; } });
/**
 * @param xpub - a base-58 encoded extended public key (BIP32)
 * @param compressed flag to determine if return key should be compressed/uncompressed
 * @return a compressed or an uncompresseed public key in hexadecimal
 */
function xPubToPub(xpub, compressed) {
    if (!isValidXpub(xpub)) {
        throw new Error('invalid xpub');
    }
    return utxo_lib_1.ECPair.fromPublicKey(utxo_lib_1.bip32.fromBase58(xpub, utxo_lib_1.networks.bitcoin).publicKey, {
        compressed,
    }).publicKey.toString('hex');
}
/**
 * @param {string} xpub - a base-58 encoded extended public key (BIP32)
 * @returns {string} the uncompressed public key in hexadecimal
 */
function xpubToUncompressedPub(xpub) {
    return xPubToPub(xpub, false);
}
exports.xpubToUncompressedPub = xpubToUncompressedPub;
/**
 * @param {string} xpub - a base-58 encoded extended public key (BIP32)
 * @returns {string} the uncompressed public key in hexadecimal
 */
function xpubToCompressedPub(xpub) {
    return xPubToPub(xpub, true);
}
exports.xpubToCompressedPub = xpubToCompressedPub;
/**
 * @param {string} xprv - base58-encoded extended private key (BIP32)
 * @returns {string} the hex-encoded raw private key
 */
function xprvToRawPrv(xprv) {
    if (!isValidXprv(xprv)) {
        throw new Error('invalid xprv');
    }
    const { privateKey } = utxo_lib_1.bip32.fromBase58(xprv, utxo_lib_1.networks.bitcoin);
    if (!privateKey) {
        throw new Error('invalid xprv');
    }
    return privateKey.toString('hex');
}
exports.xprvToRawPrv = xprvToRawPrv;
/**
 * @param {string} prv - Private key in hex format to get the extended keys for
 * @returns {ExtendedKeys} xprv and xpub in string format
 */
function rawPrvToExtendedKeys(prv) {
    const hd = utxo_lib_1.bip32.fromPrivateKey(Buffer.from(prv, 'hex'), Buffer.alloc(32));
    return {
        xprv: hd.toBase58(),
        xpub: hd.neutered().toBase58(),
    };
}
exports.rawPrvToExtendedKeys = rawPrvToExtendedKeys;
/**
 * Whether the input is a valid BIP32 xpub or not
 *
 * @param xpub
 */
function isValidXpub(xpub) {
    if (xpub.substr(0, 4) !== 'xpub') {
        // check for xpub formats we don't support, such as tpub
        return false;
    }
    try {
        utxo_lib_1.bip32.fromBase58(xpub, utxo_lib_1.networks.bitcoin);
    }
    catch (err) {
        return false;
    }
    // if HD generation didn't throw, it is a valid xpub
    return true;
}
exports.isValidXpub = isValidXpub;
/**
 * Whether the input is a valid BIP32 xprv or not
 *
 * @param xprv
 */
function isValidXprv(xprv) {
    if (xprv.substr(0, 4) !== 'xprv') {
        // check for xprv formats we don't support
        return false;
    }
    try {
        utxo_lib_1.bip32.fromBase58(xprv, utxo_lib_1.networks.bitcoin);
    }
    catch (err) {
        return false;
    }
    // if HD generation didn't throw, it is a valid xprv
    return true;
}
exports.isValidXprv = isValidXprv;
/**
 * Whether the input is a valid secp256k1 public key
 *
 * @param pub
 */
function isValidPub(pub) {
    try {
        utxo_lib_1.ECPair.fromPublicKey(Buffer.from(pub, 'hex'));
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidPub = isValidPub;
/**
 * Whether the input is a valid secp256k1 private key
 *
 * @param prv
 */
function isValidPrv(prv) {
    try {
        utxo_lib_1.ECPair.fromPrivateKey(Buffer.from(prv, 'hex'));
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.isValidPrv = isValidPrv;
/**
 * Whether the input is a valid ed25519 private key
 *
 * @param {string} prv A hexadecimal private key to validate
 * @returns {boolean} Whether the input is a valid public key or not
 */
function isValidEd25519Seed(prv) {
    try {
        const decodedPrv = toUint8Array(prv);
        return decodedPrv.length === nacl.sign.seedLength;
    }
    catch (e) {
        return false;
    }
}
exports.isValidEd25519Seed = isValidEd25519Seed;
/**
 * Whether the input is a valid ed25519 private key
 *
 * @param {string} prv A hexadecimal private key to validate
 * @returns {boolean} Whether the input is a valid public key or not
 */
function isValidEd25519SecretKey(prv) {
    try {
        const decodedPrv = toUint8Array(prv);
        return decodedPrv.length === nacl.sign.secretKeyLength;
    }
    catch (e) {
        return false;
    }
}
exports.isValidEd25519SecretKey = isValidEd25519SecretKey;
/**
 * Whether the input is a valid ed25519 public key
 *
 * @param {string} pub A hexadecimal public key to validate
 * @returns {boolean} Whether the input is a valid public key or not
 */
function isValidEd25519PublicKey(pub) {
    try {
        const decodedPub = new Uint8Array(Buffer.from(pub, 'hex'));
        return decodedPub.length === nacl.sign.publicKeyLength;
    }
    catch (e) {
        return false;
    }
}
exports.isValidEd25519PublicKey = isValidEd25519PublicKey;
/**
 * Whether the input is a valid BLS private key
 *
 * @param {string} prv a private key to validate
 * @returns {boolean} Whether the input is a valid private key or not
 */
function isValidBLSPrivateKey(prv) {
    try {
        return bls.Fr.isValid(BigInt('0x' + prv));
    }
    catch (e) {
        return false;
    }
}
exports.isValidBLSPrivateKey = isValidBLSPrivateKey;
/**
 * Whether input is a valid BLS public key
 *
 * @param {string} pub the public key to validate
 * @returns {boolean} Whether input is a valid public key or not
 */
function isValidBLSPublicKey(pub) {
    try {
        bls.PointG1.fromCompressedHex(strip_hex_prefix_1.default(pub)).assertValidity();
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.isValidBLSPublicKey = isValidBLSPublicKey;
/**
 * Returns an hex string of the given buffer
 *
 * @param {Buffer | Uint8Array} buffer - the buffer to be converted to hex
 * @returns {string} - the hex value
 */
function toHex(buffer) {
    return hex.encode(buffer, true);
}
exports.toHex = toHex;
/**
 * Check if base58 decoded string is equale to length
 *
 * @param {string} value - string to be checked
 * @param {number} length - expected decoded length
 * @return {boolean} if the string can decoded as base58 and match the expected length
 */
function isBase58(value, length) {
    try {
        return !!value && bs58_1.default.decode(value).length === length;
    }
    catch (e) {
        return false;
    }
}
exports.isBase58 = isBase58;
/**
 * Returns a Uint8Array of the given hex string
 *
 * @param {string} str - the hex string to be converted
 * @returns {string} - the Uint8Array value
 */
function toUint8Array(str) {
    return hex.decode(str);
}
exports.toUint8Array = toUint8Array;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FjY291bnQtbGliL3V0aWwvY3J5cHRvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw4Q0FBMEQ7QUFDMUQsZ0RBQWtDO0FBQ2xDLG9EQUFzQztBQUN0QyxxREFBdUM7QUFDdkMsd0VBQThDO0FBRTlDLGdEQUF3QjtBQUV4Qjs7R0FFRztBQUNILGtEQUFrSDtBQUF6Ryx1SEFBQSx3QkFBd0IsT0FBQTtBQUFFLHVIQUFBLHdCQUF3QixPQUFBO0FBQUUsMEdBQUEsV0FBVyxPQUFBO0FBQUUsMEdBQUEsV0FBVyxPQUFBO0FBRXJGOzs7O0dBSUc7QUFDSCxTQUFTLFNBQVMsQ0FBQyxJQUFZLEVBQUUsVUFBbUI7SUFDbEQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQ2pDO0lBQ0QsT0FBTyxpQkFBTSxDQUFDLGFBQWEsQ0FBQyxnQkFBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsbUJBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLEVBQUU7UUFDOUUsVUFBVTtLQUNYLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9CLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixxQkFBcUIsQ0FBQyxJQUFZO0lBQ2hELE9BQU8sU0FBUyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBRkQsc0RBRUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixtQkFBbUIsQ0FBQyxJQUFZO0lBQzlDLE9BQU8sU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMvQixDQUFDO0FBRkQsa0RBRUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixZQUFZLENBQUMs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QUFPLENBQUMsaUJBQWlCLENBQUMsMEJBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ3BFLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7QUFDSCxDQUFDO0FBUEQsa0RBT0M7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLEtBQUssQ0FBQyxNQUEyQjtJQUMvQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2xDLENBQUM7QUFGRCxzQkFFQztBQUVEOzs7Ozs7R0FNRztBQUVILFNBQWdCLFFBQVEsQ0FBQyxLQUFhLEVBQUUsTUFBYztJQUNwRCxJQUFJO1FBQ0YsT0FBTyxDQUFDLENBQUMsS0FBSyxJQUFJLGNBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQztLQUN4RDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsT0FBTyxLQUFLLENBQUM7S0FDZDtBQUNILENBQUM7QUFORCw0QkFNQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLEdBQVc7SUFDdEMsT0FBTyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3pCLENBQUM7QUFGRCxvQ0FFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGJpcDMyLCBFQ1BhaXIsIG5ldHdvcmtzIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCAqIGFzIG5hY2wgZnJvbSAndHdlZXRuYWNsJztcbmltcG9ydCAqIGFzIGhleCBmcm9tICdAc3RhYmxlbGliL2hleCc7XG5pbXBvcnQgKiBhcyBibHMgZnJvbSAnbm9ibGUtYmxzMTItMzgxJztcbmltcG9ydCBzdHJpcEhleFByZWZpeCBmcm9tICdzdHJpcC1oZXgtcHJlZml4JztcbmltcG9ydCB7IEV4dGVuZGVkS2V5cyB9IGZyb20gJy4uL2Jhc2VDb2luJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIC0gdXNlIEBiaXRnby9zZGstbGliLW1wYyBpbnN0ZWFkXG4gKi9cbmV4cG9ydCB7IGNvbnZlcnRIZXhBcnJUb0JpZ0ludEFyciwgY29udmVydEJpZ0ludEFyclRvSGV4QXJyLCBoZXhUb0JpZ0ludCwgYmlnSW50VG9IZXggfSBmcm9tICdAYml0Z28vc2RrLWxpYi1tcGMnO1xuXG4vKipcbiAqIEBwYXJhbSB4cHViIC0gYSBiYXNlLTU4IGVuY29kZWQgZXh0ZW5kZWQgcHVibGljIGtleSAoQklQMzIpXG4gKiBAcGFyYW0gY29tcHJlc3NlZCBmbGFnIHRvIGRldGVybWluZSBpZiByZXR1cm4ga2V5IHNob3VsZCBiZSBjb21wcmVzc2VkL3VuY29tcHJlc3NlZFxuICogQHJldHVybiBhIGNvbXByZXNzZWQgb3IgYW4gdW5jb21wcmVzc2VlZCBwdWJsaWMga2V5IGluIGhleGFkZWNpbWFsXG4gKi9cbmZ1bmN0aW9uIHhQdWJUb1B1Yih4cHViOiBzdHJpbmcsIGNvbXByZXNzZWQ6IGJvb2xlYW4pIHtcbiAgaWYgKCFpc1ZhbGlkWHB1Yih4cHViKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB4cHViJyk7XG4gIH1cbiAgcmV0dXJuIEVDUGFpci5mcm9tUHVibGljS2V5KGJpcDMyLmZyb21CYXNlNTgoeHB1YiwgbmV0d29ya3MuYml0Y29pbikucHVibGljS2V5LCB7XG4gICAgY29tcHJlc3NlZCxcbiAgfSkucHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30geHB1YiAtIGEgYmFzZS01OCBlbmNvZGVkIGV4dGVuZGVkIHB1YmxpYyBrZXkgKEJJUDMyKVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5IGluIGhleGFkZWNpbWFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4cHViVG9VbmNvbXByZXNzZWRQdWIoeHB1Yjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHhQdWJUb1B1Yih4cHViLCBmYWxzZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHhwdWIgLSBhIGJhc2UtNTggZW5jb2RlZCBleHRlbmRlZCBwdWJsaWMga2V5IChCSVAzMilcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB1bmNvbXByZXNzZWQgcHVibGljIGtleSBpbiBoZXhhZGVjaW1hbFxuICovXG5leHBvcnQgZnVuY3Rpb24geHB1YlRvQ29tcHJlc3NlZFB1Yih4cHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4geFB1YlRvUHViKHhwdWIsIHRydWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB4cHJ2IC0gYmFzZTU4LWVuY29kZWQgZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgKEJJUDMyKVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGhleC1lbmNvZGVkIHJhdyBwcml2YXRlIGtleVxuICovXG5leHBvcnQgZnVuY3Rpb24geHBydlRvUmF3UHJ2KHhwcnY6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghaXNWYWxpZFhwcnYoeHBydikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgeHBydicpO1xuICB9XG5cbiAgY29uc3QgeyBwcml2YXRlS2V5IH0gPSBiaXAzMi5mcm9tQmFzZTU4KHhwcnYsIG5ldHdvcmtzLmJpdGNvaW4pO1xuICBpZiAoIXByaXZhdGVLZXkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgeHBydicpO1xuICB9XG4gIHJldHVybiBwcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJ2IC0gUHJpdmF0ZSBrZXkgaW4gaGV4IGZvcm1hdCB0byBnZXQgdGhlIGV4dGVuZGVkIGtleXMgZm9yXG4gKiBAcmV0dXJucyB7RXh0ZW5kZWRLZXlzfSB4cHJ2IGFuZCB4cHViIGluIHN0cmluZyBmb3JtYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhd1BydlRvRXh0ZW5kZWRLZXlzKHBydjogc3RyaW5nKTogRXh0ZW5kZWRLZXlzIHtcbiAgY29uc3QgaGQgPSBiaXAzMi5mcm9tUHJpdmF0ZUtleShCdWZmZXIuZnJvbShwcnYsICdoZXgnKSwgQnVmZmVyLmFsbG9jKDMyKSk7XG4gIHJldHVybiB7XG4gICAgeHBydjogaGQudG9CYXNlNTgoKSxcbiAgICB4cHViOiBoZC5uZXV0ZXJlZCgpLnRvQmFzZTU4KCksXG4gIH07XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgaW5wdXQgaXMgYSB2YWxpZCBCSVAzMiB4cHViIG9yIG5vdFxuICpcbiAqIEBwYXJhbSB4cHViXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkWHB1Yih4cHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHhwdWIuc3Vic3RyKDAsIDQpICE9PSAneHB1YicpIHtcbiAgICAvLyBjaGVjayBmb3IgeHB1YiBmb3JtYXRzIHdlIGRvbid0IHN1cHBvcnQsIHN1Y2ggYXMgdHB1YlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGJpcDMyLmZyb21CYXNlNTgoeHB1YiwgbmV0d29ya3MuYml0Y29pbik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBpZiBIRCBnZW5lcmF0aW9uIGRpZG4ndCB0aHJvdywgaXQgaXMgYSB2YWxpZCB4cHViXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGEgdmFsaWQgQklQMzIgeHBydiBvciBub3RcbiAqXG4gKiBAcGFyYW0geHBydlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFhwcnYoeHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICh4cHJ2LnN1YnN0cigwLCA0KSAhPT0gJ3hwcnYnKSB7XG4gICAgLy8gY2hlY2sgZm9yIHhwcnYgZm9ybWF0cyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgYmlwMzIuZnJvbUJhc2U1OCh4cHJ2LCBuZXR3b3Jrcy5iaXRjb2luKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGlmIEhEIGdlbmVyYXRpb24gZGlkbid0IHRocm93LCBpdCBpcyBhIHZhbGlkIHhwcnZcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgaW5wdXQgaXMgYSB2YWxpZCBzZWNwMjU2azEgcHVibGljIGtleVxuICpcbiAqIEBwYXJhbSBwdWJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQdWIocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBFQ1BhaXIuZnJvbVB1YmxpY0tleShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgaW5wdXQgaXMgYSB2YWxpZCBzZWNwMjU2azEgcHJpdmF0ZSBrZXlcbiAqXG4gKiBAcGFyYW0gcHJ2XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgRUNQYWlyLmZyb21Qcml2YXRlS2V5KEJ1ZmZlci5mcm9tKHBydiwgJ2hleCcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhIHZhbGlkIGVkMjU1MTkgcHJpdmF0ZSBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJ2IEEgaGV4YWRlY2ltYWwgcHJpdmF0ZSBrZXkgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhIHZhbGlkIHB1YmxpYyBrZXkgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRWQyNTUxOVNlZWQocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkUHJ2ID0gdG9VaW50OEFycmF5KHBydik7XG4gICAgcmV0dXJuIGRlY29kZWRQcnYubGVuZ3RoID09PSBuYWNsLnNpZ24uc2VlZExlbmd0aDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGEgdmFsaWQgZWQyNTUxOSBwcml2YXRlIGtleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcnYgQSBoZXhhZGVjaW1hbCBwcml2YXRlIGtleSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGlucHV0IGlzIGEgdmFsaWQgcHVibGljIGtleSBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRFZDI1NTE5U2VjcmV0S2V5KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZFBydiA9IHRvVWludDhBcnJheShwcnYpO1xuICAgIHJldHVybiBkZWNvZGVkUHJ2Lmxlbmd0aCA9PT0gbmFjbC5zaWduLnNlY3JldEtleUxlbmd0aDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGlucHV0IGlzIGEgdmFsaWQgZWQyNTUxOSBwdWJsaWMga2V5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHB1YiBBIGhleGFkZWNpbWFsIHB1YmxpYyBrZXkgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhIHZhbGlkIHB1YmxpYyBrZXkgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRlY29kZWRQdWIgPSBuZXcgVWludDhBcnJheShCdWZmZXIuZnJvbShwdWIsICdoZXgnKSk7XG4gICAgcmV0dXJuIGRlY29kZWRQdWIubGVuZ3RoID09PSBuYWNsLnNpZ24ucHVibGljS2V5TGVuZ3RoO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogV2hldGhlciB0aGUgaW5wdXQgaXMgYSB2YWxpZCBCTFMgcHJpdmF0ZSBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJ2IGEgcHJpdmF0ZSBrZXkgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBpbnB1dCBpcyBhIHZhbGlkIHByaXZhdGUga2V5IG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEJMU1ByaXZhdGVLZXkocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYmxzLkZyLmlzVmFsaWQoQmlnSW50KCcweCcgKyBwcnYpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFdoZXRoZXIgaW5wdXQgaXMgYSB2YWxpZCBCTFMgcHVibGljIGtleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWIgdGhlIHB1YmxpYyBrZXkgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIGlucHV0IGlzIGEgdmFsaWQgcHVibGljIGtleSBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRCTFNQdWJsaWNLZXkocHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBibHMuUG9pbnRHMS5mcm9tQ29tcHJlc3NlZEhleChzdHJpcEhleFByZWZpeChwdWIpKS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBoZXggc3RyaW5nIG9mIHRoZSBnaXZlbiBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IFVpbnQ4QXJyYXl9IGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gYmUgY29udmVydGVkIHRvIGhleFxuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaGV4IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChidWZmZXI6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gaGV4LmVuY29kZShidWZmZXIsIHRydWUpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGJhc2U1OCBkZWNvZGVkIHN0cmluZyBpcyBlcXVhbGUgdG8gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gc3RyaW5nIHRvIGJlIGNoZWNrZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggLSBleHBlY3RlZCBkZWNvZGVkIGxlbmd0aFxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgdGhlIHN0cmluZyBjYW4gZGVjb2RlZCBhcyBiYXNlNTggYW5kIG1hdGNoIHRoZSBleHBlY3RlZCBsZW5ndGhcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCYXNlNTgodmFsdWU6IHN0cmluZywgbGVuZ3RoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiBiczU4LmRlY29kZSh2YWx1ZSkubGVuZ3RoID09PSBsZW5ndGg7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgVWludDhBcnJheSBvZiB0aGUgZ2l2ZW4gaGV4IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSB0aGUgaGV4IHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIFVpbnQ4QXJyYXkgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVWludDhBcnJheShzdHI6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gaGV4LmRlY29kZShzdHIpO1xufVxuIl19