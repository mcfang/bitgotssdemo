"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitGoAPI = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const sjcl = require("@bitgo/sjcl");
const utxolib = require("@bitgo/utxo-lib");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bitcoinMessage = require("bitcoinjs-message");
const browser_or_node_1 = require("browser-or-node");
const bs58 = require("bs58");
const crypto_1 = require("crypto");
const debug_1 = require("debug");
const _ = require("lodash");
const secp256k1 = require("secp256k1");
const superagent = require("superagent");
const urlLib = require("url");
const api_1 = require("./api");
const encrypt_1 = require("./encrypt");
const shamir = require("secrets.js-grempe");
const pjson = require("../package.json");
const debug = debug_1.default('bitgo:api');
const Blockchain = require('./v1/blockchain');
const Keychains = require('./v1/keychains');
const Wallet = require("./v1/wallet");
const Wallets = require('./v1/wallets');
const Markets = require('./v1/markets');
const PendingApprovals = require('./v1/pendingapprovals');
const TravelRule = require('./v1/travelRule');
const TransactionBuilder = require('./v1/transactionBuilder');
let proxyAgent;
if (!browser_or_node_1.isBrowser && !browser_or_node_1.isWebWorker) {
    debug('enabling proxy-agent');
    proxyAgent = require('proxy-agent').ProxyAgent;
}
const patchedRequestMethods = ['get', 'post', 'put', 'del', 'patch'];
class BitGoAPI {
    constructor(params = {}) {
        this._authVersion = 2;
        this._hmacVerification = true;
        this._version = pjson.version;
        this.cookiesPropagationEnabled = false;
        if (!sdk_core_1.common.validateParams(params, [], [
            'accessToken',
            'userAgent',
            'customRootURI',
            'customBitcoinNetwork',
            'serverXpub',
            'stellarFederationServerUrl',
        ]) ||
            (params.useProduction && !_.isBoolean(params.useProduction))) {
            throw new Error('invalid argument');
        }
        // By default, we operate on the test server.
        // Deprecate useProduction in the future
        let env;
        if (params.useProduction) {
            if (params.env && params.env !== 'prod') {
                throw new Error('cannot use useProduction when env=' + params.env);
            }
            env = 'prod';
        }
        else if (params.customRootURI ||
            params.customBitcoinNetwork ||
            params.customSigningAddress ||
            params.serverXpub ||
            process.env.BITGO_CUSTOM_ROOT_URI ||
            process.env.BITGO_CUSTOM_BITCOIN_NETWORK) {
            // for branch deploys, we want to be able to specify custom endpoints while still
            // maintaining the name of specified the environment
            env = params.env === 'branch' ? 'branch' : 'custom';
            if (params.customRootURI) {
                sdk_core_1.common.Environments[env].uri = params.customRootURI;
            }
            if (params.customBitcoinNetwork) {
                sdk_core_1.common.Environments[env].network = params.customBitcoinNetwork;
            }
            if (params.customSigningAddress) {
                sdk_core_1.common.Environments[env].customSigningAddress = params.customSigningAddress;
            }
            if (params.serverXpub) {
                sdk_core_1.common.Environments[env].serverXpub = params.serverXpub;
            }
            if (params.stellarFederationServerUrl) {
                sdk_core_1.common.Environments[env].stellarFederationServerUrl = params.stellarFederationServerUrl;
            }
            if (params.cookiesPropagationEnabled) {
                this.cookiesPropagationEnabled = true;
            }
        }
        else {
            env = params.env || process.env.BITGO_ENV;
        }
        // if this hasn't been set to true already some conditions are not met
        if (params.cookiesPropagationEnabled && !this.cookiesPropagationEnabled) {
            throw new Error('Cookies are only allowed when custom URIs are in use');
        }
        if (params.authVersion !== undefined) {
            this._authVersion = params.authVersion;
        }
        // if this env is an alias, swap it out with the equivalent supported environment
        if (env in sdk_core_1.AliasEnvironments) {
            env = sdk_core_1.AliasEnvironments[env];
        }
        if (env === 'custom' && _.isUndefined(sdk_core_1.common.Environments[env].uri)) {
            throw new Error('must use --customrooturi or set the BITGO_CUSTOM_ROOT_URI environment variable when using the custom environment');
        }
        if (env) {
            if (sdk_core_1.common.Environments[env]) {
                this._baseUrl = sdk_core_1.common.Environments[env].uri;
            }
            else {
                throw new Error('invalid environment ' + env + '. Supported environments: prod, test, dev, latest');
            }
        }
        else {
            env = 'test';
            if (!BitGoAPI._testnetWarningMessage) {
                BitGoAPI._testnetWarningMessage = true;
                console.log('BitGo SDK env not set - defaulting to test at test.bitgo.com.');
            }
            this._baseUrl = sdk_core_1.common.Environments[env].uri;
        }
        this._env = this.env = env;
        const supportedApiTokens = ['etherscanApiToken', 'polygonscanApiToken', 'snowtraceApiToken'];
        Object.keys(params).forEach((key) => {
            if (supportedApiTokens.includes(key)) {
                sdk_core_1.common.Environments[env][key] = params[key];
            }
        });
        sdk_core_1.common.setNetwork(sdk_core_1.common.Environments[env].network);
        this._baseApiUrl = this._baseUrl + '/api/v1';
        this._baseApiUrlV2 = this._baseUrl + '/api/v2';
        this._token = params.accessToken;
        this._userAgent = params.userAgent || 'BitGoJS-api/' + this.version();
        this._reqId = undefined;
        this._refreshToken = params.refreshToken;
        this._clientId = params.clientId;
        this._clientSecret = params.clientSecret;
        this._keychains = null;
        this._wallets = null;
        // whether to perform extra client-side validation for some things, such as
        // address validation or signature validation. defaults to true, but can be
        // turned off by setting to false. can also be overridden individually in the
        // functions that use it.
        this._validate = params.validate === undefined ? true : params.validate;
        if (!params.hmacVerification && params.hmacVerification !== undefined) {
            if ((env == 'prod' || env == 'adminProd') && sdk_core_1.common.Environments[env].hmacVerificationEnforced) {
                throw new Error(`Cannot disable request HMAC verification in environment ${this.getEnv()}`);
            }
            debug('HMAC verification explicitly disabled by constructor option');
            this._hmacVerification = params.hmacVerification;
        }
        if (!params.proxy && process.env.BITGO_USE_PROXY) {
            params.proxy = process.env.BITGO_USE_PROXY;
        }
        if (process.browser && params.proxy) {
            throw new Error('cannot use https proxy params while in browser');
        }
        this._proxy = params.proxy;
        // capture outer stack so we have useful debug information if fetch constants fails
        const e = new Error();
        // Kick off first load of constants
        this.fetchConstants().catch((err) => {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch initial client constants from BitGo');
                debug(e.stack);
            }
        });
    }
    /**
     * Get a superagent request for specified http method and URL configured to the SDK configuration
     * @param method - http method for the new request
     * @param url - URL for the new request
     */
    getAgentRequest(method, url) {
        let req = superagent[method](url);
        if (this.cookiesPropagationEnabled) {
            req = req.withCredentials();
        }
        return req;
    }
    /**
     * Create a basecoin object
     * @param name
     */
    coin(name) {
        return sdk_core_1.GlobalCoinFactory.getInstance(this, name);
    }
    /**
     * Return the current BitGo environment
     */
    getEnv() {
        return this._env;
    }
    /**
     * Return the current auth version used for requests to the BitGo server
     */
    getAuthVersion() {
        return this._authVersion;
    }
    /**
     * This is a patching function which can apply our authorization
     * headers to any outbound request.
     * @param method
     */
    requestPatch(method, url) {
        const req = this.getAgentRequest(method, url);
        if (this._proxy && proxyAgent !== undefined) {
            debug('proxying request through %s', this._proxy);
            const agent = new proxyAgent(this._proxy);
            if (agent) {
                req.agent(agent);
            }
        }
        const originalThen = req.then.bind(req);
        req.then = (onfulfilled, onrejected) => {
            var _a, _b;
            // intercept a request before it's submitted to the server for v2 authentication (based on token)
            if (this._version) {
                // TODO - decide where to get version
                req.set('BitGo-SDK-Version', this._version);
            }
            if (!_.isUndefined(this._reqId)) {
                req.set('Request-ID', this._reqId.toString());
                // increment after setting the header so the sequence numbers start at 0
                this._reqId.inc();
                // request ids must be set before each request instead of being kept
                // inside the bitgo object. This is to prevent reentrancy issues where
                // multiple simultaneous requests could cause incorrect reqIds to be used
                delete this._reqId;
            }
            // prevent IE from caching requests
            req.set('If-Modified-Since', 'Mon, 26 Jul 1997 05:00:00 GMT');
            if (!process.browser && this._userAgent) {
                // If not in the browser, set the User-Agent. Browsers don't allow
                // setting of User-Agent, so we must disable this when run in the
                // browser (browserify sets process.browser).
                req.set('User-Agent', this._userAgent);
            }
            // Set the request timeout to just above 5 minutes by default
            req.timeout(process.env.BITGO_TIMEOUT * 1000 || 305 * 1000);
            // if there is no token, and we're not logged in, the request cannot be v2 authenticated
            req.isV2Authenticated = true;
            req.authenticationToken = this._token;
            // some of the older tokens appear to be only 40 characters long
            if ((this._token && this._token.length !== 67 && this._token.indexOf('v2x') !== 0) || req.forceV1Auth) {
                // use the old method
                req.isV2Authenticated = false;
                req.set('Authorization', 'Bearer ' + this._token);
                debug('sending v1 %s request to %s with token %s', method, url, (_a = this._token) === null || _a === void 0 ? void 0 : _a.substr(0, 8));
                return originalThen(onfulfilled).catch(onrejected);
            }
            req.set('BitGo-Auth-Version', this._authVersion === 3 ? '3.0' : '2.0');
            if (this._token) {
                const data = api_1.serializeRequestData(req);
                api_1.setRequestQueryString(req);
                const requestProperties = this.calculateRequestHeaders({
                    url: req.url,
                    token: this._token,
                    method,
                    text: data || '',
                });
                req.set('Auth-Timestamp', requestProperties.timestamp.toString());
                // we're not sending the actual token, but only its hash
                req.set('Authorization', 'Bearer ' + requestProperties.tokenHash);
                debug('sending v2 %s request to %s with token %s', method, url, (_b = this._token) === null || _b === void 0 ? void 0 : _b.substr(0, 8));
                // set the HMAC
                req.set('HMAC', requestProperties.hmac);
            }
            /**
             * Verify the response before calling the original onfulfilled handler,
             * and make sure onrejected is called if a verification error is encountered
             */
            const newOnFulfilled = onfulfilled
                ? (response) => {
                    // HMAC verification is only allowed to be skipped in certain environments.
                    // This is checked in the constructor, but checking it again at request time
                    // will help prevent against tampering of this property after the object is created
                    if (!this._hmacVerification && !sdk_core_1.common.Environments[this.getEnv()].hmacVerificationEnforced) {
                        return onfulfilled(response);
                    }
                    const verifiedResponse = api_1.verifyResponse(this, this._token, method, req, response);
                    return onfulfilled(verifiedResponse);
                }
                : null;
            return originalThen(newOnFulfilled).catch(onrejected);
        };
        return api_1.toBitgoRequest(req);
    }
    get(url) {
        return this.requestPatch('get', url);
    }
    post(url) {
        return this.requestPatch('post', url);
    }
    put(url) {
        return this.requestPatch('put', url);
    }
    del(url) {
        return this.requestPatch('del', url);
    }
    patch(url) {
        return this.requestPatch('patch', url);
    }
    /**
     * Calculate the HMAC for the given key and message
     * @param key {String} - the key to use for the HMAC
     * @param message {String} - the actual message to HMAC
     * @returns {*} - the result of the HMAC operation
     */
    calculateHMAC(key, message) {
        return crypto_1.createHmac('sha256', key).update(message).digest('hex');
    }
    /**
     * Calculate the subject string that is to be HMAC'ed for a HTTP request or response
     * @param urlPath request url, including query params
     * @param text request body text
     * @param timestamp request timestamp from `Date.now()`
     * @param statusCode Only set for HTTP responses, leave blank for requests
     * @param method request method
     * @returns {string}
     */
    calculateHMACSubject({ urlPath, text, timestamp, statusCode, method }) {
        const urlDetails = urlLib.parse(urlPath);
        const queryPath = urlDetails.query && urlDetails.query.length > 0 ? urlDetails.path : urlDetails.pathname;
        if (!_.isUndefined(statusCode) && _.isInteger(statusCode) && _.isFinite(statusCode)) {
            if (this._authVersion === 3) {
                return [method.toUpperCase(), timestamp, queryPath, statusCode, text].join('|');
            }
            return [timestamp, queryPath, statusCode, text].join('|');
        }
        if (this._authVersion === 3) {
            return [method.toUpperCase(), timestamp, '3.0', queryPath, text].join('|');
        }
        return [timestamp, queryPath, text].join('|');
    }
    /**
     * Calculate the HMAC for an HTTP request
     */
    calculateRequestHMAC({ url: urlPath, text, timestamp, token, method }) {
        const signatureSubject = this.calculateHMACSubject({ urlPath, text, timestamp, method });
        // calculate the HMAC
        return this.calculateHMAC(token, signatureSubject);
    }
    /**
     * Calculate request headers with HMAC
     */
    calculateRequestHeaders({ url, text, token, method }) {
        const timestamp = Date.now();
        const hmac = this.calculateRequestHMAC({ url, text, timestamp, token, method });
        // calculate the SHA256 hash of the token
        const hashDigest = sjcl.hash.sha256.hash(token);
        const tokenHash = sjcl.codec.hex.fromBits(hashDigest);
        return {
            hmac,
            timestamp,
            tokenHash,
        };
    }
    /**
     * Verify the HMAC for an HTTP response
     */
    verifyResponse({ url: urlPath, statusCode, text, timestamp, token, hmac, method, }) {
        const signatureSubject = this.calculateHMACSubject({
            urlPath,
            text,
            timestamp,
            statusCode,
            method,
        });
        // calculate the HMAC
        const expectedHmac = this.calculateHMAC(token, signatureSubject);
        // determine if the response is still within the validity window (5 minute window)
        const now = Date.now();
        const isInResponseValidityWindow = timestamp >= now - 1000 * 60 * 5 && timestamp <= now;
        // verify the HMAC and timestamp
        return {
            isValid: expectedHmac === hmac,
            expectedHmac,
            signatureSubject,
            isInResponseValidityWindow,
            verificationTime: now,
        };
    }
    /**
     * Fetch useful constant values from the BitGo server.
     * These values do change infrequently, so they need to be fetched,
     * but are unlikely to change during the lifetime of a BitGo object,
     * so they can safely cached.
     */
    async fetchConstants() {
        var _a, _b;
        const env = this.getEnv();
        if (!BitGoAPI._constants) {
            BitGoAPI._constants = {};
        }
        if (!BitGoAPI._constantsExpire) {
            BitGoAPI._constantsExpire = {};
        }
        if (BitGoAPI._constants[env] && BitGoAPI._constantsExpire[env] && new Date() < BitGoAPI._constantsExpire[env]) {
            return BitGoAPI._constants[env];
        }
        // client constants call cannot be authenticated using the normal HMAC validation
        // scheme, so we need to use a raw superagent instance to do this request.
        // Proxy settings must still be respected however
        const resultPromise = this.getAgentRequest('get', this.url('/client/constants'));
        resultPromise.set('BitGo-SDK-Version', this._version);
        const result = await (this._proxy ? resultPromise.proxy(this._proxy) : resultPromise);
        BitGoAPI._constants[env] = result.body.constants;
        if (((_a = result.body) === null || _a === void 0 ? void 0 : _a.ttl) && typeof ((_b = result.body) === null || _b === void 0 ? void 0 : _b.ttl) === 'number') {
            BitGoAPI._constantsExpire[env] = new Date(new Date().getTime() + result.body.ttl * 1000);
        }
        return BitGoAPI._constants[env];
    }
    /**
     * Create a url for calling BitGo platform APIs
     * @param path
     * @param version
     */
    url(path, version = 1) {
        const baseUrl = version === 2 ? this._baseApiUrlV2 : this._baseApiUrl;
        return baseUrl + path;
    }
    /**
     * Create a url for calling BitGo microservice APIs
     */
    microservicesUrl(path) {
        return this._baseUrl + path;
    }
    /**
     * Gets the version of the BitGoJS package
     */
    version() {
        return this._version;
    }
    /**
     * Test connectivity to the server
     * @param params
     */
    ping({ reqId } = {}) {
        if (reqId) {
            this._reqId = reqId;
        }
        return this.get(this.url('/ping')).result();
    }
    /**
     * Set a request tracer to provide request IDs during multi-request workflows
     */
    setRequestTracer(reqTracer) {
        if (reqTracer) {
            this._reqId = reqTracer;
        }
    }
    /**
     * Utility function to encrypt locally.
     */
    encrypt(params) {
        sdk_core_1.common.validateParams(params, ['input', 'password'], []);
        if (!params.password) {
            throw new Error(`cannot encrypt without password`);
        }
        return encrypt_1.encrypt(params.password, params.input);
    }
    /**
     * Decrypt an encrypted string locally.
     */
    decrypt(params) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['input', 'password'], []);
        if (!params.password) {
            throw new Error(`cannot decrypt without password`);
        }
        try {
            return encrypt_1.decrypt(params.password, params.input);
        }
        catch (error) {
            if (error.message.includes("ccm: tag doesn't match")) {
                error.message = 'password error - ' + error.message;
            }
            throw error;
        }
    }
    /**
     * Serialize this BitGo object to a JSON object.
     *
     * Caution: contains sensitive data
     */
    toJSON() {
        return {
            user: this._user,
            token: this._token,
            extensionKey: this._extensionKey ? this._extensionKey.toWIF() : undefined,
            ecdhXprv: this._ecdhXprv,
        };
    }
    /**
     * Get the current user
     */
    user() {
        return this._user;
    }
    /**
     * Deserialize a JSON serialized BitGo object.
     *
     * Overwrites the properties on the current BitGo object with
     * those of the deserialzed object.
     *
     * @param json
     */
    fromJSON(json) {
        this._user = json.user;
        this._token = json.token;
        this._ecdhXprv = json.ecdhXprv;
        if (json.extensionKey) {
            const network = sdk_core_1.common.Environments[this.getEnv()].network;
            this._extensionKey = utxolib.ECPair.fromWIF(json.extensionKey, utxolib.networks[network]);
        }
    }
    /**
     * Process the username, password and otp into an object containing the username and hashed password, ready to
     * send to bitgo for authentication.
     */
    preprocessAuthenticationParams({ username, password, otp, forceSMS, extensible, trust, }) {
        if (!_.isString(username)) {
            throw new Error('expected string username');
        }
        if (!_.isString(password)) {
            throw new Error('expected string password');
        }
        const lowerName = username.toLowerCase();
        // Calculate the password HMAC so we don't send clear-text passwords
        const hmacPassword = this.calculateHMAC(lowerName, password);
        const authParams = {
            email: lowerName,
            password: hmacPassword,
            forceSMS: !!forceSMS,
        };
        if (otp) {
            authParams.otp = otp;
            if (trust) {
                authParams.trust = 1;
            }
        }
        if (extensible) {
            this._extensionKey = sdk_core_1.makeRandomKey();
            authParams.extensible = true;
            authParams.extensionAddress = sdk_core_1.getAddressP2PKH(this._extensionKey);
        }
        return authParams;
    }
    /**
     * Synchronous method for activating an access token.
     */
    authenticateWithAccessToken({ accessToken }) {
        debug('now authenticating with access token %s', accessToken.substring(0, 8));
        this._token = accessToken;
    }
    /**
     * Creates a new ECDH keychain for the user.
     * @param {string} loginPassword - The user's login password.
     * @returns {Promise<any>} - A promise that resolves with the new ECDH keychain data.
     * @throws {Error} - Throws an error if there is an issue creating the keychain.
     */
    async createUserEcdhKeychain(loginPassword) {
        const keyData = this.keychains().create();
        const hdNode = sdk_core_1.bitcoin.HDNode.fromBase58(keyData.xprv);
        /**
         * Add the new ECDH keychain to the user's account.
         * @type {Promise<any>} - A promise that resolves with the new ECDH keychain.
         */
        return await this.keychains().add({
            source: 'ecdh',
            xpub: hdNode.neutered().toBase58(),
            encryptedXprv: this.encrypt({
                password: loginPassword,
                input: hdNode.toBase58(),
            }),
        });
    }
    /**
     * Updates the user's settings with the provided parameters.
     * @param {Object} params - The parameters to update the user's settings with.
     * @returns {Promise<any>}
     * @throws {Error} - Throws an error if there is an issue updating the user's settings.
     */
    async updateUserSettings(params) {
        return this.put(this.url('/user/settings', 2)).send(params).result();
    }
    /**
     * Ensures that the user's ECDH keychain is created for wallet sharing and TSS wallets.
     * If the keychain does not exist, it will be created and the user's settings will be updated.
     * @param {string} loginPassword - The user's login password.
     * @returns {Promise<any>} - A promise that resolves with the user's settings ensuring we have the ecdhKeychain in there.
     * @throws {Error} - Throws an error if there is an issue creating the keychain or updating the user's settings.
     */
    async ensureUserEcdhKeychainIsCreated(loginPassword) {
        /**
         * Get the user's current settings.
         */
        const userSettings = await this.get(this.url('/user/settings')).result();
        /**
         * If the user's ECDH keychain does not exist, create a new keychain and update the user's settings.
         */
        if (!userSettings.settings.ecdhKeychain) {
            const newKeychain = await this.createUserEcdhKeychain(loginPassword);
            await this.updateUserSettings({
                settings: {
                    ecdhKeychain: newKeychain.xpub,
                },
            });
            /**
             * Update the user's settings object with the new ECDH keychain.
             */
            userSettings.settings.ecdhKeychain = newKeychain.xpub;
        }
        /**
         * Return the user's ECDH keychain settings.
         */
        return userSettings.settings;
    }
    /**
     * Login to the bitgo platform.
     */
    async authenticate(params) {
        try {
            if (!_.isObject(params)) {
                throw new Error('required object params');
            }
            if (!_.isString(params.password)) {
                throw new Error('expected string password');
            }
            const forceV1Auth = !!params.forceV1Auth;
            const authParams = this.preprocessAuthenticationParams(params);
            const password = params.password;
            if (this._token) {
                return new Error('already logged in');
            }
            const authUrl = this.microservicesUrl('/api/auth/v1/session');
            const request = this.post(authUrl);
            if (forceV1Auth) {
                request.forceV1Auth = true;
                // tell the server that the client was forced to downgrade the authentication protocol
                authParams.forceV1Auth = true;
                debug('forcing v1 auth for call to authenticate');
            }
            const response = await request.send(authParams);
            // extract body and user information
            const body = response.body;
            this._user = body.user;
            if (body.access_token) {
                this._token = body.access_token;
                // if the downgrade was forced, adding a warning message might be prudent
            }
            else {
                // check the presence of an encrypted ECDH xprv
                // if not present, legacy account
                const encryptedXprv = body.encryptedECDHXprv;
                if (!encryptedXprv) {
                    throw new Error('Keychain needs encryptedXprv property');
                }
                const responseDetails = this.handleTokenIssuance(response.body, password);
                this._token = responseDetails.token;
                this._ecdhXprv = responseDetails.ecdhXprv;
                // verify the response's authenticity
                api_1.verifyResponse(this, responseDetails.token, 'post', request, response);
                // add the remaining component for easier access
                response.body.access_token = this._token;
            }
            const userSettings = params.ensureEcdhKeychain ? await this.ensureUserEcdhKeychainIsCreated(password) : undefined;
            if (userSettings === null || userSettings === void 0 ? void 0 : userSettings.ecdhKeychain) {
                response.body.user.ecdhKeychain = userSettings.ecdhKeychain;
            }
            return api_1.handleResponseResult()(response);
        }
        catch (e) {
            api_1.handleResponseError(e);
        }
    }
    /**
     *
     * @param responseBody Response body object
     * @param password Password for the symmetric decryption
     */
    handleTokenIssuance(responseBody, password) {
        // make sure the response body contains the necessary properties
        sdk_core_1.common.validateParams(responseBody, ['derivationPath'], ['encryptedECDHXprv']);
        const environment = this._env;
        const environmentConfig = sdk_core_1.common.Environments[environment];
        const serverXpub = environmentConfig.serverXpub;
        let ecdhXprv = this._ecdhXprv;
        if (!ecdhXprv) {
            if (!password || !responseBody.encryptedECDHXprv) {
                throw new Error('ecdhXprv property must be set or password and encrypted encryptedECDHXprv must be provided');
            }
            try {
                ecdhXprv = this.decrypt({
                    input: responseBody.encryptedECDHXprv,
                    password: password,
                });
            }
            catch (e) {
                e.errorCode = 'ecdh_xprv_decryption_failure';
                console.error('Failed to decrypt encryptedECDHXprv.');
                throw e;
            }
        }
        // construct HDNode objects for client's xprv and server's xpub
        const clientHDNode = utxo_lib_1.bip32.fromBase58(ecdhXprv);
        const serverHDNode = utxo_lib_1.bip32.fromBase58(serverXpub);
        // BIP32 derivation path is applied to both client and server master keys
        const derivationPath = sdk_core_1.sanitizeLegacyPath(responseBody.derivationPath);
        const clientDerivedNode = clientHDNode.derivePath(derivationPath);
        const serverDerivedNode = serverHDNode.derivePath(derivationPath);
        const publicKey = serverDerivedNode.publicKey;
        const secretKey = clientDerivedNode.privateKey;
        if (!secretKey) {
            throw new Error('no client private Key');
        }
        const secret = Buffer.from(
        // FIXME(BG-34386): we should use `secp256k1.ecdh()` in the future
        //                  see discussion here https://github.com/bitcoin-core/secp256k1/issues/352
        secp256k1.publicKeyTweakMul(publicKey, secretKey)).toString('hex');
        // decrypt token with symmetric ECDH key
        let response;
        try {
            response = {
                token: this.decrypt({
                    input: responseBody.encryptedToken,
                    password: secret,
                }),
            };
        }
        catch (e) {
            e.errorCode = 'token_decryption_failure';
            console.error('Failed to decrypt token.');
            throw e;
        }
        if (!this._ecdhXprv) {
            response.ecdhXprv = ecdhXprv;
        }
        return response;
    }
    /**
     */
    verifyPassword(params = {}) {
        if (!_.isString(params.password)) {
            throw new Error('missing required string password');
        }
        if (!this._user || !this._user.username) {
            throw new Error('no current user');
        }
        const hmacPassword = this.calculateHMAC(this._user.username, params.password);
        return this.post(this.url('/user/verifypassword')).send({ password: hmacPassword }).result('valid');
    }
    /**
     * Clear out all state from this BitGo object, effectively logging out the current user.
     */
    clear() {
        // TODO: are there any other fields which should be cleared?
        this._user = undefined;
        this._token = undefined;
        this._refreshToken = undefined;
        this._ecdhXprv = undefined;
    }
    /**
     * Use refresh token to get new access token.
     * If the refresh token is null/defined, then we use the stored token from auth
     */
    async refreshToken(params = {}) {
        sdk_core_1.common.validateParams(params, [], ['refreshToken']);
        const refreshToken = params.refreshToken || this._refreshToken;
        if (!refreshToken) {
            throw new Error('Must provide refresh token or have authenticated with Oauth before');
        }
        if (!this._clientId || !this._clientSecret) {
            throw new Error('Need client id and secret set first to use this');
        }
        const body = await this.post(this._baseUrl + '/oauth/token')
            .send({
            grant_type: 'refresh_token',
            refresh_token: refreshToken,
            client_id: this._clientId,
            client_secret: this._clientSecret,
        })
            .result();
        this._token = body.access_token;
        this._refreshToken = body.refresh_token;
        return body;
    }
    /**
     *
     * listAccessTokens
     * Get information on all of the BitGo access tokens on the user
     * @return {
     *  id: <id of the token>
     *  label: <the user-provided label for this token>
     *  user: <id of the user on the token>
     *  enterprise <id of the enterprise this token is valid for>
     *  client: <the auth client that this token belongs to>
     *  scope: <list of allowed OAuth scope values>
     *  created: <date the token was created>
     *  expires: <date the token will expire>
     *  origin: <the origin for which this token is valid>
     *  isExtensible: <flag indicating if the token can be extended>
     *  extensionAddress: <address whose private key's signature is necessary for extensions>
     *  unlock: <info for actions that require an unlock before firing>
     * }
     */
    async listAccessTokens() {
        return this.get(this.url('/user/accesstoken')).send().result('accessTokens');
    }
    /**
     * addAccessToken
     * Add a BitGo API Access Token to the current user account
     * @param params {
     *    otp: (required) <valid otp code>
     *    label: (required) <label for the token>
     *    duration: <length of time in seconds the token will be valid for>
     *    ipRestrict: <array of IP address strings to whitelist>
     *    txValueLimit: <number of outgoing satoshis allowed on this token>
     *    scope: (required) <authorization scope of the requested token>
     * }
     * @return {
     *    id: <id of the token>
     *    token: <access token hex string to be used for BitGo API request verification>
     *    label: <user-provided label for this token>
     *    user: <id of the user on the token>
     *    enterprise <id of the enterprise this token is valid for>
     *    client: <the auth client that this token belongs to>
     *    scope: <list of allowed OAuth scope values>
     *    created: <date the token was created>
     *    expires: <date the token will expire>
     *    origin: <the origin for which this token is valid>
     *    isExtensible: <flag indicating if the token can be extended>
     *    extensionAddress: <address whose private key's signature is necessary for extensions>
     *    unlock: <info for actions that require an unlock before firing>
     * }
     */
    async addAccessToken(params) {
        var _a;
        try {
            if (!_.isString(params.label)) {
                throw new Error('required string label');
            }
            // check non-string params
            if (params.duration) {
                if (!_.isNumber(params.duration) || params.duration < 0) {
                    throw new Error('duration must be a non-negative number');
                }
            }
            if (params.ipRestrict) {
                if (!_.isArray(params.ipRestrict)) {
                    throw new Error('ipRestrict must be an array');
                }
                _.forEach(params.ipRestrict, (ipAddr) => {
                    if (!_.isString(ipAddr)) {
                        throw new Error('ipRestrict must be an array of IP address strings');
                    }
                });
            }
            if (params.txValueLimit) {
                if (!_.isNumber(params.txValueLimit)) {
                    throw new Error('txValueLimit must be a number');
                }
                if (params.txValueLimit < 0) {
                    throw new Error('txValueLimit must be a non-negative number');
                }
            }
            if (params.scope && params.scope.length > 0) {
                if (!_.isArray(params.scope)) {
                    throw new Error('scope must be an array');
                }
            }
            else {
                throw new Error('must specify scope for token');
            }
            const authUrl = this.microservicesUrl('/api/auth/v1/accesstoken');
            const request = this.post(authUrl);
            if (!this._ecdhXprv) {
                // without a private key, the user cannot decrypt the new access token the server will send
                request.forceV1Auth = true;
                debug('forcing v1 auth for adding access token using token %s', (_a = this._token) === null || _a === void 0 ? void 0 : _a.substr(0, 8));
            }
            const response = await request.send(params);
            if (request.forceV1Auth) {
                response.body.warning = 'A protocol downgrade has occurred because this is a legacy account.';
                return api_1.handleResponseResult()(response);
            }
            // verify the authenticity of the server's response before proceeding any further
            api_1.verifyResponse(this, this._token, 'post', request, response);
            const responseDetails = this.handleTokenIssuance(response.body);
            response.body.token = responseDetails.token;
            return api_1.handleResponseResult()(response);
        }
        catch (e) {
            api_1.handleResponseError(e);
        }
    }
    /**
     * Sets the expire time of an access token matching either the id or label to the current date, effectively deleting it
     *
     * Params:
     * id: <id of the access token to be deleted>
     * label: <label of the access token to be deleted>
     *
     * Returns:
     * id: <id of the token>
     * label: <user-provided label for this token>
     * user: <id of the user on the token>
     * enterprise <id of the enterprise this token is valid for>
     * client: <the auth client that this token belongs to>
     * scope: <list of allowed OAuth scope values>
     * created: <date the token was created>
     * expires: <date the token will expire>
     * origin: <the origin for which this token is valid>
     * isExtensible: <flag indicating if the token can be extended>
     * extensionAddress: <address whose private key's signature is ne*cessary for extensions>
     * unlock: <info for actions that require an unlock before firing>
     * @param params
     */
    async removeAccessToken({ id, label }) {
        if ((!id && !label) || (id && label)) {
            throw new Error('must provide exactly one of id or label');
        }
        if (id) {
            return this.del(this.url(`/user/accesstoken/${id}`))
                .send()
                .result();
        }
        const tokens = await this.listAccessTokens();
        if (!tokens) {
            throw new Error('token with this label does not exist');
        }
        const matchingTokens = _.filter(tokens, { label });
        if (matchingTokens.length > 1) {
            throw new Error('ambiguous call: multiple tokens matching this label');
        }
        if (matchingTokens.length === 0) {
            throw new Error('token with this label does not exist');
        }
        return this.del(this.url(`/user/accesstoken/${matchingTokens[0].id}`))
            .send()
            .result();
    }
    /**
     * Generate a random password
     * @param   {Number} numWords     Number of 32-bit words
     * @returns {String}          base58 random password
     */
    generateRandomPassword(numWords = 5) {
        const bytes = sjcl.codec.bytes.fromBits(sjcl.random.randomWords(numWords));
        return bs58.encode(bytes);
    }
    /**
     * Logout of BitGo
     */
    async logout() {
        const result = await this.get(this.url('/user/logout')).result();
        this.clear();
        return result;
    }
    /**
     * Get a user by ID (name/email only)
     * @param id
     *
     * @deprecated
     */
    async getUser({ id }) {
        if (!_.isString(id)) {
            throw new Error('expected string id');
        }
        return this.get(this.url(`/user/${id}`)).result('user');
    }
    /**
     * Get the current logged in user
     */
    async me() {
        return this.getUser({ id: 'me' });
    }
    /**
     * Unlock the session by providing OTP
     * @param {string} otp Required OTP code for the account.
     * @param {number} duration Desired duration of the unlock in seconds (default=600, max=3600).
     */
    async unlock({ otp, duration }) {
        if (otp && !_.isString(otp)) {
            throw new Error('expected string or undefined otp');
        }
        return this.post(this.url('/user/unlock')).send({ otp, duration }).result();
    }
    /**
     * Lock the session
     */
    async lock() {
        return this.post(this.url('/user/lock')).result();
    }
    /**
     * Get the current session
     */
    async session() {
        return this.get(this.url('/user/session')).result('session');
    }
    /**
     * Trigger a push/sms for the OTP code
     * @param {boolean} params.forceSMS If set to true, will use SMS to send the OTP to the user even if they have other 2FA method set up.
     * @deprecated
     */
    async sendOTP(params = {}) {
        return this.post(this.url('/user/sendotp')).send(params).result();
    }
    /**
     * Extend token, provided the current token is extendable
     * @param params
     * - duration: duration in seconds by which to extend the token, starting at the current time
     */
    async extendToken(params = {}) {
        if (!this._extensionKey) {
            throw new Error('missing required property _extensionKey');
        }
        const timestamp = Date.now();
        const duration = params.duration;
        const message = timestamp + '|' + this._token + '|' + duration;
        const privateKey = this._extensionKey.privateKey;
        if (!privateKey) {
            throw new Error('no privateKey on extensionKey');
        }
        const isCompressed = this._extensionKey.compressed;
        const prefix = utxolib.networks.bitcoin.messagePrefix;
        const signature = bitcoinMessage.sign(message, privateKey, isCompressed, prefix).toString('hex');
        return this.post(this.url('/user/extendtoken'))
            .send(params)
            .set('timestamp', timestamp.toString())
            .set('signature', signature)
            .result();
    }
    /**
     * Get a key for sharing a wallet with a user
     * @param email email of user to share wallet with
     */
    async getSharingKey({ email }) {
        if (!_.isString(email)) {
            throw new Error('required string email');
        }
        return this.post(this.url('/user/sharingkey')).send({ email }).result();
    }
    /**
     * Users that want to sign with a key will use this api to fetch the keychain and the path.
     * Users that want to verify a signature will use this api to fetch another users ecdh pubkey.
     * Note: If the user id is not provided, it will default to getting the current user's keychain.
     * @param bitgo
     * @param enterpriseId
     * @param userId
     */
    async getSigningKeyForUser(enterpriseId, userId) {
        const user = userId !== null && userId !== void 0 ? userId : 'me';
        return this.get(this.url(`/enterprise/${enterpriseId}/user/${user}/signingkey`, 2))
            .query({})
            .result();
    }
    /**
     *
     */
    getValidate() {
        return this._validate;
    }
    /**
     *
     */
    setValidate(validate) {
        if (!_.isBoolean(validate)) {
            throw new Error('invalid argument');
        }
        this._validate = validate;
    }
    /**
     * Register a new coin instance with its builder factory
     * @param {string} name coin name as it was registered in @bitgo/statics
     * @param {CoinConstructor} coin the builder factory class for that coin
     * @returns {void}
     */
    register(name, coin) {
        sdk_core_1.GlobalCoinFactory.register(name, coin);
    }
    /**
     * Get bitcoin market data
     *
     * @deprecated
     */
    markets() {
        if (!this._markets) {
            this._markets = new Markets(this);
        }
        return this._markets;
    }
    /**
     * Get the latest bitcoin prices
     * (Deprecated: Will be removed in the future) use `bitgo.markets().latest()`
     * @deprecated
     */
    // cb-compat
    async market() {
        return this.get(this.url('/market/latest')).result();
    }
    /**
     * Get market data from yesterday
     * (Deprecated: Will be removed in the future) use bitgo.markets().yesterday()
     * @deprecated
     */
    async yesterday() {
        return this.get(this.url('/market/yesterday')).result();
    }
    /**
     * Get the blockchain object.
     * @deprecated
     */
    blockchain() {
        if (!this._blockchain) {
            this._blockchain = new Blockchain(this);
        }
        return this._blockchain;
    }
    /**
     * Get the user's keychains object.
     * @deprecated
     */
    keychains() {
        if (!this._keychains) {
            this._keychains = new Keychains(this);
        }
        return this._keychains;
    }
    /**
     * Get the travel rule object
     * @deprecated
     */
    travelRule() {
        if (!this._travelRule) {
            this._travelRule = new TravelRule(this);
        }
        return this._travelRule;
    }
    /**
     * Get the user's wallets object.
     * @deprecated
     */
    wallets() {
        if (!this._wallets) {
            this._wallets = new Wallets(this);
        }
        return this._wallets;
    }
    /**
     * Get pending approvals that can be approved/ or rejected
     * @deprecated
     */
    pendingApprovals() {
        if (!this._pendingApprovals) {
            this._pendingApprovals = new PendingApprovals(this);
        }
        return this._pendingApprovals;
    }
    /**
     * A factory method to create a new Wallet object, initialized with the wallet params
     * Can be used to reconstitute a wallet from cached data
     * @param walletParams
     * @deprecated
     */
    newWalletObject(walletParams) {
        return new Wallet(this, walletParams);
    }
    /**
     * V1 method for calculating miner fee amounts, given the number and
     * type of transaction inputs, along with a fee rate in satoshis per vkB.
     *
     * This method should not be used for new code.
     *
     * @deprecated
     * @param params
     * @return {any}
     */
    async calculateMinerFeeInfo(params) {
        return TransactionBuilder.calculateMinerFeeInfo(params);
    }
    /**
     * Verify a Bitcoin address is a valid base58 address
     * @deprecated
     */
    verifyAddress(params = {}) {
        sdk_core_1.common.validateParams(params, ['address'], []);
        if (!_.isString(params.address)) {
            throw new Error('missing required string address');
        }
        const networkName = sdk_core_1.common.Environments[this.getEnv()].network;
        const network = utxolib.networks[networkName];
        let address;
        try {
            address = utxolib.address.fromBase58Check(params.address, network);
        }
        catch (e) {
            return false;
        }
        return address.version === network.pubKeyHash || address.version === network.scriptHash;
    }
    /**
     * Split a secret into shards using Shamir Secret Sharing.
     * @param seed A hexadecimal secret to split
     * @param passwords An array of the passwords used to encrypt each share
     * @param m The threshold number of shards necessary to reconstitute the secret
     */
    splitSecret({ seed, passwords, m }) {
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (!_.isInteger(m) || m < 2) {
            throw new Error('m must be a positive integer greater than or equal to 2');
        }
        if (passwords.length < m) {
            throw new Error('passwords array length cannot be less than m');
        }
        const n = passwords.length;
        const secrets = shamir.share(seed, n, m);
        const shards = _.zipWith(secrets, passwords, (shard, password) => {
            return this.encrypt({ input: shard, password });
        });
        const node = utxo_lib_1.bip32.fromSeed(Buffer.from(seed, 'hex'));
        return {
            xpub: node.neutered().toBase58(),
            m,
            n,
            seedShares: shards,
        };
    }
    /**
     * Reconstitute a secret which was sharded with `splitSecret`.
     * @param shards
     * @param passwords
     */
    reconstituteSecret({ shards, passwords }) {
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        const secrets = _.zipWith(shards, passwords, (shard, password) => {
            return this.decrypt({ input: shard, password });
        });
        const seed = shamir.combine(secrets);
        const node = utxo_lib_1.bip32.fromSeed(Buffer.from(seed, 'hex'));
        return {
            xpub: node.neutered().toBase58(),
            xprv: node.toBase58(),
            seed,
        };
    }
    /**
     *
     * @param shards
     * @param passwords
     * @param m
     * @param xpub Optional xpub to verify the results against
     */
    verifyShards({ shards, passwords, m, xpub }) {
        /**
         * Generate all possible combinations of a given array's values given subset size m
         * @param array The array whose values are to be arranged in all combinations
         * @param m The size of each subset
         * @param entryIndices Recursively trailing set of currently chosen array indices for the combination subset under construction
         * @returns {Array}
         */
        const generateCombinations = (array, m, entryIndices = []) => {
            let combinations = [];
            if (entryIndices.length === m) {
                const currentCombination = _.at(array, entryIndices);
                return [currentCombination];
            }
            // The highest index
            let entryIndex = _.last(entryIndices);
            // If there are currently no indices, assume -1
            if (_.isUndefined(entryIndex)) {
                entryIndex = -1;
            }
            for (let i = entryIndex + 1; i < array.length; i++) {
                // append the current index to the trailing indices
                const currentEntryIndices = [...entryIndices, i];
                const newCombinations = generateCombinations(array, m, currentEntryIndices);
                combinations = [...combinations, ...newCombinations];
            }
            return combinations;
        };
        if (!Array.isArray(shards)) {
            throw new Error('shards must be an array');
        }
        if (!Array.isArray(passwords)) {
            throw new Error('passwords must be an array');
        }
        if (shards.length !== passwords.length) {
            throw new Error('shards and passwords arrays must have same length');
        }
        const secrets = _.zipWith(shards, passwords, (shard, password) => {
            return this.decrypt({ input: shard, password });
        });
        const secretCombinations = generateCombinations(secrets, m);
        const seeds = secretCombinations.map((currentCombination) => {
            return shamir.combine(currentCombination);
        });
        const uniqueSeeds = _.uniq(seeds);
        if (uniqueSeeds.length !== 1) {
            return false;
        }
        const seed = _.first(uniqueSeeds);
        const node = utxo_lib_1.bip32.fromSeed(Buffer.from(seed, 'hex'));
        const restoredXpub = node.neutered().toBase58();
        if (!_.isUndefined(xpub)) {
            if (!_.isString(xpub)) {
                throw new Error('xpub must be a string');
            }
            if (restoredXpub !== xpub) {
                return false;
            }
        }
        return true;
    }
    /**
     * @deprecated - use `getSharedSecret()`
     */
    getECDHSecret({ otherPubKeyHex, eckey }) {
        if (!_.isString(otherPubKeyHex)) {
            throw new Error('otherPubKeyHex string required');
        }
        if (!_.isObject(eckey)) {
            throw new Error('eckey object required');
        }
        return sdk_core_1.getSharedSecret(eckey, Buffer.from(otherPubKeyHex, 'hex')).toString('hex');
    }
    /**
     * Gets the user's private ECDH keychain
     */
    async getECDHKeychain(ecdhKeychainPub) {
        if (!ecdhKeychainPub) {
            const result = await this.get(this.url('/user/settings')).result();
            if (!result.settings.ecdhKeychain) {
                return new Error('ecdh keychain not found for user');
            }
            ecdhKeychainPub = result.settings.ecdhKeychain;
        }
        return this.keychains().get({ xpub: ecdhKeychainPub });
    }
    /**
     * Returns the user derived public and private ECDH keypair
     * @param password password to decrypt the user's ECDH encrypted private key
     * @param entId? optional enterprise id to check for permissions
     */
    async getEcdhKeypairPrivate(password, entId) {
        const userSigningKey = await this.getSigningKeyForUser(entId);
        const pubkeyOfAdminEcdhKeyHex = userSigningKey.derivedPubkey;
        if (!userSigningKey.ecdhKeychain || !userSigningKey.derivationPath) {
            throw new Error('Something went wrong with the user keychain. Please contact support@bitgo.com.');
        }
        const userEcdhKeychain = await this.getECDHKeychain(userSigningKey.ecdhKeychain);
        let xprv;
        try {
            xprv = this.decrypt({
                password: password,
                input: userEcdhKeychain.encryptedXprv,
            });
        }
        catch (e) {
            throw new Error('Incorrect password. Please try again.');
        }
        return {
            derivedPubKey: pubkeyOfAdminEcdhKeyHex,
            derivationPath: userSigningKey.derivationPath,
            xprv,
        };
    }
    /**
     * @param params
     * - operatingSystem: one of ios, android
     * - pushToken: hex-formatted token for the respective native push notification service
     * @returns {*}
     * @deprecated
     */
    async registerPushToken(params) {
        params = params || {};
        sdk_core_1.common.validateParams(params, ['pushToken', 'operatingSystem'], []);
        if (!this._token) {
            // this device has to be registered to an extensible session
            throw new Error('not logged in');
        }
        const postParams = _.pick(params, ['pushToken', 'operatingSystem']);
        return this.post(this.url('/devices')).send(postParams).result();
    }
    /**
     * @param params
     * - pushVerificationToken: the token received via push notification to confirm the device's mobility
     * @deprecated
     */
    verifyPushToken(params) {
        if (!_.isObject(params)) {
            throw new Error('required object params');
        }
        if (!_.isString(params.pushVerificationToken)) {
            throw new Error('required string pushVerificationToken');
        }
        if (!this._token) {
            // this device has to be registered to an extensible session
            throw new Error('not logged in');
        }
        const postParams = _.pick(params, 'pushVerificationToken');
        return this.post(this.url('/devices/verify')).send(postParams).result();
    }
    /**
     * Login to the bitgo system using an authcode generated via Oauth
     */
    async authenticateWithAuthCode(params) {
        if (!_.isObject(params)) {
            throw new Error('required object params');
        }
        if (!_.isString(params.authCode)) {
            throw new Error('required string authCode');
        }
        if (!this._clientId || !this._clientSecret) {
            throw new Error('Need client id and secret set first to use this');
        }
        const authCode = params.authCode;
        if (this._token) {
            throw new Error('already logged in');
        }
        const request = this.post(this._baseUrl + '/oauth/token');
        request.forceV1Auth = true; // OAuth currently only supports v1 authentication
        const body = await request
            .send({
            grant_type: 'authorization_code',
            code: authCode,
            client_id: this._clientId,
            client_secret: this._clientSecret,
        })
            .result();
        this._token = body.access_token;
        this._refreshToken = body.refresh_token;
        this._user = await this.me();
        return body;
    }
    /**
     * Change the password of the currently logged in user.
     * Also change all v1 and v2 keychain passwords if they match the
     * given oldPassword. Returns nothing on success.
     * @param oldPassword {String} - the current password
     * @param newPassword {String} - the new password
     */
    async changePassword({ oldPassword, newPassword }) {
        if (!_.isString(oldPassword)) {
            throw new Error('expected string oldPassword');
        }
        if (!_.isString(newPassword)) {
            throw new Error('expected string newPassword');
        }
        const user = this.user();
        if (typeof user !== 'object' || !user.username) {
            throw new Error('missing required object user');
        }
        const validation = await this.verifyPassword({ password: oldPassword });
        if (!validation) {
            throw new Error('the provided oldPassword is incorrect');
        }
        // it doesn't matter which coin we choose because the v2 updatePassword functions updates all v2 keychains
        // we just need to choose a coin that exists in the current environment
        const coin = sdk_core_1.common.Environments[this.getEnv()].network === 'bitcoin' ? 'btc' : 'tbtc';
        const updateKeychainPasswordParams = { oldPassword, newPassword };
        const v1KeychainUpdatePWResult = await this.keychains().updatePassword(updateKeychainPasswordParams);
        const v2Keychains = await this.coin(coin).keychains().updatePassword(updateKeychainPasswordParams);
        const updatePasswordParams = {
            keychains: v1KeychainUpdatePWResult.keychains,
            v2_keychains: v2Keychains,
            version: v1KeychainUpdatePWResult.version,
            oldPassword: this.calculateHMAC(user.username, oldPassword),
            password: this.calculateHMAC(user.username, newPassword),
        };
        return this.post(this.url('/user/changepassword')).send(updatePasswordParams).result();
    }
    /**
     * Get all the address labels on all of the user's wallets
     *
     * @deprecated
     */
    async labels() {
        return this.get(this.url('/labels')).result('labels');
    }
    /**
     * Estimates approximate fee per kb needed for a tx to get into a block
     * @param {number} params.numBlocks target blocks for the transaction to be confirmed
     * @param {number} params.maxFee maximum fee willing to be paid (for safety)
     * @param {array[string]} params.inputs list of unconfirmed txIds from which this transaction uses inputs
     * @param {number} params.txSize estimated transaction size in bytes, optional parameter used for CPFP estimation.
     * @param {boolean} params.cpfpAware flag indicating fee should take into account CPFP
     * @deprecated
     */
    async estimateFee(params = {}) {
        const queryParams = { version: 12 };
        if (params.numBlocks) {
            if (!_.isNumber(params.numBlocks)) {
                throw new Error('invalid argument');
            }
            queryParams.numBlocks = params.numBlocks;
        }
        if (params.maxFee) {
            if (!_.isNumber(params.maxFee)) {
                throw new Error('invalid argument');
            }
            queryParams.maxFee = params.maxFee;
        }
        if (params.inputs) {
            if (!Array.isArray(params.inputs)) {
                throw new Error('invalid argument');
            }
            queryParams.inputs = params.inputs;
        }
        if (params.txSize) {
            if (!_.isNumber(params.txSize)) {
                throw new Error('invalid argument');
            }
            queryParams.txSize = params.txSize;
        }
        if (params.cpfpAware) {
            if (!_.isBoolean(params.cpfpAware)) {
                throw new Error('invalid argument');
            }
            queryParams.cpfpAware = params.cpfpAware;
        }
        return this.get(this.url('/tx/fee')).query(queryParams).result();
    }
    /**
     * Get BitGo's guarantee using an instant id
     * @param params
     * @deprecated
     */
    async instantGuarantee(params) {
        if (!_.isString(params.id)) {
            throw new Error('required string id');
        }
        const body = await this.get(this.url('/instant/' + params.id)).result();
        if (!body.guarantee) {
            throw new Error('no guarantee found in response body');
        }
        if (!body.signature) {
            throw new Error('no signature found in guarantee response body');
        }
        const signingAddress = sdk_core_1.common.Environments[this.getEnv()].signingAddress;
        const signatureBuffer = Buffer.from(body.signature, 'hex');
        const prefix = utxolib.networks[sdk_core_1.common.Environments[this.getEnv()].network].messagePrefix;
        const isValidSignature = bitcoinMessage.verify(body.guarantee, signingAddress, signatureBuffer, prefix);
        if (!isValidSignature) {
            throw new Error('incorrect signature');
        }
        return body;
    }
    /**
     * Get a target address for payment of a BitGo fee
     * @deprecated
     */
    async getBitGoFeeAddress() {
        return this.post(this.url('/billing/address')).send({}).result();
    }
    /**
     * Gets an address object (including the wallet id) for a given address.
     * @param {string} params.address The address to look up.
     * @deprecated
     */
    async getWalletAddress({ address }) {
        return this.get(this.url(`/walletaddress/${address}`)).result();
    }
    /**
     * Fetch list of user webhooks
     *
     * @returns {*}
     * @deprecated
     */
    async listWebhooks() {
        return this.get(this.url('/webhooks')).result();
    }
    /**
     * Add new user webhook
     *
     * @param params
     * @returns {*}
     * @deprecated
     */
    async addWebhook(params) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.post(this.url('/webhooks')).send(params).result();
    }
    /**
     * Remove user webhook
     *
     * @param params
     * @returns {*}
     * @deprecated
     */
    async removeWebhook(params) {
        if (!_.isString(params.url)) {
            throw new Error('required string url');
        }
        if (!_.isString(params.type)) {
            throw new Error('required string type');
        }
        return this.del(this.url('/webhooks')).send(params).result();
    }
    /**
     * Fetch list of webhook notifications for the user
     *
     * @param params
     * @returns {*}
     */
    async listWebhookNotifications(params = {}) {
        const query = {};
        if (params.prevId) {
            if (!_.isString(params.prevId)) {
                throw new Error('invalid prevId argument, expecting string');
            }
            query.prevId = params.prevId;
        }
        if (params.limit) {
            if (!_.isNumber(params.limit)) {
                throw new Error('invalid limit argument, expecting number');
            }
            query.limit = params.limit;
        }
        return this.get(this.url('/webhooks/notifications')).query(query).result();
    }
    /**
     * Simulate a user webhook
     *
     * @param params
     * @returns {*}
     */
    async simulateWebhook(params) {
        sdk_core_1.common.validateParams(params, ['webhookId', 'blockId'], []);
        if (!_.isString(params.webhookId)) {
            throw new Error('required string webhookId');
        }
        if (!_.isString(params.blockId)) {
            throw new Error('required string blockId');
        }
        return this.post(this.url(`/webhooks/${params.webhookId}/simulate`))
            .send(params)
            .result();
    }
    /**
     * Synchronously get constants which are relevant to the client.
     *
     * Note: This function has a known race condition. It may return different values over time,
     * especially if called shortly after creation of the BitGo object.
     *
     * New code should call fetchConstants() directly instead.
     *
     * @deprecated
     * @return {Object} The client constants object
     */
    getConstants() {
        // kick off a fresh request for the client constants
        this.fetchConstants().catch(function (err) {
            if (err) {
                // make sure an error does not terminate the entire script
                console.error('failed to fetch client constants from BitGo');
                console.trace(err);
            }
        });
        // use defaultConstants as the backup for keys that are not set in this._constants
        return _.merge({}, sdk_core_1.defaultConstants(this.getEnv()), BitGoAPI._constants[this.getEnv()]);
    }
}
exports.BitGoAPI = BitGoAPI;
BitGoAPI._testnetWarningMessage = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Z29BUEkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYml0Z29BUEkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsOENBcUJ5QjtBQUN6QixvQ0FBb0M7QUFDcEMsMkNBQTJDO0FBQzNDLDhDQUF5RDtBQUN6RCxvREFBb0Q7QUFDcEQscURBQXlEO0FBQ3pELDZCQUE2QjtBQUM3QixtQ0FBb0M7QUFDcEMsaUNBQTZCO0FBQzdCLDRCQUE0QjtBQUM1Qix1Q0FBdUM7QUFDdkMseUNBQXlDO0FBQ3pDLDhCQUE4QjtBQUM5QiwrQkFPZTtBQUNmLHVDQUE2QztBQXlDN0MsNENBQTZDO0FBQzdDLHlDQUEwQztBQUMxQyxNQUFNLEtBQUssR0FBRyxlQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFcEMsTUFBTSxVQUFVLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7QUFDOUMsTUFBTSxTQUFTLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDNUMsc0NBQXVDO0FBRXZDLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN4QyxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDeEMsTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQztBQUMxRCxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUM5QyxNQUFNLGtCQUFrQixHQUFHLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0FBRTlELElBQUksVUFBZSxDQUFDO0FBQ3BCLElBQUksQ0FBQywyQkFBUyxJQUFJLENBQUMsNkJBQVcsRUFBRTtJQUM5QixLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztJQUM5QixVQUFVLEdBQUcsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLFVBQVUsQ0FBQztDQUNoRDtBQUVELE1BQU0scUJBQXFCLEdB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TSxDQUFDLFNBQVMsRUFBRTtZQUNwQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUNyQztZQUNELFdBQVcsQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztTQUMxQztRQUNELElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUNqQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUNyQztZQUNELFdBQVcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUNwQztRQUNELElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQ2pDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUNyQztZQUNELFdBQVcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUNwQztRQUNELElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTtZQUNqQixJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUNyQztZQUNELFdBQVcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUNwQztRQUNELElBQUksTUFBTSxDQUFDLFNBQVMsRUFBRTtZQUNwQixJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQzthQUNyQztZQUNE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QUMsQ0FBQzthQUNwQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsa0ZBQWtGO1FBQ2xGLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsMkJBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQzFGLENBQUM7O0FBMzJESCw0QkE0MkRDO0FBajJEa0IsK0JBQXNCLEdBQUcsS0FBSyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQWxpYXNFbnZpcm9ubWVudHMsXG4gIEJhc2VDb2luLFxuICBiaXRjb2luLFxuICBCaXRHb0Jhc2UsXG4gIEJpdEdvUmVxdWVzdCxcbiAgQ29pbkNvbnN0cnVjdG9yLFxuICBjb21tb24sXG4gIERlY3J5cHRPcHRpb25zLFxuICBkZWZhdWx0Q29uc3RhbnRzLFxuICBFY2RoRGVyaXZlZEtleXBhaXIsXG4gIEVuY3J5cHRPcHRpb25zLFxuICBFbnZpcm9ubWVudE5hbWUsXG4gIGdldEFkZHJlc3NQMlBLSCxcbiAgZ2V0U2hhcmVkU2VjcmV0LFxuICBHZXRTaGFyaW5nS2V5T3B0aW9ucyxcbiAgR2V0U2lnbmluZ0tleUFwaSxcbiAgR2xvYmFsQ29pbkZhY3RvcnksXG4gIElSZXF1ZXN0VHJhY2VyLFxuICBtYWtlUmFuZG9tS2V5LFxuICBzYW5pdGl6ZUxlZ2FjeVBhdGgsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgKiBhcyBzamNsIGZyb20gJ0BiaXRnby9zamNsJztcbmltcG9ydCAqIGFzIHV0eG9saWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IGJpcDMyLCBFQ1BhaXJJbnRlcmZhY2UgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgYml0Y29pbk1lc3NhZ2UgZnJvbSAnYml0Y29pbmpzLW1lc3NhZ2UnO1xuaW1wb3J0IHsgaXNCcm93c2VyLCBpc1dlYldvcmtlciB9IGZyb20gJ2Jyb3dzZXItb3Itbm9kZSc7XG5pbXBvcnQgKiBhcyBiczU4IGZyb20gJ2JzNTgnO1xuaW1wb3J0IHsgY3JlYXRlSG1hYyB9IGZyb20gJ2NyeXB0byc7XG5pbXBvcnQgZGVidWdMaWIgZnJvbSAnZGVidWcnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgc2VjcDI1NmsxIGZyb20gJ3NlY3AyNTZrMSc7XG5pbXBvcnQgKiBhcyBzdXBlcmFnZW50IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgdXJsTGliIGZyb20gJ3VybCc7XG5pbXBvcnQge1xuICBoYW5kbGVSZXNwb25zZUVycm9yLFxuICBoYW5kbGVSZXNwb25zZVJlc3VsdCxcbiAgc2VyaWFsaXplUmVxdWVzdERhdGEsXG4gIHNldFJlcXVlc3RRdWVyeVN0cmluZyxcbiAgdG9CaXRnb1JlcXVlc3QsXG4gIHZlcmlmeVJlc3BvbnNlLFxufSBmcm9tICcuL2FwaSc7XG5pbXBvcnQgeyBkZWNyeXB0LCBlbmNyeXB0IH0gZnJvbSAnLi9lbmNyeXB0JztcbmltcG9ydCB7XG4gIEFjY2Vzc1Rva2VuT3B0aW9ucyxcbiAgQWRkQWNjZXNzVG9rZW5PcHRpb25zLFxuICBBZGRBY2Nlc3NUb2tlblJlc3BvbnNlLFxuICBBdXRoZW50aWNhdGVPcHRpb25zLFxuICBBdXRoZW50aWNhdGVXaXRoQXV0aENvZGVPcHRpb25zLFxuICBCaXRHb0FQSU9wdGlvbnMsXG4gIEJpdEdvSnNvbixcbiAgQml0R29TaW11bGF0ZVdlYmhvb2tPcHRpb25zLFxuICBDYWxjdWxhdGVIbWFjU3ViamVjdE9wdGlvbnMsXG4gIENhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzT3B0aW9ucyxcbiAgQ2FsY3VsYXRlUmVxdWVzdEhtYWNPcHRpb25zLFxuICBDaGFuZ2VQYXNzd29yZE9wdGlvbnMsXG4gIERlcHJlY2F0ZWRWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgRXN0aW1hdGVGZWVPcHRpb25zLFxuICBFeHRlbmRUb2tlbk9wdGlvbnMsXG4gIEdldEVjZGhTZWNyZXRPcHRpb25zLFxuICBHZXRVc2VyT3B0aW9ucyxcbiAgTGlzdFdlYmhvb2tOb3RpZmljYXRpb25zT3B0aW9ucyxcbiAgTG9naW5SZXNwb25zZSxcbiAgUGluZ09wdGlvbnMsXG4gIFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyxcbiAgUmVjb25zdGl0dXRlZFNlY3JldCxcbiAgUmVjb25zdGl0dXRlU2VjcmV0T3B0aW9ucyxcbiAgUmVnaXN0ZXJQdXNoVG9rZW5PcHRpb25zLFxuICBSZW1vdmVBY2Nlc3NUb2tlbk9wdGlvbnMsXG4gIFJlcXVlc3RIZWFkZXJzLFxuICBTcGxpdFNlY3JldCxcbiAgU3BsaXRTZWNyZXRPcHRpb25zLFxuICBUb2tlbklzc3VhbmNlLFxuICBUb2tlbklzc3VhbmNlUmVzcG9uc2UsXG4gIFVubG9ja09wdGlvbnMsXG4gIFVzZXIsXG4gIFZlcmlmeVBhc3N3b3JkT3B0aW9ucyxcbiAgVmVyaWZ5UHVzaFRva2VuT3B0aW9ucyxcbiAgVmVyaWZ5UmVzcG9uc2VJbmZvLFxuICBWZXJpZnlSZXNwb25zZU9wdGlvbnMsXG4gIFZlcmlmeVNoYXJkc09wdGlvbnMsXG4gIFdlYmhvb2tPcHRpb25zLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCBzaGFtaXIgPSByZXF1aXJlKCdzZWNyZXRzLmpzLWdyZW1wZScpO1xuaW1wb3J0IHBqc29uID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzphcGknKTtcblxuY29uc3QgQmxvY2tjaGFpbiA9IHJlcXVpcmUoJy4vdjEvYmxvY2tjaGFpbicpO1xuY29uc3QgS2V5Y2hhaW5zID0gcmVxdWlyZSgnLi92MS9rZXljaGFpbnMnKTtcbmltcG9ydCBXYWxsZXQgPSByZXF1aXJlKCcuL3YxL3dhbGxldCcpO1xuXG5jb25zdCBXYWxsZXRzID0gcmVxdWlyZSgnLi92MS93YWxsZXRzJyk7XG5jb25zdCBNYXJrZXRzID0gcmVxdWlyZSgnLi92MS9tYXJrZXRzJyk7XG5jb25zdCBQZW5kaW5nQXBwcm92YWxzID0gcmVxdWlyZSgnLi92MS9wZW5kaW5nYXBwcm92YWxzJyk7XG5jb25zdCBUcmF2ZWxSdWxlID0gcmVxdWlyZSgnLi92MS90cmF2ZWxSdWxlJyk7XG5jb25zdCBUcmFuc2FjdGlvbkJ1aWxkZXIgPSByZXF1aXJlKCcuL3YxL3RyYW5zYWN0aW9uQnVpbGRlcicpO1xuXG5sZXQgcHJveHlBZ2VudDogYW55O1xuaWYgKCFpc0Jyb3dzZXIgJiYgIWlzV2ViV29ya2VyKSB7XG4gIGRlYnVnKCdlbmFibGluZyBwcm94eS1hZ2VudCcpO1xuICBwcm94eUFnZW50ID0gcmVxdWlyZSgncHJveHktYWdlbnQnKS5Qcm94eUFnZW50O1xufVxuXG5jb25zdCBwYXRjaGVkUmVxdWVzdE1ldGhvZHMgPSBbJ2dldCcsICdwb3N0JywgJ3B1dCcsICdkZWwnLCAncGF0Y2gnXSBhcyBjb25zdDtcblxuZXhwb3J0IGNsYXNzIEJpdEdvQVBJIGltcGxlbWVudHMgQml0R29CYXNlIHtcbiAgLy8gdjEgdHlwZXNcbiAgcHJvdGVjdGVkIF9rZXljaGFpbnM6IGFueTtcbiAgcHJvdGVjdGVkIF93YWxsZXRzOiBhbnk7XG4gIHByb3RlY3RlZCBfbWFya2V0cz86IGFueTtcbiAgcHJvdGVjdGVkIF9ibG9ja2NoYWluPzogYW55O1xuICBwcm90ZWN0ZWQgX3RyYXZlbFJ1bGU/OiBhbnk7XG4gIHByb3RlY3RlZCBfcGVuZGluZ0FwcHJvdmFscz86IGFueTtcblxuICBwcm90ZWN0ZWQgc3RhdGljIF9jb25zdGFudHM6IGFueTtcbiAgcHJvdGVjdGVkIHN0YXRpYyBfY29uc3RhbnRzRXhwaXJlOiBhbnk7XG4gIHByb3RlY3RlZCBzdGF0aWMgX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSA9IGZhbHNlO1xuICBwdWJsaWMgcmVhZG9ubHkgZW52OiBFbnZpcm9ubWVudE5hbWU7XG4gIHByb3RlY3RlZCByZWFkb25seSBfYmFzZVVybDogc3RyaW5nO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2Jhc2VBcGlVcmw6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9iYXNlQXBpVXJsVjI6IHN0cmluZztcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9lbnY6IEVudmlyb25tZW50TmFtZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9hdXRoVmVyc2lvbjogRXhjbHVkZTxCaXRHb0FQSU9wdGlvbnNbJ2F1dGhWZXJzaW9uJ10sIHVuZGVmaW5lZD4gPSAyO1xuICBwcm90ZWN0ZWQgX2htYWNWZXJpZmljYXRpb24gPSB0cnVlO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3Byb3h5Pzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3VzZXI/OiBVc2VyO1xuICBwcm90ZWN0ZWQgX2V4dGVuc2lvbktleT86IEVDUGFpckludGVyZmFjZTtcbiAgcHJvdGVjdGVkIF9yZXFJZD86IElSZXF1ZXN0VHJhY2VyO1xuICBwcm90ZWN0ZWQgX3Rva2VuPzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3ZlcnNpb24gPSBwanNvbi52ZXJzaW9uO1xuICBwcm90ZWN0ZWQgX3VzZXJBZ2VudD86IHN0cmluZztcbiAgcHJvdGVjdGVkIF9lY2RoWHBydj86IHN0cmluZztcbiAgcHJvdGVjdGVkIF9yZWZyZXNoVG9rZW4/OiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBfY2xpZW50SWQ/OiBzdHJpbmc7XG4gIHByb3RlY3RlZCByZWFkb25seSBfY2xpZW50U2VjcmV0Pzogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3ZhbGlkYXRlOiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgY29va2llc1Byb3BhZ2F0aW9uRW5hYmxlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihwYXJhbXM6IEJpdEdvQVBJT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jb29raWVzUHJvcGFnYXRpb25FbmFibGVkID0gZmFsc2U7XG4gICAgaWYgKFxuICAgICAgIWNvbW1vbi52YWxpZGF0ZVBhcmFtcyhcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBbXSxcbiAgICAgICAgW1xuICAgICAgICAgICdhY2Nlc3NUb2tlbicsXG4gICAgICAgICAgJ3VzZXJBZ2VudCcsXG4gICAgICAgICAgJ2N1c3RvbVJvb3RVUkknLFxuICAgICAgICAgICdjdXN0b21CaXRjb2luTmV0d29yaycsXG4gICAgICAgICAgJ3NlcnZlclhwdWInLFxuICAgICAgICAgICdzdGVsbGFyRmVkZXJhdGlvblNlcnZlclVybCcsXG4gICAgICAgIF1cbiAgICAgICkgfHxcbiAgICAgIChwYXJhbXMudXNlUHJvZHVjdGlvbiAmJiAhXy5pc0Jvb2xlYW4ocGFyYW1zLnVzZVByb2R1Y3Rpb24pKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2Ugb3BlcmF0ZSBvbiB0aGUgdGVzdCBzZXJ2ZXIuXG4gICAgLy8gRGVwcmVjYXRlIHVzZVByb2R1Y3Rpb24gaW4gdGhlIGZ1dHVyZVxuICAgIGxldCBlbnY6IEVudmlyb25tZW50TmFtZTtcblxuICAgIGlmIChwYXJhbXMudXNlUHJvZHVjdGlvbikge1xuICAgICAgaWYgKHBhcmFtcy5lbnYgJiYgcGFyYW1zLmVudiAhPT0gJ3Byb2QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHVzZSB1c2VQcm9kdWN0aW9uIHdoZW4gZW52PScgKyBwYXJhbXMuZW52KTtcbiAgICAgIH1cbiAgICAgIGVudiA9ICdwcm9kJztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcGFyYW1zLmN1c3RvbVJvb3RVUkkgfHxcbiAgICAgIHBhcmFtcy5jdXN0b21CaXRjb2luTmV0d29yayB8fFxuICAgICAgcGFyYW1zLmN1c3RvbVNpZ25pbmdBZGRyZXNzIHx8XG4gICAgICBwYXJhbXMuc2VydmVyWHB1YiB8fFxuICAgICAgcHJvY2Vzcy5lbnYuQklUR09fQ1VTVE9NX1JPT1RfVVJJIHx8XG4gICAgICBwcm9jZXNzLmVudi5CSVRHT19DVVNUT01fQklUQ09JTl9ORVRXT1JLXG4gICAgKSB7XG4gICAgICAvLyBmb3IgYnJhbmNoIGRlcGxveXMsIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBzcGVjaWZ5IGN1c3RvbSBlbmRwb2ludHMgd2hpbGUgc3RpbGxcbiAgICAgIC8vIG1haW50YWluaW5nIHRoZSBuYW1lIG9mIHNwZWNpZmllZCB0aGUgZW52aXJvbm1lbnRcbiAgICAgIGVudiA9IHBhcmFtcy5lbnYgPT09ICdicmFuY2gnID8gJ2JyYW5jaCcgOiAnY3VzdG9tJztcbiAgICAgIGlmIChwYXJhbXMuY3VzdG9tUm9vdFVSSSkge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0udXJpID0gcGFyYW1zLmN1c3RvbVJvb3RVUkk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmN1c3RvbUJpdGNvaW5OZXR3b3JrKSB7XG4gICAgICAgIGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS5uZXR3b3JrID0gcGFyYW1zLmN1c3RvbUJpdGNvaW5OZXR3b3JrO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jdXN0b21TaWduaW5nQWRkcmVzcykge1xuICAgICAgICAoY29tbW9uLkVudmlyb25tZW50c1tlbnZdIGFzIGFueSkuY3VzdG9tU2lnbmluZ0FkZHJlc3MgPSBwYXJhbXMuY3VzdG9tU2lnbmluZ0FkZHJlc3M7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnNlcnZlclhwdWIpIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnNlcnZlclhwdWIgPSBwYXJhbXMuc2VydmVyWHB1YjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuc3RlbGxhckZlZGVyYXRpb25TZXJ2ZXJVcmwpIHtcbiAgICAgICAgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsID0gcGFyYW1zLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy5jb29raWVzUHJvcGFnYXRpb25FbmFibGVkKSB7XG4gICAgICAgIHRoaXMuY29va2llc1Byb3BhZ2F0aW9uRW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudiA9IHBhcmFtcy5lbnYgfHwgKHByb2Nlc3MuZW52LkJJVEdPX0VOViBhcyBFbnZpcm9ubWVudE5hbWUpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoaXMgaGFzbid0IGJlZW4gc2V0IHRvIHRydWUgYWxyZWFkeSBzb21lIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXRcbiAgICBpZiAocGFyYW1zLmNvb2tpZXNQcm9wYWdhdGlvbkVuYWJsZWQgJiYgIXRoaXMuY29va2llc1Byb3BhZ2F0aW9uRW5hYmxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb29raWVzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBjdXN0b20gVVJJcyBhcmUgaW4gdXNlJyk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtcy5hdXRoVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9hdXRoVmVyc2lvbiA9IHBhcmFtcy5hdXRoVmVyc2lvbjtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGlzIGVudiBpcyBhbiBhbGlhcywgc3dhcCBpdCBvdXQgd2l0aCB0aGUgZXF1aXZhbGVudCBzdXBwb3J0ZWQgZW52aXJvbm1lbnRcbiAgICBpZiAoZW52IGluIEFsaWFzRW52aXJvbm1lbnRzKSB7XG4gICAgICBlbnYgPSBBbGlhc0Vudmlyb25tZW50c1tlbnZdO1xuICAgIH1cblxuICAgIGlmIChlbnYgPT09ICdjdXN0b20nICYmIF8uaXNVbmRlZmluZWQoY29tbW9uLkVudmlyb25tZW50c1tlbnZdLnVyaSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ211c3QgdXNlIC0tY3VzdG9tcm9vdHVyaSBvciBzZXQgdGhlIEJJVEdPX0NVU1RPTV9ST09UX1VSSSBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aGVuIHVzaW5nIHRoZSBjdXN0b20gZW52aXJvbm1lbnQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChlbnYpIHtcbiAgICAgIGlmIChjb21tb24uRW52aXJvbm1lbnRzW2Vudl0pIHtcbiAgICAgICAgdGhpcy5fYmFzZVVybCA9IGNvbW1vbi5FbnZpcm9ubWVudHNbZW52XS51cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW52aXJvbm1lbnQgJyArIGVudiArICcuIFN1cHBvcnRlZCBlbnZpcm9ubWVudHM6IHByb2QsIHRlc3QsIGRldiwgbGF0ZXN0Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudiA9ICd0ZXN0JztcbiAgICAgIGlmICghQml0R29BUEkuX3Rlc3RuZXRXYXJuaW5nTWVzc2FnZSkge1xuICAgICAgICBCaXRHb0FQSS5fdGVzdG5ldFdhcm5pbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS5sb2coJ0JpdEdvIFNESyBlbnYgbm90IHNldCAtIGRlZmF1bHRpbmcgdG8gdGVzdCBhdCB0ZXN0LmJpdGdvLmNvbS4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Jhc2VVcmwgPSBjb21tb24uRW52aXJvbm1lbnRzW2Vudl0udXJpO1xuICAgIH1cbiAgICB0aGlzLl9lbnYgPSB0aGlzLmVudiA9IGVudjtcblxuICAgIGNvbnN0IHN1cHBvcnRlZEFwaVRva2VucyA9IFsnZXRoZXJzY2FuQXBpVG9rZW4nLCAncG9seWdvbnNjYW5BcGlUb2tlbicsICdzbm93dHJhY2VBcGlUb2tlbiddO1xuXG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmIChzdXBwb3J0ZWRBcGlUb2tlbnMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjb21tb24uRW52aXJvbm1lbnRzW2Vudl1ba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29tbW9uLnNldE5ldHdvcmsoY29tbW9uLkVudmlyb25tZW50c1tlbnZdLm5ldHdvcmspO1xuXG4gICAgdGhpcy5fYmFzZUFwaVVybCA9IHRoaXMuX2Jhc2VVcmwgKyAnL2FwaS92MSc7XG4gICAgdGhpcy5fYmFzZUFwaVVybFYyID0gdGhpcy5fYmFzZVVybCArICcvYXBpL3YyJztcbiAgICB0aGlzLl90b2tlbiA9IHBhcmFtcy5hY2Nlc3NUb2tlbjtcbiAgICB0aGlzLl91c2VyQWdlbnQgPSBwYXJhbXMudXNlckFnZW50IHx8ICdCaXRHb0pTLWFwaS8nICsgdGhpcy52ZXJzaW9uKCk7XG4gICAgdGhpcy5fcmVxSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVmcmVzaFRva2VuID0gcGFyYW1zLnJlZnJlc2hUb2tlbjtcbiAgICB0aGlzLl9jbGllbnRJZCA9IHBhcmFtcy5jbGllbnRJZDtcbiAgICB0aGlzLl9jbGllbnRTZWNyZXQgPSBwYXJhbXMuY2xpZW50U2VjcmV0O1xuICAgIHRoaXMuX2tleWNoYWlucyA9IG51bGw7XG4gICAgdGhpcy5fd2FsbGV0cyA9IG51bGw7XG5cbiAgICAvLyB3aGV0aGVyIHRvIHBlcmZvcm0gZXh0cmEgY2xpZW50LXNpZGUgdmFsaWRhdGlvbiBmb3Igc29tZSB0aGluZ3MsIHN1Y2ggYXNcbiAgICAvLyBhZGRyZXNzIHZhbGlkYXRpb24gb3Igc2lnbmF0dXJlIHZhbGlkYXRpb24uIGRlZmF1bHRzIHRvIHRydWUsIGJ1dCBjYW4gYmVcbiAgICAvLyB0dXJuZWQgb2ZmIGJ5IHNldHRpbmcgdG8gZmFsc2UuIGNhbiBhbHNvIGJlIG92ZXJyaWRkZW4gaW5kaXZpZHVhbGx5IGluIHRoZVxuICAgIC8vIGZ1bmN0aW9ucyB0aGF0IHVzZSBpdC5cbiAgICB0aGlzLl92YWxpZGF0ZSA9IHBhcmFtcy52YWxpZGF0ZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy52YWxpZGF0ZTtcblxuICAgIGlmICghcGFyYW1zLmhtYWNWZXJpZmljYXRpb24gJiYgcGFyYW1zLmhtYWNWZXJpZmljYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKChlbnYgPT0gJ3Byb2QnIHx8IGVudiA9PSAnYWRtaW5Qcm9kJykgJiYgY29tbW9uLkVudmlyb25tZW50c1tlbnZdLmhtYWNWZXJpZmljYXRpb25FbmZvcmNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkaXNhYmxlIHJlcXVlc3QgSE1BQyB2ZXJpZmljYXRpb24gaW4gZW52aXJvbm1lbnQgJHt0aGlzLmdldEVudigpfWApO1xuICAgICAgfVxuICAgICAgZGVidWcoJ0hNQUMgdmVyaWZpY2F0aW9uIGV4cGxpY2l0bHkgZGlzYWJsZWQgYnkgY29uc3RydWN0b3Igb3B0aW9uJyk7XG4gICAgICB0aGlzLl9obWFjVmVyaWZpY2F0aW9uID0gcGFyYW1zLmhtYWNWZXJpZmljYXRpb247XG4gICAgfVxuICAgIGlmICghcGFyYW1zLnByb3h5ICYmIHByb2Nlc3MuZW52LkJJVEdPX1VTRV9QUk9YWSkge1xuICAgICAgcGFyYW1zLnByb3h5ID0gcHJvY2Vzcy5lbnYuQklUR09fVVNFX1BST1hZO1xuICAgIH1cblxuICAgIGlmICgocHJvY2VzcyBhcyBhbnkpLmJyb3dzZXIgJiYgcGFyYW1zLnByb3h5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB1c2UgaHR0cHMgcHJveHkgcGFyYW1zIHdoaWxlIGluIGJyb3dzZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm94eSA9IHBhcmFtcy5wcm94eTtcblxuICAgIC8vIGNhcHR1cmUgb3V0ZXIgc3RhY2sgc28gd2UgaGF2ZSB1c2VmdWwgZGVidWcgaW5mb3JtYXRpb24gaWYgZmV0Y2ggY29uc3RhbnRzIGZhaWxzXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcigpO1xuXG4gICAgLy8gS2ljayBvZmYgZmlyc3QgbG9hZCBvZiBjb25zdGFudHNcbiAgICB0aGlzLmZldGNoQ29uc3RhbnRzKCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICAvLyBtYWtlIHN1cmUgYW4gZXJyb3IgZG9lcyBub3QgdGVybWluYXRlIHRoZSBlbnRpcmUgc2NyaXB0XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBmZXRjaCBpbml0aWFsIGNsaWVudCBjb25zdGFudHMgZnJvbSBCaXRHbycpO1xuICAgICAgICBkZWJ1ZyhlLnN0YWNrKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzdXBlcmFnZW50IHJlcXVlc3QgZm9yIHNwZWNpZmllZCBodHRwIG1ldGhvZCBhbmQgVVJMIGNvbmZpZ3VyZWQgdG8gdGhlIFNESyBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSBtZXRob2QgLSBodHRwIG1ldGhvZCBmb3IgdGhlIG5ldyByZXF1ZXN0XG4gICAqIEBwYXJhbSB1cmwgLSBVUkwgZm9yIHRoZSBuZXcgcmVxdWVzdFxuICAgKi9cbiAgcHJvdGVjdGVkIGdldEFnZW50UmVxdWVzdChtZXRob2Q6ICh0eXBlb2YgcGF0Y2hlZFJlcXVlc3RNZXRob2RzKVtudW1iZXJdLCB1cmw6IHN0cmluZyk6IHN1cGVyYWdlbnQuU3VwZXJBZ2VudFJlcXVlc3Qge1xuICAgIGxldCByZXE6IHN1cGVyYWdlbnQuU3VwZXJBZ2VudFJlcXVlc3QgPSBzdXBlcmFnZW50W21ldGhvZF0odXJsKTtcbiAgICBpZiAodGhpcy5jb29raWVzUHJvcGFnYXRpb25FbmFibGVkKSB7XG4gICAgICByZXEgPSByZXEud2l0aENyZWRlbnRpYWxzKCk7XG4gICAgfVxuICAgIHJldHVybiByZXE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGJhc2Vjb2luIG9iamVjdFxuICAgKiBAcGFyYW0gbmFtZVxuICAgKi9cbiAgcHVibGljIGNvaW4obmFtZTogc3RyaW5nKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBHbG9iYWxDb2luRmFjdG9yeS5nZXRJbnN0YW5jZSh0aGlzLCBuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgQml0R28gZW52aXJvbm1lbnRcbiAgICovXG4gIGdldEVudigpOiBFbnZpcm9ubWVudE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9lbnY7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IGF1dGggdmVyc2lvbiB1c2VkIGZvciByZXF1ZXN0cyB0byB0aGUgQml0R28gc2VydmVyXG4gICAqL1xuICBnZXRBdXRoVmVyc2lvbigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9hdXRoVmVyc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgcGF0Y2hpbmcgZnVuY3Rpb24gd2hpY2ggY2FuIGFwcGx5IG91ciBhdXRob3JpemF0aW9uXG4gICAqIGhlYWRlcnMgdG8gYW55IG91dGJvdW5kIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBtZXRob2RcbiAgICovXG4gIHByaXZhdGUgcmVxdWVzdFBhdGNoKG1ldGhvZDogKHR5cGVvZiBwYXRjaGVkUmVxdWVzdE1ldGhvZHMpW251bWJlcl0sIHVybDogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVxID0gdGhpcy5nZXRBZ2VudFJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIGlmICh0aGlzLl9wcm94eSAmJiBwcm94eUFnZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlYnVnKCdwcm94eWluZyByZXF1ZXN0IHRocm91Z2ggJXMnLCB0aGlzLl9wcm94eSk7XG4gICAgICBjb25zdCBhZ2VudCA9IG5ldyBwcm94eUFnZW50KHRoaXMuX3Byb3h5KTtcbiAgICAgIGlmIChhZ2VudCkge1xuICAgICAgICByZXEuYWdlbnQoYWdlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsVGhlbiA9IHJlcS50aGVuLmJpbmQocmVxKTtcbiAgICByZXEudGhlbiA9IChvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkgPT4ge1xuICAgICAgLy8gaW50ZXJjZXB0IGEgcmVxdWVzdCBiZWZvcmUgaXQncyBzdWJtaXR0ZWQgdG8gdGhlIHNlcnZlciBmb3IgdjIgYXV0aGVudGljYXRpb24gKGJhc2VkIG9uIHRva2VuKVxuICAgICAgaWYgKHRoaXMuX3ZlcnNpb24pIHtcbiAgICAgICAgLy8gVE9ETyAtIGRlY2lkZSB3aGVyZSB0byBnZXQgdmVyc2lvblxuICAgICAgICByZXEuc2V0KCdCaXRHby1TREstVmVyc2lvbicsIHRoaXMuX3ZlcnNpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodGhpcy5fcmVxSWQpKSB7XG4gICAgICAgIHJlcS5zZXQoJ1JlcXVlc3QtSUQnLCB0aGlzLl9yZXFJZC50b1N0cmluZygpKTtcblxuICAgICAgICAvLyBpbmNyZW1lbnQgYWZ0ZXIgc2V0dGluZyB0aGUgaGVhZGVyIHNvIHRoZSBzZXF1ZW5jZSBudW1iZXJzIHN0YXJ0IGF0IDBcbiAgICAgICAgdGhpcy5fcmVxSWQuaW5jKCk7XG5cbiAgICAgICAgLy8gcmVxdWVzdCBpZHMgbXVzdCBiZSBzZXQgYmVmb3JlIGVhY2ggcmVxdWVzdCBpbnN0ZWFkIG9mIGJlaW5nIGtlcHRcbiAgICAgICAgLy8gaW5zaWRlIHRoZSBiaXRnbyBvYmplY3QuIFRoaXMgaXMgdG8gcHJldmVudCByZWVudHJhbmN5IGlzc3VlcyB3aGVyZVxuICAgICAgICAvLyBtdWx0aXBsZSBzaW11bHRhbmVvdXMgcmVxdWVzdHMgY291bGQgY2F1c2UgaW5jb3JyZWN0IHJlcUlkcyB0byBiZSB1c2VkXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZXFJZDtcbiAgICAgIH1cblxuICAgICAgLy8gcHJldmVudCBJRSBmcm9tIGNhY2hpbmcgcmVxdWVzdHNcbiAgICAgIHJlcS5zZXQoJ0lmLU1vZGlmaWVkLVNpbmNlJywgJ01vbiwgMjYgSnVsIDE5OTcgMDU6MDA6MDAgR01UJyk7XG5cbiAgICAgIGlmICghKHByb2Nlc3MgYXMgYW55KS5icm93c2VyICYmIHRoaXMuX3VzZXJBZ2VudCkge1xuICAgICAgICAvLyBJZiBub3QgaW4gdGhlIGJyb3dzZXIsIHNldCB0aGUgVXNlci1BZ2VudC4gQnJvd3NlcnMgZG9uJ3QgYWxsb3dcbiAgICAgICAgLy8gc2V0dGluZyBvZiBVc2VyLUFnZW50LCBzbyB3ZSBtdXN0IGRpc2FibGUgdGhpcyB3aGVuIHJ1biBpbiB0aGVcbiAgICAgICAgLy8gYnJvd3NlciAoYnJvd3NlcmlmeSBzZXRzIHByb2Nlc3MuYnJvd3NlcikuXG4gICAgICAgIHJlcS5zZXQoJ1VzZXItQWdlbnQnLCB0aGlzLl91c2VyQWdlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCB0byBqdXN0IGFib3ZlIDUgbWludXRlcyBieSBkZWZhdWx0XG4gICAgICByZXEudGltZW91dCgocHJvY2Vzcy5lbnYuQklUR09fVElNRU9VVCBhcyBhbnkpICogMTAwMCB8fCAzMDUgKiAxMDAwKTtcblxuICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gdG9rZW4sIGFuZCB3ZSdyZSBub3QgbG9nZ2VkIGluLCB0aGUgcmVxdWVzdCBjYW5ub3QgYmUgdjIgYXV0aGVudGljYXRlZFxuICAgICAgcmVxLmlzVjJBdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICAgIHJlcS5hdXRoZW50aWNhdGlvblRva2VuID0gdGhpcy5fdG9rZW47XG4gICAgICAvLyBzb21lIG9mIHRoZSBvbGRlciB0b2tlbnMgYXBwZWFyIHRvIGJlIG9ubHkgNDAgY2hhcmFjdGVycyBsb25nXG4gICAgICBpZiAoKHRoaXMuX3Rva2VuICYmIHRoaXMuX3Rva2VuLmxlbmd0aCAhPT0gNjcgJiYgdGhpcy5fdG9rZW4uaW5kZXhPZigndjJ4JykgIT09IDApIHx8IHJlcS5mb3JjZVYxQXV0aCkge1xuICAgICAgICAvLyB1c2UgdGhlIG9sZCBtZXRob2RcbiAgICAgICAgcmVxLmlzVjJBdXRoZW50aWNhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgcmVxLnNldCgnQXV0aG9yaXphdGlvbicsICdCZWFyZXIgJyArIHRoaXMuX3Rva2VuKTtcbiAgICAgICAgZGVidWcoJ3NlbmRpbmcgdjEgJXMgcmVxdWVzdCB0byAlcyB3aXRoIHRva2VuICVzJywgbWV0aG9kLCB1cmwsIHRoaXMuX3Rva2VuPy5zdWJzdHIoMCwgOCkpO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxUaGVuKG9uZnVsZmlsbGVkKS5jYXRjaChvbnJlamVjdGVkKTtcbiAgICAgIH1cblxuICAgICAgcmVxLnNldCgnQml0R28tQXV0aC1WZXJzaW9uJywgdGhpcy5fYXV0aFZlcnNpb24gPT09IDMgPyAnMy4wJyA6ICcyLjAnKTtcblxuICAgICAgaWYgKHRoaXMuX3Rva2VuKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBzZXJpYWxpemVSZXF1ZXN0RGF0YShyZXEpO1xuICAgICAgICBzZXRSZXF1ZXN0UXVlcnlTdHJpbmcocmVxKTtcblxuICAgICAgICBjb25zdCByZXF1ZXN0UHJvcGVydGllcyA9IHRoaXMuY2FsY3VsYXRlUmVxdWVzdEhlYWRlcnMoe1xuICAgICAgICAgIHVybDogcmVxLnVybCxcbiAgICAgICAgICB0b2tlbjogdGhpcy5fdG9rZW4sXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIHRleHQ6IGRhdGEgfHwgJycsXG4gICAgICAgIH0pO1xuICAgICAgICByZXEuc2V0KCdBdXRoLVRpbWVzdGFtcCcsIHJlcXVlc3RQcm9wZXJ0aWVzLnRpbWVzdGFtcC50b1N0cmluZygpKTtcblxuICAgICAgICAvLyB3ZSdyZSBub3Qgc2VuZGluZyB0aGUgYWN0dWFsIHRva2VuLCBidXQgb25seSBpdHMgaGFzaFxuICAgICAgICByZXEuc2V0KCdBdXRob3JpemF0aW9uJywgJ0JlYXJlciAnICsgcmVxdWVzdFByb3BlcnRpZXMudG9rZW5IYXNoKTtcbiAgICAgICAgZGVidWcoJ3NlbmRpbmcgdjIgJXMgcmVxdWVzdCB0byAlcyB3aXRoIHRva2VuICVzJywgbWV0aG9kLCB1cmwsIHRoaXMuX3Rva2VuPy5zdWJzdHIoMCwgOCkpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgSE1BQ1xuICAgICAgICByZXEuc2V0KCdITUFDJywgcmVxdWVzdFByb3BlcnRpZXMuaG1hYyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVmVyaWZ5IHRoZSByZXNwb25zZSBiZWZvcmUgY2FsbGluZyB0aGUgb3JpZ2luYWwgb25mdWxmaWxsZWQgaGFuZGxlcixcbiAgICAgICAqIGFuZCBtYWtlIHN1cmUgb25yZWplY3RlZCBpcyBjYWxsZWQgaWYgYSB2ZXJpZmljYXRpb24gZXJyb3IgaXMgZW5jb3VudGVyZWRcbiAgICAgICAqL1xuICAgICAgY29uc3QgbmV3T25GdWxmaWxsZWQgPSBvbmZ1bGZpbGxlZFxuICAgICAgICA/IChyZXNwb25zZTogc3VwZXJhZ2VudC5SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gSE1BQyB2ZXJpZmljYXRpb24gaXMgb25seSBhbGxvd2VkIHRvIGJlIHNraXBwZWQgaW4gY2VydGFpbiBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGNoZWNrZWQgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgY2hlY2tpbmcgaXQgYWdhaW4gYXQgcmVxdWVzdCB0aW1lXG4gICAgICAgICAgICAvLyB3aWxsIGhlbHAgcHJldmVudCBhZ2FpbnN0IHRhbXBlcmluZyBvZiB0aGlzIHByb3BlcnR5IGFmdGVyIHRoZSBvYmplY3QgaXMgY3JlYXRlZFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9obWFjVmVyaWZpY2F0aW9uICYmICFjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLmhtYWNWZXJpZmljYXRpb25FbmZvcmNlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gb25mdWxmaWxsZWQocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2ZXJpZmllZFJlc3BvbnNlID0gdmVyaWZ5UmVzcG9uc2UodGhpcywgdGhpcy5fdG9rZW4sIG1ldGhvZCwgcmVxLCByZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gb25mdWxmaWxsZWQodmVyaWZpZWRSZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICA6IG51bGw7XG4gICAgICByZXR1cm4gb3JpZ2luYWxUaGVuKG5ld09uRnVsZmlsbGVkKS5jYXRjaChvbnJlamVjdGVkKTtcbiAgICB9O1xuICAgIHJldHVybiB0b0JpdGdvUmVxdWVzdChyZXEpO1xuICB9XG5cbiAgZ2V0KHVybDogc3RyaW5nKTogQml0R29SZXF1ZXN0IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0UGF0Y2goJ2dldCcsIHVybCk7XG4gIH1cbiAgcG9zdCh1cmw6IHN0cmluZyk6IEJpdEdvUmVxdWVzdCB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFBhdGNoKCdwb3N0JywgdXJsKTtcbiAgfVxuICBwdXQodXJsOiBzdHJpbmcpOiBCaXRHb1JlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQYXRjaCgncHV0JywgdXJsKTtcbiAgfVxuICBkZWwodXJsOiBzdHJpbmcpOiBCaXRHb1JlcXVlc3Qge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RQYXRjaCgnZGVsJywgdXJsKTtcbiAgfVxuICBwYXRjaCh1cmw6IHN0cmluZyk6IEJpdEdvUmVxdWVzdCB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdFBhdGNoKCdwYXRjaCcsIHVybCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBITUFDIGZvciB0aGUgZ2l2ZW4ga2V5IGFuZCBtZXNzYWdlXG4gICAqIEBwYXJhbSBrZXkge1N0cmluZ30gLSB0aGUga2V5IHRvIHVzZSBmb3IgdGhlIEhNQUNcbiAgICogQHBhcmFtIG1lc3NhZ2Uge1N0cmluZ30gLSB0aGUgYWN0dWFsIG1lc3NhZ2UgdG8gSE1BQ1xuICAgKiBAcmV0dXJucyB7Kn0gLSB0aGUgcmVzdWx0IG9mIHRoZSBITUFDIG9wZXJhdGlvblxuICAgKi9cbiAgY2FsY3VsYXRlSE1BQyhrZXk6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCdoZXgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIHN1YmplY3Qgc3RyaW5nIHRoYXQgaXMgdG8gYmUgSE1BQydlZCBmb3IgYSBIVFRQIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAgICogQHBhcmFtIHVybFBhdGggcmVxdWVzdCB1cmwsIGluY2x1ZGluZyBxdWVyeSBwYXJhbXNcbiAgICogQHBhcmFtIHRleHQgcmVxdWVzdCBib2R5IHRleHRcbiAgICogQHBhcmFtIHRpbWVzdGFtcCByZXF1ZXN0IHRpbWVzdGFtcCBmcm9tIGBEYXRlLm5vdygpYFxuICAgKiBAcGFyYW0gc3RhdHVzQ29kZSBPbmx5IHNldCBmb3IgSFRUUCByZXNwb25zZXMsIGxlYXZlIGJsYW5rIGZvciByZXF1ZXN0c1xuICAgKiBAcGFyYW0gbWV0aG9kIHJlcXVlc3QgbWV0aG9kXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjYWxjdWxhdGVITUFDU3ViamVjdCh7IHVybFBhdGgsIHRleHQsIHRpbWVzdGFtcCwgc3RhdHVzQ29kZSwgbWV0aG9kIH06IENhbGN1bGF0ZUhtYWNTdWJqZWN0T3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgdXJsRGV0YWlscyA9IHVybExpYi5wYXJzZSh1cmxQYXRoKTtcbiAgICBjb25zdCBxdWVyeVBhdGggPSB1cmxEZXRhaWxzLnF1ZXJ5ICYmIHVybERldGFpbHMucXVlcnkubGVuZ3RoID4gMCA/IHVybERldGFpbHMucGF0aCA6IHVybERldGFpbHMucGF0aG5hbWU7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHN0YXR1c0NvZGUpICYmIF8uaXNJbnRlZ2VyKHN0YXR1c0NvZGUpICYmIF8uaXNGaW5pdGUoc3RhdHVzQ29kZSkpIHtcbiAgICAgIGlmICh0aGlzLl9hdXRoVmVyc2lvbiA9PT0gMykge1xuICAgICAgICByZXR1cm4gW21ldGhvZC50b1VwcGVyQ2FzZSgpLCB0aW1lc3RhbXAsIHF1ZXJ5UGF0aCwgc3RhdHVzQ29kZSwgdGV4dF0uam9pbignfCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0aW1lc3RhbXAsIHF1ZXJ5UGF0aCwgc3RhdHVzQ29kZSwgdGV4dF0uam9pbignfCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYXV0aFZlcnNpb24gPT09IDMpIHtcbiAgICAgIHJldHVybiBbbWV0aG9kLnRvVXBwZXJDYXNlKCksIHRpbWVzdGFtcCwgJzMuMCcsIHF1ZXJ5UGF0aCwgdGV4dF0uam9pbignfCcpO1xuICAgIH1cbiAgICByZXR1cm4gW3RpbWVzdGFtcCwgcXVlcnlQYXRoLCB0ZXh0XS5qb2luKCd8Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBITUFDIGZvciBhbiBIVFRQIHJlcXVlc3RcbiAgICovXG4gIGNhbGN1bGF0ZVJlcXVlc3RITUFDKHsgdXJsOiB1cmxQYXRoLCB0ZXh0LCB0aW1lc3RhbXAsIHRva2VuLCBtZXRob2QgfTogQ2FsY3VsYXRlUmVxdWVzdEhtYWNPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBzaWduYXR1cmVTdWJqZWN0ID0gdGhpcy5jYWxjdWxhdGVITUFDU3ViamVjdCh7IHVybFBhdGgsIHRleHQsIHRpbWVzdGFtcCwgbWV0aG9kIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBITUFDXG4gICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlSE1BQyh0b2tlbiwgc2lnbmF0dXJlU3ViamVjdCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHJlcXVlc3QgaGVhZGVycyB3aXRoIEhNQUNcbiAgICovXG4gIGNhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzKHsgdXJsLCB0ZXh0LCB0b2tlbiwgbWV0aG9kIH06IENhbGN1bGF0ZVJlcXVlc3RIZWFkZXJzT3B0aW9ucyk6IFJlcXVlc3RIZWFkZXJzIHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGhtYWMgPSB0aGlzLmNhbGN1bGF0ZVJlcXVlc3RITUFDKHsgdXJsLCB0ZXh0LCB0aW1lc3RhbXAsIHRva2VuLCBtZXRob2QgfSk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIFNIQTI1NiBoYXNoIG9mIHRoZSB0b2tlblxuICAgIGNvbnN0IGhhc2hEaWdlc3QgPSBzamNsLmhhc2guc2hhMjU2Lmhhc2godG9rZW4pO1xuICAgIGNvbnN0IHRva2VuSGFzaCA9IHNqY2wuY29kZWMuaGV4LmZyb21CaXRzKGhhc2hEaWdlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICBobWFjLFxuICAgICAgdGltZXN0YW1wLFxuICAgICAgdG9rZW5IYXNoLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoZSBITUFDIGZvciBhbiBIVFRQIHJlc3BvbnNlXG4gICAqL1xuICB2ZXJpZnlSZXNwb25zZSh7XG4gICAgdXJsOiB1cmxQYXRoLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgdGV4dCxcbiAgICB0aW1lc3RhbXAsXG4gICAgdG9rZW4sXG4gICAgaG1hYyxcbiAgICBtZXRob2QsXG4gIH06IFZlcmlmeVJlc3BvbnNlT3B0aW9ucyk6IFZlcmlmeVJlc3BvbnNlSW5mbyB7XG4gICAgY29uc3Qgc2lnbmF0dXJlU3ViamVjdCA9IHRoaXMuY2FsY3VsYXRlSE1BQ1N1YmplY3Qoe1xuICAgICAgdXJsUGF0aCxcbiAgICAgIHRleHQsXG4gICAgICB0aW1lc3RhbXAsXG4gICAgICBzdGF0dXNDb2RlLFxuICAgICAgbWV0aG9kLFxuICAgIH0pO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBITUFDXG4gICAgY29uc3QgZXhwZWN0ZWRIbWFjID0gdGhpcy5jYWxjdWxhdGVITUFDKHRva2VuLCBzaWduYXR1cmVTdWJqZWN0KTtcblxuICAgIC8vIGRldGVybWluZSBpZiB0aGUgcmVzcG9uc2UgaXMgc3RpbGwgd2l0aGluIHRoZSB2YWxpZGl0eSB3aW5kb3cgKDUgbWludXRlIHdpbmRvdylcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGlzSW5SZXNwb25zZVZhbGlkaXR5V2luZG93ID0gdGltZXN0YW1wID49IG5vdyAtIDEwMDAgKiA2MCAqIDUgJiYgdGltZXN0YW1wIDw9IG5vdztcblxuICAgIC8vIHZlcmlmeSB0aGUgSE1BQyBhbmQgdGltZXN0YW1wXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzVmFsaWQ6IGV4cGVjdGVkSG1hYyA9PT0gaG1hYyxcbiAgICAgIGV4cGVjdGVkSG1hYyxcbiAgICAgIHNpZ25hdHVyZVN1YmplY3QsXG4gICAgICBpc0luUmVzcG9uc2VWYWxpZGl0eVdpbmRvdyxcbiAgICAgIHZlcmlmaWNhdGlvblRpbWU6IG5vdyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHVzZWZ1bCBjb25zdGFudCB2YWx1ZXMgZnJvbSB0aGUgQml0R28gc2VydmVyLlxuICAgKiBUaGVzZSB2YWx1ZXMgZG8gY2hhbmdlIGluZnJlcXVlbnRseSwgc28gdGhleSBuZWVkIHRvIGJlIGZldGNoZWQsXG4gICAqIGJ1dCBhcmUgdW5saWtlbHkgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgYSBCaXRHbyBvYmplY3QsXG4gICAqIHNvIHRoZXkgY2FuIHNhZmVseSBjYWNoZWQuXG4gICAqL1xuICBhc3luYyBmZXRjaENvbnN0YW50cygpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IGVudiA9IHRoaXMuZ2V0RW52KCk7XG5cbiAgICBpZiAoIUJpdEdvQVBJLl9jb25zdGFudHMpIHtcbiAgICAgIEJpdEdvQVBJLl9jb25zdGFudHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCFCaXRHb0FQSS5fY29uc3RhbnRzRXhwaXJlKSB7XG4gICAgICBCaXRHb0FQSS5fY29uc3RhbnRzRXhwaXJlID0ge307XG4gICAgfVxuXG4gICAgaWYgKEJpdEdvQVBJLl9jb25zdGFudHNbZW52XSAmJiBCaXRHb0FQSS5fY29uc3RhbnRzRXhwaXJlW2Vudl0gJiYgbmV3IERhdGUoKSA8IEJpdEdvQVBJLl9jb25zdGFudHNFeHBpcmVbZW52XSkge1xuICAgICAgcmV0dXJuIEJpdEdvQVBJLl9jb25zdGFudHNbZW52XTtcbiAgICB9XG5cbiAgICAvLyBjbGllbnQgY29uc3RhbnRzIGNhbGwgY2Fubm90IGJlIGF1dGhlbnRpY2F0ZWQgdXNpbmcgdGhlIG5vcm1hbCBITUFDIHZhbGlkYXRpb25cbiAgICAvLyBzY2hlbWUsIHNvIHdlIG5lZWQgdG8gdXNlIGEgcmF3IHN1cGVyYWdlbnQgaW5zdGFuY2UgdG8gZG8gdGhpcyByZXF1ZXN0LlxuICAgIC8vIFByb3h5IHNldHRpbmdzIG11c3Qgc3RpbGwgYmUgcmVzcGVjdGVkIGhvd2V2ZXJcbiAgICBjb25zdCByZXN1bHRQcm9taXNlID0gdGhpcy5nZXRBZ2VudFJlcXVlc3QoJ2dldCcsIHRoaXMudXJsKCcvY2xpZW50L2NvbnN0YW50cycpKTtcbiAgICByZXN1bHRQcm9taXNlLnNldCgnQml0R28tU0RLLVZlcnNpb24nLCB0aGlzLl92ZXJzaW9uKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAodGhpcy5fcHJveHkgPyByZXN1bHRQcm9taXNlLnByb3h5KHRoaXMuX3Byb3h5KSA6IHJlc3VsdFByb21pc2UpO1xuICAgIEJpdEdvQVBJLl9jb25zdGFudHNbZW52XSA9IHJlc3VsdC5ib2R5LmNvbnN0YW50cztcblxuICAgIGlmIChyZXN1bHQuYm9keT8udHRsICYmIHR5cGVvZiByZXN1bHQuYm9keT8udHRsID09PSAnbnVtYmVyJykge1xuICAgICAgQml0R29BUEkuX2NvbnN0YW50c0V4cGlyZVtlbnZdID0gbmV3IERhdGUobmV3IERhdGUoKS5nZXRUaW1lKCkgKyAocmVzdWx0LmJvZHkudHRsIGFzIG51bWJlcikgKiAxMDAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQml0R29BUEkuX2NvbnN0YW50c1tlbnZdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHVybCBmb3IgY2FsbGluZyBCaXRHbyBwbGF0Zm9ybSBBUElzXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEBwYXJhbSB2ZXJzaW9uXG4gICAqL1xuICB1cmwocGF0aDogc3RyaW5nLCB2ZXJzaW9uID0gMSk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFzZVVybCA9IHZlcnNpb24gPT09IDIgPyB0aGlzLl9iYXNlQXBpVXJsVjIgOiB0aGlzLl9iYXNlQXBpVXJsO1xuICAgIHJldHVybiBiYXNlVXJsICsgcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB1cmwgZm9yIGNhbGxpbmcgQml0R28gbWljcm9zZXJ2aWNlIEFQSXNcbiAgICovXG4gIG1pY3Jvc2VydmljZXNVcmwocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZVVybCArIHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmVyc2lvbiBvZiB0aGUgQml0R29KUyBwYWNrYWdlXG4gICAqL1xuICB2ZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogVGVzdCBjb25uZWN0aXZpdHkgdG8gdGhlIHNlcnZlclxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBwaW5nKHsgcmVxSWQgfTogUGluZ09wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKHJlcUlkKSB7XG4gICAgICB0aGlzLl9yZXFJZCA9IHJlcUlkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3BpbmcnKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgcmVxdWVzdCB0cmFjZXIgdG8gcHJvdmlkZSByZXF1ZXN0IElEcyBkdXJpbmcgbXVsdGktcmVxdWVzdCB3b3JrZmxvd3NcbiAgICovXG4gIHNldFJlcXVlc3RUcmFjZXIocmVxVHJhY2VyOiBJUmVxdWVzdFRyYWNlcik6IHZvaWQge1xuICAgIGlmIChyZXFUcmFjZXIpIHtcbiAgICAgIHRoaXMuX3JlcUlkID0gcmVxVHJhY2VyO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGVuY3J5cHQgbG9jYWxseS5cbiAgICovXG4gIGVuY3J5cHQocGFyYW1zOiBFbmNyeXB0T3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydpbnB1dCcsICdwYXNzd29yZCddLCBbXSk7XG4gICAgaWYgKCFwYXJhbXMucGFzc3dvcmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IGVuY3J5cHQgd2l0aG91dCBwYXNzd29yZGApO1xuICAgIH1cbiAgICByZXR1cm4gZW5jcnlwdChwYXJhbXMucGFzc3dvcmQsIHBhcmFtcy5pbnB1dCk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdCBhbiBlbmNyeXB0ZWQgc3RyaW5nIGxvY2FsbHkuXG4gICAqL1xuICBkZWNyeXB0KHBhcmFtczogRGVjcnlwdE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2lucHV0JywgJ3Bhc3N3b3JkJ10sIFtdKTtcbiAgICBpZiAoIXBhcmFtcy5wYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZGVjcnlwdCB3aXRob3V0IHBhc3N3b3JkYCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZGVjcnlwdChwYXJhbXMucGFzc3dvcmQsIHBhcmFtcy5pbnB1dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiY2NtOiB0YWcgZG9lc24ndCBtYXRjaFwiKSkge1xuICAgICAgICBlcnJvci5tZXNzYWdlID0gJ3Bhc3N3b3JkIGVycm9yIC0gJyArIGVycm9yLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VyaWFsaXplIHRoaXMgQml0R28gb2JqZWN0IHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIENhdXRpb246IGNvbnRhaW5zIHNlbnNpdGl2ZSBkYXRhXG4gICAqL1xuICB0b0pTT04oKTogQml0R29Kc29uIHtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcjogdGhpcy5fdXNlcixcbiAgICAgIHRva2VuOiB0aGlzLl90b2tlbixcbiAgICAgIGV4dGVuc2lvbktleTogdGhpcy5fZXh0ZW5zaW9uS2V5ID8gdGhpcy5fZXh0ZW5zaW9uS2V5LnRvV0lGKCkgOiB1bmRlZmluZWQsXG4gICAgICBlY2RoWHBydjogdGhpcy5fZWNkaFhwcnYsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdXNlclxuICAgKi9cbiAgdXNlcigpOiBVc2VyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhIEpTT04gc2VyaWFsaXplZCBCaXRHbyBvYmplY3QuXG4gICAqXG4gICAqIE92ZXJ3cml0ZXMgdGhlIHByb3BlcnRpZXMgb24gdGhlIGN1cnJlbnQgQml0R28gb2JqZWN0IHdpdGhcbiAgICogdGhvc2Ugb2YgdGhlIGRlc2VyaWFsemVkIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGpzb25cbiAgICovXG4gIGZyb21KU09OKGpzb246IEJpdEdvSnNvbik6IHZvaWQge1xuICAgIHRoaXMuX3VzZXIgPSBqc29uLnVzZXI7XG4gICAgdGhpcy5fdG9rZW4gPSBqc29uLnRva2VuO1xuICAgIHRoaXMuX2VjZGhYcHJ2ID0ganNvbi5lY2RoWHBydjtcbiAgICBpZiAoanNvbi5leHRlbnNpb25LZXkpIHtcbiAgICAgIGNvbnN0IG5ldHdvcmsgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLm5ldHdvcms7XG4gICAgICB0aGlzLl9leHRlbnNpb25LZXkgPSB1dHhvbGliLkVDUGFpci5mcm9tV0lGKFxuICAgICAgICBqc29uLmV4dGVuc2lvbktleSxcbiAgICAgICAgdXR4b2xpYi5uZXR3b3Jrc1tuZXR3b3JrXSBhcyB1dHhvbGliLkJpdGNvaW5KU05ldHdvcmtcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIHVzZXJuYW1lLCBwYXNzd29yZCBhbmQgb3RwIGludG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHVzZXJuYW1lIGFuZCBoYXNoZWQgcGFzc3dvcmQsIHJlYWR5IHRvXG4gICAqIHNlbmQgdG8gYml0Z28gZm9yIGF1dGhlbnRpY2F0aW9uLlxuICAgKi9cbiAgcHJlcHJvY2Vzc0F1dGhlbnRpY2F0aW9uUGFyYW1zKHtcbiAgICB1c2VybmFtZSxcbiAgICBwYXNzd29yZCxcbiAgICBvdHAsXG4gICAgZm9yY2VTTVMsXG4gICAgZXh0ZW5zaWJsZSxcbiAgICB0cnVzdCxcbiAgfTogQXV0aGVudGljYXRlT3B0aW9ucyk6IFByb2Nlc3NlZEF1dGhlbnRpY2F0aW9uT3B0aW9ucyB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHVzZXJuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBzdHJpbmcgdXNlcm5hbWUnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvd2VyTmFtZSA9IHVzZXJuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwYXNzd29yZCBITUFDIHNvIHdlIGRvbid0IHNlbmQgY2xlYXItdGV4dCBwYXNzd29yZHNcbiAgICBjb25zdCBobWFjUGFzc3dvcmQgPSB0aGlzLmNhbGN1bGF0ZUhNQUMobG93ZXJOYW1lLCBwYXNzd29yZCk7XG5cbiAgICBjb25zdCBhdXRoUGFyYW1zOiBQcm9jZXNzZWRBdXRoZW50aWNhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBlbWFpbDogbG93ZXJOYW1lLFxuICAgICAgcGFzc3dvcmQ6IGhtYWNQYXNzd29yZCxcbiAgICAgIGZvcmNlU01TOiAhIWZvcmNlU01TLFxuICAgIH07XG5cbiAgICBpZiAob3RwKSB7XG4gICAgICBhdXRoUGFyYW1zLm90cCA9IG90cDtcbiAgICAgIGlmICh0cnVzdCkge1xuICAgICAgICBhdXRoUGFyYW1zLnRydXN0ID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaWJsZSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uS2V5ID0gbWFrZVJhbmRvbUtleSgpO1xuICAgICAgYXV0aFBhcmFtcy5leHRlbnNpYmxlID0gdHJ1ZTtcbiAgICAgIGF1dGhQYXJhbXMuZXh0ZW5zaW9uQWRkcmVzcyA9IGdldEFkZHJlc3NQMlBLSCh0aGlzLl9leHRlbnNpb25LZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBhdXRoUGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9ub3VzIG1ldGhvZCBmb3IgYWN0aXZhdGluZyBhbiBhY2Nlc3MgdG9rZW4uXG4gICAqL1xuICBhdXRoZW50aWNhdGVXaXRoQWNjZXNzVG9rZW4oeyBhY2Nlc3NUb2tlbiB9OiBBY2Nlc3NUb2tlbk9wdGlvbnMpOiB2b2lkIHtcbiAgICBkZWJ1Zygnbm93IGF1dGhlbnRpY2F0aW5nIHdpdGggYWNjZXNzIHRva2VuICVzJywgYWNjZXNzVG9rZW4uc3Vic3RyaW5nKDAsIDgpKTtcbiAgICB0aGlzLl90b2tlbiA9IGFjY2Vzc1Rva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRUNESCBrZXljaGFpbiBmb3IgdGhlIHVzZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2dpblBhc3N3b3JkIC0gVGhlIHVzZXIncyBsb2dpbiBwYXNzd29yZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBuZXcgRUNESCBrZXljaGFpbiBkYXRhLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXMgYW4gaXNzdWUgY3JlYXRpbmcgdGhlIGtleWNoYWluLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGNyZWF0ZVVzZXJFY2RoS2V5Y2hhaW4obG9naW5QYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCBrZXlEYXRhID0gdGhpcy5rZXljaGFpbnMoKS5jcmVhdGUoKTtcbiAgICBjb25zdCBoZE5vZGUgPSBiaXRjb2luLkhETm9kZS5mcm9tQmFzZTU4KGtleURhdGEueHBydik7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIG5ldyBFQ0RIIGtleWNoYWluIHRvIHRoZSB1c2VyJ3MgYWNjb3VudC5cbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxhbnk+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIG5ldyBFQ0RIIGtleWNoYWluLlxuICAgICAqL1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmtleWNoYWlucygpLmFkZCh7XG4gICAgICBzb3VyY2U6ICdlY2RoJyxcbiAgICAgIHhwdWI6IGhkTm9kZS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCksXG4gICAgICBlbmNyeXB0ZWRYcHJ2OiB0aGlzLmVuY3J5cHQoe1xuICAgICAgICBwYXNzd29yZDogbG9naW5QYXNzd29yZCxcbiAgICAgICAgaW5wdXQ6IGhkTm9kZS50b0Jhc2U1OCgpLFxuICAgICAgfSksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdXNlcidzIHNldHRpbmdzIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byB1cGRhdGUgdGhlIHVzZXIncyBzZXR0aW5ncyB3aXRoLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXMgYW4gaXNzdWUgdXBkYXRpbmcgdGhlIHVzZXIncyBzZXR0aW5ncy5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlVXNlclNldHRpbmdzKHBhcmFtczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wdXQodGhpcy51cmwoJy91c2VyL3NldHRpbmdzJywgMikpLnNlbmQocGFyYW1zKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgdGhlIHVzZXIncyBFQ0RIIGtleWNoYWluIGlzIGNyZWF0ZWQgZm9yIHdhbGxldCBzaGFyaW5nIGFuZCBUU1Mgd2FsbGV0cy5cbiAgICogSWYgdGhlIGtleWNoYWluIGRvZXMgbm90IGV4aXN0LCBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSB1c2VyJ3Mgc2V0dGluZ3Mgd2lsbCBiZSB1cGRhdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9naW5QYXNzd29yZCAtIFRoZSB1c2VyJ3MgbG9naW4gcGFzc3dvcmQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdXNlcidzIHNldHRpbmdzIGVuc3VyaW5nIHdlIGhhdmUgdGhlIGVjZGhLZXljaGFpbiBpbiB0aGVyZS5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZXJlIGlzIGFuIGlzc3VlIGNyZWF0aW5nIHRoZSBrZXljaGFpbiBvciB1cGRhdGluZyB0aGUgdXNlcidzIHNldHRpbmdzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBlbnN1cmVVc2VyRWNkaEtleWNoYWluSXNDcmVhdGVkKGxvZ2luUGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1c2VyJ3MgY3VycmVudCBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBhd2FpdCB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvc2V0dGluZ3MnKSkucmVzdWx0KCk7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHVzZXIncyBFQ0RIIGtleWNoYWluIGRvZXMgbm90IGV4aXN0LCBjcmVhdGUgYSBuZXcga2V5Y2hhaW4gYW5kIHVwZGF0ZSB0aGUgdXNlcidzIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGlmICghdXNlclNldHRpbmdzLnNldHRpbmdzLmVjZGhLZXljaGFpbikge1xuICAgICAgY29uc3QgbmV3S2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmNyZWF0ZVVzZXJFY2RoS2V5Y2hhaW4obG9naW5QYXNzd29yZCk7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZVVzZXJTZXR0aW5ncyh7XG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZWNkaEtleWNoYWluOiBuZXdLZXljaGFpbi54cHViLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIFVwZGF0ZSB0aGUgdXNlcidzIHNldHRpbmdzIG9iamVjdCB3aXRoIHRoZSBuZXcgRUNESCBrZXljaGFpbi5cbiAgICAgICAqL1xuICAgICAgdXNlclNldHRpbmdzLnNldHRpbmdzLmVjZGhLZXljaGFpbiA9IG5ld0tleWNoYWluLnhwdWI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdXNlcidzIEVDREgga2V5Y2hhaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgcmV0dXJuIHVzZXJTZXR0aW5ncy5zZXR0aW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dpbiB0byB0aGUgYml0Z28gcGxhdGZvcm0uXG4gICAqL1xuICBhc3luYyBhdXRoZW50aWNhdGUocGFyYW1zOiBBdXRoZW50aWNhdGVPcHRpb25zKTogUHJvbWlzZTxMb2dpblJlc3BvbnNlIHwgYW55PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgb2JqZWN0IHBhcmFtcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnBhc3N3b3JkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBwYXNzd29yZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmb3JjZVYxQXV0aCA9ICEhcGFyYW1zLmZvcmNlVjFBdXRoO1xuICAgICAgY29uc3QgYXV0aFBhcmFtcyA9IHRoaXMucHJlcHJvY2Vzc0F1dGhlbnRpY2F0aW9uUGFyYW1zKHBhcmFtcyk7XG4gICAgICBjb25zdCBwYXNzd29yZCA9IHBhcmFtcy5wYXNzd29yZDtcblxuICAgICAgaWYgKHRoaXMuX3Rva2VuKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2FscmVhZHkgbG9nZ2VkIGluJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGF1dGhVcmwgPSB0aGlzLm1pY3Jvc2VydmljZXNVcmwoJy9hcGkvYXV0aC92MS9zZXNzaW9uJyk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5wb3N0KGF1dGhVcmwpO1xuXG4gICAgICBpZiAoZm9yY2VWMUF1dGgpIHtcbiAgICAgICAgcmVxdWVzdC5mb3JjZVYxQXV0aCA9IHRydWU7XG4gICAgICAgIC8vIHRlbGwgdGhlIHNlcnZlciB0aGF0IHRoZSBjbGllbnQgd2FzIGZvcmNlZCB0byBkb3duZ3JhZGUgdGhlIGF1dGhlbnRpY2F0aW9uIHByb3RvY29sXG4gICAgICAgIGF1dGhQYXJhbXMuZm9yY2VWMUF1dGggPSB0cnVlO1xuICAgICAgICBkZWJ1ZygnZm9yY2luZyB2MSBhdXRoIGZvciBjYWxsIHRvIGF1dGhlbnRpY2F0ZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2U6IHN1cGVyYWdlbnQuUmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQoYXV0aFBhcmFtcyk7XG4gICAgICAvLyBleHRyYWN0IGJvZHkgYW5kIHVzZXIgaW5mb3JtYXRpb25cbiAgICAgIGNvbnN0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xuICAgICAgdGhpcy5fdXNlciA9IGJvZHkudXNlcjtcblxuICAgICAgaWYgKGJvZHkuYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgIHRoaXMuX3Rva2VuID0gYm9keS5hY2Nlc3NfdG9rZW47XG4gICAgICAgIC8vIGlmIHRoZSBkb3duZ3JhZGUgd2FzIGZvcmNlZCwgYWRkaW5nIGEgd2FybmluZyBtZXNzYWdlIG1pZ2h0IGJlIHBydWRlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoZWNrIHRoZSBwcmVzZW5jZSBvZiBhbiBlbmNyeXB0ZWQgRUNESCB4cHJ2XG4gICAgICAgIC8vIGlmIG5vdCBwcmVzZW50LCBsZWdhY3kgYWNjb3VudFxuICAgICAgICBjb25zdCBlbmNyeXB0ZWRYcHJ2ID0gYm9keS5lbmNyeXB0ZWRFQ0RIWHBydjtcbiAgICAgICAgaWYgKCFlbmNyeXB0ZWRYcHJ2KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXljaGFpbiBuZWVkcyBlbmNyeXB0ZWRYcHJ2IHByb3BlcnR5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNwb25zZURldGFpbHMgPSB0aGlzLmhhbmRsZVRva2VuSXNzdWFuY2UocmVzcG9uc2UuYm9keSwgcGFzc3dvcmQpO1xuICAgICAgICB0aGlzLl90b2tlbiA9IHJlc3BvbnNlRGV0YWlscy50b2tlbjtcbiAgICAgICAgdGhpcy5fZWNkaFhwcnYgPSByZXNwb25zZURldGFpbHMuZWNkaFhwcnY7XG5cbiAgICAgICAgLy8gdmVyaWZ5IHRoZSByZXNwb25zZSdzIGF1dGhlbnRpY2l0eVxuICAgICAgICB2ZXJpZnlSZXNwb25zZSh0aGlzLCByZXNwb25zZURldGFpbHMudG9rZW4sICdwb3N0JywgcmVxdWVzdCwgcmVzcG9uc2UpO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgcmVtYWluaW5nIGNvbXBvbmVudCBmb3IgZWFzaWVyIGFjY2Vzc1xuICAgICAgICByZXNwb25zZS5ib2R5LmFjY2Vzc190b2tlbiA9IHRoaXMuX3Rva2VuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBwYXJhbXMuZW5zdXJlRWNkaEtleWNoYWluID8gYXdhaXQgdGhpcy5lbnN1cmVVc2VyRWNkaEtleWNoYWluSXNDcmVhdGVkKHBhc3N3b3JkKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICh1c2VyU2V0dGluZ3M/LmVjZGhLZXljaGFpbikge1xuICAgICAgICByZXNwb25zZS5ib2R5LnVzZXIuZWNkaEtleWNoYWluID0gdXNlclNldHRpbmdzLmVjZGhLZXljaGFpbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZVJlc3BvbnNlUmVzdWx0PExvZ2luUmVzcG9uc2U+KCkocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZVJlc3BvbnNlRXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSByZXNwb25zZUJvZHkgUmVzcG9uc2UgYm9keSBvYmplY3RcbiAgICogQHBhcmFtIHBhc3N3b3JkIFBhc3N3b3JkIGZvciB0aGUgc3ltbWV0cmljIGRlY3J5cHRpb25cbiAgICovXG4gIGhhbmRsZVRva2VuSXNzdWFuY2UocmVzcG9uc2VCb2R5OiBUb2tlbklzc3VhbmNlUmVzcG9uc2UsIHBhc3N3b3JkPzogc3RyaW5nKTogVG9rZW5Jc3N1YW5jZSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSByZXNwb25zZSBib2R5IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhyZXNwb25zZUJvZHksIFsnZGVyaXZhdGlvblBhdGgnXSwgWydlbmNyeXB0ZWRFQ0RIWHBydiddKTtcblxuICAgIGNvbnN0IGVudmlyb25tZW50ID0gdGhpcy5fZW52O1xuICAgIGNvbnN0IGVudmlyb25tZW50Q29uZmlnID0gY29tbW9uLkVudmlyb25tZW50c1tlbnZpcm9ubWVudF07XG4gICAgY29uc3Qgc2VydmVyWHB1YiA9IGVudmlyb25tZW50Q29uZmlnLnNlcnZlclhwdWI7XG4gICAgbGV0IGVjZGhYcHJ2ID0gdGhpcy5fZWNkaFhwcnY7XG4gICAgaWYgKCFlY2RoWHBydikge1xuICAgICAgaWYgKCFwYXNzd29yZCB8fCAhcmVzcG9uc2VCb2R5LmVuY3J5cHRlZEVDREhYcHJ2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZWNkaFhwcnYgcHJvcGVydHkgbXVzdCBiZSBzZXQgb3IgcGFzc3dvcmQgYW5kIGVuY3J5cHRlZCBlbmNyeXB0ZWRFQ0RIWHBydiBtdXN0IGJlIHByb3ZpZGVkJyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBlY2RoWHBydiA9IHRoaXMuZGVjcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IHJlc3BvbnNlQm9keS5lbmNyeXB0ZWRFQ0RIWHBydixcbiAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmQsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlLmVycm9yQ29kZSA9ICdlY2RoX3hwcnZfZGVjcnlwdGlvbl9mYWlsdXJlJztcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlY3J5cHQgZW5jcnlwdGVkRUNESFhwcnYuJyk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RydWN0IEhETm9kZSBvYmplY3RzIGZvciBjbGllbnQncyB4cHJ2IGFuZCBzZXJ2ZXIncyB4cHViXG4gICAgY29uc3QgY2xpZW50SEROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChlY2RoWHBydik7XG4gICAgY29uc3Qgc2VydmVySEROb2RlID0gYmlwMzIuZnJvbUJhc2U1OChzZXJ2ZXJYcHViKTtcblxuICAgIC8vIEJJUDMyIGRlcml2YXRpb24gcGF0aCBpcyBhcHBsaWVkIHRvIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIgbWFzdGVyIGtleXNcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9IHNhbml0aXplTGVnYWN5UGF0aChyZXNwb25zZUJvZHkuZGVyaXZhdGlvblBhdGgpO1xuICAgIGNvbnN0IGNsaWVudERlcml2ZWROb2RlID0gY2xpZW50SEROb2RlLmRlcml2ZVBhdGgoZGVyaXZhdGlvblBhdGgpO1xuICAgIGNvbnN0IHNlcnZlckRlcml2ZWROb2RlID0gc2VydmVySEROb2RlLmRlcml2ZVBhdGgoZGVyaXZhdGlvblBhdGgpO1xuXG4gICAgY29uc3QgcHVibGljS2V5ID0gc2VydmVyRGVyaXZlZE5vZGUucHVibGljS2V5O1xuICAgIGNvbnN0IHNlY3JldEtleSA9IGNsaWVudERlcml2ZWROb2RlLnByaXZhdGVLZXk7XG4gICAgaWYgKCFzZWNyZXRLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gY2xpZW50IHByaXZhdGUgS2V5Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNlY3JldCA9IEJ1ZmZlci5mcm9tKFxuICAgICAgLy8gRklYTUUoQkctMzQzODYpOiB3ZSBzaG91bGQgdXNlIGBzZWNwMjU2azEuZWNkaCgpYCBpbiB0aGUgZnV0dXJlXG4gICAgICAvLyAgICAgICAgICAgICAgICAgIHNlZSBkaXNjdXNzaW9uIGhlcmUgaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4tY29yZS9zZWNwMjU2azEvaXNzdWVzLzM1MlxuICAgICAgc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKHB1YmxpY0tleSwgc2VjcmV0S2V5KVxuICAgICkudG9TdHJpbmcoJ2hleCcpO1xuXG4gICAgLy8gZGVjcnlwdCB0b2tlbiB3aXRoIHN5bW1ldHJpYyBFQ0RIIGtleVxuICAgIGxldCByZXNwb25zZTogVG9rZW5Jc3N1YW5jZTtcbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgIHRva2VuOiB0aGlzLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiByZXNwb25zZUJvZHkuZW5jcnlwdGVkVG9rZW4sXG4gICAgICAgICAgcGFzc3dvcmQ6IHNlY3JldCxcbiAgICAgICAgfSksXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuZXJyb3JDb2RlID0gJ3Rva2VuX2RlY3J5cHRpb25fZmFpbHVyZSc7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGVjcnlwdCB0b2tlbi4nKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmICghdGhpcy5fZWNkaFhwcnYpIHtcbiAgICAgIHJlc3BvbnNlLmVjZGhYcHJ2ID0gZWNkaFhwcnY7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIC8qKlxuICAgKi9cbiAgdmVyaWZ5UGFzc3dvcmQocGFyYW1zOiBWZXJpZnlQYXNzd29yZE9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBzdHJpbmcgcGFzc3dvcmQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3VzZXIgfHwgIXRoaXMuX3VzZXIudXNlcm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gY3VycmVudCB1c2VyJyk7XG4gICAgfVxuICAgIGNvbnN0IGhtYWNQYXNzd29yZCA9IHRoaXMuY2FsY3VsYXRlSE1BQyh0aGlzLl91c2VyLnVzZXJuYW1lLCBwYXJhbXMucGFzc3dvcmQpO1xuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvdmVyaWZ5cGFzc3dvcmQnKSkuc2VuZCh7IHBhc3N3b3JkOiBobWFjUGFzc3dvcmQgfSkucmVzdWx0KCd2YWxpZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIG91dCBhbGwgc3RhdGUgZnJvbSB0aGlzIEJpdEdvIG9iamVjdCwgZWZmZWN0aXZlbHkgbG9nZ2luZyBvdXQgdGhlIGN1cnJlbnQgdXNlci5cbiAgICovXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIC8vIFRPRE86IGFyZSB0aGVyZSBhbnkgb3RoZXIgZmllbGRzIHdoaWNoIHNob3VsZCBiZSBjbGVhcmVkP1xuICAgIHRoaXMuX3VzZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmVmcmVzaFRva2VuID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VjZGhYcHJ2ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSByZWZyZXNoIHRva2VuIHRvIGdldCBuZXcgYWNjZXNzIHRva2VuLlxuICAgKiBJZiB0aGUgcmVmcmVzaCB0b2tlbiBpcyBudWxsL2RlZmluZWQsIHRoZW4gd2UgdXNlIHRoZSBzdG9yZWQgdG9rZW4gZnJvbSBhdXRoXG4gICAqL1xuICBhc3luYyByZWZyZXNoVG9rZW4ocGFyYW1zOiB7IHJlZnJlc2hUb2tlbj86IHN0cmluZyB9ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbW1vbi52YWxpZGF0ZVBhcmFtcyhwYXJhbXMsIFtdLCBbJ3JlZnJlc2hUb2tlbiddKTtcblxuICAgIGNvbnN0IHJlZnJlc2hUb2tlbiA9IHBhcmFtcy5yZWZyZXNoVG9rZW4gfHwgdGhpcy5fcmVmcmVzaFRva2VuO1xuXG4gICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIHJlZnJlc2ggdG9rZW4gb3IgaGF2ZSBhdXRoZW50aWNhdGVkIHdpdGggT2F1dGggYmVmb3JlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9jbGllbnRJZCB8fCAhdGhpcy5fY2xpZW50U2VjcmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgY2xpZW50IGlkIGFuZCBzZWNyZXQgc2V0IGZpcnN0IHRvIHVzZSB0aGlzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHRoaXMucG9zdCh0aGlzLl9iYXNlVXJsICsgJy9vYXV0aC90b2tlbicpXG4gICAgICAuc2VuZCh7XG4gICAgICAgIGdyYW50X3R5cGU6ICdyZWZyZXNoX3Rva2VuJyxcbiAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgICBjbGllbnRfaWQ6IHRoaXMuX2NsaWVudElkLFxuICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLl9jbGllbnRTZWNyZXQsXG4gICAgICB9KVxuICAgICAgLnJlc3VsdCgpO1xuICAgIHRoaXMuX3Rva2VuID0gYm9keS5hY2Nlc3NfdG9rZW47XG4gICAgdGhpcy5fcmVmcmVzaFRva2VuID0gYm9keS5yZWZyZXNoX3Rva2VuO1xuICAgIHJldHVybiBib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIGxpc3RBY2Nlc3NUb2tlbnNcbiAgICogR2V0IGluZm9ybWF0aW9uIG9uIGFsbCBvZiB0aGUgQml0R28gYWNjZXNzIHRva2VucyBvbiB0aGUgdXNlclxuICAgKiBAcmV0dXJuIHtcbiAgICogIGlkOiA8aWQgb2YgdGhlIHRva2VuPlxuICAgKiAgbGFiZWw6IDx0aGUgdXNlci1wcm92aWRlZCBsYWJlbCBmb3IgdGhpcyB0b2tlbj5cbiAgICogIHVzZXI6IDxpZCBvZiB0aGUgdXNlciBvbiB0aGUgdG9rZW4+XG4gICAqICBlbnRlcnByaXNlIDxpZCBvZiB0aGUgZW50ZXJwcmlzZSB0aGlzIHRva2VuIGlzIHZhbGlkIGZvcj5cbiAgICogIGNsaWVudDogPHRoZSBhdXRoIGNsaWVudCB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0bz5cbiAgICogIHNjb3BlOiA8bGlzdCBvZiBhbGxvd2VkIE9BdXRoIHNjb3BlIHZhbHVlcz5cbiAgICogIGNyZWF0ZWQ6IDxkYXRlIHRoZSB0b2tlbiB3YXMgY3JlYXRlZD5cbiAgICogIGV4cGlyZXM6IDxkYXRlIHRoZSB0b2tlbiB3aWxsIGV4cGlyZT5cbiAgICogIG9yaWdpbjogPHRoZSBvcmlnaW4gZm9yIHdoaWNoIHRoaXMgdG9rZW4gaXMgdmFsaWQ+XG4gICAqICBpc0V4dGVuc2libGU6IDxmbGFnIGluZGljYXRpbmcgaWYgdGhlIHRva2VuIGNhbiBiZSBleHRlbmRlZD5cbiAgICogIGV4dGVuc2lvbkFkZHJlc3M6IDxhZGRyZXNzIHdob3NlIHByaXZhdGUga2V5J3Mgc2lnbmF0dXJlIGlzIG5lY2Vzc2FyeSBmb3IgZXh0ZW5zaW9ucz5cbiAgICogIHVubG9jazogPGluZm8gZm9yIGFjdGlvbnMgdGhhdCByZXF1aXJlIGFuIHVubG9jayBiZWZvcmUgZmlyaW5nPlxuICAgKiB9XG4gICAqL1xuICBhc3luYyBsaXN0QWNjZXNzVG9rZW5zKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvdXNlci9hY2Nlc3N0b2tlbicpKS5zZW5kKCkucmVzdWx0KCdhY2Nlc3NUb2tlbnMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhZGRBY2Nlc3NUb2tlblxuICAgKiBBZGQgYSBCaXRHbyBBUEkgQWNjZXNzIFRva2VuIHRvIHRoZSBjdXJyZW50IHVzZXIgYWNjb3VudFxuICAgKiBAcGFyYW0gcGFyYW1zIHtcbiAgICogICAgb3RwOiAocmVxdWlyZWQpIDx2YWxpZCBvdHAgY29kZT5cbiAgICogICAgbGFiZWw6IChyZXF1aXJlZCkgPGxhYmVsIGZvciB0aGUgdG9rZW4+XG4gICAqICAgIGR1cmF0aW9uOiA8bGVuZ3RoIG9mIHRpbWUgaW4gc2Vjb25kcyB0aGUgdG9rZW4gd2lsbCBiZSB2YWxpZCBmb3I+XG4gICAqICAgIGlwUmVzdHJpY3Q6IDxhcnJheSBvZiBJUCBhZGRyZXNzIHN0cmluZ3MgdG8gd2hpdGVsaXN0PlxuICAgKiAgICB0eFZhbHVlTGltaXQ6IDxudW1iZXIgb2Ygb3V0Z29pbmcgc2F0b3NoaXMgYWxsb3dlZCBvbiB0aGlzIHRva2VuPlxuICAgKiAgICBzY29wZTogKHJlcXVpcmVkKSA8YXV0aG9yaXphdGlvbiBzY29wZSBvZiB0aGUgcmVxdWVzdGVkIHRva2VuPlxuICAgKiB9XG4gICAqIEByZXR1cm4ge1xuICAgKiAgICBpZDogPGlkIG9mIHRoZSB0b2tlbj5cbiAgICogICAgdG9rZW46IDxhY2Nlc3MgdG9rZW4gaGV4IHN0cmluZyB0byBiZSB1c2VkIGZvciBCaXRHbyBBUEkgcmVxdWVzdCB2ZXJpZmljYXRpb24+XG4gICAqICAgIGxhYmVsOiA8dXNlci1wcm92aWRlZCBsYWJlbCBmb3IgdGhpcyB0b2tlbj5cbiAgICogICAgdXNlcjogPGlkIG9mIHRoZSB1c2VyIG9uIHRoZSB0b2tlbj5cbiAgICogICAgZW50ZXJwcmlzZSA8aWQgb2YgdGhlIGVudGVycHJpc2UgdGhpcyB0b2tlbiBpcyB2YWxpZCBmb3I+XG4gICAqICAgIGNsaWVudDogPHRoZSBhdXRoIGNsaWVudCB0aGF0IHRoaXMgdG9rZW4gYmVsb25ncyB0bz5cbiAgICogICAgc2NvcGU6IDxsaXN0IG9mIGFsbG93ZWQgT0F1dGggc2NvcGUgdmFsdWVzPlxuICAgKiAgICBjcmVhdGVkOiA8ZGF0ZSB0aGUgdG9rZW4gd2FzIGNyZWF0ZWQ+XG4gICAqICAgIGV4cGlyZXM6IDxkYXRlIHRoZSB0b2tlbiB3aWxsIGV4cGlyZT5cbiAgICogICAgb3JpZ2luOiA8dGhlIG9yaWdpbiBmb3Igd2hpY2ggdGhpcyB0b2tlbiBpcyB2YWxpZD5cbiAgICogICAgaXNFeHRlbnNpYmxlOiA8ZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSB0b2tlbiBjYW4gYmUgZXh0ZW5kZWQ+XG4gICAqICAgIGV4dGVuc2lvbkFkZHJlc3M6IDxhZGRyZXNzIHdob3NlIHByaXZhdGUga2V5J3Mgc2lnbmF0dXJlIGlzIG5lY2Vzc2FyeSBmb3IgZXh0ZW5zaW9ucz5cbiAgICogICAgdW5sb2NrOiA8aW5mbyBmb3IgYWN0aW9ucyB0aGF0IHJlcXVpcmUgYW4gdW5sb2NrIGJlZm9yZSBmaXJpbmc+XG4gICAqIH1cbiAgICovXG4gIGFzeW5jIGFkZEFjY2Vzc1Rva2VuKHBhcmFtczogQWRkQWNjZXNzVG9rZW5PcHRpb25zKTogUHJvbWlzZTxBZGRBY2Nlc3NUb2tlblJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMubGFiZWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGxhYmVsJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIG5vbi1zdHJpbmcgcGFyYW1zXG4gICAgICBpZiAocGFyYW1zLmR1cmF0aW9uKSB7XG4gICAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMuZHVyYXRpb24pIHx8IHBhcmFtcy5kdXJhdGlvbiA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2R1cmF0aW9uIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuaXBSZXN0cmljdCkge1xuICAgICAgICBpZiAoIV8uaXNBcnJheShwYXJhbXMuaXBSZXN0cmljdCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwUmVzdHJpY3QgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIF8uZm9yRWFjaChwYXJhbXMuaXBSZXN0cmljdCwgKGlwQWRkcikgPT4ge1xuICAgICAgICAgIGlmICghXy5pc1N0cmluZyhpcEFkZHIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwUmVzdHJpY3QgbXVzdCBiZSBhbiBhcnJheSBvZiBJUCBhZGRyZXNzIHN0cmluZ3MnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcy50eFZhbHVlTGltaXQpIHtcbiAgICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy50eFZhbHVlTGltaXQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eFZhbHVlTGltaXQgbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMudHhWYWx1ZUxpbWl0IDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHhWYWx1ZUxpbWl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJhbXMuc2NvcGUgJiYgcGFyYW1zLnNjb3BlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKCFfLmlzQXJyYXkocGFyYW1zLnNjb3BlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2NvcGUgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3Qgc3BlY2lmeSBzY29wZSBmb3IgdG9rZW4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXV0aFVybCA9IHRoaXMubWljcm9zZXJ2aWNlc1VybCgnL2FwaS9hdXRoL3YxL2FjY2Vzc3Rva2VuJyk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5wb3N0KGF1dGhVcmwpO1xuXG4gICAgICBpZiAoIXRoaXMuX2VjZGhYcHJ2KSB7XG4gICAgICAgIC8vIHdpdGhvdXQgYSBwcml2YXRlIGtleSwgdGhlIHVzZXIgY2Fubm90IGRlY3J5cHQgdGhlIG5ldyBhY2Nlc3MgdG9rZW4gdGhlIHNlcnZlciB3aWxsIHNlbmRcbiAgICAgICAgcmVxdWVzdC5mb3JjZVYxQXV0aCA9IHRydWU7XG4gICAgICAgIGRlYnVnKCdmb3JjaW5nIHYxIGF1dGggZm9yIGFkZGluZyBhY2Nlc3MgdG9rZW4gdXNpbmcgdG9rZW4gJXMnLCB0aGlzLl90b2tlbj8uc3Vic3RyKDAsIDgpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnNlbmQocGFyYW1zKTtcbiAgICAgIGlmIChyZXF1ZXN0LmZvcmNlVjFBdXRoKSB7XG4gICAgICAgIChyZXNwb25zZSBhcyBhbnkpLmJvZHkud2FybmluZyA9ICdBIHByb3RvY29sIGRvd25ncmFkZSBoYXMgb2NjdXJyZWQgYmVjYXVzZSB0aGlzIGlzIGEgbGVnYWN5IGFjY291bnQuJztcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3BvbnNlUmVzdWx0PEFkZEFjY2Vzc1Rva2VuUmVzcG9uc2U+KCkocmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyB2ZXJpZnkgdGhlIGF1dGhlbnRpY2l0eSBvZiB0aGUgc2VydmVyJ3MgcmVzcG9uc2UgYmVmb3JlIHByb2NlZWRpbmcgYW55IGZ1cnRoZXJcbiAgICAgIHZlcmlmeVJlc3BvbnNlKHRoaXMsIHRoaXMuX3Rva2VuLCAncG9zdCcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VEZXRhaWxzID0gdGhpcy5oYW5kbGVUb2tlbklzc3VhbmNlKHJlc3BvbnNlLmJvZHkpO1xuICAgICAgcmVzcG9uc2UuYm9keS50b2tlbiA9IHJlc3BvbnNlRGV0YWlscy50b2tlbjtcblxuICAgICAgcmV0dXJuIGhhbmRsZVJlc3BvbnNlUmVzdWx0PEFkZEFjY2Vzc1Rva2VuUmVzcG9uc2U+KCkocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZVJlc3BvbnNlRXJyb3IoZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGV4cGlyZSB0aW1lIG9mIGFuIGFjY2VzcyB0b2tlbiBtYXRjaGluZyBlaXRoZXIgdGhlIGlkIG9yIGxhYmVsIHRvIHRoZSBjdXJyZW50IGRhdGUsIGVmZmVjdGl2ZWx5IGRlbGV0aW5nIGl0XG4gICAqXG4gICAqIFBhcmFtczpcbiAgICogaWQ6IDxpZCBvZiB0aGUgYWNjZXNzIHRva2VuIHRvIGJlIGRlbGV0ZWQ+XG4gICAqIGxhYmVsOiA8bGFiZWwgb2YgdGhlIGFjY2VzcyB0b2tlbiB0byBiZSBkZWxldGVkPlxuICAgKlxuICAgKiBSZXR1cm5zOlxuICAgKiBpZDogPGlkIG9mIHRoZSB0b2tlbj5cbiAgICogbGFiZWw6IDx1c2VyLXByb3ZpZGVkIGxhYmVsIGZvciB0aGlzIHRva2VuPlxuICAgKiB1c2VyOiA8aWQgb2YgdGhlIHVzZXIgb24gdGhlIHRva2VuPlxuICAgKiBlbnRlcnByaXNlIDxpZCBvZiB0aGUgZW50ZXJwcmlzZSB0aGlzIHRva2VuIGlzIHZhbGlkIGZvcj5cbiAgICogY2xpZW50OiA8dGhlIGF1dGggY2xpZW50IHRoYXQgdGhpcyB0b2tlbiBiZWxvbmdzIHRvPlxuICAgKiBzY29wZTogPGxpc3Qgb2YgYWxsb3dlZCBPQXV0aCBzY29wZSB2YWx1ZXM+XG4gICAqIGNyZWF0ZWQ6IDxkYXRlIHRoZSB0b2tlbiB3YXMgY3JlYXRlZD5cbiAgICogZXhwaXJlczogPGRhdGUgdGhlIHRva2VuIHdpbGwgZXhwaXJlPlxuICAgKiBvcmlnaW46IDx0aGUgb3JpZ2luIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIHZhbGlkPlxuICAgKiBpc0V4dGVuc2libGU6IDxmbGFnIGluZGljYXRpbmcgaWYgdGhlIHRva2VuIGNhbiBiZSBleHRlbmRlZD5cbiAgICogZXh0ZW5zaW9uQWRkcmVzczogPGFkZHJlc3Mgd2hvc2UgcHJpdmF0ZSBrZXkncyBzaWduYXR1cmUgaXMgbmUqY2Vzc2FyeSBmb3IgZXh0ZW5zaW9ucz5cbiAgICogdW5sb2NrOiA8aW5mbyBmb3IgYWN0aW9ucyB0aGF0IHJlcXVpcmUgYW4gdW5sb2NrIGJlZm9yZSBmaXJpbmc+XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUFjY2Vzc1Rva2VuKHsgaWQsIGxhYmVsIH06IFJlbW92ZUFjY2Vzc1Rva2VuT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCghaWQgJiYgIWxhYmVsKSB8fCAoaWQgJiYgbGFiZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgcHJvdmlkZSBleGFjdGx5IG9uZSBvZiBpZCBvciBsYWJlbCcpO1xuICAgIH1cbiAgICBpZiAoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbCh0aGlzLnVybChgL3VzZXIvYWNjZXNzdG9rZW4vJHtpZH1gKSlcbiAgICAgICAgLnNlbmQoKVxuICAgICAgICAucmVzdWx0KCk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW5zID0gYXdhaXQgdGhpcy5saXN0QWNjZXNzVG9rZW5zKCk7XG5cbiAgICBpZiAoIXRva2Vucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b2tlbiB3aXRoIHRoaXMgbGFiZWwgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaGluZ1Rva2VucyA9IF8uZmlsdGVyKHRva2VucywgeyBsYWJlbCB9KTtcbiAgICBpZiAobWF0Y2hpbmdUb2tlbnMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbWJpZ3VvdXMgY2FsbDogbXVsdGlwbGUgdG9rZW5zIG1hdGNoaW5nIHRoaXMgbGFiZWwnKTtcbiAgICB9XG4gICAgaWYgKG1hdGNoaW5nVG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b2tlbiB3aXRoIHRoaXMgbGFiZWwgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kZWwodGhpcy51cmwoYC91c2VyL2FjY2Vzc3Rva2VuLyR7bWF0Y2hpbmdUb2tlbnNbMF0uaWR9YCkpXG4gICAgICAuc2VuZCgpXG4gICAgICAucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSByYW5kb20gcGFzc3dvcmRcbiAgICogQHBhcmFtICAge051bWJlcn0gbnVtV29yZHMgICAgIE51bWJlciBvZiAzMi1iaXQgd29yZHNcbiAgICogQHJldHVybnMge1N0cmluZ30gICAgICAgICAgYmFzZTU4IHJhbmRvbSBwYXNzd29yZFxuICAgKi9cbiAgZ2VuZXJhdGVSYW5kb21QYXNzd29yZChudW1Xb3JkcyA9IDUpOiBzdHJpbmcge1xuICAgIGNvbnN0IGJ5dGVzID0gc2pjbC5jb2RlYy5ieXRlcy5mcm9tQml0cyhzamNsLnJhbmRvbS5yYW5kb21Xb3JkcyhudW1Xb3JkcykpO1xuICAgIHJldHVybiBiczU4LmVuY29kZShieXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogTG9nb3V0IG9mIEJpdEdvXG4gICAqL1xuICBhc3luYyBsb2dvdXQoKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvbG9nb3V0JykpLnJlc3VsdCgpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHVzZXIgYnkgSUQgKG5hbWUvZW1haWwgb25seSlcbiAgICogQHBhcmFtIGlkXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBnZXRVc2VyKHsgaWQgfTogR2V0VXNlck9wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhpZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIGlkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybChgL3VzZXIvJHtpZH1gKSkucmVzdWx0KCd1c2VyJyk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlclxuICAgKi9cbiAgYXN5bmMgbWUoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXRVc2VyKHsgaWQ6ICdtZScgfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5sb2NrIHRoZSBzZXNzaW9uIGJ5IHByb3ZpZGluZyBPVFBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG90cCBSZXF1aXJlZCBPVFAgY29kZSBmb3IgdGhlIGFjY291bnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEZXNpcmVkIGR1cmF0aW9uIG9mIHRoZSB1bmxvY2sgaW4gc2Vjb25kcyAoZGVmYXVsdD02MDAsIG1heD0zNjAwKS5cbiAgICovXG4gIGFzeW5jIHVubG9jayh7IG90cCwgZHVyYXRpb24gfTogVW5sb2NrT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKG90cCAmJiAhXy5pc1N0cmluZyhvdHApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBvciB1bmRlZmluZWQgb3RwJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL3VubG9jaycpKS5zZW5kKHsgb3RwLCBkdXJhdGlvbiB9KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrIHRoZSBzZXNzaW9uXG4gICAqL1xuICBhc3luYyBsb2NrKCk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL3VzZXIvbG9jaycpKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc2Vzc2lvblxuICAgKi9cbiAgYXN5bmMgc2Vzc2lvbigpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvc2Vzc2lvbicpKS5yZXN1bHQoJ3Nlc3Npb24nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIGEgcHVzaC9zbXMgZm9yIHRoZSBPVFAgY29kZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5mb3JjZVNNUyBJZiBzZXQgdG8gdHJ1ZSwgd2lsbCB1c2UgU01TIHRvIHNlbmQgdGhlIE9UUCB0byB0aGUgdXNlciBldmVuIGlmIHRoZXkgaGF2ZSBvdGhlciAyRkEgbWV0aG9kIHNldCB1cC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIHNlbmRPVFAocGFyYW1zOiB7IGZvcmNlU01TPzogYm9vbGVhbiB9ID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL3NlbmRvdHAnKSkuc2VuZChwYXJhbXMpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCB0b2tlbiwgcHJvdmlkZWQgdGhlIGN1cnJlbnQgdG9rZW4gaXMgZXh0ZW5kYWJsZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gZHVyYXRpb246IGR1cmF0aW9uIGluIHNlY29uZHMgYnkgd2hpY2ggdG8gZXh0ZW5kIHRoZSB0b2tlbiwgc3RhcnRpbmcgYXQgdGhlIGN1cnJlbnQgdGltZVxuICAgKi9cbiAgYXN5bmMgZXh0ZW5kVG9rZW4ocGFyYW1zOiBFeHRlbmRUb2tlbk9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBfZXh0ZW5zaW9uS2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcmFtcy5kdXJhdGlvbjtcbiAgICBjb25zdCBtZXNzYWdlID0gdGltZXN0YW1wICsgJ3wnICsgdGhpcy5fdG9rZW4gKyAnfCcgKyBkdXJhdGlvbjtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gdGhpcy5fZXh0ZW5zaW9uS2V5LnByaXZhdGVLZXk7XG4gICAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByaXZhdGVLZXkgb24gZXh0ZW5zaW9uS2V5Jyk7XG4gICAgfVxuICAgIGNvbnN0IGlzQ29tcHJlc3NlZCA9IHRoaXMuX2V4dGVuc2lvbktleS5jb21wcmVzc2VkO1xuICAgIGNvbnN0IHByZWZpeCA9IHV0eG9saWIubmV0d29ya3MuYml0Y29pbi5tZXNzYWdlUHJlZml4O1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGJpdGNvaW5NZXNzYWdlLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkLCBwcmVmaXgpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy91c2VyL2V4dGVuZHRva2VuJykpXG4gICAgICAuc2VuZChwYXJhbXMpXG4gICAgICAuc2V0KCd0aW1lc3RhbXAnLCB0aW1lc3RhbXAudG9TdHJpbmcoKSlcbiAgICAgIC5zZXQoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBrZXkgZm9yIHNoYXJpbmcgYSB3YWxsZXQgd2l0aCBhIHVzZXJcbiAgICogQHBhcmFtIGVtYWlsIGVtYWlsIG9mIHVzZXIgdG8gc2hhcmUgd2FsbGV0IHdpdGhcbiAgICovXG4gIGFzeW5jIGdldFNoYXJpbmdLZXkoeyBlbWFpbCB9OiBHZXRTaGFyaW5nS2V5T3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKGVtYWlsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgZW1haWwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9zaGFyaW5na2V5JykpLnNlbmQoeyBlbWFpbCB9KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VycyB0aGF0IHdhbnQgdG8gc2lnbiB3aXRoIGEga2V5IHdpbGwgdXNlIHRoaXMgYXBpIHRvIGZldGNoIHRoZSBrZXljaGFpbiBhbmQgdGhlIHBhdGguXG4gICAqIFVzZXJzIHRoYXQgd2FudCB0byB2ZXJpZnkgYSBzaWduYXR1cmUgd2lsbCB1c2UgdGhpcyBhcGkgdG8gZmV0Y2ggYW5vdGhlciB1c2VycyBlY2RoIHB1YmtleS5cbiAgICogTm90ZTogSWYgdGhlIHVzZXIgaWQgaXMgbm90IHByb3ZpZGVkLCBpdCB3aWxsIGRlZmF1bHQgdG8gZ2V0dGluZyB0aGUgY3VycmVudCB1c2VyJ3Mga2V5Y2hhaW4uXG4gICAqIEBwYXJhbSBiaXRnb1xuICAgKiBAcGFyYW0gZW50ZXJwcmlzZUlkXG4gICAqIEBwYXJhbSB1c2VySWRcbiAgICovXG4gIGFzeW5jIGdldFNpZ25pbmdLZXlGb3JVc2VyKGVudGVycHJpc2VJZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpOiBQcm9taXNlPEdldFNpZ25pbmdLZXlBcGk+IHtcbiAgICBjb25zdCB1c2VyID0gdXNlcklkID8/ICdtZSc7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKGAvZW50ZXJwcmlzZS8ke2VudGVycHJpc2VJZH0vdXNlci8ke3VzZXJ9L3NpZ25pbmdrZXlgLCAyKSlcbiAgICAgIC5xdWVyeSh7fSlcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZ2V0VmFsaWRhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBzZXRWYWxpZGF0ZSh2YWxpZGF0ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICghXy5pc0Jvb2xlYW4odmFsaWRhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgdGhpcy5fdmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIG5ldyBjb2luIGluc3RhbmNlIHdpdGggaXRzIGJ1aWxkZXIgZmFjdG9yeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBjb2luIG5hbWUgYXMgaXQgd2FzIHJlZ2lzdGVyZWQgaW4gQGJpdGdvL3N0YXRpY3NcbiAgICogQHBhcmFtIHtDb2luQ29uc3RydWN0b3J9IGNvaW4gdGhlIGJ1aWxkZXIgZmFjdG9yeSBjbGFzcyBmb3IgdGhhdCBjb2luXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyKG5hbWU6IHN0cmluZywgY29pbjogQ29pbkNvbnN0cnVjdG9yKTogdm9pZCB7XG4gICAgR2xvYmFsQ29pbkZhY3RvcnkucmVnaXN0ZXIobmFtZSwgY29pbik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJpdGNvaW4gbWFya2V0IGRhdGFcbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIG1hcmtldHMoKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX21hcmtldHMpIHtcbiAgICAgIHRoaXMuX21hcmtldHMgPSBuZXcgTWFya2V0cyh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21hcmtldHM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXRlc3QgYml0Y29pbiBwcmljZXNcbiAgICogKERlcHJlY2F0ZWQ6IFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlKSB1c2UgYGJpdGdvLm1hcmtldHMoKS5sYXRlc3QoKWBcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIC8vIGNiLWNvbXBhdFxuICBhc3luYyBtYXJrZXQoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9tYXJrZXQvbGF0ZXN0JykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBtYXJrZXQgZGF0YSBmcm9tIHllc3RlcmRheVxuICAgKiAoRGVwcmVjYXRlZDogV2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUpIHVzZSBiaXRnby5tYXJrZXRzKCkueWVzdGVyZGF5KClcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIHllc3RlcmRheSgpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL21hcmtldC95ZXN0ZXJkYXknKSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBibG9ja2NoYWluIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGJsb2NrY2hhaW4oKTogYW55IHtcbiAgICBpZiAoIXRoaXMuX2Jsb2NrY2hhaW4pIHtcbiAgICAgIHRoaXMuX2Jsb2NrY2hhaW4gPSBuZXcgQmxvY2tjaGFpbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2Jsb2NrY2hhaW47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyJ3Mga2V5Y2hhaW5zIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGtleWNoYWlucygpOiBhbnkge1xuICAgIGlmICghdGhpcy5fa2V5Y2hhaW5zKSB7XG4gICAgICB0aGlzLl9rZXljaGFpbnMgPSBuZXcgS2V5Y2hhaW5zKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2V5Y2hhaW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHJhdmVsIHJ1bGUgb2JqZWN0XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICB0cmF2ZWxSdWxlKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl90cmF2ZWxSdWxlKSB7XG4gICAgICB0aGlzLl90cmF2ZWxSdWxlID0gbmV3IFRyYXZlbFJ1bGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmF2ZWxSdWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIHdhbGxldHMgb2JqZWN0LlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgd2FsbGV0cygpOiBhbnkge1xuICAgIGlmICghdGhpcy5fd2FsbGV0cykge1xuICAgICAgdGhpcy5fd2FsbGV0cyA9IG5ldyBXYWxsZXRzKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcGVuZGluZyBhcHByb3ZhbHMgdGhhdCBjYW4gYmUgYXBwcm92ZWQvIG9yIHJlamVjdGVkXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBwZW5kaW5nQXBwcm92YWxzKCk6IGFueSB7XG4gICAgaWYgKCF0aGlzLl9wZW5kaW5nQXBwcm92YWxzKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nQXBwcm92YWxzID0gbmV3IFBlbmRpbmdBcHByb3ZhbHModGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nQXBwcm92YWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFdhbGxldCBvYmplY3QsIGluaXRpYWxpemVkIHdpdGggdGhlIHdhbGxldCBwYXJhbXNcbiAgICogQ2FuIGJlIHVzZWQgdG8gcmVjb25zdGl0dXRlIGEgd2FsbGV0IGZyb20gY2FjaGVkIGRhdGFcbiAgICogQHBhcmFtIHdhbGxldFBhcmFtc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgbmV3V2FsbGV0T2JqZWN0KHdhbGxldFBhcmFtcyk6IGFueSB7XG4gICAgcmV0dXJuIG5ldyBXYWxsZXQodGhpcywgd2FsbGV0UGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWMSBtZXRob2QgZm9yIGNhbGN1bGF0aW5nIG1pbmVyIGZlZSBhbW91bnRzLCBnaXZlbiB0aGUgbnVtYmVyIGFuZFxuICAgKiB0eXBlIG9mIHRyYW5zYWN0aW9uIGlucHV0cywgYWxvbmcgd2l0aCBhIGZlZSByYXRlIGluIHNhdG9zaGlzIHBlciB2a0IuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCBmb3IgbmV3IGNvZGUuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgYXN5bmMgY2FsY3VsYXRlTWluZXJGZWVJbmZvKHBhcmFtczogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25CdWlsZGVyLmNhbGN1bGF0ZU1pbmVyRmVlSW5mbyhwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBhIEJpdGNvaW4gYWRkcmVzcyBpcyBhIHZhbGlkIGJhc2U1OCBhZGRyZXNzXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICB2ZXJpZnlBZGRyZXNzKHBhcmFtczogRGVwcmVjYXRlZFZlcmlmeUFkZHJlc3NPcHRpb25zID0ge30pOiBib29sZWFuIHtcbiAgICBjb21tb24udmFsaWRhdGVQYXJhbXMocGFyYW1zLCBbJ2FkZHJlc3MnXSwgW10pO1xuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHN0cmluZyBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV0d29ya05hbWUgPSBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuZ2V0RW52KCldLm5ldHdvcms7XG4gICAgY29uc3QgbmV0d29yayA9IHV0eG9saWIubmV0d29ya3NbbmV0d29ya05hbWVdO1xuXG4gICAgbGV0IGFkZHJlc3M7XG4gICAgdHJ5IHtcbiAgICAgIGFkZHJlc3MgPSB1dHhvbGliLmFkZHJlc3MuZnJvbUJhc2U1OENoZWNrKHBhcmFtcy5hZGRyZXNzLCBuZXR3b3JrKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZHJlc3MudmVyc2lvbiA9PT0gbmV0d29yay5wdWJLZXlIYXNoIHx8IGFkZHJlc3MudmVyc2lvbiA9PT0gbmV0d29yay5zY3JpcHRIYXNoO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IGEgc2VjcmV0IGludG8gc2hhcmRzIHVzaW5nIFNoYW1pciBTZWNyZXQgU2hhcmluZy5cbiAgICogQHBhcmFtIHNlZWQgQSBoZXhhZGVjaW1hbCBzZWNyZXQgdG8gc3BsaXRcbiAgICogQHBhcmFtIHBhc3N3b3JkcyBBbiBhcnJheSBvZiB0aGUgcGFzc3dvcmRzIHVzZWQgdG8gZW5jcnlwdCBlYWNoIHNoYXJlXG4gICAqIEBwYXJhbSBtIFRoZSB0aHJlc2hvbGQgbnVtYmVyIG9mIHNoYXJkcyBuZWNlc3NhcnkgdG8gcmVjb25zdGl0dXRlIHRoZSBzZWNyZXRcbiAgICovXG4gIHNwbGl0U2VjcmV0KHsgc2VlZCwgcGFzc3dvcmRzLCBtIH06IFNwbGl0U2VjcmV0T3B0aW9ucyk6IFNwbGl0U2VjcmV0IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFzc3dvcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNJbnRlZ2VyKG0pIHx8IG0gPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ20gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDInKTtcbiAgICB9XG5cbiAgICBpZiAocGFzc3dvcmRzLmxlbmd0aCA8IG0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFzc3dvcmRzIGFycmF5IGxlbmd0aCBjYW5ub3QgYmUgbGVzcyB0aGFuIG0nKTtcbiAgICB9XG5cbiAgICBjb25zdCBuID0gcGFzc3dvcmRzLmxlbmd0aDtcbiAgICBjb25zdCBzZWNyZXRzOiBzdHJpbmdbXSA9IHNoYW1pci5zaGFyZShzZWVkLCBuLCBtKTtcbiAgICBjb25zdCBzaGFyZHMgPSBfLnppcFdpdGgoc2VjcmV0cywgcGFzc3dvcmRzLCAoc2hhcmQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNyeXB0KHsgaW5wdXQ6IHNoYXJkLCBwYXNzd29yZCB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBub2RlID0gYmlwMzIuZnJvbVNlZWQoQnVmZmVyLmZyb20oc2VlZCwgJ2hleCcpKTtcbiAgICByZXR1cm4ge1xuICAgICAgeHB1Yjogbm9kZS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCksXG4gICAgICBtLFxuICAgICAgbixcbiAgICAgIHNlZWRTaGFyZXM6IHNoYXJkcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY29uc3RpdHV0ZSBhIHNlY3JldCB3aGljaCB3YXMgc2hhcmRlZCB3aXRoIGBzcGxpdFNlY3JldGAuXG4gICAqIEBwYXJhbSBzaGFyZHNcbiAgICogQHBhcmFtIHBhc3N3b3Jkc1xuICAgKi9cbiAgcmVjb25zdGl0dXRlU2VjcmV0KHsgc2hhcmRzLCBwYXNzd29yZHMgfTogUmVjb25zdGl0dXRlU2VjcmV0T3B0aW9ucyk6IFJlY29uc3RpdHV0ZWRTZWNyZXQge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFyZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShwYXNzd29yZHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKHNoYXJkcy5sZW5ndGggIT09IHBhc3N3b3Jkcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2hhcmRzIGFuZCBwYXNzd29yZHMgYXJyYXlzIG11c3QgaGF2ZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY3JldHMgPSBfLnppcFdpdGgoc2hhcmRzLCBwYXNzd29yZHMsIChzaGFyZCwgcGFzc3dvcmQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmRlY3J5cHQoeyBpbnB1dDogc2hhcmQsIHBhc3N3b3JkIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHNlZWQ6IHN0cmluZyA9IHNoYW1pci5jb21iaW5lKHNlY3JldHMpO1xuICAgIGNvbnN0IG5vZGUgPSBiaXAzMi5mcm9tU2VlZChCdWZmZXIuZnJvbShzZWVkLCAnaGV4JykpO1xuICAgIHJldHVybiB7XG4gICAgICB4cHViOiBub2RlLm5ldXRlcmVkKCkudG9CYXNlNTgoKSBhcyBzdHJpbmcsXG4gICAgICB4cHJ2OiBub2RlLnRvQmFzZTU4KCkgYXMgc3RyaW5nLFxuICAgICAgc2VlZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBzaGFyZHNcbiAgICogQHBhcmFtIHBhc3N3b3Jkc1xuICAgKiBAcGFyYW0gbVxuICAgKiBAcGFyYW0geHB1YiBPcHRpb25hbCB4cHViIHRvIHZlcmlmeSB0aGUgcmVzdWx0cyBhZ2FpbnN0XG4gICAqL1xuICB2ZXJpZnlTaGFyZHMoeyBzaGFyZHMsIHBhc3N3b3JkcywgbSwgeHB1YiB9OiBWZXJpZnlTaGFyZHNPcHRpb25zKTogYm9vbGVhbiB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYWxsIHBvc3NpYmxlIGNvbWJpbmF0aW9ucyBvZiBhIGdpdmVuIGFycmF5J3MgdmFsdWVzIGdpdmVuIHN1YnNldCBzaXplIG1cbiAgICAgKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHdob3NlIHZhbHVlcyBhcmUgdG8gYmUgYXJyYW5nZWQgaW4gYWxsIGNvbWJpbmF0aW9uc1xuICAgICAqIEBwYXJhbSBtIFRoZSBzaXplIG9mIGVhY2ggc3Vic2V0XG4gICAgICogQHBhcmFtIGVudHJ5SW5kaWNlcyBSZWN1cnNpdmVseSB0cmFpbGluZyBzZXQgb2YgY3VycmVudGx5IGNob3NlbiBhcnJheSBpbmRpY2VzIGZvciB0aGUgY29tYmluYXRpb24gc3Vic2V0IHVuZGVyIGNvbnN0cnVjdGlvblxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBjb25zdCBnZW5lcmF0ZUNvbWJpbmF0aW9ucyA9IChhcnJheTogc3RyaW5nW10sIG06IG51bWJlciwgZW50cnlJbmRpY2VzOiBudW1iZXJbXSA9IFtdKTogc3RyaW5nW11bXSA9PiB7XG4gICAgICBsZXQgY29tYmluYXRpb25zOiBzdHJpbmdbXVtdID0gW107XG5cbiAgICAgIGlmIChlbnRyeUluZGljZXMubGVuZ3RoID09PSBtKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb21iaW5hdGlvbiA9IF8uYXQoYXJyYXksIGVudHJ5SW5kaWNlcyk7XG4gICAgICAgIHJldHVybiBbY3VycmVudENvbWJpbmF0aW9uXTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGhpZ2hlc3QgaW5kZXhcbiAgICAgIGxldCBlbnRyeUluZGV4ID0gXy5sYXN0KGVudHJ5SW5kaWNlcyk7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgY3VycmVudGx5IG5vIGluZGljZXMsIGFzc3VtZSAtMVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoZW50cnlJbmRleCkpIHtcbiAgICAgICAgZW50cnlJbmRleCA9IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IGVudHJ5SW5kZXggKyAxOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBjdXJyZW50IGluZGV4IHRvIHRoZSB0cmFpbGluZyBpbmRpY2VzXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFbnRyeUluZGljZXMgPSBbLi4uZW50cnlJbmRpY2VzLCBpXTtcbiAgICAgICAgY29uc3QgbmV3Q29tYmluYXRpb25zID0gZ2VuZXJhdGVDb21iaW5hdGlvbnMoYXJyYXksIG0sIGN1cnJlbnRFbnRyeUluZGljZXMpO1xuICAgICAgICBjb21iaW5hdGlvbnMgPSBbLi4uY29tYmluYXRpb25zLCAuLi5uZXdDb21iaW5hdGlvbnNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tYmluYXRpb25zO1xuICAgIH07XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaGFyZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFzc3dvcmRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZHMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cblxuICAgIGlmIChzaGFyZHMubGVuZ3RoICE9PSBwYXNzd29yZHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NoYXJkcyBhbmQgcGFzc3dvcmRzIGFycmF5cyBtdXN0IGhhdmUgc2FtZSBsZW5ndGgnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNyZXRzID0gXy56aXBXaXRoKHNoYXJkcywgcGFzc3dvcmRzLCAoc2hhcmQsIHBhc3N3b3JkKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5kZWNyeXB0KHsgaW5wdXQ6IHNoYXJkLCBwYXNzd29yZCB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzZWNyZXRDb21iaW5hdGlvbnMgPSBnZW5lcmF0ZUNvbWJpbmF0aW9ucyhzZWNyZXRzLCBtKTtcbiAgICBjb25zdCBzZWVkcyA9IHNlY3JldENvbWJpbmF0aW9ucy5tYXAoKGN1cnJlbnRDb21iaW5hdGlvbikgPT4ge1xuICAgICAgcmV0dXJuIHNoYW1pci5jb21iaW5lKGN1cnJlbnRDb21iaW5hdGlvbik7XG4gICAgfSk7XG4gICAgY29uc3QgdW5pcXVlU2VlZHMgPSBfLnVuaXEoc2VlZHMpO1xuICAgIGlmICh1bmlxdWVTZWVkcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IF8uZmlyc3QodW5pcXVlU2VlZHMpO1xuICAgIGNvbnN0IG5vZGUgPSBiaXAzMi5mcm9tU2VlZChCdWZmZXIuZnJvbShzZWVkLCAnaGV4JykpO1xuICAgIGNvbnN0IHJlc3RvcmVkWHB1YiA9IG5vZGUubmV1dGVyZWQoKS50b0Jhc2U1OCgpO1xuXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHhwdWIpKSB7XG4gICAgICBpZiAoIV8uaXNTdHJpbmcoeHB1YikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4cHViIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN0b3JlZFhwdWIgIT09IHhwdWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIC0gdXNlIGBnZXRTaGFyZWRTZWNyZXQoKWBcbiAgICovXG4gIGdldEVDREhTZWNyZXQoeyBvdGhlclB1YktleUhleCwgZWNrZXkgfTogR2V0RWNkaFNlY3JldE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIGlmICghXy5pc1N0cmluZyhvdGhlclB1YktleUhleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3RoZXJQdWJLZXlIZXggc3RyaW5nIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghXy5pc09iamVjdChlY2tleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWNrZXkgb2JqZWN0IHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFNoYXJlZFNlY3JldChlY2tleSwgQnVmZmVyLmZyb20ob3RoZXJQdWJLZXlIZXgsICdoZXgnKSkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVzZXIncyBwcml2YXRlIEVDREgga2V5Y2hhaW5cbiAgICovXG4gIGFzeW5jIGdldEVDREhLZXljaGFpbihlY2RoS2V5Y2hhaW5QdWI/OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghZWNkaEtleWNoYWluUHViKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldCh0aGlzLnVybCgnL3VzZXIvc2V0dGluZ3MnKSkucmVzdWx0KCk7XG4gICAgICBpZiAoIXJlc3VsdC5zZXR0aW5ncy5lY2RoS2V5Y2hhaW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignZWNkaCBrZXljaGFpbiBub3QgZm91bmQgZm9yIHVzZXInKTtcbiAgICAgIH1cbiAgICAgIGVjZGhLZXljaGFpblB1YiA9IHJlc3VsdC5zZXR0aW5ncy5lY2RoS2V5Y2hhaW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmtleWNoYWlucygpLmdldCh7IHhwdWI6IGVjZGhLZXljaGFpblB1YiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1c2VyIGRlcml2ZWQgcHVibGljIGFuZCBwcml2YXRlIEVDREgga2V5cGFpclxuICAgKiBAcGFyYW0gcGFzc3dvcmQgcGFzc3dvcmQgdG8gZGVjcnlwdCB0aGUgdXNlcidzIEVDREggZW5jcnlwdGVkIHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBlbnRJZD8gb3B0aW9uYWwgZW50ZXJwcmlzZSBpZCB0byBjaGVjayBmb3IgcGVybWlzc2lvbnNcbiAgICovXG4gIGFzeW5jIGdldEVjZGhLZXlwYWlyUHJpdmF0ZShwYXNzd29yZDogc3RyaW5nLCBlbnRJZDogc3RyaW5nKTogUHJvbWlzZTxFY2RoRGVyaXZlZEtleXBhaXI+IHtcbiAgICBjb25zdCB1c2VyU2lnbmluZ0tleSA9IGF3YWl0IHRoaXMuZ2V0U2lnbmluZ0tleUZvclVzZXIoZW50SWQpO1xuICAgIGNvbnN0IHB1YmtleU9mQWRtaW5FY2RoS2V5SGV4ID0gdXNlclNpZ25pbmdLZXkuZGVyaXZlZFB1YmtleTtcbiAgICBpZiAoIXVzZXJTaWduaW5nS2V5LmVjZGhLZXljaGFpbiB8fCAhdXNlclNpZ25pbmdLZXkuZGVyaXZhdGlvblBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCB0aGUgdXNlciBrZXljaGFpbi4gUGxlYXNlIGNvbnRhY3Qgc3VwcG9ydEBiaXRnby5jb20uJyk7XG4gICAgfVxuICAgIGNvbnN0IHVzZXJFY2RoS2V5Y2hhaW4gPSBhd2FpdCB0aGlzLmdldEVDREhLZXljaGFpbih1c2VyU2lnbmluZ0tleS5lY2RoS2V5Y2hhaW4pO1xuICAgIGxldCB4cHJ2O1xuICAgIHRyeSB7XG4gICAgICB4cHJ2ID0gdGhpcy5kZWNyeXB0KHtcbiAgICAgICAgcGFzc3dvcmQ6IHBhc3N3b3JkLFxuICAgICAgICBpbnB1dDogdXNlckVjZGhLZXljaGFpbi5lbmNyeXB0ZWRYcHJ2LFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcGFzc3dvcmQuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkZXJpdmVkUHViS2V5OiBwdWJrZXlPZkFkbWluRWNkaEtleUhleCxcbiAgICAgIGRlcml2YXRpb25QYXRoOiB1c2VyU2lnbmluZ0tleS5kZXJpdmF0aW9uUGF0aCxcbiAgICAgIHhwcnYsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIC0gb3BlcmF0aW5nU3lzdGVtOiBvbmUgb2YgaW9zLCBhbmRyb2lkXG4gICAqIC0gcHVzaFRva2VuOiBoZXgtZm9ybWF0dGVkIHRva2VuIGZvciB0aGUgcmVzcGVjdGl2ZSBuYXRpdmUgcHVzaCBub3RpZmljYXRpb24gc2VydmljZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIHJlZ2lzdGVyUHVzaFRva2VuKHBhcmFtczogUmVnaXN0ZXJQdXNoVG9rZW5PcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWydwdXNoVG9rZW4nLCAnb3BlcmF0aW5nU3lzdGVtJ10sIFtdKTtcblxuICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgIC8vIHRoaXMgZGV2aWNlIGhhcyB0byBiZSByZWdpc3RlcmVkIHRvIGFuIGV4dGVuc2libGUgc2Vzc2lvblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgbG9nZ2VkIGluJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcG9zdFBhcmFtcyA9IF8ucGljayhwYXJhbXMsIFsncHVzaFRva2VuJywgJ29wZXJhdGluZ1N5c3RlbSddKTtcblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy9kZXZpY2VzJykpLnNlbmQocG9zdFBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHB1c2hWZXJpZmljYXRpb25Ub2tlbjogdGhlIHRva2VuIHJlY2VpdmVkIHZpYSBwdXNoIG5vdGlmaWNhdGlvbiB0byBjb25maXJtIHRoZSBkZXZpY2UncyBtb2JpbGl0eVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgdmVyaWZ5UHVzaFRva2VuKHBhcmFtczogVmVyaWZ5UHVzaFRva2VuT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgb2JqZWN0IHBhcmFtcycpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMucHVzaFZlcmlmaWNhdGlvblRva2VuKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgcHVzaFZlcmlmaWNhdGlvblRva2VuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgLy8gdGhpcyBkZXZpY2UgaGFzIHRvIGJlIHJlZ2lzdGVyZWQgdG8gYW4gZXh0ZW5zaWJsZSBzZXNzaW9uXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBsb2dnZWQgaW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3N0UGFyYW1zID0gXy5waWNrKHBhcmFtcywgJ3B1c2hWZXJpZmljYXRpb25Ub2tlbicpO1xuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybCgnL2RldmljZXMvdmVyaWZ5JykpLnNlbmQocG9zdFBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogTG9naW4gdG8gdGhlIGJpdGdvIHN5c3RlbSB1c2luZyBhbiBhdXRoY29kZSBnZW5lcmF0ZWQgdmlhIE9hdXRoXG4gICAqL1xuICBhc3luYyBhdXRoZW50aWNhdGVXaXRoQXV0aENvZGUocGFyYW1zOiBBdXRoZW50aWNhdGVXaXRoQXV0aENvZGVPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNPYmplY3QocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBvYmplY3QgcGFyYW1zJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5hdXRoQ29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIGF1dGhDb2RlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9jbGllbnRJZCB8fCAhdGhpcy5fY2xpZW50U2VjcmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgY2xpZW50IGlkIGFuZCBzZWNyZXQgc2V0IGZpcnN0IHRvIHVzZSB0aGlzJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXV0aENvZGUgPSBwYXJhbXMuYXV0aENvZGU7XG5cbiAgICBpZiAodGhpcy5fdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYWxyZWFkeSBsb2dnZWQgaW4nKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5wb3N0KHRoaXMuX2Jhc2VVcmwgKyAnL29hdXRoL3Rva2VuJyk7XG4gICAgcmVxdWVzdC5mb3JjZVYxQXV0aCA9IHRydWU7IC8vIE9BdXRoIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHYxIGF1dGhlbnRpY2F0aW9uXG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlcXVlc3RcbiAgICAgIC5zZW5kKHtcbiAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICAgIGNvZGU6IGF1dGhDb2RlLFxuICAgICAgICBjbGllbnRfaWQ6IHRoaXMuX2NsaWVudElkLFxuICAgICAgICBjbGllbnRfc2VjcmV0OiB0aGlzLl9jbGllbnRTZWNyZXQsXG4gICAgICB9KVxuICAgICAgLnJlc3VsdCgpO1xuXG4gICAgdGhpcy5fdG9rZW4gPSBib2R5LmFjY2Vzc190b2tlbjtcbiAgICB0aGlzLl9yZWZyZXNoVG9rZW4gPSBib2R5LnJlZnJlc2hfdG9rZW47XG4gICAgdGhpcy5fdXNlciA9IGF3YWl0IHRoaXMubWUoKTtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIHBhc3N3b3JkIG9mIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAqIEFsc28gY2hhbmdlIGFsbCB2MSBhbmQgdjIga2V5Y2hhaW4gcGFzc3dvcmRzIGlmIHRoZXkgbWF0Y2ggdGhlXG4gICAqIGdpdmVuIG9sZFBhc3N3b3JkLiBSZXR1cm5zIG5vdGhpbmcgb24gc3VjY2Vzcy5cbiAgICogQHBhcmFtIG9sZFBhc3N3b3JkIHtTdHJpbmd9IC0gdGhlIGN1cnJlbnQgcGFzc3dvcmRcbiAgICogQHBhcmFtIG5ld1Bhc3N3b3JkIHtTdHJpbmd9IC0gdGhlIG5ldyBwYXNzd29yZFxuICAgKi9cbiAgYXN5bmMgY2hhbmdlUGFzc3dvcmQoeyBvbGRQYXNzd29yZCwgbmV3UGFzc3dvcmQgfTogQ2hhbmdlUGFzc3dvcmRPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcob2xkUGFzc3dvcmQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHN0cmluZyBvbGRQYXNzd29yZCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhuZXdQYXNzd29yZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgc3RyaW5nIG5ld1Bhc3N3b3JkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlciA9IHRoaXMudXNlcigpO1xuICAgIGlmICh0eXBlb2YgdXNlciAhPT0gJ29iamVjdCcgfHwgIXVzZXIudXNlcm5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBvYmplY3QgdXNlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSBhd2FpdCB0aGlzLnZlcmlmeVBhc3N3b3JkKHsgcGFzc3dvcmQ6IG9sZFBhc3N3b3JkIH0pO1xuICAgIGlmICghdmFsaWRhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgcHJvdmlkZWQgb2xkUGFzc3dvcmQgaXMgaW5jb3JyZWN0Jyk7XG4gICAgfVxuXG4gICAgLy8gaXQgZG9lc24ndCBtYXR0ZXIgd2hpY2ggY29pbiB3ZSBjaG9vc2UgYmVjYXVzZSB0aGUgdjIgdXBkYXRlUGFzc3dvcmQgZnVuY3Rpb25zIHVwZGF0ZXMgYWxsIHYyIGtleWNoYWluc1xuICAgIC8vIHdlIGp1c3QgbmVlZCB0byBjaG9vc2UgYSBjb2luIHRoYXQgZXhpc3RzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAgY29uc3QgY29pbiA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5nZXRFbnYoKV0ubmV0d29yayA9PT0gJ2JpdGNvaW4nID8gJ2J0YycgOiAndGJ0Yyc7XG5cbiAgICBjb25zdCB1cGRhdGVLZXljaGFpblBhc3N3b3JkUGFyYW1zID0geyBvbGRQYXNzd29yZCwgbmV3UGFzc3dvcmQgfTtcbiAgICBjb25zdCB2MUtleWNoYWluVXBkYXRlUFdSZXN1bHQgPSBhd2FpdCB0aGlzLmtleWNoYWlucygpLnVwZGF0ZVBhc3N3b3JkKHVwZGF0ZUtleWNoYWluUGFzc3dvcmRQYXJhbXMpO1xuICAgIGNvbnN0IHYyS2V5Y2hhaW5zID0gYXdhaXQgdGhpcy5jb2luKGNvaW4pLmtleWNoYWlucygpLnVwZGF0ZVBhc3N3b3JkKHVwZGF0ZUtleWNoYWluUGFzc3dvcmRQYXJhbXMpO1xuXG4gICAgY29uc3QgdXBkYXRlUGFzc3dvcmRQYXJhbXMgPSB7XG4gICAgICBrZXljaGFpbnM6IHYxS2V5Y2hhaW5VcGRhdGVQV1Jlc3VsdC5rZXljaGFpbnMsXG4gICAgICB2Ml9rZXljaGFpbnM6IHYyS2V5Y2hhaW5zLFxuICAgICAgdmVyc2lvbjogdjFLZXljaGFpblVwZGF0ZVBXUmVzdWx0LnZlcnNpb24sXG4gICAgICBvbGRQYXNzd29yZDogdGhpcy5jYWxjdWxhdGVITUFDKHVzZXIudXNlcm5hbWUsIG9sZFBhc3N3b3JkKSxcbiAgICAgIHBhc3N3b3JkOiB0aGlzLmNhbGN1bGF0ZUhNQUModXNlci51c2VybmFtZSwgbmV3UGFzc3dvcmQpLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcy5wb3N0KHRoaXMudXJsKCcvdXNlci9jaGFuZ2VwYXNzd29yZCcpKS5zZW5kKHVwZGF0ZVBhc3N3b3JkUGFyYW1zKS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRoZSBhZGRyZXNzIGxhYmVscyBvbiBhbGwgb2YgdGhlIHVzZXIncyB3YWxsZXRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBsYWJlbHMoKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQodGhpcy51cmwoJy9sYWJlbHMnKSkucmVzdWx0KCdsYWJlbHMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFc3RpbWF0ZXMgYXBwcm94aW1hdGUgZmVlIHBlciBrYiBuZWVkZWQgZm9yIGEgdHggdG8gZ2V0IGludG8gYSBibG9ja1xuICAgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLm51bUJsb2NrcyB0YXJnZXQgYmxvY2tzIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgY29uZmlybWVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMubWF4RmVlIG1heGltdW0gZmVlIHdpbGxpbmcgdG8gYmUgcGFpZCAoZm9yIHNhZmV0eSlcbiAgICogQHBhcmFtIHthcnJheVtzdHJpbmddfSBwYXJhbXMuaW5wdXRzIGxpc3Qgb2YgdW5jb25maXJtZWQgdHhJZHMgZnJvbSB3aGljaCB0aGlzIHRyYW5zYWN0aW9uIHVzZXMgaW5wdXRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMudHhTaXplIGVzdGltYXRlZCB0cmFuc2FjdGlvbiBzaXplIGluIGJ5dGVzLCBvcHRpb25hbCBwYXJhbWV0ZXIgdXNlZCBmb3IgQ1BGUCBlc3RpbWF0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5jcGZwQXdhcmUgZmxhZyBpbmRpY2F0aW5nIGZlZSBzaG91bGQgdGFrZSBpbnRvIGFjY291bnQgQ1BGUFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgZXN0aW1hdGVGZWUocGFyYW1zOiBFc3RpbWF0ZUZlZU9wdGlvbnMgPSB7fSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcXVlcnlQYXJhbXM6IGFueSA9IHsgdmVyc2lvbjogMTIgfTtcbiAgICBpZiAocGFyYW1zLm51bUJsb2Nrcykge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy5udW1CbG9ja3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMubnVtQmxvY2tzID0gcGFyYW1zLm51bUJsb2NrcztcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5tYXhGZWUpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubWF4RmVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5UGFyYW1zLm1heEZlZSA9IHBhcmFtcy5tYXhGZWU7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuaW5wdXRzKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLmlucHV0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5pbnB1dHMgPSBwYXJhbXMuaW5wdXRzO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnR4U2l6ZSkge1xuICAgICAgaWYgKCFfLmlzTnVtYmVyKHBhcmFtcy50eFNpemUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgfVxuICAgICAgcXVlcnlQYXJhbXMudHhTaXplID0gcGFyYW1zLnR4U2l6ZTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jcGZwQXdhcmUpIHtcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocGFyYW1zLmNwZnBBd2FyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBxdWVyeVBhcmFtcy5jcGZwQXdhcmUgPSBwYXJhbXMuY3BmcEF3YXJlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3R4L2ZlZScpKS5xdWVyeShxdWVyeVBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEJpdEdvJ3MgZ3VhcmFudGVlIHVzaW5nIGFuIGluc3RhbnQgaWRcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgaW5zdGFudEd1YXJhbnRlZShwYXJhbXM6IHsgaWQ6IHN0cmluZyB9KTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgaWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gYXdhaXQgdGhpcy5nZXQodGhpcy51cmwoJy9pbnN0YW50LycgKyBwYXJhbXMuaWQpKS5yZXN1bHQoKTtcbiAgICBpZiAoIWJvZHkuZ3VhcmFudGVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGd1YXJhbnRlZSBmb3VuZCBpbiByZXNwb25zZSBib2R5Jyk7XG4gICAgfVxuICAgIGlmICghYm9keS5zaWduYXR1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gc2lnbmF0dXJlIGZvdW5kIGluIGd1YXJhbnRlZSByZXNwb25zZSBib2R5Jyk7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25pbmdBZGRyZXNzID0gY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmdldEVudigpXS5zaWduaW5nQWRkcmVzcztcbiAgICBjb25zdCBzaWduYXR1cmVCdWZmZXIgPSBCdWZmZXIuZnJvbShib2R5LnNpZ25hdHVyZSwgJ2hleCcpO1xuICAgIGNvbnN0IHByZWZpeCA9IHV0eG9saWIubmV0d29ya3NbY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmdldEVudigpXS5uZXR3b3JrXS5tZXNzYWdlUHJlZml4O1xuICAgIGNvbnN0IGlzVmFsaWRTaWduYXR1cmUgPSBiaXRjb2luTWVzc2FnZS52ZXJpZnkoYm9keS5ndWFyYW50ZWUsIHNpZ25pbmdBZGRyZXNzLCBzaWduYXR1cmVCdWZmZXIsIHByZWZpeCk7XG4gICAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29ycmVjdCBzaWduYXR1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgdGFyZ2V0IGFkZHJlc3MgZm9yIHBheW1lbnQgb2YgYSBCaXRHbyBmZWVcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGdldEJpdEdvRmVlQWRkcmVzcygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy9iaWxsaW5nL2FkZHJlc3MnKSkuc2VuZCh7fSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhZGRyZXNzIG9iamVjdCAoaW5jbHVkaW5nIHRoZSB3YWxsZXQgaWQpIGZvciBhIGdpdmVuIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYWRkcmVzcyBUaGUgYWRkcmVzcyB0byBsb29rIHVwLlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0V2FsbGV0QWRkcmVzcyh7IGFkZHJlc3MgfTogeyBhZGRyZXNzOiBzdHJpbmcgfSk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKGAvd2FsbGV0YWRkcmVzcy8ke2FkZHJlc3N9YCkpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGxpc3Qgb2YgdXNlciB3ZWJob29rc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFzeW5jIGxpc3RXZWJob29rcygpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmdldCh0aGlzLnVybCgnL3dlYmhvb2tzJykpLnJlc3VsdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBuZXcgdXNlciB3ZWJob29rXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBhc3luYyBhZGRXZWJob29rKHBhcmFtczogV2ViaG9va09wdGlvbnMpOiBQcm9taXNlPGFueT4ge1xuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudXJsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgdXJsJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy50eXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlZCBzdHJpbmcgdHlwZScpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBvc3QodGhpcy51cmwoJy93ZWJob29rcycpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHVzZXIgd2ViaG9va1xuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlV2ViaG9vayhwYXJhbXM6IFdlYmhvb2tPcHRpb25zKTogUHJvbWlzZTxhbnk+IHtcbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLnVybCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHVybCcpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwYXJhbXMudHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZWQgc3RyaW5nIHR5cGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kZWwodGhpcy51cmwoJy93ZWJob29rcycpKS5zZW5kKHBhcmFtcykucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggbGlzdCBvZiB3ZWJob29rIG5vdGlmaWNhdGlvbnMgZm9yIHRoZSB1c2VyXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBhc3luYyBsaXN0V2ViaG9va05vdGlmaWNhdGlvbnMocGFyYW1zOiBMaXN0V2ViaG9va05vdGlmaWNhdGlvbnNPcHRpb25zID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHF1ZXJ5OiBhbnkgPSB7fTtcbiAgICBpZiAocGFyYW1zLnByZXZJZCkge1xuICAgICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy5wcmV2SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcmV2SWQgYXJndW1lbnQsIGV4cGVjdGluZyBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5LnByZXZJZCA9IHBhcmFtcy5wcmV2SWQ7XG4gICAgfVxuICAgIGlmIChwYXJhbXMubGltaXQpIHtcbiAgICAgIGlmICghXy5pc051bWJlcihwYXJhbXMubGltaXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBsaW1pdCBhcmd1bWVudCwgZXhwZWN0aW5nIG51bWJlcicpO1xuICAgICAgfVxuICAgICAgcXVlcnkubGltaXQgPSBwYXJhbXMubGltaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMudXJsKCcvd2ViaG9va3Mvbm90aWZpY2F0aW9ucycpKS5xdWVyeShxdWVyeSkucmVzdWx0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB1c2VyIHdlYmhvb2tcbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGFzeW5jIHNpbXVsYXRlV2ViaG9vayhwYXJhbXM6IEJpdEdvU2ltdWxhdGVXZWJob29rT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgY29tbW9uLnZhbGlkYXRlUGFyYW1zKHBhcmFtcywgWyd3ZWJob29rSWQnLCAnYmxvY2tJZCddLCBbXSk7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHBhcmFtcy53ZWJob29rSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyB3ZWJob29rSWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocGFyYW1zLmJsb2NrSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVpcmVkIHN0cmluZyBibG9ja0lkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucG9zdCh0aGlzLnVybChgL3dlYmhvb2tzLyR7cGFyYW1zLndlYmhvb2tJZH0vc2ltdWxhdGVgKSlcbiAgICAgIC5zZW5kKHBhcmFtcylcbiAgICAgIC5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91c2x5IGdldCBjb25zdGFudHMgd2hpY2ggYXJlIHJlbGV2YW50IHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaGFzIGEga25vd24gcmFjZSBjb25kaXRpb24uIEl0IG1heSByZXR1cm4gZGlmZmVyZW50IHZhbHVlcyBvdmVyIHRpbWUsXG4gICAqIGVzcGVjaWFsbHkgaWYgY2FsbGVkIHNob3J0bHkgYWZ0ZXIgY3JlYXRpb24gb2YgdGhlIEJpdEdvIG9iamVjdC5cbiAgICpcbiAgICogTmV3IGNvZGUgc2hvdWxkIGNhbGwgZmV0Y2hDb25zdGFudHMoKSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbGllbnQgY29uc3RhbnRzIG9iamVjdFxuICAgKi9cbiAgZ2V0Q29uc3RhbnRzKCk6IGFueSB7XG4gICAgLy8ga2ljayBvZmYgYSBmcmVzaCByZXF1ZXN0IGZvciB0aGUgY2xpZW50IGNvbnN0YW50c1xuICAgIHRoaXMuZmV0Y2hDb25zdGFudHMoKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhbiBlcnJvciBkb2VzIG5vdCB0ZXJtaW5hdGUgdGhlIGVudGlyZSBzY3JpcHRcbiAgICAgICAgY29uc29sZS5lcnJvcignZmFpbGVkIHRvIGZldGNoIGNsaWVudCBjb25zdGFudHMgZnJvbSBCaXRHbycpO1xuICAgICAgICBjb25zb2xlLnRyYWNlKGVycik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB1c2UgZGVmYXVsdENvbnN0YW50cyBhcyB0aGUgYmFja3VwIGZvciBrZXlzIHRoYXQgYXJlIG5vdCBzZXQgaW4gdGhpcy5fY29uc3RhbnRzXG4gICAgcmV0dXJuIF8ubWVyZ2Uoe30sIGRlZmF1bHRDb25zdGFudHModGhpcy5nZXRFbnYoKSksIEJpdEdvQVBJLl9jb25zdGFudHNbdGhpcy5nZXRFbnYoKV0pO1xuICB9XG59XG4iXX0=