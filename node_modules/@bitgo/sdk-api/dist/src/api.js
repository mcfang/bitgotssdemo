"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyResponse = exports.setRequestQueryString = exports.serializeRequestData = exports.handleResponseError = exports.handleResponseResult = exports.toBitgoRequest = void 0;
/**
 * @prettier
 */
const debug_1 = require("debug");
const eol = require("eol");
const _ = require("lodash");
const sanitizeHtml = require("sanitize-html");
const superagent = require("superagent");
const urlLib = require("url");
const querystring = require("querystring");
const sdk_core_1 = require("@bitgo/sdk-core");
const debug = debug_1.default('bitgo:api');
/**
 * Add the bitgo-specific result() function on a superagent request.
 *
 * If the server response is successful, the `result()` function will return either the entire response body,
 * or the field from the response body specified by the `optionalField` parameter if it is provided.
 *
 * If the server response with an error, `result()` will handle HTTP errors appropriately by
 * rethrowing them as an `ApiResponseError` if possible, and otherwise rethrowing the underlying response error.
 *
 * @param req
 */
function toBitgoRequest(req) {
    return Object.assign(req, {
        result(optionalField) {
            return req.then((response) => handleResponseResult(optionalField)(response), (error) => handleResponseError(error));
        },
    });
}
exports.toBitgoRequest = toBitgoRequest;
/**
 * Return a function which extracts the specified response body property from the response if successful,
 * otherwise throw an `ApiErrorResponse` parsed from the response body.
 * @param optionalField
 */
function handleResponseResult(optionalField) {
    return function (res) {
        if (_.isNumber(res.status) && res.status >= 200 && res.status < 300) {
            return optionalField ? res.body[optionalField] : res.body;
        }
        throw errFromResponse(res);
    };
}
exports.handleResponseResult = handleResponseResult;
/**
 * Extract relevant information from a successful response (that is, a response with an HTTP status code
 * between 200 and 299), but which resulted in an application specific error and use it to construct and
 * throw an `ApiErrorResponse`.
 *
 * @param res
 */
function errFromResponse(res) {
    var _a;
    const message = createResponseErrorString(res);
    const status = res.status;
    const result = res.body;
    const invalidToken = _.has(res.header, 'x-auth-required') && res.header['x-auth-required'] === 'true';
    const needsOtp = ((_a = res.body) === null || _a === void 0 ? void 0 : _a.needsOTP) !== undefined;
    return new sdk_core_1.ApiResponseError(message, status, result, invalidToken, needsOtp);
}
/**
 * Handle an error or an error containing an HTTP response and use it to throw a well-formed error object.
 *
 * @param e
 */
function handleResponseError(e) {
    if (e.response) {
        throw errFromResponse(e.response);
    }
    throw e;
}
exports.handleResponseError = handleResponseError;
/**
 * There are many ways a request can fail, and may ways information on that failure can be
 * communicated to the client. This function tries to handle those cases and create a sane error string
 * @param res Response from an HTTP request
 */
function createResponseErrorString(res) {
    var _a;
    let errString = res.status.toString(); // at the very least we'll have the status code
    if ((_a = res.body) === null || _a === void 0 ? void 0 : _a.error) {
        // this is the case we hope for, where the server gives us a nice error from the JSON body
        errString = res.body.error;
    }
    else if (res.text) {
        // if the response came back as text, we try to parse it as HTML and remove all tags, leaving us
        // just the bare text, which we then trim of excessive newlines and limit to a certain length
        try {
            let sanitizedText = sanitizeHtml(res.text, { allowedTags: [] });
            sanitizedText = sanitizedText.trim();
            sanitizedText = eol.lf(sanitizedText); // use '\n' for all newlines
            sanitizedText = _.replace(sanitizedText, /\n[ |\t]{1,}\n/g, '\n\n'); // remove the spaces/tabs between newlines
            sanitizedText = _.replace(sanitizedText, /[\n]{3,}/g, '\n\n'); // have at most 2 consecutive newlines
            sanitizedText = sanitizedText.substring(0, 5000); // prevent message from getting too large
            errString = errString + '\n' + sanitizedText; // add it to our existing errString (at this point the more info the better!)
        }
        catch (e) {
            // do nothing, the response's HTML was too wacky to be parsed cleanly
            debug('got error with message "%s" while creating response error string from response: %s', e.message, res.text);
        }
    }
    return errString;
}
/**
 * Serialize request data based on the request content type
 * Note: Not sure this is still needed or even useful. Consider removing.
 * @param req
 */
function serializeRequestData(req) {
    let data = req._data;
    if (typeof data !== 'string') {
        let contentType = req.get('Content-Type');
        // Parse out just the content type from the header (ignore the charset)
        if (contentType) {
            contentType = contentType.split(';')[0];
        }
        let serialize = superagent.serialize[contentType];
        if (!serialize && /[\/+]json\b/.test(contentType)) {
            serialize = superagent.serialize['application/json'];
        }
        if (serialize) {
            data = serialize(data);
            req._data = data;
            return data;
        }
    }
}
exports.serializeRequestData = serializeRequestData;
/**
 * Set the superagent query string correctly for browsers or node.
 * @param req
 */
function setRequestQueryString(req) {
    const urlDetails = urlLib.parse(req.url);
    let queryString;
    const query = req._query;
    const qs = req.qs;
    if (query && query.length > 0) {
        // browser version
        queryString = query.join('&');
        req._query = [];
    }
    else if (qs) {
        // node version
        queryString = querystring.stringify(qs);
        req.qs = null;
    }
    if (queryString) {
        if (urlDetails.search) {
            urlDetails.search += '&' + queryString;
        }
        else {
            urlDetails.search = '?' + queryString;
        }
        req.url = urlLib.format(urlDetails);
    }
}
exports.setRequestQueryString = setRequestQueryString;
/**
 * Verify that the response received from the server is signed correctly.
 * Right now, it is very permissive with the timestamp variance.
 */
function verifyResponse(bitgo, token, method, req, response) {
    // we can't verify the response if we're not authenticated
    if (!req.isV2Authenticated || !req.authenticationToken) {
        return response;
    }
    const verificationResponse = bitgo.verifyResponse({
        url: req.url,
        hmac: response.header.hmac,
        statusCode: response.status,
        text: response.text,
        timestamp: response.header.timestamp,
        token: req.authenticationToken,
        method,
    });
    if (!verificationResponse.isValid) {
        // calculate the HMAC
        const receivedHmac = response.header.hmac;
        const expectedHmac = verificationResponse.expectedHmac;
        const signatureSubject = verificationResponse.signatureSubject;
        // Log only the first 10 characters of the token to ensure the full token isn't logged.
        const partialBitgoToken = token ? token.substring(0, 10) : '';
        const errorDetails = {
            expectedHmac,
            receivedHmac,
            hmacInput: signatureSubject,
            requestToken: req.authenticationToken,
            bitgoToken: partialBitgoToken,
        };
        debug('Invalid response HMAC: %O', errorDetails);
        throw new sdk_core_1.ApiResponseError('invalid response HMAC, possible man-in-the-middle-attack', 511, errorDetails);
    }
    if (bitgo.getAuthVersion() === 3 && !verificationResponse.isInResponseValidityWindow) {
        const errorDetails = {
            timestamp: response.header.timestamp,
            verificationTime: verificationResponse.verificationTime,
        };
        debug('Server response outside response validity time window: %O', errorDetails);
        throw new sdk_core_1.ApiResponseError('server response outside response validity time window, possible man-in-the-middle-attack', 511, errorDetails);
    }
    return response;
}
exports.verifyResponse = verifyResponse;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2FwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQTs7R0FFRztBQUNILGlDQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLDhDQUE4QztBQUM5Qyx5Q0FBeUM7QUFDekMsOEJBQThCO0FBQzlCLDJDQUEyQztBQUUzQyw4Q0FBaUU7QUFLakUsTUFBTSxLQUFLLEdBQUcsZUFBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBRWpDOzs7Ozs7Ozs7O0dBVUc7QUFDSCxTQUFnQixjQUFjLENBQzVCLEdBQWlDO0lBRWpDLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUU7UUFDeEIsTUFBTSxDQUFDLGFBQXNCO1lBQzNCLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FDYixDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsb0JBQW9CLENBQXFCLGFBQWEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUMvRSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQ3RDLENBQUM7UUFDSixDQUFDO0tBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQVhELHdDQVdDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLG9CQUFvQixDQUNsQyxhQUFzQjtJQUV0QixPQUFPLFVBQVUsR0FBd0I7UUFDdkMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxHQUFHLENBQUMsTUFBTSxJQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLEdBQUcsRUFBRTtZQUNuRSxPQUFPLGFBQWEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztTQUMzRDtRQUNELE1BQU0sZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzdC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RkFBdUY7UUFDdkYsTUFBTSxpQkFBaUIsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7UUFDOUQsTUFBTSxZQUFZLEdBQUc7WUFDbkIsWUFBWTtZQUNaLFlBQVk7WUFDWixTQUFTLEVBQUUsZ0JBQWdCO1lBQzNCLFlBQVksRUFBRSxHQUFHLENBQUMsbUJBQW1CO1lBQ3JDLFVBQVUsRUFBRSxpQkFBaUI7U0FDOUIsQ0FBQztRQUNGLEtBQUssQ0FBQywyQkFBMkIsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNqRCxNQUFNLElBQUksMkJBQWdCLENBQUMsMERBQTBELEVBQUUsR0FBRyxFQUFFLFlBQVksQ0FBQyxDQUFDO0tBQzNHO0lBRUQsSUFBSSxLQUFLLENBQUMsY0FBYyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsMEJBQTBCLEVBQUU7UUFDcEYsTUFBTSxZQUFZLEdBQUc7WUFDbkIsU0FBUyxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsU0FBUztZQUNwQyxnQkFBZ0IsRUFBRSxvQkFBb0IsQ0FBQyxnQkFBZ0I7U0FDeEQsQ0FBQztRQUNGLEtBQUssQ0FBQywyREFBMkQsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUNqRixNQUFNLElBQUksMkJBQWdCLENBQ3hCLDBGQUEwRixFQUMxRixHQUFHLEVBQ0gsWUFBWSxDQUNiLENBQUM7S0FDSDtJQUNELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUFyREQsd0NBcURDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0IERlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCAqIGFzIGVvbCBmcm9tICdlb2wnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgc2FuaXRpemVIdG1sIGZyb20gJ3Nhbml0aXplLWh0bWwnO1xuaW1wb3J0ICogYXMgc3VwZXJhZ2VudCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIHVybExpYiBmcm9tICd1cmwnO1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuXG5pbXBvcnQgeyBBcGlSZXNwb25zZUVycm9yLCBCaXRHb1JlcXVlc3QgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuXG5pbXBvcnQgeyBWZXJpZnlSZXNwb25zZU9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IEJpdEdvQVBJIH0gZnJvbSAnLi9iaXRnb0FQSSc7XG5cbmNvbnN0IGRlYnVnID0gRGVidWcoJ2JpdGdvOmFwaScpO1xuXG4vKipcbiAqIEFkZCB0aGUgYml0Z28tc3BlY2lmaWMgcmVzdWx0KCkgZnVuY3Rpb24gb24gYSBzdXBlcmFnZW50IHJlcXVlc3QuXG4gKlxuICogSWYgdGhlIHNlcnZlciByZXNwb25zZSBpcyBzdWNjZXNzZnVsLCB0aGUgYHJlc3VsdCgpYCBmdW5jdGlvbiB3aWxsIHJldHVybiBlaXRoZXIgdGhlIGVudGlyZSByZXNwb25zZSBib2R5LFxuICogb3IgdGhlIGZpZWxkIGZyb20gdGhlIHJlc3BvbnNlIGJvZHkgc3BlY2lmaWVkIGJ5IHRoZSBgb3B0aW9uYWxGaWVsZGAgcGFyYW1ldGVyIGlmIGl0IGlzIHByb3ZpZGVkLlxuICpcbiAqIElmIHRoZSBzZXJ2ZXIgcmVzcG9uc2Ugd2l0aCBhbiBlcnJvciwgYHJlc3VsdCgpYCB3aWxsIGhhbmRsZSBIVFRQIGVycm9ycyBhcHByb3ByaWF0ZWx5IGJ5XG4gKiByZXRocm93aW5nIHRoZW0gYXMgYW4gYEFwaVJlc3BvbnNlRXJyb3JgIGlmIHBvc3NpYmxlLCBhbmQgb3RoZXJ3aXNlIHJldGhyb3dpbmcgdGhlIHVuZGVybHlpbmcgcmVzcG9uc2UgZXJyb3IuXG4gKlxuICogQHBhcmFtIHJlcVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaXRnb1JlcXVlc3Q8UmVzcG9uc2VSZXN1bHRUeXBlID0gYW55PihcbiAgcmVxOiBzdXBlcmFnZW50LlN1cGVyQWdlbnRSZXF1ZXN0XG4pOiBCaXRHb1JlcXVlc3Q8UmVzcG9uc2VSZXN1bHRUeXBlPiB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHJlcSwge1xuICAgIHJlc3VsdChvcHRpb25hbEZpZWxkPzogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gcmVxLnRoZW4oXG4gICAgICAgIChyZXNwb25zZSkgPT4gaGFuZGxlUmVzcG9uc2VSZXN1bHQ8UmVzcG9uc2VSZXN1bHRUeXBlPihvcHRpb25hbEZpZWxkKShyZXNwb25zZSksXG4gICAgICAgIChlcnJvcikgPT4gaGFuZGxlUmVzcG9uc2VFcnJvcihlcnJvcilcbiAgICAgICk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggZXh0cmFjdHMgdGhlIHNwZWNpZmllZCByZXNwb25zZSBib2R5IHByb3BlcnR5IGZyb20gdGhlIHJlc3BvbnNlIGlmIHN1Y2Nlc3NmdWwsXG4gKiBvdGhlcndpc2UgdGhyb3cgYW4gYEFwaUVycm9yUmVzcG9uc2VgIHBhcnNlZCBmcm9tIHRoZSByZXNwb25zZSBib2R5LlxuICogQHBhcmFtIG9wdGlvbmFsRmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlUmVzdWx0PFJlc3BvbnNlUmVzdWx0VHlwZT4oXG4gIG9wdGlvbmFsRmllbGQ/OiBzdHJpbmdcbik6IChyZXM6IHN1cGVyYWdlbnQuUmVzcG9uc2UpID0+IFJlc3BvbnNlUmVzdWx0VHlwZSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzOiBzdXBlcmFnZW50LlJlc3BvbnNlKTogUmVzcG9uc2VSZXN1bHRUeXBlIHtcbiAgICBpZiAoXy5pc051bWJlcihyZXMuc3RhdHVzKSAmJiByZXMuc3RhdHVzID49IDIwMCAmJiByZXMuc3RhdHVzIDwgMzAwKSB7XG4gICAgICByZXR1cm4gb3B0aW9uYWxGaWVsZCA/IHJlcy5ib2R5W29wdGlvbmFsRmllbGRdIDogcmVzLmJvZHk7XG4gICAgfVxuICAgIHRocm93IGVyckZyb21SZXNwb25zZShyZXMpO1xuICB9O1xufVxuXG4vKipcbiAqIEV4dHJhY3QgcmVsZXZhbnQgaW5mb3JtYXRpb24gZnJvbSBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgKHRoYXQgaXMsIGEgcmVzcG9uc2Ugd2l0aCBhbiBIVFRQIHN0YXR1cyBjb2RlXG4gKiBiZXR3ZWVuIDIwMCBhbmQgMjk5KSwgYnV0IHdoaWNoIHJlc3VsdGVkIGluIGFuIGFwcGxpY2F0aW9uIHNwZWNpZmljIGVycm9yIGFuZCB1c2UgaXQgdG8gY29uc3RydWN0IGFuZFxuICogdGhyb3cgYW4gYEFwaUVycm9yUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSByZXNcbiAqL1xuZnVuY3Rpb24gZXJyRnJvbVJlc3BvbnNlPFJlc3BvbnNlQm9keVR5cGU+KHJlczogc3VwZXJhZ2VudC5SZXNwb25zZSk6IEFwaVJlc3BvbnNlRXJyb3Ige1xuICBjb25zdCBtZXNzYWdlID0gY3JlYXRlUmVzcG9uc2VFcnJvclN0cmluZyhyZXMpO1xuICBjb25zdCBzdGF0dXMgPSByZXMuc3RhdHVzO1xuICBjb25zdCByZXN1bHQgPSByZXMuYm9keSBhcyBSZXNwb25zZUJvZHlUeXBlO1xuICBjb25zdCBpbnZhbGlkVG9rZW4gPSBfLmhhcyhyZXMuaGVhZGVyLCAneC1hdXRoLXJlcXVpcmVkJykgJiYgcmVzLmhlYWRlclsneC1hdXRoLXJlcXVpcmVkJ10gPT09ICd0cnVlJztcbiAgY29uc3QgbmVlZHNPdHAgPSByZXMuYm9keT8ubmVlZHNPVFAgIT09IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG5ldyBBcGlSZXNwb25zZUVycm9yKG1lc3NhZ2UsIHN0YXR1cywgcmVzdWx0LCBpbnZhbGlkVG9rZW4sIG5lZWRzT3RwKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgYW4gZXJyb3Igb3IgYW4gZXJyb3IgY29udGFpbmluZyBhbiBIVFRQIHJlc3BvbnNlIGFuZCB1c2UgaXQgdG8gdGhyb3cgYSB3ZWxsLWZvcm1lZCBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlRXJyb3IoZTogRXJyb3IgJiB7IHJlc3BvbnNlPzogc3VwZXJhZ2VudC5SZXNwb25zZSB9KTogbmV2ZXIge1xuICBpZiAoZS5yZXNwb25zZSkge1xuICAgIHRocm93IGVyckZyb21SZXNwb25zZShlLnJlc3BvbnNlKTtcbiAgfVxuICB0aHJvdyBlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSBtYW55IHdheXMgYSByZXF1ZXN0IGNhbiBmYWlsLCBhbmQgbWF5IHdheXMgaW5mb3JtYXRpb24gb24gdGhhdCBmYWlsdXJlIGNhbiBiZVxuICogY29tbXVuaWNhdGVkIHRvIHRoZSBjbGllbnQuIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gaGFuZGxlIHRob3NlIGNhc2VzIGFuZCBjcmVhdGUgYSBzYW5lIGVycm9yIHN0cmluZ1xuICogQHBhcmFtIHJlcyBSZXNwb25zZSBmcm9tIGFuIEhUVFAgcmVxdWVzdFxuICovXG5mdW5jdGlvbiBjcmVhdGVSZXNwb25zZUVycm9yU3RyaW5nKHJlczogc3VwZXJhZ2VudC5SZXNwb25zZSk6IHN0cmluZyB7XG4gIGxldCBlcnJTdHJpbmcgPSByZXMuc3RhdHVzLnRvU3RyaW5nKCk7IC8vIGF0IHRoZSB2ZXJ5IGxlYXN0IHdlJ2xsIGhhdmUgdGhlIHN0YXR1cyBjb2RlXG4gIGlmIChyZXMuYm9keT8uZXJyb3IpIHtcbiAgICAvLyB0aGlzIGlzIHRoZSBjYXNlIHdlIGhvcGUgZm9yLCB3aGVyZSB0aGUgc2VydmVyIGdpdmVzIHVzIGEgbmljZSBlcnJvciBmcm9tIHRoZSBKU09OIGJvZHlcbiAgICBlcnJTdHJpbmcgPSByZXMuYm9keS5lcnJvcjtcbiAgfSBlbHNlIGlmIChyZXMudGV4dCkge1xuICAgIC8vIGlmIHRoZSByZXNwb25zZSBjYW1lIGJhY2sgYXMgdGV4dCwgd2UgdHJ5IHRvIHBhcnNlIGl0IGFzIEhUTUwgYW5kIHJlbW92ZSBhbGwgdGFncywgbGVhdmluZyB1c1xuICAgIC8vIGp1c3QgdGhlIGJhcmUgdGV4dCwgd2hpY2ggd2UgdGhlbiB0cmltIG9mIGV4Y2Vzc2l2ZSBuZXdsaW5lcyBhbmQgbGltaXQgdG8gYSBjZXJ0YWluIGxlbmd0aFxuICAgIHRyeSB7XG4gICAgICBsZXQgc2FuaXRpemVkVGV4dCA9IHNhbml0aXplSHRtbChyZXMudGV4dCwgeyBhbGxvd2VkVGFnczogW10gfSk7XG4gICAgICBzYW5pdGl6ZWRUZXh0ID0gc2FuaXRpemVkVGV4dC50cmltKCk7XG4gICAgICBzYW5pdGl6ZWRUZXh0ID0gZW9sLmxmKHNhbml0aXplZFRleHQpOyAvLyB1c2UgJ1xcbicgZm9yIGFsbCBuZXdsaW5lc1xuICAgICAgc2FuaXRpemVkVGV4dCA9IF8ucmVwbGFjZShzYW5pdGl6ZWRUZXh0LCAvXFxuWyB8XFx0XXsxLH1cXG4vZywgJ1xcblxcbicpOyAvLyByZW1vdmUgdGhlIHNwYWNlcy90YWJzIGJldHdlZW4gbmV3bGluZXNcbiAgICAgIHNhbml0aXplZFRleHQgPSBfLnJlcGxhY2Uoc2FuaXRpemVkVGV4dCwgL1tcXG5dezMsfS9nLCAnXFxuXFxuJyk7IC8vIGhhdmUgYXQgbW9zdCAyIGNvbnNlY3V0aXZlIG5ld2xpbmVzXG4gICAgICBzYW5pdGl6ZWRUZXh0ID0gc2FuaXRpemVkVGV4dC5zdWJzdHJpbmcoMCwgNTAwMCk7IC8vIHByZXZlbnQgbWVzc2FnZSBmcm9tIGdldHRpbmcgdG9vIGxhcmdlXG4gICAgICBlcnJTdHJpbmcgPSBlcnJTdHJpbmcgKyAnXFxuJyArIHNhbml0aXplZFRleHQ7IC8vIGFkZCBpdCB0byBvdXIgZXhpc3RpbmcgZXJyU3RyaW5nIChhdCB0aGlzIHBvaW50IHRoZSBtb3JlIGluZm8gdGhlIGJldHRlciEpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZG8gbm90aGluZywgdGhlIHJlc3BvbnNlJ3MgSFRNTCB3YXMgdG9vIHdhY2t5IHRvIGJlIHBhcnNlZCBjbGVhbmx5XG4gICAgICBkZWJ1ZygnZ290IGVycm9yIHdpdGggbWVzc2FnZSBcIiVzXCIgd2hpbGUgY3JlYXRpbmcgcmVzcG9uc2UgZXJyb3Igc3RyaW5nIGZyb20gcmVzcG9uc2U6ICVzJywgZS5tZXNzYWdlLCByZXMudGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVyclN0cmluZztcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgcmVxdWVzdCBkYXRhIGJhc2VkIG9uIHRoZSByZXF1ZXN0IGNvbnRlbnQgdHlwZVxuICogTm90ZTogTm90IHN1cmUgdGhpcyBpcyBzdGlsbCBuZWVkZWQgb3IgZXZlbiB1c2VmdWwuIENvbnNpZGVyIHJlbW92aW5nLlxuICogQHBhcmFtIHJlcVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplUmVxdWVzdERhdGEocmVxOiBzdXBlcmFnZW50LlJlcXVlc3QpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBsZXQgZGF0YTogc3RyaW5nIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSAocmVxIGFzIGFueSkuX2RhdGE7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICBsZXQgY29udGVudFR5cGUgPSByZXEuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICAvLyBQYXJzZSBvdXQganVzdCB0aGUgY29udGVudCB0eXBlIGZyb20gdGhlIGhlYWRlciAoaWdub3JlIHRoZSBjaGFyc2V0KVxuICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZS5zcGxpdCgnOycpWzBdO1xuICAgIH1cbiAgICBsZXQgc2VyaWFsaXplID0gc3VwZXJhZ2VudC5zZXJpYWxpemVbY29udGVudFR5cGVdO1xuICAgIGlmICghc2VyaWFsaXplICYmIC9bXFwvK11qc29uXFxiLy50ZXN0KGNvbnRlbnRUeXBlKSkge1xuICAgICAgc2VyaWFsaXplID0gc3VwZXJhZ2VudC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZSkge1xuICAgICAgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgICAgIChyZXEgYXMgYW55KS5fZGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN1cGVyYWdlbnQgcXVlcnkgc3RyaW5nIGNvcnJlY3RseSBmb3IgYnJvd3NlcnMgb3Igbm9kZS5cbiAqIEBwYXJhbSByZXFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFJlcXVlc3RRdWVyeVN0cmluZyhyZXE6IHN1cGVyYWdlbnQuU3VwZXJBZ2VudFJlcXVlc3QpOiB2b2lkIHtcbiAgY29uc3QgdXJsRGV0YWlscyA9IHVybExpYi5wYXJzZShyZXEudXJsKTtcblxuICBsZXQgcXVlcnlTdHJpbmc6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgY29uc3QgcXVlcnk6IHN0cmluZ1tdID0gKHJlcSBhcyBhbnkpLl9xdWVyeTtcbiAgY29uc3QgcXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSAocmVxIGFzIGFueSkucXM7XG4gIGlmIChxdWVyeSAmJiBxdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgLy8gYnJvd3NlciB2ZXJzaW9uXG4gICAgcXVlcnlTdHJpbmcgPSBxdWVyeS5qb2luKCcmJyk7XG4gICAgKHJlcSBhcyBhbnkpLl9xdWVyeSA9IFtdO1xuICB9IGVsc2UgaWYgKHFzKSB7XG4gICAgLy8gbm9kZSB2ZXJzaW9uXG4gICAgcXVlcnlTdHJpbmcgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkocXMpO1xuICAgIChyZXEgYXMgYW55KS5xcyA9IG51bGw7XG4gIH1cblxuICBpZiAocXVlcnlTdHJpbmcpIHtcbiAgICBpZiAodXJsRGV0YWlscy5zZWFyY2gpIHtcbiAgICAgIHVybERldGFpbHMuc2VhcmNoICs9ICcmJyArIHF1ZXJ5U3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cmxEZXRhaWxzLnNlYXJjaCA9ICc/JyArIHF1ZXJ5U3RyaW5nO1xuICAgIH1cbiAgICByZXEudXJsID0gdXJsTGliLmZvcm1hdCh1cmxEZXRhaWxzKTtcbiAgfVxufVxuXG4vKipcbiAqIFZlcmlmeSB0aGF0IHRoZSByZXNwb25zZSByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgaXMgc2lnbmVkIGNvcnJlY3RseS5cbiAqIFJpZ2h0IG5vdywgaXQgaXMgdmVyeSBwZXJtaXNzaXZlIHdpdGggdGhlIHRpbWVzdGFtcCB2YXJpYW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVJlc3BvbnNlKFxuICBiaXRnbzogQml0R29BUEksXG4gIHRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gIG1ldGhvZDogVmVyaWZ5UmVzcG9uc2VPcHRpb25zWydtZXRob2QnXSxcbiAgcmVxOiBzdXBlcmFnZW50LlN1cGVyQWdlbnRSZXF1ZXN0LFxuICByZXNwb25zZTogc3VwZXJhZ2VudC5SZXNwb25zZVxuKTogc3VwZXJhZ2VudC5SZXNwb25zZSB7XG4gIC8vIHdlIGNhbid0IHZlcmlmeSB0aGUgcmVzcG9uc2UgaWYgd2UncmUgbm90IGF1dGhlbnRpY2F0ZWRcbiAgaWYgKCFyZXEuaXNWMkF1dGhlbnRpY2F0ZWQgfHwgIXJlcS5hdXRoZW50aWNhdGlvblRva2VuKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbiAgY29uc3QgdmVyaWZpY2F0aW9uUmVzcG9uc2UgPSBiaXRnby52ZXJpZnlSZXNwb25zZSh7XG4gICAgdXJsOiByZXEudXJsLFxuICAgIGhtYWM6IHJlc3BvbnNlLmhlYWRlci5obWFjLFxuICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICB0ZXh0OiByZXNwb25zZS50ZXh0LFxuICAgIHRpbWVzdGFtcDogcmVzcG9uc2UuaGVhZGVyLnRpbWVzdGFtcCxcbiAgICB0b2tlbjogcmVxLmF1dGhlbnRpY2F0aW9uVG9rZW4sXG4gICAgbWV0aG9kLFxuICB9KTtcblxuICBpZiAoIXZlcmlmaWNhdGlvblJlc3BvbnNlLmlzVmFsaWQpIHtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIEhNQUNcbiAgICBjb25zdCByZWNlaXZlZEhtYWMgPSByZXNwb25zZS5oZWFkZXIuaG1hYztcbiAgICBjb25zdCBleHBlY3RlZEhtYWMgPSB2ZXJpZmljYXRpb25SZXNwb25zZS5leHBlY3RlZEhtYWM7XG4gICAgY29uc3Qgc2lnbmF0dXJlU3ViamVjdCA9IHZlcmlmaWNhdGlvblJlc3BvbnNlLnNpZ25hdHVyZVN1YmplY3Q7XG4gICAgLy8gTG9nIG9ubHkgdGhlIGZpcnN0IDEwIGNoYXJhY3RlcnMgb2YgdGhlIHRva2VuIHRvIGVuc3VyZSB0aGUgZnVsbCB0b2tlbiBpc24ndCBsb2dnZWQuXG4gICAgY29uc3QgcGFydGlhbEJpdGdvVG9rZW4gPSB0b2tlbiA/IHRva2VuLnN1YnN0cmluZygwLCAxMCkgOiAnJztcbiAgICBjb25zdCBlcnJvckRldGFpbHMgPSB7XG4gICAgICBleHBlY3RlZEhtYWMsXG4gICAgICByZWNlaXZlZEhtYWMsXG4gICAgICBobWFjSW5wdXQ6IHNpZ25hdHVyZVN1YmplY3QsXG4gICAgICByZXF1ZXN0VG9rZW46IHJlcS5hdXRoZW50aWNhdGlvblRva2VuLFxuICAgICAgYml0Z29Ub2tlbjogcGFydGlhbEJpdGdvVG9rZW4sXG4gICAgfTtcbiAgICBkZWJ1ZygnSW52YWxpZCByZXNwb25zZSBITUFDOiAlTycsIGVycm9yRGV0YWlscyk7XG4gICAgdGhyb3cgbmV3IEFwaVJlc3BvbnNlRXJyb3IoJ2ludmFsaWQgcmVzcG9uc2UgSE1BQywgcG9zc2libGUgbWFuLWluLXRoZS1taWRkbGUtYXR0YWNrJywgNTExLCBlcnJvckRldGFpbHMpO1xuICB9XG5cbiAgaWYgKGJpdGdvLmdldEF1dGhWZXJzaW9uKCkgPT09IDMgJiYgIXZlcmlmaWNhdGlvblJlc3BvbnNlLmlzSW5SZXNwb25zZVZhbGlkaXR5V2luZG93KSB7XG4gICAgY29uc3QgZXJyb3JEZXRhaWxzID0ge1xuICAgICAgdGltZXN0YW1wOiByZXNwb25zZS5oZWFkZXIudGltZXN0YW1wLFxuICAgICAgdmVyaWZpY2F0aW9uVGltZTogdmVyaWZpY2F0aW9uUmVzcG9uc2UudmVyaWZpY2F0aW9uVGltZSxcbiAgICB9O1xuICAgIGRlYnVnKCdTZXJ2ZXIgcmVzcG9uc2Ugb3V0c2lkZSByZXNwb25zZSB2YWxpZGl0eSB0aW1lIHdpbmRvdzogJU8nLCBlcnJvckRldGFpbHMpO1xuICAgIHRocm93IG5ldyBBcGlSZXNwb25zZUVycm9yKFxuICAgICAgJ3NlcnZlciByZXNwb25zZSBvdXRzaWRlIHJlc3BvbnNlIHZhbGlkaXR5IHRpbWUgd2luZG93LCBwb3NzaWJsZSBtYW4taW4tdGhlLW1pZGRsZS1hdHRhY2snLFxuICAgICAgNTExLFxuICAgICAgZXJyb3JEZXRhaWxzXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzcG9uc2U7XG59XG4iXX0=