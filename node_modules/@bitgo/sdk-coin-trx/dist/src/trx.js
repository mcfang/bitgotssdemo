"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Trx = exports.NodeTypes = exports.TOKEN_CONTRACT_ADDRESSES = exports.DEFAULT_SCAN_FACTOR = exports.RECOVER_TRANSACTION_EXPIRY = exports.SAFE_TRON_TOKEN_TRANSACTION_FEE = exports.SAFE_TRON_TRANSACTION_FEE = exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE = void 0;
/**
 * @prettier
 */
const secp256k1 = __importStar(require("secp256k1"));
const crypto_1 = require("crypto");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const request = __importStar(require("superagent"));
const sdk_core_1 = require("@bitgo/sdk-core");
const lib_1 = require("./lib");
const builder_1 = require("./lib/builder");
const lodash_1 = require("lodash");
exports.MINIMUM_TRON_MSIG_TRANSACTION_FEE = 1e6;
exports.SAFE_TRON_TRANSACTION_FEE = 2.1 * 1e6; // TRON foundation recommends 2.1 TRX as fees for guaranteed transaction
exports.SAFE_TRON_TOKEN_TRANSACTION_FEE = 100 * 1e6; // TRON foundation recommends 100 TRX as fees for guaranteed transaction
exports.RECOVER_TRANSACTION_EXPIRY = 86400000; // 24 hour
exports.DEFAULT_SCAN_FACTOR = 20; // default number of receive addresses to scan for funds
exports.TOKEN_CONTRACT_ADDRESSES = [
    // mainnet tokens
    'TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8',
    'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
    // testnet tokens
    'TSdZwNqpHofzP6BsBKGQUWdBeJphLmF6id',
    'TG3XXyExBkPp9nzdajDZsozEu4BkaSJozs',
];
var NodeTypes;
(function (NodeTypes) {
    NodeTypes[NodeTypes["Full"] = 0] = "Full";
    NodeTypes[NodeTypes["Solidity"] = 1] = "Solidity";
})(NodeTypes = exports.NodeTypes || (exports.NodeTypes = {}));
class Trx extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    /** @inheritdoc */
    transactionDataAllowed() {
        return true;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Trx(bitgo, staticsCoin);
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
    /** @inheritDoc */
    allowsAccountConsolidations() {
        return true;
    }
    /**
     * Checks if this is a valid base58 or hex address
     * @param address
     */
    isValidAddress(address) {
        if (!address) {
            return false;
        }
        return this.isValidHexAddress(address) || lib_1.Utils.isBase58Address(address);
    }
    /**
     * Checks if this is a valid hex address
     * @param address hex address
     */
    isValidHexAddress(address) {
        return /^41[0-9a-f]{40}$/i.test(address);
    }
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed) {
        // TODO: move this and address creation logic to account-lib
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256 bit chain code, both of which must be
            // random. 512 bits is therefore the maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        const hd = utxo_lib_1.bip32.fromSeed(seed);
        return {
            pub: hd.neutered().toBase58(),
            prv: hd.toBase58(),
        };
    }
    isValidXpub(xpub) {
        try {
            return utxo_lib_1.bip32.fromBase58(xpub).isNeutered();
        }
        catch (e) {
            return false;
        }
    }
    isValidPub(pub) {
        if (this.isValidXpub(pub)) {
            // xpubs can be converted into regular pubs, so technically it is a valid pub
            return true;
        }
        return new RegExp('^04[a-zA-Z0-9]{128}$').test(pub);
    }
    async parseTransaction(params) {
        return {};
    }
    async isWalletAddress(params) {
        throw new sdk_core_1.MethodNotImplementedError();
    }
    async verifyTransaction(params) {
        return true;
    }
    /**
     * Derive a user key using the chain path of the address
     * @param key
     * @param path
     * @returns {string} derived private key
     */
    deriveKeyWithPath({ key, path }) {
        const keychain = utxo_lib_1.bip32.fromBase58(key);
        const derivedKeyNode = keychain.derivePath(path);
        return derivedKeyNode.toBase58();
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param params.wallet.addressVersion {String} this is the version of the Algorand multisig address generation format
     * @returns Bluebird<SignedTransaction>
     */
    async signTransaction(params) {
        var _a, _b;
        const txBuilder = builder_1.getBuilder(this.getChain()).from(params.txPrebuild.txHex);
        let key;
        const { chain, index } = (_b = (_a = params.txPrebuild) === null || _a === void 0 ? void 0 : _a.addressInfo) !== null && _b !== void 0 ? _b : { chain: 0, index: 0 };
        if (chain === 0 && index === 0) {
            key = params.prv;
        }
        else {
            const derivationPath = `0/0/${chain}/${index}`;
            key = this.deriveKeyWithPath({ key: params.prv, path: derivationPath });
        }
        txBuilder.sign({ key });
        const transaction = await txBuilder.build();
        const response = {
            txHex: JSON.stringify(transaction.toJson()),
        };
        if (transaction.toJson().signature.length >= 2) {
            return response;
        }
        // Half signed transaction
        return {
            halfSigned: response,
        };
    }
    /**
     * Return boolean indicating whether input is valid seed for the coin
     *
     * @param prv - the prv to be checked
     */
    isValidXprv(prv) {
        try {
            return !utxo_lib_1.bip32.fromBase58(prv).isNeutered();
        }
        catch {
            return false;
        }
    }
    /**
     * Convert a message to string in hexadecimal format.
     *
     * @param message {Buffer|String} message to sign
     * @return the message as a hexadecimal string
     */
    toHexString(message) {
        if (typeof message === 'string') {
            return Buffer.from(message).toString('hex');
        }
        else if (Buffer.isBuffer(message)) {
            return message.toString('hex');
        }
        else {
            throw new Error('Invalid messaged passed to signMessage');
        }
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        var _a;
        const toSign = this.toHexString(message);
        let prv = key.prv;
        if (this.isValidXprv(prv)) {
            prv = (_a = utxo_lib_1.bip32.fromBase58(prv).privateKey) === null || _a === void 0 ? void 0 : _a.toString('hex');
        }
        if (!prv) {
            throw new Error('no privateKey');
        }
        let sig = lib_1.Utils.signString(toSign, prv, true);
        // remove the preceding 0x
        sig = sig.replace(/^0x/, '');
        return Buffer.from(sig, 'hex');
    }
    /**
     * Converts an xpub to a uncompressed pub
     * @param xpub
     */
    xpubToUncompressedPub(xpub) {
        if (!this.isValidXpub(xpub)) {
            throw new Error('invalid xpub');
        }
        const publicKey = utxo_lib_1.bip32.fromBase58(xpub, utxo_lib_1.networks.bitcoin).publicKey;
        return Buffer.from(secp256k1.publicKeyConvert(publicKey, false /* compressed */)).toString('hex');
    }
    /**
     * Modify prebuild before sending it to the server.
     * @param buildParams The whitelisted parameters for this prebuild
     */
    async getExtraPrebuildParams(buildParams) {
        if (buildParams.recipients[0].data && buildParams.feeLimit) {
            buildParams.recipients[0].feeLimit = buildParams.feeLimit;
        }
    }
    pubToHexAddress(pub) {
        const byteArrayAddr = lib_1.Utils.getByteArrayFromHexAddress(pub);
        const rawAddress = lib_1.Utils.getRawAddressFromPubKey(byteArrayAddr);
        return lib_1.Utils.getHexAddressFromByteArray(rawAddress);
    }
    xprvToCompressedPrv(xprv) {
        if (!this.isValidXprv(xprv)) {
            throw new Error('invalid xprv');
        }
        const hdNode = utxo_lib_1.bip32.fromBase58(xprv, utxo_lib_1.networks.bitcoin);
        if (!hdNode.privateKey) {
            throw new Error('no privateKey');
        }
        return hdNode.privateKey.toString('hex');
    }
    getNodeUrl(node) {
        switch (node) {
            case NodeTypes.Full:
                return sdk_core_1.common.Environments[this.bitgo.getEnv()].tronNodes.full;
            case NodeTypes.Solidity:
                return sdk_core_1.common.Environments[this.bitgo.getEnv()].tronNodes.solidity;
            default:
                throw new Error('node type not found');
        }
    }
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Trongrid
     */
    async recoveryPost(query) {
        const nodeUri = this.getNodeUrl(query.node);
        const response = await request
            .post(nodeUri + query.path)
            .type('json')
            .send(query.jsonObj);
        if (!response.ok) {
            throw new Error('could not reach Tron node');
        }
        // unfortunately, it doesn't look like most TRON nodes return valid json as body
        return JSON.parse(response.text);
    }
    /**
     * Make a query to Trongrid for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Trongrid
     */
    async recoveryGet(query) {
        const nodeUri = this.getNodeUrl(query.node);
        const response = await request
            .get(nodeUri + query.path)
            .type('json')
            .send(query.jsonObj);
        if (!response.ok) {
            throw new Error('could not reach Tron node');
        }
        // unfortunately, it doesn't look like most TRON nodes return valid json as body
        return JSON.parse(response.text);
    }
    /**
     * Query our explorer for the balance of an address
     * @param address {String} the address encoded in hex
     * @returns {BigNumber} address balance
     */
    async getAccountBalancesFromNode(address) {
        return await this.recoveryGet({
            path: '/v1/accounts/' + address,
            jsonObj: {},
            node: NodeTypes.Full,
        });
    }
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     */
    async getBuildTransaction(toAddr, fromAddr, amount) {
        // our addresses should be base58, we'll have to encode to hex
        return await this.recoveryPost({
            path: '/wallet/createtransaction',
            jsonObj: {
                to_address: toAddr,
                owner_address: fromAddr,
                amount,
            },
            node: NodeTypes.Full,
        });
    }
    /**
     * Retrieves our build transaction from a node.
     * @param toAddr hex-encoded address
     * @param fromAddr hex-encoded address
     * @param amount
     */
    async getTriggerSmartContractTransaction(toAddr, fromAddr, amount, contractAddr) {
        const functionSelector = 'transfer(address,uint256)';
        const types = ['address', 'uint256'];
        const values = [toAddr, amount];
        const parameter = lib_1.Utils.encodeDataParams(types, values, '');
        return await this.recoveryPost({
            path: '/wallet/triggersmartcontract',
            jsonObj: {
                owner_address: fromAddr,
                contract_address: contractAddr,
                function_selector: functionSelector,
                parameter: parameter,
                fee_limit: 100000000,
            },
            node: NodeTypes.Full,
        });
    }
    /**
     * Throws an error if any keys in the ownerKeys collection don't match the keys array we pass
     * @param ownerKeys
     * @param keys
     */
    checkPermissions(ownerKeys, keys) {
        keys = keys.map((k) => k.toUpperCase());
        ownerKeys.map((key) => {
            const hexKey = key.address.toUpperCase();
            if (!keys.includes(hexKey)) {
                throw new Error(`pub address ${hexKey} not found in account`);
            }
            if (key.weight !== 1) {
                throw new Error('owner permission is invalid for this structure');
            }
        });
    }
    /**
     * Format for offline vault signing
     * @param {BaseTransaction} tx
     * @param {number} fee
     * @param {number} recoveryAmount
     * @returns {RecoveryTransaction}
     */
    formatForOfflineVault(tx, fee, recoveryAmount, addressInfo) {
        const txJSON = tx.toJson();
        const format = {
            txHex: JSON.stringify(txJSON),
            recoveryAmount,
            feeInfo: {
                fee: `${fee}`,
            },
            tx: txJSON,
            coin: this.getChain(),
        };
        return addressInfo ? { ...format, addressInfo } : format;
    }
    /**
     * Builds a funds recovery transaction without BitGo.
     * We need to do three queries during this:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     *
     * Note 1: for base address recoveries, fund will be recovered to recovery destination if base address balance is
     * more than 2.1 TRX for native TRX recovery and 100 TRX for token recover. For receive addresses, fund will be
     * recovered to base address first then swept to base address(decided as the universal pattern in team meeting).
     *
     * Note 2: the function supports token sweep from base address.
     * TODO: support token sweep from receive address.
     *
     * @param params
     */
    async recover(params) {
        const isKrsRecovery = sdk_core_1.getIsKrsRecovery(params);
        const isUnsignedSweep = sdk_core_1.getIsUnsignedSweep(params);
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new Error('Invalid destination address!');
        }
        let startIdx = params.startingScanIndex;
        if (lodash_1.isUndefined(startIdx)) {
            startIdx = 1;
        }
        else if (!lodash_1.isInteger(startIdx) || startIdx < 0) {
            throw new Error('Invalid starting index to scan for addresses');
        }
        let numIteration = params.scan;
        if (lodash_1.isUndefined(numIteration)) {
            numIteration = 20;
        }
        else if (!lodash_1.isInteger(numIteration) || numIteration <= 0) {
            throw new Error('Invalid scanning factor');
        }
        // get our user, backup keys
        const keys = sdk_core_1.getBip32Keys(this.bitgo, params, { requireBitGoXpub: false });
        // we need to decode our bitgoKey to a base58 address
        const bitgoHexAddr = this.pubToHexAddress(this.xpubToUncompressedPub(params.bitgoKey));
        let recoveryFromAddrHex = bitgoHexAddr;
        let recoveryToAddressHex = lib_1.Utils.getHexAddressFromBase58Address(params.recoveryDestination);
        // call the node to get our account balance for base address
        let account = await this.getAccountBalancesFromNode(lib_1.Utils.getBase58AddressFromHex(recoveryFromAddrHex));
        let recoveryAmount = account.data[0].balance;
        let userXPrv = keys[0].toBase58();
        let isReceiveAddress = false;
        let addressInfo;
        // Tokens must be recovered before the native asset. First construct token txns
        let rawTokenTxn;
        for (const token of account.data[0].trc20) {
            for (const tokenContractAddr of exports.TOKEN_CONTRACT_ADDRESSES) {
                if (token[tokenContractAddr]) {
                    const amount = token[tokenContractAddr];
                    const tokenContractAddrHex = lib_1.Utils.getHexAddressFromBase58Address(tokenContractAddr);
                    rawTokenTxn = (await this.getTriggerSmartContractTransaction(recoveryToAddressHex, recoveryFromAddrHex, amount, tokenContractAddrHex)).transaction;
                    recoveryAmount = parseInt(amount, 10);
                    break;
                }
            }
        }
        // build and sign token txns
        if (rawTokenTxn) {
            // Check there is sufficient of the native asset to cover fees
            const trxBalance = account.data[0].balance;
            if (trxBalance < exports.SAFE_TRON_TOKEN_TRANSACTION_FEE) {
                throw new Error(`Amount of funds to recover ${trxBalance} is less than ${exports.SAFE_TRON_TOKEN_TRANSACTION_FEE} and wouldn't be able to fund a trc20 send`);
            }
            const txBuilder = builder_1.getBuilder(this.getChain()).from(rawTokenTxn);
            // this tx should be enough to drop into a node
            if (isUnsignedSweep) {
                return this.formatForOfflineVault(await txBuilder.build(), exports.SAFE_TRON_TOKEN_TRANSACTION_FEE, recoveryAmount);
            }
            const userPrv = this.xprvToCompressedPrv(userXPrv);
            txBuilder.sign({ key: userPrv });
            // krs recoveries don't get signed
            if (!isKrsRecovery && !isReceiveAddress) {
                const backupXPrv = keys[1].toBase58();
                const backupPrv = this.xprvToCompressedPrv(backupXPrv);
                txBuilder.sign({ key: backupPrv });
            }
            return this.formatForOfflineVault(await txBuilder.build(), exports.SAFE_TRON_TOKEN_TRANSACTION_FEE, recoveryAmount);
        }
        // Now let us recover the native Tron
        if (recoveryAmount > exports.SAFE_TRON_TRANSACTION_FEE) {
            const userXPub = keys[0].neutered().toBase58();
            const backupXPub = keys[1].neutered().toBase58();
            // check multisig permissions
            const keyHexAddresses = [
                this.pubToHexAddress(this.xpubToUncompressedPub(userXPub)),
                this.pubToHexAddress(this.xpubToUncompressedPub(backupXPub)),
                bitgoHexAddr,
            ];
            // run checks to ensure this is a valid tx - permissions match our signer keys
            const ownerKeys = [];
            for (const key of account.data[0].owner_permission.keys) {
                const address = lib_1.Utils.getHexAddressFromBase58Address(key.address);
                const weight = key.weight;
                ownerKeys.push({ address, weight });
            }
            const activePermissionKeys = [];
            for (const key of account.data[0].active_permission[0].keys) {
                const address = lib_1.Utils.getHexAddressFromBase58Address(key.address);
                const weight = key.weight;
                activePermissionKeys.push({ address, weight });
            }
            this.checkPermissions(ownerKeys, keyHexAddresses);
            this.checkPermissions(activePermissionKeys, keyHexAddresses);
        }
        else {
            // Check receive addresses for funds
            // Check for first derived wallet with funds
            // Receive addresses are derived from the user key
            for (let i = startIdx; i < numIteration + startIdx; i++) {
                const derivationPath = `0/0/0/${i}`;
                const userKey = keys[0].derivePath(derivationPath);
                const xpub = userKey.neutered();
                const receiveAddress = this.pubToHexAddress(this.xpubToUncompressedPub(xpub.toBase58()));
                const address = lib_1.Utils.getBase58AddressFromHex(receiveAddress);
                // call the node to get our account balance
                const accountInfo = await this.getAccountBalancesFromNode(address);
                if (accountInfo.data[0] && accountInfo.data[0].balance > exports.SAFE_TRON_TRANSACTION_FEE) {
                    account = accountInfo;
                    recoveryAmount = accountInfo.data[0].balance;
                    userXPrv = userKey.toBase58(); // assign derived userXPrx
                    isReceiveAddress = true;
                    recoveryFromAddrHex = receiveAddress;
                    recoveryToAddressHex = bitgoHexAddr;
                    addressInfo = {
                        address,
                        chain: 0,
                        index: i,
                    };
                    break;
                }
            }
        }
        // a sweep potentially needs to pay for multi-sig transfer, destination account activation and bandwidth
        // TRON foundation recommends 2.1 TRX for guaranteed confirmation
        if (!recoveryAmount || exports.SAFE_TRON_TRANSACTION_FEE >= recoveryAmount) {
            throw new Error(`Amount of funds to recover ${recoveryAmount} is less than ${exports.SAFE_TRON_TRANSACTION_FEE} and wouldn't be able to fund a send`);
        }
        const recoveryAmountMinusFees = recoveryAmount - exports.SAFE_TRON_TRANSACTION_FEE;
        const buildTx = await this.getBuildTransaction(recoveryToAddressHex, recoveryFromAddrHex, recoveryAmountMinusFees);
        // construct our tx
        const txBuilder = builder_1.getBuilder(this.getChain()).from(buildTx);
        // Default expiry is 1 minute which is too short for recovery purposes
        // extend the expiry to 1 day
        txBuilder.extendValidTo(exports.RECOVER_TRANSACTION_EXPIRY);
        const tx = await txBuilder.build();
        // this tx should be enough to drop into a node
        if (isUnsignedSweep) {
            return this.formatForOfflineVault(tx, exports.SAFE_TRON_TRANSACTION_FEE, recoveryAmountMinusFees, addressInfo);
        }
        const userPrv = this.xprvToCompressedPrv(userXPrv);
        txBuilder.sign({ key: userPrv });
        // krs recoveries don't get signed
        if (!isKrsRecovery && !isReceiveAddress) {
            const backupXPrv = keys[1].toBase58();
            const backupPrv = this.xprvToCompressedPrv(backupXPrv);
            txBuilder.sign({ key: backupPrv });
        }
        const txSigned = await txBuilder.build();
        return this.formatForOfflineVault(txSigned, exports.SAFE_TRON_TRANSACTION_FEE, recoveryAmountMinusFees, addressInfo);
    }
    /**
     * Builds native TRX recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     * Note: there will be another recoverTokenConsolidations function to support token recover from receive addresses.
     *
     * @param {ConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    async recoverConsolidations(params) {
        const isUnsignedConsolidations = sdk_core_1.getIsUnsignedSweep(params);
        const startIdx = params.startingScanIndex || 1;
        const endIdx = params.endingScanIndex || startIdx + exports.DEFAULT_SCAN_FACTOR;
        if (startIdx < 1 || endIdx <= startIdx || endIdx - startIdx > 10 * exports.DEFAULT_SCAN_FACTOR) {
            throw new Error(`Invalid starting or ending index to scan for addresses. startingScanIndex: ${startIdx}, endingScanIndex: ${endIdx}.`);
        }
        const keys = sdk_core_1.getBip32Keys(this.bitgo, params, { requireBitGoXpub: false });
        const baseAddrHex = this.pubToHexAddress(this.xpubToUncompressedPub(params.bitgoKey));
        const txnsBatch = [];
        for (let i = startIdx; i < endIdx; i++) {
            const derivationPath = `0/0/0/${i}`;
            const userKey = keys[0].derivePath(derivationPath);
            const userKeyXPub = userKey.neutered();
            const receiveAddressHex = this.pubToHexAddress(this.xpubToUncompressedPub(userKeyXPub.toBase58()));
            const receiveAddress = lib_1.Utils.getBase58AddressFromHex(receiveAddressHex);
            // call the node to get our account balance
            const accountInfo = await this.getAccountBalancesFromNode(receiveAddress);
            if (accountInfo.data[0] && accountInfo.data[0].balance > exports.SAFE_TRON_TRANSACTION_FEE) {
                const addressBalance = accountInfo.data[0].balance;
                const addressInfo = {
                    address: receiveAddress,
                    chain: 0,
                    index: i,
                };
                const recoveryAmount = addressBalance - exports.SAFE_TRON_TRANSACTION_FEE;
                const buildTx = await this.getBuildTransaction(baseAddrHex, receiveAddressHex, recoveryAmount);
                // construct our tx
                const txBuilder = builder_1.getBuilder(this.getChain()).from(buildTx);
                // Default expiry is 1 minute which is too short for recovery purposes
                // extend the expiry to 1 day
                txBuilder.extendValidTo(exports.RECOVER_TRANSACTION_EXPIRY);
                if (!isUnsignedConsolidations) {
                    const userPrv = this.xprvToCompressedPrv(userKey.toBase58());
                    // receive address only needs to be signed by user key
                    txBuilder.sign({ key: userPrv });
                }
                const tx = await txBuilder.build();
                txnsBatch.push(this.formatForOfflineVault(tx, exports.SAFE_TRON_TRANSACTION_FEE, recoveryAmount, addressInfo));
            }
        }
        return {
            transactions: txnsBatch,
        };
    }
    /**
     * Explain a Tron transaction from txHex
     * @param params
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const txBuilder = builder_1.getBuilder(this.getChain()).from(txHex);
        const tx = await txBuilder.build();
        const outputs = [
            {
                amount: tx.outputs[0].value.toString(),
                address: tx.outputs[0].address, // Should turn it into a readable format, aka base58
            },
        ];
        const displayOrder = [
            'id',
            'outputAmount',
            'changeAmount',
            'outputs',
            'changeOutputs',
            'fee',
            'timestamp',
            'expiration',
        ];
        return {
            displayOrder,
            id: tx.id,
            outputs,
            outputAmount: outputs[0].amount,
            changeOutputs: [],
            changeAmount: '0',
            fee: params.feeInfo,
            timestamp: tx.validFrom,
            expiration: tx.validTo,
        };
    }
}
exports.Trx = Trx;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJ4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3RyeC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0dBRUc7QUFDSCxxREFBdUM7QUFDdkMsbUNBQXFDO0FBRXJDLDhDQUFrRDtBQUNsRCxvREFBc0M7QUFDdEMsOENBb0J5QjtBQUN6QiwrQkFBeUQ7QUFDekQsMkNBQTJDO0FBRTNDLG1DQUFnRDtBQUVuQyxRQUFBLGlDQUFpQyxHQUFHLEdBQUcsQ0FBQztBQUN4QyxRQUFBLHlCQUF5QixHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyx3RUFBd0U7QUFDL0csUUFBQSwrQkFBK0IsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUMsd0VBQXdFO0FBQ3JILFFBQUEsMEJBQTBCLEdBQUcsUUFBUSxDQUFDLENBQUMsVUFBVTtBQUNqRCxRQUFBLG1CQUFtQixHQUFHLEVBQUUsQ0FBQyxDQUFDLHdEQUF3RDtBQUVsRixRQUFBLHdCQUF3QixHQUFHO0lBQ3RDLGlCQUFpQjtJQUNqQixvQ0FBb0M7SUFDcEMsb0NBQW9DO0lBQ3BDLGlCQUFpQjtJQUNqQixvQ0FBb0M7SUFDcEMsb0NBQW9DO0NBQ3JDLENBQUM7QUE0RUYsSUFBWSxTQUdYO0FBSEQsV0FBWSxTQUFTO0lBQ25CLHlDQUFJLENBQUE7SUFDSixpREFBUSxDQUFBO0FBQ1YsQ0FBQyxFQUhXLFNBQVMsR0FBVCxpQkFBUyxLQUFULGlCQUFTLFFBR3BCO0FBU0QsTUFBYSxHQUFJLFNBQVEsbUJBQVE7SUFHL0IsWUFBWSxLQUFnQixFQUFFLFdBQXVDO1FBQ25FLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUViLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDaEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFBb0QsQ0FBQyxDQUFDO1NBQ3ZFO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7SUFDbEMsQ0FBQztJQUVE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K0JBQStCLENBQUMsQ0FBQztTQUNsRDtRQUNELE1BQU0sU0FBUyxHQUFHLG9CQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzFELE1BQU0sRUFBRSxHQUFHLE1BQU0sU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ25DLE1BQU0sT0FBTyxHQUFHO1lBQ2Q7Z0JBQ0UsTUFBTSxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTtnQkFDdEMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLG9EQUFvRDthQUNyRjtTQUNGLENBQUM7UUFFRixNQUFNLFlBQVksR0FBRztZQUNuQixJQUFJO1lBQ0osY0FBYztZQUNkLGNBQWM7WUFDZCxTQUFTO1lBQ1QsZUFBZTtZQUNmLEtBQUs7WUFDTCxXQUFXO1lBQ1gsWUFBWTtTQUNiLENBQUM7UUFFRixPQUFPO1lBQ0wsWUFBWTtZQUNaLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTtZQUNULE9BQU87WUFDUCxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU07WUFDL0IsYUFBYSxFQUFFLEVBQUU7WUFDakIsWUFBWSxFQUFFLEdBQUc7WUFDakIsR0FBRyxFQUFFLE1BQU0sQ0FBQyxPQUFPO1lBQ25CLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUztZQUN2QixVQUFVLEVBQUUsRUFBRSxDQUFDLE9BQU87U0FDdkIsQ0FBQztJQUNKLENBQUM7Q0FDRjtBQXZ0QkQsa0JBdXRCQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIHNlY3AyNTZrMSBmcm9tICdzZWNwMjU2azEnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgQ29pbkZhbWlseSwgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgYmlwMzIsIG5ldHdvcmtzIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQml0R29CYXNlLFxuICBjb21tb24sXG4gIGdldEJpcDMyS2V5cyxcbiAgZ2V0SXNLcnNSZWNvdmVyeSxcbiAgZ2V0SXNVbnNpZ25lZFN3ZWVwLFxuICBLZXlQYWlyLFxuICBNZXRob2ROb3RJbXBsZW1lbnRlZEVycm9yLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBUcmFuc2FjdGlvbkZlZSxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXMgUmVjaXBpZW50LFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBCYXNlVHJhbnNhY3Rpb24sXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBJbnRlcmZhY2UsIFV0aWxzLCBXcmFwcGVkQnVpbGRlciB9IGZyb20gJy4vbGliJztcbmltcG9ydCB7IGdldEJ1aWxkZXIgfSBmcm9tICcuL2xpYi9idWlsZGVyJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uUmVjZWlwdCB9IGZyb20gJy4vbGliL2lmYWNlJztcbmltcG9ydCB7IGlzSW50ZWdlciwgaXNVbmRlZmluZWQgfSBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgY29uc3QgTUlOSU1VTV9UUk9OX01TSUdfVFJBTlNBQ1RJT05fRkVFID0gMWU2O1xuZXhwb3J0IGNvbnN0IFNBRkVfVFJPTl9UUkFOU0FDVElPTl9GRUUgPSAyLjEgKiAxZTY7IC8vIFRST04gZm91bmRhdGlvbiByZWNvbW1lbmRzIDIuMSBUUlggYXMgZmVlcyBmb3IgZ3VhcmFudGVlZCB0cmFuc2FjdGlvblxuZXhwb3J0IGNvbnN0IFNBRkVfVFJPTl9UT0tFTl9UUkFOU0FDVElPTl9GRUUgPSAxMDAgKiAxZTY7IC8vIFRST04gZm91bmRhdGlvbiByZWNvbW1lbmRzIDEwMCBUUlggYXMgZmVlcyBmb3IgZ3VhcmFudGVlZCB0cmFuc2FjdGlvblxuZXhwb3J0IGNvbnN0IFJFQ09WRVJfVFJBTlNBQ1RJT05fRVhQSVJZID0gODY0MDAwMDA7IC8vIDI0IGhvdXJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NDQU5fRkFDVE9SID0gMjA7IC8vIGRlZmF1bHQgbnVtYmVyIG9mIHJlY2VpdmUgYWRkcmVzc2VzIHRvIHNjYW4gZm9yIGZ1bmRzXG5cbmV4cG9ydCBjb25zdCBUT0tFTl9DT05UUkFDVF9BRERSRVNTRVMgPSBbXG4gIC8vIG1haW5uZXQgdG9rZW5zXG4gICdURWt4aVRlaG56U21TZTJYcXJCajR3MzJSVU45NjZyZHo4JyxcbiAgJ1RSN05IcWplS1F4R1RDaThxOFpZNHBMOG90U3pnakxqNnQnLFxuICAvLyB0ZXN0bmV0IHRva2Vuc1xuICAnVFNkWndOcXBIb2Z6UDZCc0JLR1FVV2RCZUpwaExtRjZpZCcsXG4gICdURzNYWHlFeEJrUHA5bnpkYWpEWnNvekV1NEJrYVNKb3pzJyxcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJvblNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHhJbmZvIHtcbiAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gIGZyb206IHN0cmluZztcbiAgdHhpZDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFkZHJlc3NJbmZvIHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBjaGFpbjogbnVtYmVyO1xuICBpbmRleDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyb25UcmFuc2FjdGlvbkV4cGxhbmF0aW9uIGV4dGVuZHMgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIGV4cGlyYXRpb246IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHhJbmZvOiBUeEluZm87XG4gIGFkZHJlc3NJbmZvPzogQWRkcmVzc0luZm87XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZzsgLy8gdHhIZXggaXMgcG9vcmx5IG5hbWVkIGhlcmU7IGl0IGlzIGp1c3QgYSB3cmFwcGVkIEpTT04gb2JqZWN0XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZzsgLy8gdHhIZXggaXMgcG9vcmx5IG5hbWVkIGhlcmU7IGl0IGlzIGp1c3QgYSB3cmFwcGVkIEpTT04gb2JqZWN0XG4gIH07XG4gIGZlZUluZm86IFRyYW5zYWN0aW9uRmVlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5T3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZzsgLy8gQm94IEFcbiAgYmFja3VwS2V5OiBzdHJpbmc7IC8vIEJveCBCXG4gIGJpdGdvS2V5OiBzdHJpbmc7IC8vIEJveCBDIC0gdGhpcyBpcyBiaXRnbydzIHhwdWIgYW5kIHdpbGwgYmUgdXNlZCB0byBkZXJpdmUgdGhlaXIgcm9vdCBhZGRyZXNzXG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZzsgLy8gYmFzZTU4IGFkZHJlc3NcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG4gIHN0YXJ0aW5nU2NhbkluZGV4PzogbnVtYmVyO1xuICBzY2FuPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbnNvbGlkYXRpb25SZWNvdmVyeU9wdGlvbnMge1xuICB1c2VyS2V5OiBzdHJpbmc7XG4gIGJhY2t1cEtleTogc3RyaW5nO1xuICBiaXRnb0tleTogc3RyaW5nO1xuICBzdGFydGluZ1NjYW5JbmRleD86IG51bWJlcjsgLy8gZGVmYXVsdCB0byAxIChpbmNsdXNpdmUpXG4gIGVuZGluZ1NjYW5JbmRleD86IG51bWJlcjsgLy8gZGVmYXVsdCB0byBzdGFydGluZ1NjYW5JbmRleCArIDIwIChleGNsdXNpdmUpXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uc29saWRhdGlvblJlY292ZXJ5QmF0Y2gge1xuICB0cmFuc2FjdGlvbnM6IFJlY292ZXJ5VHJhbnNhY3Rpb25bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGZWVJbmZvIHtcbiAgZmVlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3ZlcnlUcmFuc2FjdGlvbiB7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBmZWVJbmZvPzogRmVlSW5mbztcbiAgY29pbj86IHN0cmluZztcbiAgdHg/OiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICByZWNvdmVyeUFtb3VudD86IG51bWJlcjtcbiAgdG9rZW5UeHM/OiBUcmFuc2FjdGlvblJlY2VpcHRbXTtcbiAgYWRkcmVzc0luZm8/OiBBZGRyZXNzSW5mbztcbn1cblxuZXhwb3J0IGVudW0gTm9kZVR5cGVzIHtcbiAgRnVsbCxcbiAgU29saWRpdHksXG59XG5cbi8qKlxuICogVGhpcyBzdHJ1Y3R1cmUgaXMgbm90IGEgY29tcGxldGUgbW9kZWwgb2YgdGhlIEFjY291bnRSZXNwb25zZSBmcm9tIGEgbm9kZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50UmVzcG9uc2Uge1xuICBkYXRhOiBbSW50ZXJmYWNlLkFjY291bnRJbmZvXTtcbn1cblxuZXhwb3J0IGNsYXNzIFRyeCBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pIHtcbiAgICBzdXBlcihiaXRnbyk7XG5cbiAgICBpZiAoIXN0YXRpY3NDb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29uc3RydWN0b3IgcGFyYW1ldGVyIHN0YXRpY3NDb2luJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGljc0NvaW4gPSBzdGF0aWNzQ29pbjtcbiAgfVxuXG4gIGdldENoYWluKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgZ2V0RmFtaWx5KCk6IENvaW5GYW1pbHkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mYW1pbHk7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cblxuICBnZXRCYXNlRmFjdG9yKCkge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhdGljc0NvaW4uZGVjaW1hbFBsYWNlcyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdHJhbnNhY3Rpb25EYXRhQWxsb3dlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBUcngoYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpcyBhIHZhbGlkIGJhc2U1OCBvciBoZXggYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzc1xuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZEhleEFkZHJlc3MoYWRkcmVzcykgfHwgVXRpbHMuaXNCYXNlNThBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGlzIGEgdmFsaWQgaGV4IGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3MgaGV4IGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRIZXhBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvXjQxWzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZWQyNTUxOSBrZXkgcGFpclxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViLCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgLy8gVE9ETzogbW92ZSB0aGlzIGFuZCBhZGRyZXNzIGNyZWF0aW9uIGxvZ2ljIHRvIGFjY291bnQtbGliXG4gICAgaWYgKCFzZWVkKSB7XG4gICAgICAvLyBBbiBleHRlbmRlZCBwcml2YXRlIGtleSBoYXMgYm90aCBhIG5vcm1hbCAyNTYgYml0IHByaXZhdGUga2V5IGFuZCBhIDI1NiBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlXG4gICAgICAvLyByYW5kb20uIDUxMiBiaXRzIGlzIHRoZXJlZm9yZSB0aGUgbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGhkID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogaGQubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgICAgcHJ2OiBoZC50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICBpc1ZhbGlkWHB1Yih4cHViOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJpcDMyLmZyb21CYXNlNTgoeHB1YikuaXNOZXV0ZXJlZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZFhwdWIocHViKSkge1xuICAgICAgLy8geHB1YnMgY2FuIGJlIGNvbnZlcnRlZCBpbnRvIHJlZ3VsYXIgcHVicywgc28gdGVjaG5pY2FsbHkgaXQgaXMgYSB2YWxpZCBwdWJcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXjA0W2EtekEtWjAtOV17MTI4fSQnKS50ZXN0KHB1Yik7XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgYXN5bmMgaXNXYWxsZXRBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSB1c2VyIGtleSB1c2luZyB0aGUgY2hhaW4gcGF0aCBvZiB0aGUgYWRkcmVzc1xuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBwYXRoXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGRlcml2ZWQgcHJpdmF0ZSBrZXlcbiAgICovXG4gIGRlcml2ZUtleVdpdGhQYXRoKHsga2V5LCBwYXRoIH06IHsga2V5OiBzdHJpbmc7IHBhdGg6IHN0cmluZyB9KTogc3RyaW5nIHtcbiAgICBjb25zdCBrZXljaGFpbiA9IGJpcDMyLmZyb21CYXNlNTgoa2V5KTtcbiAgICBjb25zdCBkZXJpdmVkS2V5Tm9kZSA9IGtleWNoYWluLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgcmV0dXJuIGRlcml2ZWRLZXlOb2RlLnRvQmFzZTU4KCk7XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB7T2JqZWN0fSBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy5wcnYge1N0cmluZ30gdXNlciBwcnZcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQuYWRkcmVzc1ZlcnNpb24ge1N0cmluZ30gdGhpcyBpcyB0aGUgdmVyc2lvbiBvZiB0aGUgQWxnb3JhbmQgbXVsdGlzaWcgYWRkcmVzcyBnZW5lcmF0aW9uIGZvcm1hdFxuICAgKiBAcmV0dXJucyBCbHVlYmlyZDxTaWduZWRUcmFuc2FjdGlvbj5cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFRyb25TaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHR4QnVpbGRlciA9IGdldEJ1aWxkZXIodGhpcy5nZXRDaGFpbigpKS5mcm9tKHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4KTtcblxuICAgIGxldCBrZXk7XG4gICAgY29uc3QgeyBjaGFpbiwgaW5kZXggfSA9IHBhcmFtcy50eFByZWJ1aWxkPy5hZGRyZXNzSW5mbyA/PyB7IGNoYWluOiAwLCBpbmRleDogMCB9O1xuICAgIGlmIChjaGFpbiA9PT0gMCAmJiBpbmRleCA9PT0gMCkge1xuICAgICAga2V5ID0gcGFyYW1zLnBydjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBgMC8wLyR7Y2hhaW59LyR7aW5kZXh9YDtcbiAgICAgIGtleSA9IHRoaXMuZGVyaXZlS2V5V2l0aFBhdGgoeyBrZXk6IHBhcmFtcy5wcnYsIHBhdGg6IGRlcml2YXRpb25QYXRoIH0pO1xuICAgIH1cbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleSB9KTtcblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICB0eEhleDogSlNPTi5zdHJpbmdpZnkodHJhbnNhY3Rpb24udG9Kc29uKCkpLFxuICAgIH07XG4gICAgaWYgKHRyYW5zYWN0aW9uLnRvSnNvbigpLnNpZ25hdHVyZS5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvLyBIYWxmIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgIHJldHVybiB7XG4gICAgICBoYWxmU2lnbmVkOiByZXNwb25zZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBzZWVkIGZvciB0aGUgY29pblxuICAgKlxuICAgKiBAcGFyYW0gcHJ2IC0gdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqL1xuICBpc1ZhbGlkWHBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gIWJpcDMyLmZyb21CYXNlNTgocHJ2KS5pc05ldXRlcmVkKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBtZXNzYWdlIHRvIHN0cmluZyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIHtCdWZmZXJ8U3RyaW5nfSBtZXNzYWdlIHRvIHNpZ25cbiAgICogQHJldHVybiB0aGUgbWVzc2FnZSBhcyBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgKi9cbiAgdG9IZXhTdHJpbmcobWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZS50b1N0cmluZygnaGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXNzYWdlZCBwYXNzZWQgdG8gc2lnbk1lc3NhZ2UnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IHRvU2lnbiA9IHRoaXMudG9IZXhTdHJpbmcobWVzc2FnZSk7XG5cbiAgICBsZXQgcHJ2OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBrZXkucHJ2O1xuICAgIGlmICh0aGlzLmlzVmFsaWRYcHJ2KHBydikpIHtcbiAgICAgIHBydiA9IGJpcDMyLmZyb21CYXNlNTgocHJ2KS5wcml2YXRlS2V5Py50b1N0cmluZygnaGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFwcnYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcHJpdmF0ZUtleScpO1xuICAgIH1cbiAgICBsZXQgc2lnID0gVXRpbHMuc2lnblN0cmluZyh0b1NpZ24sIHBydiwgdHJ1ZSk7XG5cbiAgICAvLyByZW1vdmUgdGhlIHByZWNlZGluZyAweFxuICAgIHNpZyA9IHNpZy5yZXBsYWNlKC9eMHgvLCAnJyk7XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2lnLCAnaGV4Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4geHB1YiB0byBhIHVuY29tcHJlc3NlZCBwdWJcbiAgICogQHBhcmFtIHhwdWJcbiAgICovXG4gIHhwdWJUb1VuY29tcHJlc3NlZFB1Yih4cHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkWHB1Yih4cHViKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHhwdWInKTtcbiAgICB9XG5cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBiaXAzMi5mcm9tQmFzZTU4KHhwdWIsIG5ldHdvcmtzLmJpdGNvaW4pLnB1YmxpY0tleTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSAvKiBjb21wcmVzc2VkICovKSkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmeSBwcmVidWlsZCBiZWZvcmUgc2VuZGluZyBpdCB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMgVGhlIHdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgZm9yIHRoaXMgcHJlYnVpbGRcbiAgICovXG4gIGFzeW5jIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKGJ1aWxkUGFyYW1zLnJlY2lwaWVudHNbMF0uZGF0YSAmJiBidWlsZFBhcmFtcy5mZWVMaW1pdCkge1xuICAgICAgYnVpbGRQYXJhbXMucmVjaXBpZW50c1swXS5mZWVMaW1pdCA9IGJ1aWxkUGFyYW1zLmZlZUxpbWl0O1xuICAgIH1cbiAgfVxuXG4gIHB1YlRvSGV4QWRkcmVzcyhwdWI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgYnl0ZUFycmF5QWRkciA9IFV0aWxzLmdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKHB1Yik7XG4gICAgY29uc3QgcmF3QWRkcmVzcyA9IFV0aWxzLmdldFJhd0FkZHJlc3NGcm9tUHViS2V5KGJ5dGVBcnJheUFkZHIpO1xuICAgIHJldHVybiBVdGlscy5nZXRIZXhBZGRyZXNzRnJvbUJ5dGVBcnJheShyYXdBZGRyZXNzKTtcbiAgfVxuXG4gIHhwcnZUb0NvbXByZXNzZWRQcnYoeHBydjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZFhwcnYoeHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB4cHJ2Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgaGROb2RlID0gYmlwMzIuZnJvbUJhc2U1OCh4cHJ2LCBuZXR3b3Jrcy5iaXRjb2luKTtcbiAgICBpZiAoIWhkTm9kZS5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByaXZhdGVLZXknKTtcbiAgICB9XG4gICAgcmV0dXJuIGhkTm9kZS5wcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Tm9kZVVybChub2RlOiBOb2RlVHlwZXMpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAobm9kZSkge1xuICAgICAgY2FzZSBOb2RlVHlwZXMuRnVsbDpcbiAgICAgICAgcmV0dXJuIGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0udHJvbk5vZGVzLmZ1bGw7XG4gICAgICBjYXNlIE5vZGVUeXBlcy5Tb2xpZGl0eTpcbiAgICAgICAgcmV0dXJuIGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0udHJvbk5vZGVzLnNvbGlkaXR5O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub2RlIHR5cGUgbm90IGZvdW5kJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNYWtlIGEgcXVlcnkgdG8gVHJvbmdyaWQgZm9yIGluZm9ybWF0aW9uIHN1Y2ggYXMgYmFsYW5jZSwgdG9rZW4gYmFsYW5jZSwgc29saWRpdHkgY2FsbHNcbiAgICogQHBhcmFtIHF1ZXJ5IHtPYmplY3R9IGtleS12YWx1ZSBwYWlycyBvZiBwYXJhbWV0ZXJzIHRvIGFwcGVuZCBhZnRlciAvYXBpXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHJlc3BvbnNlIGZyb20gVHJvbmdyaWRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVjb3ZlcnlQb3N0KHF1ZXJ5OiB7IHBhdGg6IHN0cmluZzsganNvbk9iajogYW55OyBub2RlOiBOb2RlVHlwZXMgfSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3Qgbm9kZVVyaSA9IHRoaXMuZ2V0Tm9kZVVybChxdWVyeS5ub2RlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFxuICAgICAgLnBvc3Qobm9kZVVyaSArIHF1ZXJ5LnBhdGgpXG4gICAgICAudHlwZSgnanNvbicpXG4gICAgICAuc2VuZChxdWVyeS5qc29uT2JqKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWNoIFRyb24gbm9kZScpO1xuICAgIH1cblxuICAgIC8vIHVuZm9ydHVuYXRlbHksIGl0IGRvZXNuJ3QgbG9vayBsaWtlIG1vc3QgVFJPTiBub2RlcyByZXR1cm4gdmFsaWQganNvbiBhcyBib2R5XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UudGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHF1ZXJ5IHRvIFRyb25ncmlkIGZvciBpbmZvcm1hdGlvbiBzdWNoIGFzIGJhbGFuY2UsIHRva2VuIGJhbGFuY2UsIHNvbGlkaXR5IGNhbGxzXG4gICAqIEBwYXJhbSBxdWVyeSB7T2JqZWN0fSBrZXktdmFsdWUgcGFpcnMgb2YgcGFyYW1ldGVycyB0byBhcHBlbmQgYWZ0ZXIgL2FwaVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXNwb25zZSBmcm9tIFRyb25ncmlkXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlY292ZXJ5R2V0KHF1ZXJ5OiB7IHBhdGg6IHN0cmluZzsganNvbk9iajogYW55OyBub2RlOiBOb2RlVHlwZXMgfSk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3Qgbm9kZVVyaSA9IHRoaXMuZ2V0Tm9kZVVybChxdWVyeS5ub2RlKTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFxuICAgICAgLmdldChub2RlVXJpICsgcXVlcnkucGF0aClcbiAgICAgIC50eXBlKCdqc29uJylcbiAgICAgIC5zZW5kKHF1ZXJ5Lmpzb25PYmopO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhY2ggVHJvbiBub2RlJyk7XG4gICAgfVxuXG4gICAgLy8gdW5mb3J0dW5hdGVseSwgaXQgZG9lc24ndCBsb29rIGxpa2UgbW9zdCBUUk9OIG5vZGVzIHJldHVybiB2YWxpZCBqc29uIGFzIGJvZHlcbiAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwb25zZS50ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBvdXIgZXhwbG9yZXIgZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIGFkZHJlc3MgZW5jb2RlZCBpbiBoZXhcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gYWRkcmVzcyBiYWxhbmNlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEFjY291bnRCYWxhbmNlc0Zyb21Ob2RlKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QWNjb3VudFJlc3BvbnNlPiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVjb3ZlcnlHZXQoe1xuICAgICAgcGF0aDogJy92MS9hY2NvdW50cy8nICsgYWRkcmVzcyxcbiAgICAgIGpzb25PYmo6IHt9LFxuICAgICAgbm9kZTogTm9kZVR5cGVzLkZ1bGwsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIG91ciBidWlsZCB0cmFuc2FjdGlvbiBmcm9tIGEgbm9kZS5cbiAgICogQHBhcmFtIHRvQWRkciBoZXgtZW5jb2RlZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBmcm9tQWRkciBoZXgtZW5jb2RlZCBhZGRyZXNzXG4gICAqIEBwYXJhbSBhbW91bnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0QnVpbGRUcmFuc2FjdGlvbihcbiAgICB0b0FkZHI6IHN0cmluZyxcbiAgICBmcm9tQWRkcjogc3RyaW5nLFxuICAgIGFtb3VudDogbnVtYmVyXG4gICk6IFByb21pc2U8SW50ZXJmYWNlLlRyYW5zYWN0aW9uUmVjZWlwdD4ge1xuICAgIC8vIG91ciBhZGRyZXNzZXMgc2hvdWxkIGJlIGJhc2U1OCwgd2UnbGwgaGF2ZSB0byBlbmNvZGUgdG8gaGV4XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVjb3ZlcnlQb3N0KHtcbiAgICAgIHBhdGg6ICcvd2FsbGV0L2NyZWF0ZXRyYW5zYWN0aW9uJyxcbiAgICAgIGpzb25PYmo6IHtcbiAgICAgICAgdG9fYWRkcmVzczogdG9BZGRyLFxuICAgICAgICBvd25lcl9hZGRyZXNzOiBmcm9tQWRkcixcbiAgICAgICAgYW1vdW50LFxuICAgICAgfSxcbiAgICAgIG5vZGU6IE5vZGVUeXBlcy5GdWxsLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBvdXIgYnVpbGQgdHJhbnNhY3Rpb24gZnJvbSBhIG5vZGUuXG4gICAqIEBwYXJhbSB0b0FkZHIgaGV4LWVuY29kZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gZnJvbUFkZHIgaGV4LWVuY29kZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldFRyaWdnZXJTbWFydENvbnRyYWN0VHJhbnNhY3Rpb24oXG4gICAgdG9BZGRyOiBzdHJpbmcsXG4gICAgZnJvbUFkZHI6IHN0cmluZyxcbiAgICBhbW91bnQ6IHN0cmluZyxcbiAgICBjb250cmFjdEFkZHI6IHN0cmluZ1xuICApOiBQcm9taXNlPHsgdHJhbnNhY3Rpb246IEludGVyZmFjZS5UcmFuc2FjdGlvblJlY2VpcHQgfT4ge1xuICAgIGNvbnN0IGZ1bmN0aW9uU2VsZWN0b3IgPSAndHJhbnNmZXIoYWRkcmVzcyx1aW50MjU2KSc7XG4gICAgY29uc3QgdHlwZXMgPSBbJ2FkZHJlc3MnLCAndWludDI1NiddO1xuICAgIGNvbnN0IHZhbHVlcyA9IFt0b0FkZHIsIGFtb3VudF07XG4gICAgY29uc3QgcGFyYW1ldGVyID0gVXRpbHMuZW5jb2RlRGF0YVBhcmFtcyh0eXBlcywgdmFsdWVzLCAnJyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucmVjb3ZlcnlQb3N0KHtcbiAgICAgIHBhdGg6ICcvd2FsbGV0L3RyaWdnZXJzbWFydGNvbnRyYWN0JyxcbiAgICAgIGpzb25PYmo6IHtcbiAgICAgICAgb3duZXJfYWRkcmVzczogZnJvbUFkZHIsXG4gICAgICAgIGNvbnRyYWN0X2FkZHJlc3M6IGNvbnRyYWN0QWRkcixcbiAgICAgICAgZnVuY3Rpb25fc2VsZWN0b3I6IGZ1bmN0aW9uU2VsZWN0b3IsXG4gICAgICAgIHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuICAgICAgICBmZWVfbGltaXQ6IDEwMDAwMDAwMCxcbiAgICAgIH0sXG4gICAgICBub2RlOiBOb2RlVHlwZXMuRnVsbCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IGtleXMgaW4gdGhlIG93bmVyS2V5cyBjb2xsZWN0aW9uIGRvbid0IG1hdGNoIHRoZSBrZXlzIGFycmF5IHdlIHBhc3NcbiAgICogQHBhcmFtIG93bmVyS2V5c1xuICAgKiBAcGFyYW0ga2V5c1xuICAgKi9cbiAgY2hlY2tQZXJtaXNzaW9ucyhvd25lcktleXM6IHsgYWRkcmVzczogc3RyaW5nOyB3ZWlnaHQ6IG51bWJlciB9W10sIGtleXM6IHN0cmluZ1tdKSB7XG4gICAga2V5cyA9IGtleXMubWFwKChrKSA9PiBrLnRvVXBwZXJDYXNlKCkpO1xuXG4gICAgb3duZXJLZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBoZXhLZXkgPSBrZXkuYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKCFrZXlzLmluY2x1ZGVzKGhleEtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwdWIgYWRkcmVzcyAke2hleEtleX0gbm90IGZvdW5kIGluIGFjY291bnRgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleS53ZWlnaHQgIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvd25lciBwZXJtaXNzaW9uIGlzIGludmFsaWQgZm9yIHRoaXMgc3RydWN0dXJlJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0IGZvciBvZmZsaW5lIHZhdWx0IHNpZ25pbmdcbiAgICogQHBhcmFtIHtCYXNlVHJhbnNhY3Rpb259IHR4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmZWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlY292ZXJ5QW1vdW50XG4gICAqIEByZXR1cm5zIHtSZWNvdmVyeVRyYW5zYWN0aW9ufVxuICAgKi9cbiAgZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KFxuICAgIHR4OiBCYXNlVHJhbnNhY3Rpb24sXG4gICAgZmVlOiBudW1iZXIsXG4gICAgcmVjb3ZlcnlBbW91bnQ6IG51bWJlcixcbiAgICBhZGRyZXNzSW5mbz86IEFkZHJlc3NJbmZvXG4gICk6IFJlY292ZXJ5VHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IHR4SlNPTiA9IHR4LnRvSnNvbigpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHtcbiAgICAgIHR4SGV4OiBKU09OLnN0cmluZ2lmeSh0eEpTT04pLFxuICAgICAgcmVjb3ZlcnlBbW91bnQsXG4gICAgICBmZWVJbmZvOiB7XG4gICAgICAgIGZlZTogYCR7ZmVlfWAsXG4gICAgICB9LFxuICAgICAgdHg6IHR4SlNPTiwgLy8gTGVhdmluZyBpdCBhcyB0eEpTT04gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgfTtcbiAgICByZXR1cm4gYWRkcmVzc0luZm8gPyB7IC4uLmZvcm1hdCwgYWRkcmVzc0luZm8gfSA6IGZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvLlxuICAgKiBXZSBuZWVkIHRvIGRvIHRocmVlIHF1ZXJpZXMgZHVyaW5nIHRoaXM6XG4gICAqIDEpIE5vZGUgcXVlcnkgLSBob3cgbXVjaCBtb25leSBpcyBpbiB0aGUgYWNjb3VudFxuICAgKiAyKSBCdWlsZCB0cmFuc2FjdGlvbiAtIGJ1aWxkIG91ciB0cmFuc2FjdGlvbiBmb3IgdGhlIGFtb3VudFxuICAgKiAzKSBTZW5kIHNpZ25lZCBidWlsZCAtIHNlbmQgb3VyIHNpZ25lZCBidWlsZCB0byBhIHB1YmxpYyBub2RlXG4gICAqXG4gICAqIE5vdGUgMTogZm9yIGJhc2UgYWRkcmVzcyByZWNvdmVyaWVzLCBmdW5kIHdpbGwgYmUgcmVjb3ZlcmVkIHRvIHJlY292ZXJ5IGRlc3RpbmF0aW9uIGlmIGJhc2UgYWRkcmVzcyBiYWxhbmNlIGlzXG4gICAqIG1vcmUgdGhhbiAyLjEgVFJYIGZvciBuYXRpdmUgVFJYIHJlY292ZXJ5IGFuZCAxMDAgVFJYIGZvciB0b2tlbiByZWNvdmVyLiBGb3IgcmVjZWl2ZSBhZGRyZXNzZXMsIGZ1bmQgd2lsbCBiZVxuICAgKiByZWNvdmVyZWQgdG8gYmFzZSBhZGRyZXNzIGZpcnN0IHRoZW4gc3dlcHQgdG8gYmFzZSBhZGRyZXNzKGRlY2lkZWQgYXMgdGhlIHVuaXZlcnNhbCBwYXR0ZXJuIGluIHRlYW0gbWVldGluZykuXG4gICAqXG4gICAqIE5vdGUgMjogdGhlIGZ1bmN0aW9uIHN1cHBvcnRzIHRva2VuIHN3ZWVwIGZyb20gYmFzZSBhZGRyZXNzLlxuICAgKiBUT0RPOiBzdXBwb3J0IHRva2VuIHN3ZWVwIGZyb20gcmVjZWl2ZSBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxSZWNvdmVyeVRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGdldElzS3JzUmVjb3ZlcnkocGFyYW1zKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBnZXRJc1Vuc2lnbmVkU3dlZXAocGFyYW1zKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXN0aW5hdGlvbiBhZGRyZXNzIScpO1xuICAgIH1cblxuICAgIGxldCBzdGFydElkeCA9IHBhcmFtcy5zdGFydGluZ1NjYW5JbmRleDtcbiAgICBpZiAoaXNVbmRlZmluZWQoc3RhcnRJZHgpKSB7XG4gICAgICBzdGFydElkeCA9IDE7XG4gICAgfSBlbHNlIGlmICghaXNJbnRlZ2VyKHN0YXJ0SWR4KSB8fCBzdGFydElkeCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGFydGluZyBpbmRleCB0byBzY2FuIGZvciBhZGRyZXNzZXMnKTtcbiAgICB9XG4gICAgbGV0IG51bUl0ZXJhdGlvbiA9IHBhcmFtcy5zY2FuO1xuICAgIGlmIChpc1VuZGVmaW5lZChudW1JdGVyYXRpb24pKSB7XG4gICAgICBudW1JdGVyYXRpb24gPSAyMDtcbiAgICB9IGVsc2UgaWYgKCFpc0ludGVnZXIobnVtSXRlcmF0aW9uKSB8fCBudW1JdGVyYXRpb24gPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNjYW5uaW5nIGZhY3RvcicpO1xuICAgIH1cblxuICAgIC8vIGdldCBvdXIgdXNlciwgYmFja3VwIGtleXNcbiAgICBjb25zdCBrZXlzID0gZ2V0QmlwMzJLZXlzKHRoaXMuYml0Z28sIHBhcmFtcywgeyByZXF1aXJlQml0R29YcHViOiBmYWxzZSB9KTtcblxuICAgIC8vIHdlIG5lZWQgdG8gZGVjb2RlIG91ciBiaXRnb0tleSB0byBhIGJhc2U1OCBhZGRyZXNzXG4gICAgY29uc3QgYml0Z29IZXhBZGRyID0gdGhpcy5wdWJUb0hleEFkZHJlc3ModGhpcy54cHViVG9VbmNvbXByZXNzZWRQdWIocGFyYW1zLmJpdGdvS2V5KSk7XG4gICAgbGV0IHJlY292ZXJ5RnJvbUFkZHJIZXggPSBiaXRnb0hleEFkZHI7XG4gICAgbGV0IHJlY292ZXJ5VG9BZGRyZXNzSGV4ID0gVXRpbHMuZ2V0SGV4QWRkcmVzc0Zyb21CYXNlNThBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKTtcblxuICAgIC8vIGNhbGwgdGhlIG5vZGUgdG8gZ2V0IG91ciBhY2NvdW50IGJhbGFuY2UgZm9yIGJhc2UgYWRkcmVzc1xuICAgIGxldCBhY2NvdW50ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50QmFsYW5jZXNGcm9tTm9kZShVdGlscy5nZXRCYXNlNThBZGRyZXNzRnJvbUhleChyZWNvdmVyeUZyb21BZGRySGV4KSk7XG4gICAgbGV0IHJlY292ZXJ5QW1vdW50ID0gYWNjb3VudC5kYXRhWzBdLmJhbGFuY2U7XG5cbiAgICBsZXQgdXNlclhQcnYgPSBrZXlzWzBdLnRvQmFzZTU4KCk7XG4gICAgbGV0IGlzUmVjZWl2ZUFkZHJlc3MgPSBmYWxzZTtcbiAgICBsZXQgYWRkcmVzc0luZm86IEFkZHJlc3NJbmZvIHwgdW5kZWZpbmVkO1xuXG4gICAgLy8gVG9rZW5zIG11c3QgYmUgcmVjb3ZlcmVkIGJlZm9yZSB0aGUgbmF0aXZlIGFzc2V0LiBGaXJzdCBjb25zdHJ1Y3QgdG9rZW4gdHhuc1xuICAgIGxldCByYXdUb2tlblR4bjogYW55IHwgdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgYWNjb3VudC5kYXRhWzBdLnRyYzIwKSB7XG4gICAgICBmb3IgKGNvbnN0IHRva2VuQ29udHJhY3RBZGRyIG9mIFRPS0VOX0NPTlRSQUNUX0FERFJFU1NFUykge1xuICAgICAgICBpZiAodG9rZW5bdG9rZW5Db250cmFjdEFkZHJdKSB7XG4gICAgICAgICAgY29uc3QgYW1vdW50ID0gdG9rZW5bdG9rZW5Db250cmFjdEFkZHJdO1xuICAgICAgICAgIGNvbnN0IHRva2VuQ29udHJhY3RBZGRySGV4ID0gVXRpbHMuZ2V0SGV4QWRkcmVzc0Zyb21CYXNlNThBZGRyZXNzKHRva2VuQ29udHJhY3RBZGRyKTtcbiAgICAgICAgICByYXdUb2tlblR4biA9IChcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0VHJpZ2dlclNtYXJ0Q29udHJhY3RUcmFuc2FjdGlvbihcbiAgICAgICAgICAgICAgcmVjb3ZlcnlUb0FkZHJlc3NIZXgsXG4gICAgICAgICAgICAgIHJlY292ZXJ5RnJvbUFkZHJIZXgsXG4gICAgICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgICAgICAgdG9rZW5Db250cmFjdEFkZHJIZXhcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLnRyYW5zYWN0aW9uO1xuICAgICAgICAgIHJlY292ZXJ5QW1vdW50ID0gcGFyc2VJbnQoYW1vdW50LCAxMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBidWlsZCBhbmQgc2lnbiB0b2tlbiB0eG5zXG4gICAgaWYgKHJhd1Rva2VuVHhuKSB7XG4gICAgICAvLyBDaGVjayB0aGVyZSBpcyBzdWZmaWNpZW50IG9mIHRoZSBuYXRpdmUgYXNzZXQgdG8gY292ZXIgZmVlc1xuICAgICAgY29uc3QgdHJ4QmFsYW5jZSA9IGFjY291bnQuZGF0YVswXS5iYWxhbmNlO1xuICAgICAgaWYgKHRyeEJhbGFuY2UgPCBTQUZFX1RST05fVE9LRU5fVFJBTlNBQ1RJT05fRkVFKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQW1vdW50IG9mIGZ1bmRzIHRvIHJlY292ZXIgJHt0cnhCYWxhbmNlfSBpcyBsZXNzIHRoYW4gJHtTQUZFX1RST05fVE9LRU5fVFJBTlNBQ1RJT05fRkVFfSBhbmQgd291bGRuJ3QgYmUgYWJsZSB0byBmdW5kIGEgdHJjMjAgc2VuZGBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdHhCdWlsZGVyID0gZ2V0QnVpbGRlcih0aGlzLmdldENoYWluKCkpLmZyb20ocmF3VG9rZW5UeG4pO1xuXG4gICAgICAvLyB0aGlzIHR4IHNob3VsZCBiZSBlbm91Z2ggdG8gZHJvcCBpbnRvIGEgbm9kZVxuICAgICAgaWYgKGlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGb3JPZmZsaW5lVmF1bHQoYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCksIFNBRkVfVFJPTl9UT0tFTl9UUkFOU0FDVElPTl9GRUUsIHJlY292ZXJ5QW1vdW50KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlclBydiA9IHRoaXMueHBydlRvQ29tcHJlc3NlZFBydih1c2VyWFBydik7XG5cbiAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiB1c2VyUHJ2IH0pO1xuXG4gICAgICAvLyBrcnMgcmVjb3ZlcmllcyBkb24ndCBnZXQgc2lnbmVkXG4gICAgICBpZiAoIWlzS3JzUmVjb3ZlcnkgJiYgIWlzUmVjZWl2ZUFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgYmFja3VwWFBydiA9IGtleXNbMV0udG9CYXNlNTgoKTtcbiAgICAgICAgY29uc3QgYmFja3VwUHJ2ID0gdGhpcy54cHJ2VG9Db21wcmVzc2VkUHJ2KGJhY2t1cFhQcnYpO1xuXG4gICAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBiYWNrdXBQcnYgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRGb3JPZmZsaW5lVmF1bHQoYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCksIFNBRkVfVFJPTl9UT0tFTl9UUkFOU0FDVElPTl9GRUUsIHJlY292ZXJ5QW1vdW50KTtcbiAgICB9XG5cbiAgICAvLyBOb3cgbGV0IHVzIHJlY292ZXIgdGhlIG5hdGl2ZSBUcm9uXG4gICAgaWYgKHJlY292ZXJ5QW1vdW50ID4gU0FGRV9UUk9OX1RSQU5TQUNUSU9OX0ZFRSkge1xuICAgICAgY29uc3QgdXNlclhQdWIgPSBrZXlzWzBdLm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcbiAgICAgIGNvbnN0IGJhY2t1cFhQdWIgPSBrZXlzWzFdLm5ldXRlcmVkKCkudG9CYXNlNTgoKTtcblxuICAgICAgLy8gY2hlY2sgbXVsdGlzaWcgcGVybWlzc2lvbnNcbiAgICAgIGNvbnN0IGtleUhleEFkZHJlc3NlcyA9IFtcbiAgICAgICAgdGhpcy5wdWJUb0hleEFkZHJlc3ModGhpcy54cHViVG9VbmNvbXByZXNzZWRQdWIodXNlclhQdWIpKSxcbiAgICAgICAgdGhpcy5wdWJUb0hleEFkZHJlc3ModGhpcy54cHViVG9VbmNvbXByZXNzZWRQdWIoYmFja3VwWFB1YikpLFxuICAgICAgICBiaXRnb0hleEFkZHIsXG4gICAgICBdO1xuICAgICAgLy8gcnVuIGNoZWNrcyB0byBlbnN1cmUgdGhpcyBpcyBhIHZhbGlkIHR4IC0gcGVybWlzc2lvbnMgbWF0Y2ggb3VyIHNpZ25lciBrZXlzXG4gICAgICBjb25zdCBvd25lcktleXM6IHsgYWRkcmVzczogc3RyaW5nOyB3ZWlnaHQ6IG51bWJlciB9W10gPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGFjY291bnQuZGF0YVswXS5vd25lcl9wZXJtaXNzaW9uLmtleXMpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IFV0aWxzLmdldEhleEFkZHJlc3NGcm9tQmFzZTU4QWRkcmVzcyhrZXkuYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IGtleS53ZWlnaHQ7XG4gICAgICAgIG93bmVyS2V5cy5wdXNoKHsgYWRkcmVzcywgd2VpZ2h0IH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aXZlUGVybWlzc2lvbktleXM6IHsgYWRkcmVzczogc3RyaW5nOyB3ZWlnaHQ6IG51bWJlciB9W10gPSBbXTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGFjY291bnQuZGF0YVswXS5hY3RpdmVfcGVybWlzc2lvblswXS5rZXlzKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBVdGlscy5nZXRIZXhBZGRyZXNzRnJvbUJhc2U1OEFkZHJlc3Moa2V5LmFkZHJlc3MpO1xuICAgICAgICBjb25zdCB3ZWlnaHQgPSBrZXkud2VpZ2h0O1xuICAgICAgICBhY3RpdmVQZXJtaXNzaW9uS2V5cy5wdXNoKHsgYWRkcmVzcywgd2VpZ2h0IH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja1Blcm1pc3Npb25zKG93bmVyS2V5cywga2V5SGV4QWRkcmVzc2VzKTtcbiAgICAgIHRoaXMuY2hlY2tQZXJtaXNzaW9ucyhhY3RpdmVQZXJtaXNzaW9uS2V5cywga2V5SGV4QWRkcmVzc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hlY2sgcmVjZWl2ZSBhZGRyZXNzZXMgZm9yIGZ1bmRzXG4gICAgICAvLyBDaGVjayBmb3IgZmlyc3QgZGVyaXZlZCB3YWxsZXQgd2l0aCBmdW5kc1xuICAgICAgLy8gUmVjZWl2ZSBhZGRyZXNzZXMgYXJlIGRlcml2ZWQgZnJvbSB0aGUgdXNlciBrZXlcbiAgICAgIGZvciAobGV0IGkgPSBzdGFydElkeDsgaSA8IG51bUl0ZXJhdGlvbiArIHN0YXJ0SWR4OyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSBgMC8wLzAvJHtpfWA7XG4gICAgICAgIGNvbnN0IHVzZXJLZXkgPSBrZXlzWzBdLmRlcml2ZVBhdGgoZGVyaXZhdGlvblBhdGgpO1xuICAgICAgICBjb25zdCB4cHViID0gdXNlcktleS5uZXV0ZXJlZCgpO1xuICAgICAgICBjb25zdCByZWNlaXZlQWRkcmVzcyA9IHRoaXMucHViVG9IZXhBZGRyZXNzKHRoaXMueHB1YlRvVW5jb21wcmVzc2VkUHViKHhwdWIudG9CYXNlNTgoKSkpO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gVXRpbHMuZ2V0QmFzZTU4QWRkcmVzc0Zyb21IZXgocmVjZWl2ZUFkZHJlc3MpO1xuICAgICAgICAvLyBjYWxsIHRoZSBub2RlIHRvIGdldCBvdXIgYWNjb3VudCBiYWxhbmNlXG4gICAgICAgIGNvbnN0IGFjY291bnRJbmZvID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50QmFsYW5jZXNGcm9tTm9kZShhZGRyZXNzKTtcblxuICAgICAgICBpZiAoYWNjb3VudEluZm8uZGF0YVswXSAmJiBhY2NvdW50SW5mby5kYXRhWzBdLmJhbGFuY2UgPiBTQUZFX1RST05fVFJBTlNBQ1RJT05fRkVFKSB7XG4gICAgICAgICAgYWNjb3VudCA9IGFjY291bnRJbmZvO1xuICAgICAgICAgIHJlY292ZXJ5QW1vdW50ID0gYWNjb3VudEluZm8uZGF0YVswXS5iYWxhbmNlO1xuICAgICAgICAgIHVzZXJYUHJ2ID0gdXNlcktleS50b0Jhc2U1OCgpOyAvLyBhc3NpZ24gZGVyaXZlZCB1c2VyWFByeFxuICAgICAgICAgIGlzUmVjZWl2ZUFkZHJlc3MgPSB0cnVlO1xuICAgICAgICAgIHJlY292ZXJ5RnJvbUFkZHJIZXggPSByZWNlaXZlQWRkcmVzcztcbiAgICAgICAgICByZWNvdmVyeVRvQWRkcmVzc0hleCA9IGJpdGdvSGV4QWRkcjtcbiAgICAgICAgICBhZGRyZXNzSW5mbyA9IHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBjaGFpbjogMCxcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhIHN3ZWVwIHBvdGVudGlhbGx5IG5lZWRzIHRvIHBheSBmb3IgbXVsdGktc2lnIHRyYW5zZmVyLCBkZXN0aW5hdGlvbiBhY2NvdW50IGFjdGl2YXRpb24gYW5kIGJhbmR3aWR0aFxuICAgIC8vIFRST04gZm91bmRhdGlvbiByZWNvbW1lbmRzIDIuMSBUUlggZm9yIGd1YXJhbnRlZWQgY29uZmlybWF0aW9uXG4gICAgaWYgKCFyZWNvdmVyeUFtb3VudCB8fCBTQUZFX1RST05fVFJBTlNBQ1RJT05fRkVFID49IHJlY292ZXJ5QW1vdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBbW91bnQgb2YgZnVuZHMgdG8gcmVjb3ZlciAke3JlY292ZXJ5QW1vdW50fSBpcyBsZXNzIHRoYW4gJHtTQUZFX1RST05fVFJBTlNBQ1RJT05fRkVFfSBhbmQgd291bGRuJ3QgYmUgYWJsZSB0byBmdW5kIGEgc2VuZGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjb3ZlcnlBbW91bnRNaW51c0ZlZXMgPSByZWNvdmVyeUFtb3VudCAtIFNBRkVfVFJPTl9UUkFOU0FDVElPTl9GRUU7XG4gICAgY29uc3QgYnVpbGRUeCA9IGF3YWl0IHRoaXMuZ2V0QnVpbGRUcmFuc2FjdGlvbihyZWNvdmVyeVRvQWRkcmVzc0hleCwgcmVjb3ZlcnlGcm9tQWRkckhleCwgcmVjb3ZlcnlBbW91bnRNaW51c0ZlZXMpO1xuXG4gICAgLy8gY29uc3RydWN0IG91ciB0eFxuICAgIGNvbnN0IHR4QnVpbGRlciA9IChnZXRCdWlsZGVyKHRoaXMuZ2V0Q2hhaW4oKSkgYXMgV3JhcHBlZEJ1aWxkZXIpLmZyb20oYnVpbGRUeCk7XG4gICAgLy8gRGVmYXVsdCBleHBpcnkgaXMgMSBtaW51dGUgd2hpY2ggaXMgdG9vIHNob3J0IGZvciByZWNvdmVyeSBwdXJwb3Nlc1xuICAgIC8vIGV4dGVuZCB0aGUgZXhwaXJ5IHRvIDEgZGF5XG4gICAgdHhCdWlsZGVyLmV4dGVuZFZhbGlkVG8oUkVDT1ZFUl9UUkFOU0FDVElPTl9FWFBJUlkpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG5cbiAgICAvLyB0aGlzIHR4IHNob3VsZCBiZSBlbm91Z2ggdG8gZHJvcCBpbnRvIGEgbm9kZVxuICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdEZvck9mZmxpbmVWYXVsdCh0eCwgU0FGRV9UUk9OX1RSQU5TQUNUSU9OX0ZFRSwgcmVjb3ZlcnlBbW91bnRNaW51c0ZlZXMsIGFkZHJlc3NJbmZvKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyUHJ2ID0gdGhpcy54cHJ2VG9Db21wcmVzc2VkUHJ2KHVzZXJYUHJ2KTtcblxuICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiB1c2VyUHJ2IH0pO1xuXG4gICAgLy8ga3JzIHJlY292ZXJpZXMgZG9uJ3QgZ2V0IHNpZ25lZFxuICAgIGlmICghaXNLcnNSZWNvdmVyeSAmJiAhaXNSZWNlaXZlQWRkcmVzcykge1xuICAgICAgY29uc3QgYmFja3VwWFBydiA9IGtleXNbMV0udG9CYXNlNTgoKTtcbiAgICAgIGNvbnN0IGJhY2t1cFBydiA9IHRoaXMueHBydlRvQ29tcHJlc3NlZFBydihiYWNrdXBYUHJ2KTtcblxuICAgICAgdHhCdWlsZGVyLnNpZ24oeyBrZXk6IGJhY2t1cFBydiB9KTtcbiAgICB9XG4gICAgY29uc3QgdHhTaWduZWQgPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICByZXR1cm4gdGhpcy5mb3JtYXRGb3JPZmZsaW5lVmF1bHQodHhTaWduZWQsIFNBRkVfVFJPTl9UUkFOU0FDVElPTl9GRUUsIHJlY292ZXJ5QW1vdW50TWludXNGZWVzLCBhZGRyZXNzSW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIG5hdGl2ZSBUUlggcmVjb3ZlcmllcyBvZiByZWNlaXZlIGFkZHJlc3NlcyBpbiBiYXRjaCB3aXRob3V0IEJpdEdvLlxuICAgKiBGdW5kcyB3aWxsIGJlIHJlY292ZXJlZCB0byBiYXNlIGFkZHJlc3MgZmlyc3QuIFlvdSBuZWVkIHRvIGluaXRpYXRlIGFub3RoZXIgc3dlZXAgdHhuIGFmdGVyIHRoYXQuXG4gICAqIE5vdGU6IHRoZXJlIHdpbGwgYmUgYW5vdGhlciByZWNvdmVyVG9rZW5Db25zb2xpZGF0aW9ucyBmdW5jdGlvbiB0byBzdXBwb3J0IHRva2VuIHJlY292ZXIgZnJvbSByZWNlaXZlIGFkZHJlc3Nlcy5cbiAgICpcbiAgICogQHBhcmFtIHtDb25zb2xpZGF0aW9uUmVjb3ZlcnlPcHRpb25zfSBwYXJhbXMgLSBvcHRpb25zIGZvciBjb25zb2xpZGF0aW9uIHJlY292ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5zdGFydGluZ1NjYW5JbmRleF0gLSByZWNlaXZlIGFkZHJlc3MgaW5kZXggdG8gc3RhcnQgc2Nhbm5pbmcgZnJvbS4gZGVmYXVsdCB0byAxIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5lbmRpbmdTY2FuSW5kZXhdIC0gcmVjZWl2ZSBhZGRyZXNzIGluZGV4IHRvIGVuZCBzY2FubmluZyBhdC4gZGVmYXVsdCB0byBzdGFydGluZ1NjYW5JbmRleCArIDIwIChleGNsdXNpdmUpLlxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlckNvbnNvbGlkYXRpb25zKHBhcmFtczogQ29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8Q29uc29saWRhdGlvblJlY292ZXJ5QmF0Y2g+IHtcbiAgICBjb25zdCBpc1Vuc2lnbmVkQ29uc29saWRhdGlvbnMgPSBnZXRJc1Vuc2lnbmVkU3dlZXAocGFyYW1zKTtcbiAgICBjb25zdCBzdGFydElkeCA9IHBhcmFtcy5zdGFydGluZ1NjYW5JbmRleCB8fCAxO1xuICAgIGNvbnN0IGVuZElkeCA9IHBhcmFtcy5lbmRpbmdTY2FuSW5kZXggfHwgc3RhcnRJZHggKyBERUZBVUxUX1NDQU5fRkFDVE9SO1xuXG4gICAgaWYgKHN0YXJ0SWR4IDwgMSB8fCBlbmRJZHggPD0gc3RhcnRJZHggfHwgZW5kSWR4IC0gc3RhcnRJZHggPiAxMCAqIERFRkFVTFRfU0NBTl9GQUNUT1IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgc3RhcnRpbmcgb3IgZW5kaW5nIGluZGV4IHRvIHNjYW4gZm9yIGFkZHJlc3Nlcy4gc3RhcnRpbmdTY2FuSW5kZXg6ICR7c3RhcnRJZHh9LCBlbmRpbmdTY2FuSW5kZXg6ICR7ZW5kSWR4fS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBnZXRCaXAzMktleXModGhpcy5iaXRnbywgcGFyYW1zLCB7IHJlcXVpcmVCaXRHb1hwdWI6IGZhbHNlIH0pO1xuICAgIGNvbnN0IGJhc2VBZGRySGV4ID0gdGhpcy5wdWJUb0hleEFkZHJlc3ModGhpcy54cHViVG9VbmNvbXByZXNzZWRQdWIocGFyYW1zLmJpdGdvS2V5KSk7XG5cbiAgICBjb25zdCB0eG5zQmF0Y2g6IFJlY292ZXJ5VHJhbnNhY3Rpb25bXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBzdGFydElkeDsgaSA8IGVuZElkeDsgaSsrKSB7XG4gICAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9IGAwLzAvMC8ke2l9YDtcbiAgICAgIGNvbnN0IHVzZXJLZXkgPSBrZXlzWzBdLmRlcml2ZVBhdGgoZGVyaXZhdGlvblBhdGgpO1xuICAgICAgY29uc3QgdXNlcktleVhQdWIgPSB1c2VyS2V5Lm5ldXRlcmVkKCk7XG4gICAgICBjb25zdCByZWNlaXZlQWRkcmVzc0hleCA9IHRoaXMucHViVG9IZXhBZGRyZXNzKHRoaXMueHB1YlRvVW5jb21wcmVzc2VkUHViKHVzZXJLZXlYUHViLnRvQmFzZTU4KCkpKTtcbiAgICAgIGNvbnN0IHJlY2VpdmVBZGRyZXNzID0gVXRpbHMuZ2V0QmFzZTU4QWRkcmVzc0Zyb21IZXgocmVjZWl2ZUFkZHJlc3NIZXgpO1xuICAgICAgLy8gY2FsbCB0aGUgbm9kZSB0byBnZXQgb3VyIGFjY291bnQgYmFsYW5jZVxuICAgICAgY29uc3QgYWNjb3VudEluZm8gPSBhd2FpdCB0aGlzLmdldEFjY291bnRCYWxhbmNlc0Zyb21Ob2RlKHJlY2VpdmVBZGRyZXNzKTtcblxuICAgICAgaWYgKGFjY291bnRJbmZvLmRhdGFbMF0gJiYgYWNjb3VudEluZm8uZGF0YVswXS5iYWxhbmNlID4gU0FGRV9UUk9OX1RSQU5TQUNUSU9OX0ZFRSkge1xuICAgICAgICBjb25zdCBhZGRyZXNzQmFsYW5jZSA9IGFjY291bnRJbmZvLmRhdGFbMF0uYmFsYW5jZTtcbiAgICAgICAgY29uc3QgYWRkcmVzc0luZm8gPSB7XG4gICAgICAgICAgYWRkcmVzczogcmVjZWl2ZUFkZHJlc3MsXG4gICAgICAgICAgY2hhaW46IDAsXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlY292ZXJ5QW1vdW50ID0gYWRkcmVzc0JhbGFuY2UgLSBTQUZFX1RST05fVFJBTlNBQ1RJT05fRkVFO1xuICAgICAgICBjb25zdCBidWlsZFR4ID0gYXdhaXQgdGhpcy5nZXRCdWlsZFRyYW5zYWN0aW9uKGJhc2VBZGRySGV4LCByZWNlaXZlQWRkcmVzc0hleCwgcmVjb3ZlcnlBbW91bnQpO1xuICAgICAgICAvLyBjb25zdHJ1Y3Qgb3VyIHR4XG4gICAgICAgIGNvbnN0IHR4QnVpbGRlciA9IChnZXRCdWlsZGVyKHRoaXMuZ2V0Q2hhaW4oKSkgYXMgV3JhcHBlZEJ1aWxkZXIpLmZyb20oYnVpbGRUeCk7XG4gICAgICAgIC8vIERlZmF1bHQgZXhwaXJ5IGlzIDEgbWludXRlIHdoaWNoIGlzIHRvbyBzaG9ydCBmb3IgcmVjb3ZlcnkgcHVycG9zZXNcbiAgICAgICAgLy8gZXh0ZW5kIHRoZSBleHBpcnkgdG8gMSBkYXlcbiAgICAgICAgdHhCdWlsZGVyLmV4dGVuZFZhbGlkVG8oUkVDT1ZFUl9UUkFOU0FDVElPTl9FWFBJUlkpO1xuXG4gICAgICAgIGlmICghaXNVbnNpZ25lZENvbnNvbGlkYXRpb25zKSB7XG4gICAgICAgICAgY29uc3QgdXNlclBydiA9IHRoaXMueHBydlRvQ29tcHJlc3NlZFBydih1c2VyS2V5LnRvQmFzZTU4KCkpO1xuICAgICAgICAgIC8vIHJlY2VpdmUgYWRkcmVzcyBvbmx5IG5lZWRzIHRvIGJlIHNpZ25lZCBieSB1c2VyIGtleVxuICAgICAgICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiB1c2VyUHJ2IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgICAgIHR4bnNCYXRjaC5wdXNoKHRoaXMuZm9ybWF0Rm9yT2ZmbGluZVZhdWx0KHR4LCBTQUZFX1RST05fVFJBTlNBQ1RJT05fRkVFLCByZWNvdmVyeUFtb3VudCwgYWRkcmVzc0luZm8pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNhY3Rpb25zOiB0eG5zQmF0Y2gsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluIGEgVHJvbiB0cmFuc2FjdGlvbiBmcm9tIHR4SGV4XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFRyb25UcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICBpZiAoIXR4SGV4IHx8ICFwYXJhbXMuZmVlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgIH1cbiAgICBjb25zdCB0eEJ1aWxkZXIgPSBnZXRCdWlsZGVyKHRoaXMuZ2V0Q2hhaW4oKSkuZnJvbSh0eEhleCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCBvdXRwdXRzID0gW1xuICAgICAge1xuICAgICAgICBhbW91bnQ6IHR4Lm91dHB1dHNbMF0udmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgYWRkcmVzczogdHgub3V0cHV0c1swXS5hZGRyZXNzLCAvLyBTaG91bGQgdHVybiBpdCBpbnRvIGEgcmVhZGFibGUgZm9ybWF0LCBha2EgYmFzZTU4XG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCBkaXNwbGF5T3JkZXIgPSBbXG4gICAgICAnaWQnLFxuICAgICAgJ291dHB1dEFtb3VudCcsXG4gICAgICAnY2hhbmdlQW1vdW50JyxcbiAgICAgICdvdXRwdXRzJyxcbiAgICAgICdjaGFuZ2VPdXRwdXRzJyxcbiAgICAgICdmZWUnLFxuICAgICAgJ3RpbWVzdGFtcCcsXG4gICAgICAnZXhwaXJhdGlvbicsXG4gICAgXTtcblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5T3JkZXIsXG4gICAgICBpZDogdHguaWQsXG4gICAgICBvdXRwdXRzLFxuICAgICAgb3V0cHV0QW1vdW50OiBvdXRwdXRzWzBdLmFtb3VudCxcbiAgICAgIGNoYW5nZU91dHB1dHM6IFtdLCAvLyBhY2NvdW50IGJhc2VkIGRvZXMgbm90IHVzZSBjaGFuZ2Ugb3V0cHV0c1xuICAgICAgY2hhbmdlQW1vdW50OiAnMCcsIC8vIGFjY291bnQgYmFzZSBkb2VzIG5vdCBtYWtlIGNoYW5nZVxuICAgICAgZmVlOiBwYXJhbXMuZmVlSW5mbyxcbiAgICAgIHRpbWVzdGFtcDogdHgudmFsaWRGcm9tLFxuICAgICAgZXhwaXJhdGlvbjogdHgudmFsaWRUbyxcbiAgICB9O1xuICB9XG59XG4iXX0=