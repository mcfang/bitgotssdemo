"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeDataParams = exports.encodeDataParams = exports.toHex = exports.isValidRawTransactionFormat = exports.isValidTxJsonString = exports.decodeAccountPermissionUpdateContract = exports.decodeTriggerSmartContract = exports.decodeTransferContract = exports.isValidHex = exports.decodeRawTransaction = exports.decodeTransaction = exports.getRawAddressFromPubKey = exports.signString = exports.signTransaction = exports.getBase58AddressFromHex = exports.getBase58AddressFromByteArray = exports.getAddressFromPriKey = exports.getPubKeyFromPriKey = exports.getHexAddressFromBase58Address = exports.verifySignature = exports.getHexAddressFromByteArray = exports.getByteArrayFromHexAddress = exports.isBase58Address = exports.tokenTestnetContractAddresses = exports.tokenMainnetContractAddresses = void 0;
const assert_1 = __importDefault(require("assert"));
const hex = __importStar(require("@stablelib/hex"));
const tronweb = __importStar(require("tronweb"));
const tron_1 = require("../../resources/protobuf/tron");
const sdk_core_1 = require("@bitgo/sdk-core");
const enum_1 = require("./enum");
const utils_1 = require("ethers/lib/utils");
const ADDRESS_PREFIX_REGEX = /^(41)/;
const ADDRESS_PREFIX = '41';
exports.tokenMainnetContractAddresses = [
    'TEkxiTehnzSmSe2XqrBj4w32RUN966rdz8',
    'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
];
exports.tokenTestnetContractAddresses = [
    'TSdZwNqpHofzP6BsBKGQUWdBeJphLmF6id',
    'TG3XXyExBkPp9nzdajDZsozEu4BkaSJozs',
];
/**
 * @param address
 */
function isBase58Address(address) {
    return tronweb.utils.crypto.isAddressValid(address);
}
exports.isBase58Address = isBase58Address;
/**
 * @param str
 */
function getByteArrayFromHexAddress(str) {
    return tronweb.utils.code.hexStr2byteArray(str.replace('0x', ''));
}
exports.getByteArrayFromHexAddress = getByteArrayFromHexAddress;
/**
 * @param arr
 */
function getHexAddressFromByteArray(arr) {
    return tronweb.utils.code.byteArray2hexStr(arr);
}
exports.getHexAddressFromByteArray = getHexAddressFromByteArray;
/**
 * @param messageToVerify
 * @param base58Address
 * @param sigHex
 * @param useTronHeader
 */
function verifySignature(messageToVerify, base58Address, sigHex, useTronHeader = true) {
    if (!isValidHex(sigHex)) {
        throw new sdk_core_1.UtilsError('signature is not in a valid format, needs to be hexadecimal');
    }
    if (!isValidHex(messageToVerify)) {
        throw new sdk_core_1.UtilsError('message is not in a valid format, needs to be hexadecimal');
    }
    if (!isBase58Address(base58Address)) {
        throw new sdk_core_1.UtilsError('address needs to be base58 encoded');
    }
    return tronweb.Trx.verifySignature(messageToVerify, base58Address, sigHex, useTronHeader);
}
exports.verifySignature = verifySignature;
/**
 * @param base58
 */
function getHexAddressFromBase58Address(base58) {
    // pulled from: https://github.com/TRON-US/tronweb/blob/dcb8efa36a5ebb65c4dab3626e90256a453f3b0d/src/utils/help.js#L17
    // but they don't surface this call in index.js
    const bytes = tronweb.utils.crypto.decodeBase58Address(base58);
    return getHexAddressFromByteArray(bytes);
}
exports.getHexAddressFromBase58Address = getHexAddressFromBase58Address;
/**
 * @param privateKey
 */
function getPubKeyFromPriKey(privateKey) {
    return tronweb.utils.crypto.getPubKeyFromPriKey(privateKey);
}
exports.getPubKeyFromPriKey = getPubKeyFromPriKey;
/**
 * @param privateKey
 */
function getAddressFromPriKey(privateKey) {
    return tronweb.utils.crypto.getAddressFromPriKey(privateKey);
}
exports.getAddressFromPriKey = getAddressFromPriKey;
/**
 * @param address
 */
function getBase58AddressFromByteArray(address) {
    return tronweb.utils.crypto.getBase58CheckAddress(address);
}
exports.getBase58AddressFromByteArray = getBase58AddressFromByteArray;
/**
 * @param hex
 */
function getBase58AddressFromHex(hex) {
    const arr = getByteArrayFromHexAddress(hex);
    return getBase58AddressFromByteArray(arr);
}
exports.getBase58AddressFromHex = getBase58AddressFromHex;
/**
 * @param privateKey
 * @param transaction
 */
function signTransaction(privateKey, transaction) {
    return tronweb.utils.crypto.signTransaction(privateKey, transaction);
}
exports.signTransaction = signTransaction;
/**
 * @param message
 * @param privateKey
 * @param useTronHeader
 */
function signString(message, privateKey, useTronHeader = true) {
    return tronweb.Trx.signString(message, privateKey, useTronHeader);
}
exports.signString = signString;
/**
 * @param pubBytes
 */
function getRawAddressFromPubKey(pubBytes) {
    return tronweb.utils.crypto.computeAddress(pubBytes);
}
exports.getRawAddressFromPubKey = getRawAddressFromPubKey;
/**
 * Decodes a hex encoded transaction in its protobuf representation.
 *
 * @param hexString raw_data_hex field from tron transactions
 */
function decodeTransaction(hexString) {
    const rawTransaction = decodeRawTransaction(hexString);
    // there should not be multiple contracts in this data
    if (rawTransaction.contracts.length !== 1) {
        throw new sdk_core_1.UtilsError('Number of contracts is greater than 1.');
    }
    let contract;
    let contractType;
    // ensure the contract type is supported
    switch (rawTransaction.contracts[0].parameter.type_url) {
        case 'type.googleapis.com/protocol.TransferContract':
            contractType = enum_1.ContractType.Transfer;
            contract = exports.decodeTransferContract(rawTransaction.contracts[0].parameter.value);
            break;
        case 'type.googleapis.com/protocol.AccountPermissionUpdateContract':
            contractType = enum_1.ContractType.AccountPermissionUpdate;
            contract = exports.decodeAccountPermissionUpdateContract(rawTransaction.contracts[0].parameter.value);
            break;
        case 'type.googleapis.com/protocol.TriggerSmartContract':
            contractType = enum_1.ContractType.TriggerSmartContract;
            contract = exports.decodeTriggerSmartContract(rawTransaction.contracts[0].parameter.value);
            break;
        default:
            throw new sdk_core_1.UtilsError('Unsupported contract type');
    }
    return {
        contractType,
        contract,
        expiration: rawTransaction.expiration,
        timestamp: rawTransaction.timestamp,
        ref_block_bytes: rawTransaction.blockBytes,
        ref_block_hash: rawTransaction.blockHash,
        fee_limit: +rawTransaction.feeLimit,
    };
}
exports.decodeTransaction = decodeTransaction;
/**
 * Decodes a transaction's raw field from a base64 encoded string. This is a protobuf representation.
 *
 * @param hexString this is the raw hexadecimal encoded string. Doc found in the following link.
 * @example
 * @see {@link https://github.com/BitGo/bitgo-account-lib/blob/5f282588701778a4421c75fa61f42713f56e95b9/resources/protobuf/tron.proto#L319}
 */
function decodeRawTransaction(hexString) {
    const bytes = Buffer.from(hexString, 'hex');
    let raw;
    try {
        // we need to decode our raw_data_hex field first
        raw = tron_1.protocol.Transaction.raw.decode(bytes);
    }
    catch (e) {
        throw new sdk_core_1.UtilsError('There was an error decoding the initial raw_data_hex from the serialized tx.');
    }
    return {
        expiration: Number(raw.expiration),
        timestamp: Number(raw.timestamp),
        contracts: raw.contract,
        blockBytes: toHex(raw.refBlockBytes),
        feeLimit: raw.feeLimit,
        blockHash: toHex(raw.refBlockHash),
    };
}
exports.decodeRawTransaction = decodeRawTransaction;
/**
 * Indicates whether the passed string is a safe hex string for tron's purposes.
 *
 * @param hex A valid hex string must be a string made of numbers and characters and has an even length.
 */
function isValidHex(hex) {
    return /^(0x)?([0-9a-f]{2})+$/i.test(hex);
}
exports.isValidHex = isValidHex;
/** Deserialize the segment of the txHex which corresponds with the details of the transfer
 *
 * @param transferHex is the value property of the "parameter" field of contractList[0]
 * */
function decodeTransferContract(transferHex) {
    const contractBytes = Buffer.from(transferHex, 'base64');
    let transferContract;
    try {
        transferContract = tron_1.protocol.TransferContract.decode(contractBytes);
    }
    catch (e) {
        throw new sdk_core_1.UtilsError('There was an error decoding the transfer contract in the transaction.');
    }
    if (!transferContract.ownerAddress) {
        throw new sdk_core_1.UtilsError('Owner address does not exist in this transfer contract.');
    }
    if (!transferContract.toAddress) {
        throw new sdk_core_1.UtilsError('Destination address does not exist in this transfer contract.');
    }
    if (!transferContract.hasOwnProperty('amount')) {
        throw new sdk_core_1.UtilsError('Amount does not exist in this transfer contract.');
    }
    // deserialize attributes
    const owner_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.ownerAddress, 'base64').toString('hex')));
    const to_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(transferContract.toAddress, 'base64').toString('hex')));
    const amount = transferContract.amount;
    return [
        {
            parameter: {
                value: {
                    amount: Number(amount),
                    owner_address,
                    to_address,
                },
            },
        },
    ];
}
exports.decodeTransferContract = decodeTransferContract;
/**
 * Deserialize the segment of the txHex corresponding with trigger smart contract
 *
 * @param {string} base64
 * @returns {AccountPermissionUpdateContract}
 */
function decodeTriggerSmartContract(base64) {
    let contractCallDecoded;
    try {
        contractCallDecoded = tron_1.protocol.TriggerSmartContract.decode(Buffer.from(base64, 'base64')).toJSON();
    }
    catch (e) {
        throw new sdk_core_1.UtilsError('There was an error decoding the contract call in the transaction.');
    }
    if (!contractCallDecoded.ownerAddress) {
        throw new sdk_core_1.UtilsError('Owner address does not exist in this contract call.');
    }
    if (!contractCallDecoded.contractAddress) {
        throw new sdk_core_1.UtilsError('Destination contract address does not exist in this contract call.');
    }
    if (!contractCallDecoded.data) {
        throw new sdk_core_1.UtilsError('Data does not exist in this contract call.');
    }
    // deserialize attributes
    const owner_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(contractCallDecoded.ownerAddress, 'base64').toString('hex')));
    const contract_address = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(contractCallDecoded.contractAddress, 'base64').toString('hex')));
    const data = contractCallDecoded.data;
    return [
        {
            parameter: {
                value: {
                    data: data,
                    owner_address,
                    contract_address,
                },
            },
        },
    ];
}
exports.decodeTriggerSmartContract = decodeTriggerSmartContract;
/**
 * Deserialize the segment of the txHex corresponding with the details of the contract which updates
 * account permission
 *
 * @param {string} base64
 * @returns {AccountPermissionUpdateContract}
 */
function decodeAccountPermissionUpdateContract(base64) {
    const accountUpdateContract = tron_1.protocol.AccountPermissionUpdateContract.decode(Buffer.from(base64, 'base64')).toJSON();
    assert_1.default(accountUpdateContract.ownerAddress);
    assert_1.default(accountUpdateContract.owner);
    assert_1.default(accountUpdateContract.hasOwnProperty('actives'));
    const ownerAddress = getBase58AddressFromByteArray(getByteArrayFromHexAddress(Buffer.from(accountUpdateContract.ownerAddress, 'base64').toString('hex')));
    const owner = createPermission(accountUpdateContract.owner);
    let witness = undefined;
    if (accountUpdateContract.witness) {
        witness = createPermission(accountUpdateContract.witness);
    }
    const activeList = accountUpdateContract.actives.map((active) => createPermission(active));
    return {
        ownerAddress,
        owner,
        witness,
        actives: activeList,
    };
}
exports.decodeAccountPermissionUpdateContract = decodeAccountPermissionUpdateContract;
/**
 * @param raw
 */
function createPermission(raw) {
    let permissionType;
    const permission = raw.permissionName.toLowerCase().trim();
    if (permission === 'owner') {
        permissionType = enum_1.PermissionType.Owner;
    }
    else if (permission === 'witness') {
        permissionType = enum_1.PermissionType.Witness;
    }
    else if (permission.substr(0, 6) === 'active') {
        permissionType = enum_1.PermissionType.Active;
    }
    else {
        throw new sdk_core_1.UtilsError('Permission type not parseable.');
    }
    return { type: permissionType, threshold: raw.threshold };
}
/**
 * @param rawTransaction
 */
function isValidTxJsonString(rawTransaction) {
    const transaction = JSON.parse(rawTransaction);
    return transaction.hasOwnProperty('txID');
}
exports.isValidTxJsonString = isValidTxJsonString;
/**
 * Returns whether the provided raw transaction accommodates to bitgo's preferred format
 *
 * @param {any} rawTransaction - The raw transaction to be checked
 * @returns {boolean} the validation result
 */
function isValidRawTransactionFormat(rawTransaction) {
    if (typeof rawTransaction === 'string' && (isValidHex(rawTransaction) || isValidTxJsonString(rawTransaction))) {
        return true;
    }
    return false;
}
exports.isValidRawTransactionFormat = isValidRawTransactionFormat;
/**
 * Returns an hex string of the given buffer
 *
 * @param {Buffer | Uint8Array} buffer - the buffer to be converted to hex
 * @returns {string} - the hex value
 */
function toHex(buffer) {
    return hex.encode(buffer, true);
}
exports.toHex = toHex;
/**
 * Returns a Keccak-256 encoded string of the parameters
 *
 * @param types - strings describing the types of the values
 * @param values - value to encode
 * @param methodId - the first 4 bytes of the function selector
 */
function encodeDataParams(types, values, methodId) {
    types.forEach((type, index) => {
        if (type == 'address') {
            values[index] = values[index].replace(ADDRESS_PREFIX_REGEX, '0x');
        }
    });
    const abiCoder = new utils_1.AbiCoder();
    let data;
    try {
        data = abiCoder.encode(types, values);
    }
    catch (e) {
        throw new sdk_core_1.UtilsError('There was an error encoding the data params.');
    }
    if (methodId) {
        return utils_1.hexConcat([methodId, data]).replace(/^(0x)/, '');
    }
    else {
        return data.replace(/^(0x)/, '');
    }
}
exports.encodeDataParams = encodeDataParams;
/**
 * Returns the decoded values according to the array of types
 *
 * @param types - strings describing the types of the values
 * @param data - encoded string
 */
function decodeDataParams(types, data) {
    const abiCoder = new utils_1.AbiCoder();
    data = '0x' + data.substring(8);
    return abiCoder.decode(types, data).reduce((obj, arg, index) => {
        if (types[index] == 'address')
            arg = ADDRESS_PREFIX + arg.substr(2).toLowerCase();
        obj.push(arg);
        return obj;
    }, []);
}
exports.decodeDataParams = decodeDataParams;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvREFBNEI7QUFDNUIsb0RBQXNDO0FBQ3RDLGlEQUFtQztBQUNuQyx3REFBeUQ7QUFFekQsOENBQTZDO0FBUzdDLGlDQUFzRDtBQUN0RCw0Q0FBdUQ7QUFFdkQsTUFBTSxvQkFBb0IsR0FBRyxPQUFPLENBQUM7QUFDckMsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDO0FBRWYsUUFBQSw2QkFBNkIsR0FBRztJQUMzQyxvQ0FBb0M7SUFDcEMsb0NBQW9DO0NBQ3JDLENBQUM7QUFDVyxRQUFBLDZCQUE2QixHQUFHO0lBQzNDLG9DQUFvQztJQUNwQyxvQ0FBb0M7Q0FDckMsQ0FBQztBQVFGOztHQUVHO0FBQ0gsU0FBZ0IsZUFBZSxDQUFDLE9BQWU7SUFDN0MsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdEQsQ0FBQztBQUZELDBDQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQiwwQkFBMEIsQ0FBQyxHQUFXO0lBQ3BELE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBRkQsZ0VBRUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLDBCQUEwQixDQUFDLEdBQWM7SUFDdkQsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsRCxDQUFDO0FBRkQsZ0VBRUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGVBQWUsQ0FDN0IsZUFBdUIsRUFDdkIsYUFBcUIsRUFDckIsTUFBYyxFQUNkLGFBQWEsR0FBRyxJQUFJO0lBRXBCLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDdkIsTUFBTSxJQUFJLHFCQUFVLENBQUMsNkRBQTZELENBQUMsQ0FBQztLQUNyRjtJQUVELElBQUksQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLEVBQUU7UUFDaEMsTUFBTSxJQUFJLHFCQUFVLENBQUMsMkRBQTJELENBQUMsQ0FBQztLQUNuRjtJQUVELElBQUksQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLEVBQUU7UUFDbkMsTUFBTSxJQUFJLHFCQUFVLENBQUMsb0NBQW9DLENBQUMsQ0FBQztLQUM1RDtJQUVELE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsZUFBZSxFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDNUYsQ0FBQztBQW5CRCwwQ0FtQkM7QUFFRDs7R0FFRztBQUNILFNBQWdCLDhCQUE4QixDQUFDLE1BQWM7SUFDM0Qsc0hBQXNIO0lBQ3RILCtDQUErQztJQUMvQyxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMvRCxPQUFPLDBCQUEwQixDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFMRCx3RUFLQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsbUJBQW1CLENBQUMsVUFBMEI7SUFDNUQsT0FBTyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUM5RCxDQUFDO0FBRkQsa0RBRUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLG9CQUFvQixDQUFDLFVBQTBCO0lBQzdELE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDL0QsQ0FBQztBQUZELG9EQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQiw2QkFBNkIsQ0FBQyxPQUFrQjtJQUM5RCxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdELENBQUM7QUFGRCxzRUFFQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsdUJBQXVCLENBQUMsR0FBVztJQUNqRCxNQUFNLEdBQUcsR0FBRywwQkFBMEIsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1QyxPQUFPLDZCQUE2QixDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzVDLENBQUM7QUFIRCwwREFHQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLGVBQWUsQ0FBQyxVQUE4QixFQUFFLFdBQStCO0lBQzdGLE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQztBQUN2RSxDQUFDO0FBRkQsMENBRUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsVUFBVSxDQUFDLE9BQWUsRUFBRSxVQUE4QixFQUFFLGFBQWEsR0FBRyxJQUFJO0lBQzlGLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxhQUFhLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBRkQsZ0NBRUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLHVCQUF1QixDQUFDLFFBQXdCO0lBQzlELE9BQU8sT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3ZELENBQUM7QUFGRCwwREFFQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixpQkFBaUIsQ0FBQyxTQUFpQjtJQUNqRCxNQUFNLGNBQWMsR0FBRyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUV2RCxzREFBc0Q7SUFDdEQsSUFBSSxjQUFjLENBQUMsU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDekMsTUFBTSxJQUFJLHFCQUFVLENBQUMsd0NBQXdDLENBQUMsQ0FBQztLQUNoRTtJQUVELElBQUksUUFBeUYsQ0FBQztJQUM5RixJQUFJLFlBQTBCLENBQUM7SUFDL0Isd0NBQXdDO0lBQ3hDLFFBQVEsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO1FBQ3RELEtBQUssK0NBQStDO1lBQ2xELFlBQVksR0FBRyxtQkFBWSxDQUFDLFFBQVEsQ0FBQztZQUNyQyxRQUFRLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3ZGLE1BQU07UUFDUixLQUFLLDhEQUE4RDtZQUNqRSxZQUFZLEdBQUcsbUJBQVksQ0FBQyx1QkFBdUIsQ0FBQztZQUNwRCxRQUFRLEdBQUcsT0FBTyxDQUFDLHFDQUFxQyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RHLE1BQU07UUFDUixLQUFLLG1EQUFtRDtZQUN0RCxZQUFZLEdBQUcsbUJBQVksQ0FBQyxvQkFBb0IsQ0FBQztZQUNqRCxRQUFRLEdBQUcsT0FBTyxDQUFDLDBCQUEwQixDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzNGLE1BQU07UUFDUjtZQUNFLE1BQU0sSUFBSSxxQkFBVSxDQUFDLDJCQUEyQixDQUFDLENBQUM7S0FDckQ7SUFFRCxPQUFPO1FBQ0wsWUFBWTtRQUNaLFFBQVE7UUFDUixVQUFVLEVBQUUsY0FBYyxDQUFDLFVBQVU7UUFDckMsU0FBUyxFQUFFLGNBQWMsQ0FBQyxTQUFTO1FBQ25DLGVBQWUsRUFBRSxjQUFjLENBQUMsVUFBVTtRQUMxQyxjQUFjLEVBQUUsY0FBYyxDQUFDLFNBQVM7UUFDeEMsU0FBUyxFQUFFLENBQUMsY0FBYyxDQUFDLFFBQVE7S0FDcEMsQ0FBQztBQUNKLENBQUM7QUFyQ0QsOENBcUNDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0Isb0JBQW9CLENBQUMsU0FBaUI7SUFRcEQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFFNUMsSUFBSSxHQUFHLENBQUM7SUFDUixJQUFJO1FBQ0YsaURBQWlEO1FBQ2pELEdBQUcsR0FBRyxlQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDOUM7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE1BQU0sSUFBSSxxQkFBVSxDQUFDLDhFQUE4RSxDQUFDLENBQUM7S0FDdEc7SUFFRCxPQUFPO1FBQ0wsVUFBVSxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDO1FBQ2xDLFNBQVMsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQztRQUNoQyxTQUFTLEVBQUUsR0FBRyxDQUFDLFFBQVE7UUFDdkIsVUFBVSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO1FBQ3BDLFFBQVEsRUFBRSxHQUFHLENBQUMsUUFBUTtRQUN0QixTQUFTLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUM7S0FDbkMsQ0FBQztBQUNKLENBQUM7QUExQkQsb0RBMEJDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLFVBQVUsQ0FBQyxHQUFXO0lBQ3BDLE9BQU8sd0JBQXdCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzVDLENBQUM7QUFGRCxnQ0FFQztBQUVEOzs7S0FHSztBQUNMLFNBQWdCLHNCQUFzQixDQUFDLFdBQW1CO0lBQ3hELE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3pELElBQUksZ0JBQWdCLENBQUM7SUFFckIsSUFBSTtRQUNGLGdCQUFnQixHQUFHLGVBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDcEU7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE1BQU0sSUFBSSxxQkFBVSxDQUFDLHVFQUF1RSxDQUFDLENBQUM7S0FDL0Y7SUFFRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFO1FBQ2xDLE1BQU0sSUFBSSxxQkFBVSxDQUFDLHlEQUF5RCxDQUFDLENBQUM7S0FDakY7SUFFRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFO1FBQy9CLE1BQU0sSUFBSSxxQkFBVSxDQUFDLCtEQUErRCxDQUFDLENBQUM7S0FDdkY7SUFFRCxJQUFJLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQzlDLE1BQU0sSUFBSSxxQkFBVSxDQUFDLGtEQUFrRCxDQUFDLENBQUM7S0FDMUU7SUFFRCx5QkFBeUI7SUFDekIsTUFBTSxhQUFhLEdBQUcsNkJBQTZCLENBQ2pELDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUNqRyxDQUFDO0lBQ0YsTUFBTSxVQUFVLEdBQUcsNkJBQTZCLENBQzlDLDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUM5RixDQUFDO0lBQ0YsTUFBTSxNQUFNLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxDQUFDO0lBRXZDLE9BQU87UUFDTDtZQUNFLFNBQVMsRUFBRTtnQkFDVCxLQUFLLEVBQUU7b0JBQ0wsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUM7b0JBQ3RCLGFBQWE7b0JBQ2IsVUFBVTtpQkFDWDthQUNGO1NBQ0Y7S0FDRixDQUFDO0FBQ0osQ0FBQztBQTFDRCx3REEwQ0M7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLDBCQUEwQixDQUFDLE1BQWM7SUFDdkQsSUFBSSxtQkFBbUIsQ0FBQztJQUN4QixJQUFJO1FBQ0YsbUJBQW1CLEdBQUcsZUFBUSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQ3BHO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixNQUFNLElBQUkscUJBQVUsQ0FBQyxtRUFBbUUsQ0FBQyxDQUFDO0tBQzNGO0lBRUQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFlBQVksRUFBRTtRQUNyQyxNQUFNLElBQUkscUJBQVUsQ0FBQyxxREFBcUQsQ0FBQyxDQUFDO0tBQzdFO0lBRUQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGVBQWUsRUFBRTtRQUN4QyxNQUFNLElBQUkscUJBQVUsQ0FBQyxvRUFBb0UsQ0FBQyxDQUFDO0tBQzVGO0lBRUQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRTtRQUM3QixNQUFNLElBQUkscUJBQVUsQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0tBQ3BFO0lBRUQseUJBQXlCO0lBQ3pCLE1BQU0sYUFBYSxHQUFHLDZCQUE2QixDQUNqRCwwQkFBMEIsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFlBQVksRUFBRSxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FDcEcsQ0FBQztJQUNGLE1BQU0sZ0JBQWdCLEdBQUcsNkJBQTZCLENBQ3BELDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsZUFBZSxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUN2RyxDQUFDO0lBQ0YsTUFBTSxJQUFJLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxDQUFDO0lBQ3RDLE9BQU87UUFDTDtZQUNFLFNBQVMsRUFBRTtnQkFDVCxLQUFLLEVBQUU7b0JBQ0wsSUFBSSxFQUFFLElBQUk7b0JBQ1YsYUFBYTtvQkFDYixnQkFBZ0I7aUJBQ2pCO2FBQ0Y7U0FDRjtLQUNGLENBQUM7QUFDSixDQUFDO0FBdkNELGdFQXVDQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQWdCLHFDQUFxQyxDQUFDLE1BQWM7SUFDbEUsTUFBTSxxQkFBcUIsR0FBRyxlQUFRLENBQUMsK0JBQStCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDdEgsZ0JBQU0sQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUMzQyxnQkFBTSxDQUFDLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3BDLGdCQUFNLENBQUMscUJBQXFCLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFFeEQsTUFBTSxZQUFZLEdBQUcsNkJBQTZCLENBQ2hELDBCQUEwQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsWUFBWSxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUN0RyxDQUFDO0lBQ0YsTUFBTSxLQUFLLEdBQWUsZ0JBQWdCLENBQUMscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEUsSUFBSSxPQUFPLEdBQTJCLFNBQVMsQ0FBQztJQUNoRCxJQUFJLHFCQUFxQixDQUFDLE9BQU8sRUFBRTtRQUNqQyxPQUFPLEdBQUcsZ0JBQWdCLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDM0Q7SUFDRCxNQUFNLFVBQVUsR0FBRyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBRTNGLE9BQU87UUFDTCxZQUFZO1FBQ1osS0FBSztRQUNMLE9BQU87UUFDUCxPQUFPLEVBQUUsVUFBVTtLQUNwQixDQUFDO0FBQ0osQ0FBQztBQXRCRCxzRkFzQkM7QUFFRDs7R0FFRztBQUNILFNBQVMsZ0JBQWdCLENBQUMsR0FBa0Q7SUFDMUUsSUFBSSxjQUE4QixDQUFDO0lBQ25DLE1BQU0sVUFBVSxHQUFHLEdBQUcsQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDM0QsSUFBSSxVQUFVLEtBQUssT0FBTyxFQUFFO1FBQzFCLGNBQWMsR0FBRyxxQkFBYyxDQUFDLEtBQUssQ0FBQztLQUN2QztTQUFNLElBQUksVUFBVSxLQUFLLFNBQVMsRUFBRTtRQUNuQyxjQUFjLEdBQUcscUJBQWMsQ0FBQyxPQUFPLENBQUM7S0FDekM7U0FBTSxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLFFBQVEsRUFBRTtRQUMvQyxjQUFjLEdBQUcscUJBQWMsQ0FBQyxNQUFNLENBQUM7S0FDeEM7U0FBTTtRQUNMLE1BQU0sSUFBSSxxQkFBVSxDQUFDLGdDQUFnQyxDQUFDLENBQUM7S0FDeEQ7SUFDRCxPQUFPLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUUsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQzVELENBQUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLG1CQUFtQixDQUFDLGNBQXNCO0lBQ3hELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDL0MsT0FBTyxXQUFXLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzVDLENBQUM7QUFIRCxrREFHQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBZ0IsMkJBQTJCLENBQUMsY0FBbUI7SUFDN0QsSUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLElBQUksbUJBQW1CLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRTtRQUM3RyxPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBTEQsa0VBS0M7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLEtBQUssQ0FBQyxNQUEyQjtJQUMvQyxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2xDLENBQUM7QUFGRCxzQkFFQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQWdCLGdCQUFnQixDQUFDLEtBQWUsRUFBRSxNQUFhLEVBQUUsUUFBaUI7SUFDaEYsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRTtRQUM1QixJQUFJLElBQUksSUFBSSxTQUFTLEVBQUU7WUFDckIsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDbkU7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUVILE1BQU0sUUFBUSxHQUFHLElBQUksZ0JBQVEsRUFBRSxDQUFDO0lBQ2hDLElBQUksSUFBSSxDQUFDO0lBQ1QsSUFBSTtRQUNGLElBQUksR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQztLQUN2QztJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsTUFBTSxJQUFJLHFCQUFVLENBQUMsOENBQThDLENBQUMsQ0FBQztLQUN0RTtJQUNELElBQUksUUFBUSxFQUFFO1FBQ1osT0FBTyxpQkFBUyxDQUFDLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztLQUN6RDtTQUFNO1FBQ0wsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztLQUNsQztBQUNILENBQUM7QUFuQkQsNENBbUJDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixnQkFBZ0IsQ0FBQyxLQUFlLEVBQUUsSUFBWTtJQUM1RCxNQUFNLFFBQVEsR0FBRyxJQUFJLGdCQUFRLEVBQUUsQ0FBQztJQUNoQyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEMsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxFQUFFO1FBQzdELElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLFNBQVM7WUFBRSxHQUFHLEdBQUcsY0FBYyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDbEYsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNkLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ1QsQ0FBQztBQVJELDRDQVFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0ICogYXMgaGV4IGZyb20gJ0BzdGFibGVsaWIvaGV4JztcbmltcG9ydCAqIGFzIHRyb253ZWIgZnJvbSAndHJvbndlYic7XG5pbXBvcnQgeyBwcm90b2NvbCB9IGZyb20gJy4uLy4uL3Jlc291cmNlcy9wcm90b2J1Zi90cm9uJztcblxuaW1wb3J0IHsgVXRpbHNFcnJvciB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQge1xuICBUcmFuc2ZlckNvbnRyYWN0LFxuICBSYXdEYXRhLFxuICBBY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0LFxuICBUcmFuc2FjdGlvblJlY2VpcHQsXG4gIFBlcm1pc3Npb24sXG4gIFRyaWdnZXJTbWFydENvbnRyYWN0LFxufSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IENvbnRyYWN0VHlwZSwgUGVybWlzc2lvblR5cGUgfSBmcm9tICcuL2VudW0nO1xuaW1wb3J0IHsgQWJpQ29kZXIsIGhleENvbmNhdCB9IGZyb20gJ2V0aGVycy9saWIvdXRpbHMnO1xuXG5jb25zdCBBRERSRVNTX1BSRUZJWF9SRUdFWCA9IC9eKDQxKS87XG5jb25zdCBBRERSRVNTX1BSRUZJWCA9ICc0MSc7XG5cbmV4cG9ydCBjb25zdCB0b2tlbk1haW5uZXRDb250cmFjdEFkZHJlc3NlcyA9IFtcbiAgJ1RFa3hpVGVobnpTbVNlMlhxckJqNHczMlJVTjk2NnJkejgnLFxuICAnVFI3TkhxamVLUXhHVENpOHE4Wlk0cEw4b3RTemdqTGo2dCcsXG5dO1xuZXhwb3J0IGNvbnN0IHRva2VuVGVzdG5ldENvbnRyYWN0QWRkcmVzc2VzID0gW1xuICAnVFNkWndOcXBIb2Z6UDZCc0JLR1FVV2RCZUpwaExtRjZpZCcsXG4gICdURzNYWHlFeEJrUHA5bnpkYWpEWnNvekV1NEJrYVNKb3pzJyxcbl07XG5cbi8qKlxuICogVHJvbi1zcGVjaWZpYyBoZWxwZXIgZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCB0eXBlIFRyb25CaW5hcnlMaWtlID0gQnl0ZUFycmF5IHwgQnVmZmVyIHwgVWludDhBcnJheSB8IHN0cmluZztcbmV4cG9ydCB0eXBlIEJ5dGVBcnJheSA9IG51bWJlcltdO1xuXG4vKipcbiAqIEBwYXJhbSBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2U1OEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNyeXB0by5pc0FkZHJlc3NWYWxpZChhZGRyZXNzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gc3RyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhzdHI6IHN0cmluZyk6IEJ5dGVBcnJheSB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNvZGUuaGV4U3RyMmJ5dGVBcnJheShzdHIucmVwbGFjZSgnMHgnLCAnJykpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBhcnJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhleEFkZHJlc3NGcm9tQnl0ZUFycmF5KGFycjogQnl0ZUFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY29kZS5ieXRlQXJyYXkyaGV4U3RyKGFycik7XG59XG5cbi8qKlxuICogQHBhcmFtIG1lc3NhZ2VUb1ZlcmlmeVxuICogQHBhcmFtIGJhc2U1OEFkZHJlc3NcbiAqIEBwYXJhbSBzaWdIZXhcbiAqIEBwYXJhbSB1c2VUcm9uSGVhZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUoXG4gIG1lc3NhZ2VUb1ZlcmlmeTogc3RyaW5nLFxuICBiYXNlNThBZGRyZXNzOiBzdHJpbmcsXG4gIHNpZ0hleDogc3RyaW5nLFxuICB1c2VUcm9uSGVhZGVyID0gdHJ1ZVxuKTogYm9vbGVhbiB7XG4gIGlmICghaXNWYWxpZEhleChzaWdIZXgpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ3NpZ25hdHVyZSBpcyBub3QgaW4gYSB2YWxpZCBmb3JtYXQsIG5lZWRzIHRvIGJlIGhleGFkZWNpbWFsJyk7XG4gIH1cblxuICBpZiAoIWlzVmFsaWRIZXgobWVzc2FnZVRvVmVyaWZ5KSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdtZXNzYWdlIGlzIG5vdCBpbiBhIHZhbGlkIGZvcm1hdCwgbmVlZHMgdG8gYmUgaGV4YWRlY2ltYWwnKTtcbiAgfVxuXG4gIGlmICghaXNCYXNlNThBZGRyZXNzKGJhc2U1OEFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ2FkZHJlc3MgbmVlZHMgdG8gYmUgYmFzZTU4IGVuY29kZWQnKTtcbiAgfVxuXG4gIHJldHVybiB0cm9ud2ViLlRyeC52ZXJpZnlTaWduYXR1cmUobWVzc2FnZVRvVmVyaWZ5LCBiYXNlNThBZGRyZXNzLCBzaWdIZXgsIHVzZVRyb25IZWFkZXIpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBiYXNlNThcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhleEFkZHJlc3NGcm9tQmFzZTU4QWRkcmVzcyhiYXNlNTg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHB1bGxlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vVFJPTi1VUy90cm9ud2ViL2Jsb2IvZGNiOGVmYTM2YTVlYmI2NWM0ZGFiMzYyNmU5MDI1NmE0NTNmM2IwZC9zcmMvdXRpbHMvaGVscC5qcyNMMTdcbiAgLy8gYnV0IHRoZXkgZG9uJ3Qgc3VyZmFjZSB0aGlzIGNhbGwgaW4gaW5kZXguanNcbiAgY29uc3QgYnl0ZXMgPSB0cm9ud2ViLnV0aWxzLmNyeXB0by5kZWNvZGVCYXNlNThBZGRyZXNzKGJhc2U1OCk7XG4gIHJldHVybiBnZXRIZXhBZGRyZXNzRnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHByaXZhdGVLZXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFB1YktleUZyb21QcmlLZXkocHJpdmF0ZUtleTogVHJvbkJpbmFyeUxpa2UpOiBCeXRlQXJyYXkge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jcnlwdG8uZ2V0UHViS2V5RnJvbVByaUtleShwcml2YXRlS2V5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzc0Zyb21QcmlLZXkocHJpdmF0ZUtleTogVHJvbkJpbmFyeUxpa2UpOiBCeXRlQXJyYXkge1xuICByZXR1cm4gdHJvbndlYi51dGlscy5jcnlwdG8uZ2V0QWRkcmVzc0Zyb21QcmlLZXkocHJpdmF0ZUtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIGFkZHJlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEJhc2U1OEFkZHJlc3NGcm9tQnl0ZUFycmF5KGFkZHJlc3M6IEJ5dGVBcnJheSk6IHN0cmluZyB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNyeXB0by5nZXRCYXNlNThDaGVja0FkZHJlc3MoYWRkcmVzcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIGhleFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmFzZTU4QWRkcmVzc0Zyb21IZXgoaGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBhcnIgPSBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhoZXgpO1xuICByZXR1cm4gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoYXJyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHRyYW5zYWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24ocHJpdmF0ZUtleTogc3RyaW5nIHwgQnl0ZUFycmF5LCB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZWNlaXB0KTogVHJhbnNhY3Rpb25SZWNlaXB0IHtcbiAgcmV0dXJuIHRyb253ZWIudXRpbHMuY3J5cHRvLnNpZ25UcmFuc2FjdGlvbihwcml2YXRlS2V5LCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEBwYXJhbSBwcml2YXRlS2V5XG4gKiBAcGFyYW0gdXNlVHJvbkhlYWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnblN0cmluZyhtZXNzYWdlOiBzdHJpbmcsIHByaXZhdGVLZXk6IHN0cmluZyB8IEJ5dGVBcnJheSwgdXNlVHJvbkhlYWRlciA9IHRydWUpOiBzdHJpbmcge1xuICByZXR1cm4gdHJvbndlYi5Ucnguc2lnblN0cmluZyhtZXNzYWdlLCBwcml2YXRlS2V5LCB1c2VUcm9uSGVhZGVyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcHViQnl0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJhd0FkZHJlc3NGcm9tUHViS2V5KHB1YkJ5dGVzOiBUcm9uQmluYXJ5TGlrZSk6IEJ5dGVBcnJheSB7XG4gIHJldHVybiB0cm9ud2ViLnV0aWxzLmNyeXB0by5jb21wdXRlQWRkcmVzcyhwdWJCeXRlcyk7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIGhleCBlbmNvZGVkIHRyYW5zYWN0aW9uIGluIGl0cyBwcm90b2J1ZiByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIHJhd19kYXRhX2hleCBmaWVsZCBmcm9tIHRyb24gdHJhbnNhY3Rpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUcmFuc2FjdGlvbihoZXhTdHJpbmc6IHN0cmluZyk6IFJhd0RhdGEge1xuICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IGRlY29kZVJhd1RyYW5zYWN0aW9uKGhleFN0cmluZyk7XG5cbiAgLy8gdGhlcmUgc2hvdWxkIG5vdCBiZSBtdWx0aXBsZSBjb250cmFjdHMgaW4gdGhpcyBkYXRhXG4gIGlmIChyYXdUcmFuc2FjdGlvbi5jb250cmFjdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ051bWJlciBvZiBjb250cmFjdHMgaXMgZ3JlYXRlciB0aGFuIDEuJyk7XG4gIH1cblxuICBsZXQgY29udHJhY3Q6IFRyYW5zZmVyQ29udHJhY3RbXSB8IEFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3RbXSB8IFRyaWdnZXJTbWFydENvbnRyYWN0W107XG4gIGxldCBjb250cmFjdFR5cGU6IENvbnRyYWN0VHlwZTtcbiAgLy8gZW5zdXJlIHRoZSBjb250cmFjdCB0eXBlIGlzIHN1cHBvcnRlZFxuICBzd2l0Y2ggKHJhd1RyYW5zYWN0aW9uLmNvbnRyYWN0c1swXS5wYXJhbWV0ZXIudHlwZV91cmwpIHtcbiAgICBjYXNlICd0eXBlLmdvb2dsZWFwaXMuY29tL3Byb3RvY29sLlRyYW5zZmVyQ29udHJhY3QnOlxuICAgICAgY29udHJhY3RUeXBlID0gQ29udHJhY3RUeXBlLlRyYW5zZmVyO1xuICAgICAgY29udHJhY3QgPSBleHBvcnRzLmRlY29kZVRyYW5zZmVyQ29udHJhY3QocmF3VHJhbnNhY3Rpb24uY29udHJhY3RzWzBdLnBhcmFtZXRlci52YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0eXBlLmdvb2dsZWFwaXMuY29tL3Byb3RvY29sLkFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3QnOlxuICAgICAgY29udHJhY3RUeXBlID0gQ29udHJhY3RUeXBlLkFjY291bnRQZXJtaXNzaW9uVXBkYXRlO1xuICAgICAgY29udHJhY3QgPSBleHBvcnRzLmRlY29kZUFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3QocmF3VHJhbnNhY3Rpb24uY29udHJhY3RzWzBdLnBhcmFtZXRlci52YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0eXBlLmdvb2dsZWFwaXMuY29tL3Byb3RvY29sLlRyaWdnZXJTbWFydENvbnRyYWN0JzpcbiAgICAgIGNvbnRyYWN0VHlwZSA9IENvbnRyYWN0VHlwZS5UcmlnZ2VyU21hcnRDb250cmFjdDtcbiAgICAgIGNvbnRyYWN0ID0gZXhwb3J0cy5kZWNvZGVUcmlnZ2VyU21hcnRDb250cmFjdChyYXdUcmFuc2FjdGlvbi5jb250cmFjdHNbMF0ucGFyYW1ldGVyLnZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignVW5zdXBwb3J0ZWQgY29udHJhY3QgdHlwZScpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb250cmFjdFR5cGUsXG4gICAgY29udHJhY3QsXG4gICAgZXhwaXJhdGlvbjogcmF3VHJhbnNhY3Rpb24uZXhwaXJhdGlvbixcbiAgICB0aW1lc3RhbXA6IHJhd1RyYW5zYWN0aW9uLnRpbWVzdGFtcCxcbiAgICByZWZfYmxvY2tfYnl0ZXM6IHJhd1RyYW5zYWN0aW9uLmJsb2NrQnl0ZXMsXG4gICAgcmVmX2Jsb2NrX2hhc2g6IHJhd1RyYW5zYWN0aW9uLmJsb2NrSGFzaCxcbiAgICBmZWVfbGltaXQ6ICtyYXdUcmFuc2FjdGlvbi5mZWVMaW1pdCxcbiAgfTtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgdHJhbnNhY3Rpb24ncyByYXcgZmllbGQgZnJvbSBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy4gVGhpcyBpcyBhIHByb3RvYnVmIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSBoZXhTdHJpbmcgdGhpcyBpcyB0aGUgcmF3IGhleGFkZWNpbWFsIGVuY29kZWQgc3RyaW5nLiBEb2MgZm91bmQgaW4gdGhlIGZvbGxvd2luZyBsaW5rLlxuICogQGV4YW1wbGVcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9CaXRHby9iaXRnby1hY2NvdW50LWxpYi9ibG9iLzVmMjgyNTg4NzAxNzc4YTQ0MjFjNzVmYTYxZjQyNzEzZjU2ZTk1YjkvcmVzb3VyY2VzL3Byb3RvYnVmL3Ryb24ucHJvdG8jTDMxOX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVJhd1RyYW5zYWN0aW9uKGhleFN0cmluZzogc3RyaW5nKToge1xuICBleHBpcmF0aW9uOiBudW1iZXI7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBjb250cmFjdHM6IEFycmF5PGFueT47XG4gIGJsb2NrQnl0ZXM6IHN0cmluZztcbiAgYmxvY2tIYXNoOiBzdHJpbmc7XG4gIGZlZUxpbWl0OiBzdHJpbmc7XG59IHtcbiAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuZnJvbShoZXhTdHJpbmcsICdoZXgnKTtcblxuICBsZXQgcmF3O1xuICB0cnkge1xuICAgIC8vIHdlIG5lZWQgdG8gZGVjb2RlIG91ciByYXdfZGF0YV9oZXggZmllbGQgZmlyc3RcbiAgICByYXcgPSBwcm90b2NvbC5UcmFuc2FjdGlvbi5yYXcuZGVjb2RlKGJ5dGVzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3IgZGVjb2RpbmcgdGhlIGluaXRpYWwgcmF3X2RhdGFfaGV4IGZyb20gdGhlIHNlcmlhbGl6ZWQgdHguJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cGlyYXRpb246IE51bWJlcihyYXcuZXhwaXJhdGlvbiksXG4gICAgdGltZXN0YW1wOiBOdW1iZXIocmF3LnRpbWVzdGFtcCksXG4gICAgY29udHJhY3RzOiByYXcuY29udHJhY3QsXG4gICAgYmxvY2tCeXRlczogdG9IZXgocmF3LnJlZkJsb2NrQnl0ZXMpLFxuICAgIGZlZUxpbWl0OiByYXcuZmVlTGltaXQsXG4gICAgYmxvY2tIYXNoOiB0b0hleChyYXcucmVmQmxvY2tIYXNoKSxcbiAgfTtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcGFzc2VkIHN0cmluZyBpcyBhIHNhZmUgaGV4IHN0cmluZyBmb3IgdHJvbidzIHB1cnBvc2VzLlxuICpcbiAqIEBwYXJhbSBoZXggQSB2YWxpZCBoZXggc3RyaW5nIG11c3QgYmUgYSBzdHJpbmcgbWFkZSBvZiBudW1iZXJzIGFuZCBjaGFyYWN0ZXJzIGFuZCBoYXMgYW4gZXZlbiBsZW5ndGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkSGV4KGhleDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAvXigweCk/KFswLTlhLWZdezJ9KSskL2kudGVzdChoZXgpO1xufVxuXG4vKiogRGVzZXJpYWxpemUgdGhlIHNlZ21lbnQgb2YgdGhlIHR4SGV4IHdoaWNoIGNvcnJlc3BvbmRzIHdpdGggdGhlIGRldGFpbHMgb2YgdGhlIHRyYW5zZmVyXG4gKlxuICogQHBhcmFtIHRyYW5zZmVySGV4IGlzIHRoZSB2YWx1ZSBwcm9wZXJ0eSBvZiB0aGUgXCJwYXJhbWV0ZXJcIiBmaWVsZCBvZiBjb250cmFjdExpc3RbMF1cbiAqICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVHJhbnNmZXJDb250cmFjdCh0cmFuc2ZlckhleDogc3RyaW5nKTogVHJhbnNmZXJDb250cmFjdFtdIHtcbiAgY29uc3QgY29udHJhY3RCeXRlcyA9IEJ1ZmZlci5mcm9tKHRyYW5zZmVySGV4LCAnYmFzZTY0Jyk7XG4gIGxldCB0cmFuc2ZlckNvbnRyYWN0O1xuXG4gIHRyeSB7XG4gICAgdHJhbnNmZXJDb250cmFjdCA9IHByb3RvY29sLlRyYW5zZmVyQ29udHJhY3QuZGVjb2RlKGNvbnRyYWN0Qnl0ZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciBkZWNvZGluZyB0aGUgdHJhbnNmZXIgY29udHJhY3QgaW4gdGhlIHRyYW5zYWN0aW9uLicpO1xuICB9XG5cbiAgaWYgKCF0cmFuc2ZlckNvbnRyYWN0Lm93bmVyQWRkcmVzcykge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdPd25lciBhZGRyZXNzIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgdHJhbnNmZXIgY29udHJhY3QuJyk7XG4gIH1cblxuICBpZiAoIXRyYW5zZmVyQ29udHJhY3QudG9BZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0Rlc3RpbmF0aW9uIGFkZHJlc3MgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyB0cmFuc2ZlciBjb250cmFjdC4nKTtcbiAgfVxuXG4gIGlmICghdHJhbnNmZXJDb250cmFjdC5oYXNPd25Qcm9wZXJ0eSgnYW1vdW50JykpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignQW1vdW50IGRvZXMgbm90IGV4aXN0IGluIHRoaXMgdHJhbnNmZXIgY29udHJhY3QuJyk7XG4gIH1cblxuICAvLyBkZXNlcmlhbGl6ZSBhdHRyaWJ1dGVzXG4gIGNvbnN0IG93bmVyX2FkZHJlc3MgPSBnZXRCYXNlNThBZGRyZXNzRnJvbUJ5dGVBcnJheShcbiAgICBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhCdWZmZXIuZnJvbSh0cmFuc2ZlckNvbnRyYWN0Lm93bmVyQWRkcmVzcywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdoZXgnKSlcbiAgKTtcbiAgY29uc3QgdG9fYWRkcmVzcyA9IGdldEJhc2U1OEFkZHJlc3NGcm9tQnl0ZUFycmF5KFxuICAgIGdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKEJ1ZmZlci5mcm9tKHRyYW5zZmVyQ29udHJhY3QudG9BZGRyZXNzLCAnYmFzZTY0JykudG9TdHJpbmcoJ2hleCcpKVxuICApO1xuICBjb25zdCBhbW91bnQgPSB0cmFuc2ZlckNvbnRyYWN0LmFtb3VudDtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHBhcmFtZXRlcjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGFtb3VudDogTnVtYmVyKGFtb3VudCksXG4gICAgICAgICAgb3duZXJfYWRkcmVzcyxcbiAgICAgICAgICB0b19hZGRyZXNzLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICBdO1xufVxuXG4vKipcbiAqIERlc2VyaWFsaXplIHRoZSBzZWdtZW50IG9mIHRoZSB0eEhleCBjb3JyZXNwb25kaW5nIHdpdGggdHJpZ2dlciBzbWFydCBjb250cmFjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEByZXR1cm5zIHtBY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVHJpZ2dlclNtYXJ0Q29udHJhY3QoYmFzZTY0OiBzdHJpbmcpOiBUcmlnZ2VyU21hcnRDb250cmFjdFtdIHtcbiAgbGV0IGNvbnRyYWN0Q2FsbERlY29kZWQ7XG4gIHRyeSB7XG4gICAgY29udHJhY3RDYWxsRGVjb2RlZCA9IHByb3RvY29sLlRyaWdnZXJTbWFydENvbnRyYWN0LmRlY29kZShCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKSkudG9KU09OKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIGRlY29kaW5nIHRoZSBjb250cmFjdCBjYWxsIGluIHRoZSB0cmFuc2FjdGlvbi4nKTtcbiAgfVxuXG4gIGlmICghY29udHJhY3RDYWxsRGVjb2RlZC5vd25lckFkZHJlc3MpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignT3duZXIgYWRkcmVzcyBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGNvbnRyYWN0IGNhbGwuJyk7XG4gIH1cblxuICBpZiAoIWNvbnRyYWN0Q2FsbERlY29kZWQuY29udHJhY3RBZGRyZXNzKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0Rlc3RpbmF0aW9uIGNvbnRyYWN0IGFkZHJlc3MgZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBjb250cmFjdCBjYWxsLicpO1xuICB9XG5cbiAgaWYgKCFjb250cmFjdENhbGxEZWNvZGVkLmRhdGEpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignRGF0YSBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIGNvbnRyYWN0IGNhbGwuJyk7XG4gIH1cblxuICAvLyBkZXNlcmlhbGl6ZSBhdHRyaWJ1dGVzXG4gIGNvbnN0IG93bmVyX2FkZHJlc3MgPSBnZXRCYXNlNThBZGRyZXNzRnJvbUJ5dGVBcnJheShcbiAgICBnZXRCeXRlQXJyYXlGcm9tSGV4QWRkcmVzcyhCdWZmZXIuZnJvbShjb250cmFjdENhbGxEZWNvZGVkLm93bmVyQWRkcmVzcywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdoZXgnKSlcbiAgKTtcbiAgY29uc3QgY29udHJhY3RfYWRkcmVzcyA9IGdldEJhc2U1OEFkZHJlc3NGcm9tQnl0ZUFycmF5KFxuICAgIGdldEJ5dGVBcnJheUZyb21IZXhBZGRyZXNzKEJ1ZmZlci5mcm9tKGNvbnRyYWN0Q2FsbERlY29kZWQuY29udHJhY3RBZGRyZXNzLCAnYmFzZTY0JykudG9TdHJpbmcoJ2hleCcpKVxuICApO1xuICBjb25zdCBkYXRhID0gY29udHJhY3RDYWxsRGVjb2RlZC5kYXRhO1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHBhcmFtZXRlcjoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgb3duZXJfYWRkcmVzcyxcbiAgICAgICAgICBjb250cmFjdF9hZGRyZXNzLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICBdO1xufVxuXG4vKipcbiAqIERlc2VyaWFsaXplIHRoZSBzZWdtZW50IG9mIHRoZSB0eEhleCBjb3JyZXNwb25kaW5nIHdpdGggdGhlIGRldGFpbHMgb2YgdGhlIGNvbnRyYWN0IHdoaWNoIHVwZGF0ZXNcbiAqIGFjY291bnQgcGVybWlzc2lvblxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEByZXR1cm5zIHtBY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQWNjb3VudFBlcm1pc3Npb25VcGRhdGVDb250cmFjdChiYXNlNjQ6IHN0cmluZyk6IEFjY291bnRQZXJtaXNzaW9uVXBkYXRlQ29udHJhY3Qge1xuICBjb25zdCBhY2NvdW50VXBkYXRlQ29udHJhY3QgPSBwcm90b2NvbC5BY2NvdW50UGVybWlzc2lvblVwZGF0ZUNvbnRyYWN0LmRlY29kZShCdWZmZXIuZnJvbShiYXNlNjQsICdiYXNlNjQnKSkudG9KU09OKCk7XG4gIGFzc2VydChhY2NvdW50VXBkYXRlQ29udHJhY3Qub3duZXJBZGRyZXNzKTtcbiAgYXNzZXJ0KGFjY291bnRVcGRhdGVDb250cmFjdC5vd25lcik7XG4gIGFzc2VydChhY2NvdW50VXBkYXRlQ29udHJhY3QuaGFzT3duUHJvcGVydHkoJ2FjdGl2ZXMnKSk7XG5cbiAgY29uc3Qgb3duZXJBZGRyZXNzID0gZ2V0QmFzZTU4QWRkcmVzc0Zyb21CeXRlQXJyYXkoXG4gICAgZ2V0Qnl0ZUFycmF5RnJvbUhleEFkZHJlc3MoQnVmZmVyLmZyb20oYWNjb3VudFVwZGF0ZUNvbnRyYWN0Lm93bmVyQWRkcmVzcywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdoZXgnKSlcbiAgKTtcbiAgY29uc3Qgb3duZXI6IFBlcm1pc3Npb24gPSBjcmVhdGVQZXJtaXNzaW9uKGFjY291bnRVcGRhdGVDb250cmFjdC5vd25lcik7XG4gIGxldCB3aXRuZXNzOiBQZXJtaXNzaW9uIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICBpZiAoYWNjb3VudFVwZGF0ZUNvbnRyYWN0LndpdG5lc3MpIHtcbiAgICB3aXRuZXNzID0gY3JlYXRlUGVybWlzc2lvbihhY2NvdW50VXBkYXRlQ29udHJhY3Qud2l0bmVzcyk7XG4gIH1cbiAgY29uc3QgYWN0aXZlTGlzdCA9IGFjY291bnRVcGRhdGVDb250cmFjdC5hY3RpdmVzLm1hcCgoYWN0aXZlKSA9PiBjcmVhdGVQZXJtaXNzaW9uKGFjdGl2ZSkpO1xuXG4gIHJldHVybiB7XG4gICAgb3duZXJBZGRyZXNzLFxuICAgIG93bmVyLFxuICAgIHdpdG5lc3MsXG4gICAgYWN0aXZlczogYWN0aXZlTGlzdCxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcmF3XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBlcm1pc3Npb24ocmF3OiB7IHBlcm1pc3Npb25OYW1lOiBzdHJpbmc7IHRocmVzaG9sZDogbnVtYmVyIH0pOiBQZXJtaXNzaW9uIHtcbiAgbGV0IHBlcm1pc3Npb25UeXBlOiBQZXJtaXNzaW9uVHlwZTtcbiAgY29uc3QgcGVybWlzc2lvbiA9IHJhdy5wZXJtaXNzaW9uTmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgaWYgKHBlcm1pc3Npb24gPT09ICdvd25lcicpIHtcbiAgICBwZXJtaXNzaW9uVHlwZSA9IFBlcm1pc3Npb25UeXBlLk93bmVyO1xuICB9IGVsc2UgaWYgKHBlcm1pc3Npb24gPT09ICd3aXRuZXNzJykge1xuICAgIHBlcm1pc3Npb25UeXBlID0gUGVybWlzc2lvblR5cGUuV2l0bmVzcztcbiAgfSBlbHNlIGlmIChwZXJtaXNzaW9uLnN1YnN0cigwLCA2KSA9PT0gJ2FjdGl2ZScpIHtcbiAgICBwZXJtaXNzaW9uVHlwZSA9IFBlcm1pc3Npb25UeXBlLkFjdGl2ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignUGVybWlzc2lvbiB0eXBlIG5vdCBwYXJzZWFibGUuJyk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGVybWlzc2lvblR5cGUsIHRocmVzaG9sZDogcmF3LnRocmVzaG9sZCB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSByYXdUcmFuc2FjdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFR4SnNvblN0cmluZyhyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gSlNPTi5wYXJzZShyYXdUcmFuc2FjdGlvbik7XG4gIHJldHVybiB0cmFuc2FjdGlvbi5oYXNPd25Qcm9wZXJ0eSgndHhJRCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcmF3IHRyYW5zYWN0aW9uIGFjY29tbW9kYXRlcyB0byBiaXRnbydzIHByZWZlcnJlZCBmb3JtYXRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmF3VHJhbnNhY3Rpb24gLSBUaGUgcmF3IHRyYW5zYWN0aW9uIHRvIGJlIGNoZWNrZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRSYXdUcmFuc2FjdGlvbkZvcm1hdChyYXdUcmFuc2FjdGlvbjogYW55KTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2YgcmF3VHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnICYmIChpc1ZhbGlkSGV4KHJhd1RyYW5zYWN0aW9uKSB8fCBpc1ZhbGlkVHhKc29uU3RyaW5nKHJhd1RyYW5zYWN0aW9uKSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBoZXggc3RyaW5nIG9mIHRoZSBnaXZlbiBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IFVpbnQ4QXJyYXl9IGJ1ZmZlciAtIHRoZSBidWZmZXIgdG8gYmUgY29udmVydGVkIHRvIGhleFxuICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgaGV4IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChidWZmZXI6IEJ1ZmZlciB8IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gaGV4LmVuY29kZShidWZmZXIsIHRydWUpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBLZWNjYWstMjU2IGVuY29kZWQgc3RyaW5nIG9mIHRoZSBwYXJhbWV0ZXJzXG4gKlxuICogQHBhcmFtIHR5cGVzIC0gc3RyaW5ncyBkZXNjcmliaW5nIHRoZSB0eXBlcyBvZiB0aGUgdmFsdWVzXG4gKiBAcGFyYW0gdmFsdWVzIC0gdmFsdWUgdG8gZW5jb2RlXG4gKiBAcGFyYW0gbWV0aG9kSWQgLSB0aGUgZmlyc3QgNCBieXRlcyBvZiB0aGUgZnVuY3Rpb24gc2VsZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZURhdGFQYXJhbXModHlwZXM6IHN0cmluZ1tdLCB2YWx1ZXM6IGFueVtdLCBtZXRob2RJZD86IHN0cmluZyk6IHN0cmluZyB7XG4gIHR5cGVzLmZvckVhY2goKHR5cGUsIGluZGV4KSA9PiB7XG4gICAgaWYgKHR5cGUgPT0gJ2FkZHJlc3MnKSB7XG4gICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWVzW2luZGV4XS5yZXBsYWNlKEFERFJFU1NfUFJFRklYX1JFR0VYLCAnMHgnKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IGFiaUNvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBhYmlDb2Rlci5lbmNvZGUodHlwZXMsIHZhbHVlcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIGVuY29kaW5nIHRoZSBkYXRhIHBhcmFtcy4nKTtcbiAgfVxuICBpZiAobWV0aG9kSWQpIHtcbiAgICByZXR1cm4gaGV4Q29uY2F0KFttZXRob2RJZCwgZGF0YV0pLnJlcGxhY2UoL14oMHgpLywgJycpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL14oMHgpLywgJycpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVjb2RlZCB2YWx1ZXMgYWNjb3JkaW5nIHRvIHRoZSBhcnJheSBvZiB0eXBlc1xuICpcbiAqIEBwYXJhbSB0eXBlcyAtIHN0cmluZ3MgZGVzY3JpYmluZyB0aGUgdHlwZXMgb2YgdGhlIHZhbHVlc1xuICogQHBhcmFtIGRhdGEgLSBlbmNvZGVkIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRGF0YVBhcmFtcyh0eXBlczogc3RyaW5nW10sIGRhdGE6IHN0cmluZyk6IGFueVtdIHtcbiAgY29uc3QgYWJpQ29kZXIgPSBuZXcgQWJpQ29kZXIoKTtcbiAgZGF0YSA9ICcweCcgKyBkYXRhLnN1YnN0cmluZyg4KTtcbiAgcmV0dXJuIGFiaUNvZGVyLmRlY29kZSh0eXBlcywgZGF0YSkucmVkdWNlKChvYmosIGFyZywgaW5kZXgpID0+IHtcbiAgICBpZiAodHlwZXNbaW5kZXhdID09ICdhZGRyZXNzJykgYXJnID0gQUREUkVTU19QUkVGSVggKyBhcmcuc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgb2JqLnB1c2goYXJnKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LCBbXSk7XG59XG4iXX0=