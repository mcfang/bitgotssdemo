"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionBuilder = void 0;
const crypto_1 = require("crypto");
const _ = __importStar(require("lodash"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_core_1 = require("@bitgo/sdk-core");
const utils_1 = require("./utils");
const transaction_1 = require("./transaction");
const keyPair_1 = require("./keyPair");
/**
 * Tron transaction builder.
 */
class TransactionBuilder extends sdk_core_1.BaseTransactionBuilder {
    /**
     * Public constructor.
     *
     * @param {CoinConfig} _coinConfig Configuration object
     */
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    /**
     * Parse transaction takes in raw JSON directly from the node.
     *
     * @param {TransactionReceipt} rawTransaction The Tron transaction in JSON format as returned by the Tron lib or a stringifyed version of such JSON.
     * @returns {Transaction} Tron transaction
     */
    fromImplementation(rawTransaction) {
        let tx;
        if (typeof rawTransaction === 'string') {
            const transaction = JSON.parse(rawTransaction);
            tx = new transaction_1.Transaction(this._coinConfig, transaction);
        }
        else {
            tx = new transaction_1.Transaction(this._coinConfig, rawTransaction);
        }
        return tx;
    }
    /** @inheritdoc */
    signImplementation(key) {
        if (!this.transaction.inputs) {
            throw new sdk_core_1.SigningError('Transaction has no sender');
        }
        if (!this.transaction.outputs) {
            throw new sdk_core_1.SigningError('Transaction has no receiver');
        }
        return this.applySignature(key);
    }
    applySignature(key) {
        const oldTransaction = this.transaction.toJson();
        // Store the original signatures to compare them with the new ones in a later step. Signatures
        // can be undefined if this is the first time the transaction is being signed
        const oldSignatureCount = oldTransaction.signature ? oldTransaction.signature.length : 0;
        let signedTransaction;
        try {
            const keyPair = new keyPair_1.KeyPair({ prv: key.key });
            // Since the key pair was generated using a private key, it will always have a prv attribute,
            // hence it is safe to use non-null operator
            signedTransaction = utils_1.signTransaction(keyPair.getKeys().prv, this.transaction.toJson());
        }
        catch (e) {
            throw new sdk_core_1.SigningError('Failed to sign transaction via helper.');
        }
        // Ensure that we have more signatures than what we started with
        if (!signedTransaction.signature || oldSignatureCount >= signedTransaction.signature.length) {
            throw new sdk_core_1.SigningError('Transaction signing did not return an additional signature.');
        }
        return new transaction_1.Transaction(this._coinConfig, signedTransaction);
    }
    /** @inheritdoc */
    async buildImplementation() {
        // This is a no-op since Tron transactions are built from
        if (!this.transaction.id) {
            throw new sdk_core_1.BuildTransactionError('A valid transaction must have an id');
        }
        return Promise.resolve(this.transaction);
    }
    initBuilder(tx) {
        this.transaction = this.fromImplementation(tx);
    }
    /**
     * Extend the validity of this transaction by the given amount of time
     *
     * @param {number} extensionMs The number of milliseconds to extend the validTo time
     * @returns {undefined}
     */
    extendValidTo(extensionMs) {
        this.transaction.extendExpiration(extensionMs);
    }
    /** @inheritdoc */
    validateValue(value) {
        if (value.isLessThanOrEqualTo(0)) {
            throw new Error('Value cannot be below zero.');
        }
        // max long in Java - assumed upper limit for a TRX transaction
        if (value.isGreaterThan(new bignumber_js_1.default('9223372036854775807'))) {
            throw new Error('Value cannot be greater than handled by the javatron node.');
        }
    }
    /** @inheritdoc */
    validateAddress(address) {
        // assumes a base 58 address for our addresses
        if (!utils_1.isBase58Address(address.address)) {
            throw new Error(address.address + ' is not a valid base58 address.');
        }
    }
    /** @inheritdoc */
    validateKey(key) {
        try {
            new keyPair_1.KeyPair({ prv: key.key });
        }
        catch (err) {
            throw new Error('The provided key is not valid');
        }
    }
    /**
     * Validate the contents of a raw transaction. The validation
     * phase is to compare the raw-data-hex to the raw-data of the
     * transaction.
     *
     * The contents to be validated are
     * 1. The transaction id
     * 2. The expiration date
     * 3. The timestamp
     * 4. The contract
     *
     * @param {TransactionReceipt | string} rawTransaction The raw transaction to be validated
     */
    validateRawTransaction(rawTransaction) {
        // TODO: Validation of signature
        if (!rawTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Raw transaction is empty');
        }
        let currTransaction;
        // rawTransaction can be either Stringified JSON OR
        // it can be a regular JSON object (not stringified).
        if (typeof rawTransaction === 'string') {
            try {
                currTransaction = JSON.parse(rawTransaction);
            }
            catch (e) {
                throw new sdk_core_1.ParseTransactionError('There was error in parsing the JSON string');
            }
        }
        else if (_.isObject(rawTransaction)) {
            currTransaction = rawTransaction;
        }
        else {
            throw new sdk_core_1.InvalidTransactionError('Transaction is not an object or stringified json');
        }
        const decodedRawDataHex = utils_1.decodeTransaction(currTransaction.raw_data_hex);
        if (!currTransaction.txID) {
            throw new sdk_core_1.InvalidTransactionError('Transaction ID is empty');
        }
        // Validate the transaction ID from the raw data hex
        const hexBuffer = Buffer.from(currTransaction.raw_data_hex, 'hex');
        const currTxID = crypto_1.createHash('sha256').update(hexBuffer).digest('hex');
        if (currTransaction.txID !== currTxID) {
            throw new sdk_core_1.InvalidTransactionError('Transaction has not have a valid id');
        }
        // Validate the expiration time from the raw-data-hex
        if (currTransaction.raw_data.expiration !== decodedRawDataHex.expiration) {
            throw new sdk_core_1.InvalidTransactionError('Transaction has not have a valid expiration');
        }
        // Validate the timestamp from the raw-data-hex
        if (currTransaction.raw_data.timestamp !== decodedRawDataHex.timestamp) {
            throw new sdk_core_1.InvalidTransactionError('Transaction has not have a valid timetamp');
        }
        // Transaction contract must exist
        if (!currTransaction.raw_data.contract) {
            throw new sdk_core_1.InvalidTransactionError('Transaction contracts are empty');
        }
    }
    /** @inheritdoc */
    validateTransaction(transaction) {
        const hexBuffer = Buffer.from(transaction.toJson().raw_data_hex, 'hex');
        const txId = crypto_1.createHash('sha256').update(hexBuffer).digest('hex');
        if (transaction.id !== txId) {
            throw new sdk_core_1.InvalidTransactionError(transaction.id + ' is not a valid transaction id. Expecting: ' + txId);
        }
    }
    /** @inheritdoc */
    get transaction() {
        return this._transaction;
    }
    /** @inheritdoc */
    set transaction(transaction) {
        this._transaction = transaction;
    }
}
exports.TransactionBuilder = TransactionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb25CdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi90cmFuc2FjdGlvbkJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG1DQUFvQztBQUNwQywwQ0FBNEI7QUFDNUIsZ0VBQXFDO0FBRXJDLDhDQU95QjtBQUd6QixtQ0FBOEU7QUFDOUUsK0NBQTRDO0FBQzVDLHVDQUFvQztBQUVwQzs7R0FFRztBQUNILE1BQWEsa0JBQW1CLFNBQVEsaUNBQXNCO0lBRzVEOzs7O09BSUc7SUFDSCxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDTyxrQkFBa0IsQ0FBQyxjQUEyQztRQUN0RSxJQUFJLEVBQUUsQ0FBQztRQUNQLElBQUksT0FBTyxjQUFjLEtBQUssUUFBUSxFQUFFO1lBQ3RDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDL0MsRUFBRSxHQUFHLElBQUkseUJBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1NBQ3JEO2FBQU07WUFDTCxFQUFFLEdBQUcsSUFBSSx5QkFBVyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLENBQUM7U0FDeEQ7UUFDRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxrQkFBa0I7SUFDUixrQkFBa0IsQ0FBQyxHQUFZO1FBQ3ZDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRTtZQUM1QixNQUFNLElBQUksdUJBQVksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1NBQ3JEO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFO1lBQzdCLE1BQU0sSUFBSSx1QkFBWSxDQUFDLDZCQUE2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V0FBVyxDQUFDLFdBQXdCO1FBQ2hELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7Q0FDRjtBQTlMRCxnREE4TEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQge1xuICBCYXNlS2V5LFxuICBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyLFxuICBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxuICBQYXJzZVRyYW5zYWN0aW9uRXJyb3IsXG4gIFNpZ25pbmdFcnJvcixcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uUmVjZWlwdCB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJy4vYWRkcmVzcyc7XG5pbXBvcnQgeyBzaWduVHJhbnNhY3Rpb24sIGlzQmFzZTU4QWRkcmVzcywgZGVjb2RlVHJhbnNhY3Rpb24gfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcblxuLyoqXG4gKiBUcm9uIHRyYW5zYWN0aW9uIGJ1aWxkZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkJ1aWxkZXIgZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgLy8gdHJhbnNhY3Rpb24gYmVpbmcgYnVpbHRcbiAgcHJpdmF0ZSBfdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uO1xuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvaW5Db25maWd9IF9jb2luQ29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdHJhbnNhY3Rpb24gdGFrZXMgaW4gcmF3IEpTT04gZGlyZWN0bHkgZnJvbSB0aGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblJlY2VpcHR9IHJhd1RyYW5zYWN0aW9uIFRoZSBUcm9uIHRyYW5zYWN0aW9uIGluIEpTT04gZm9ybWF0IGFzIHJldHVybmVkIGJ5IHRoZSBUcm9uIGxpYiBvciBhIHN0cmluZ2lmeWVkIHZlcnNpb24gb2Ygc3VjaCBKU09OLlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRyb24gdHJhbnNhY3Rpb25cbiAgICovXG4gIHByb3RlY3RlZCBmcm9tSW1wbGVtZW50YXRpb24ocmF3VHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVjZWlwdCB8IHN0cmluZyk6IFRyYW5zYWN0aW9uIHtcbiAgICBsZXQgdHg7XG4gICAgaWYgKHR5cGVvZiByYXdUcmFuc2FjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gSlNPTi5wYXJzZShyYXdUcmFuc2FjdGlvbik7XG4gICAgICB0eCA9IG5ldyBUcmFuc2FjdGlvbih0aGlzLl9jb2luQ29uZmlnLCB0cmFuc2FjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4ID0gbmV3IFRyYW5zYWN0aW9uKHRoaXMuX2NvaW5Db25maWcsIHJhd1RyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBzaWduSW1wbGVtZW50YXRpb24oa2V5OiBCYXNlS2V5KTogVHJhbnNhY3Rpb24ge1xuICAgIGlmICghdGhpcy50cmFuc2FjdGlvbi5pbnB1dHMpIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ1RyYW5zYWN0aW9uIGhhcyBubyBzZW5kZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudHJhbnNhY3Rpb24ub3V0cHV0cykge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignVHJhbnNhY3Rpb24gaGFzIG5vIHJlY2VpdmVyJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFwcGx5U2lnbmF0dXJlKGtleSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXBwbHlTaWduYXR1cmUoa2V5OiBCYXNlS2V5KTogVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IG9sZFRyYW5zYWN0aW9uID0gdGhpcy50cmFuc2FjdGlvbi50b0pzb24oKTtcbiAgICAvLyBTdG9yZSB0aGUgb3JpZ2luYWwgc2lnbmF0dXJlcyB0byBjb21wYXJlIHRoZW0gd2l0aCB0aGUgbmV3IG9uZXMgaW4gYSBsYXRlciBzdGVwLiBTaWduYXR1cmVzXG4gICAgLy8gY2FuIGJlIHVuZGVmaW5lZCBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoZSB0cmFuc2FjdGlvbiBpcyBiZWluZyBzaWduZWRcbiAgICBjb25zdCBvbGRTaWduYXR1cmVDb3VudCA9IG9sZFRyYW5zYWN0aW9uLnNpZ25hdHVyZSA/IG9sZFRyYW5zYWN0aW9uLnNpZ25hdHVyZS5sZW5ndGggOiAwO1xuICAgIGxldCBzaWduZWRUcmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZWNlaXB0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlQYWlyID0gbmV3IEtleVBhaXIoeyBwcnY6IGtleS5rZXkgfSk7XG4gICAgICAvLyBTaW5jZSB0aGUga2V5IHBhaXIgd2FzIGdlbmVyYXRlZCB1c2luZyBhIHByaXZhdGUga2V5LCBpdCB3aWxsIGFsd2F5cyBoYXZlIGEgcHJ2IGF0dHJpYnV0ZSxcbiAgICAgIC8vIGhlbmNlIGl0IGlzIHNhZmUgdG8gdXNlIG5vbi1udWxsIG9wZXJhdG9yXG4gICAgICBzaWduZWRUcmFuc2FjdGlvbiA9IHNpZ25UcmFuc2FjdGlvbihrZXlQYWlyLmdldEtleXMoKS5wcnYhLCB0aGlzLnRyYW5zYWN0aW9uLnRvSnNvbigpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdGYWlsZWQgdG8gc2lnbiB0cmFuc2FjdGlvbiB2aWEgaGVscGVyLicpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgbW9yZSBzaWduYXR1cmVzIHRoYW4gd2hhdCB3ZSBzdGFydGVkIHdpdGhcbiAgICBpZiAoIXNpZ25lZFRyYW5zYWN0aW9uLnNpZ25hdHVyZSB8fCBvbGRTaWduYXR1cmVDb3VudCA+PSBzaWduZWRUcmFuc2FjdGlvbi5zaWduYXR1cmUubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdUcmFuc2FjdGlvbiBzaWduaW5nIGRpZCBub3QgcmV0dXJuIGFuIGFkZGl0aW9uYWwgc2lnbmF0dXJlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24odGhpcy5fY29pbkNvbmZpZywgc2lnbmVkVHJhbnNhY3Rpb24pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBhc3luYyBidWlsZEltcGxlbWVudGF0aW9uKCk6IFByb21pc2U8VHJhbnNhY3Rpb24+IHtcbiAgICAvLyBUaGlzIGlzIGEgbm8tb3Agc2luY2UgVHJvbiB0cmFuc2FjdGlvbnMgYXJlIGJ1aWx0IGZyb21cbiAgICBpZiAoIXRoaXMudHJhbnNhY3Rpb24uaWQpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ0EgdmFsaWQgdHJhbnNhY3Rpb24gbXVzdCBoYXZlIGFuIGlkJyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy50cmFuc2FjdGlvbik7XG4gIH1cblxuICBpbml0QnVpbGRlcih0eDogVHJhbnNhY3Rpb25SZWNlaXB0IHwgc3RyaW5nKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbiA9IHRoaXMuZnJvbUltcGxlbWVudGF0aW9uKHR4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgdGhlIHZhbGlkaXR5IG9mIHRoaXMgdHJhbnNhY3Rpb24gYnkgdGhlIGdpdmVuIGFtb3VudCBvZiB0aW1lXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBleHRlbnNpb25NcyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBleHRlbmQgdGhlIHZhbGlkVG8gdGltZVxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgZXh0ZW5kVmFsaWRUbyhleHRlbnNpb25NczogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5leHRlbmRFeHBpcmF0aW9uKGV4dGVuc2lvbk1zKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB2YWxpZGF0ZVZhbHVlKHZhbHVlOiBCaWdOdW1iZXIpOiB2b2lkIHtcbiAgICBpZiAodmFsdWUuaXNMZXNzVGhhbk9yRXF1YWxUbygwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSBjYW5ub3QgYmUgYmVsb3cgemVyby4nKTtcbiAgICB9XG5cbiAgICAvLyBtYXggbG9uZyBpbiBKYXZhIC0gYXNzdW1lZCB1cHBlciBsaW1pdCBmb3IgYSBUUlggdHJhbnNhY3Rpb25cbiAgICBpZiAodmFsdWUuaXNHcmVhdGVyVGhhbihuZXcgQmlnTnVtYmVyKCc5MjIzMzcyMDM2ODU0Nzc1ODA3JykpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gaGFuZGxlZCBieSB0aGUgamF2YXRyb24gbm9kZS4nKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdmFsaWRhdGVBZGRyZXNzKGFkZHJlc3M6IEFkZHJlc3MpOiB2b2lkIHtcbiAgICAvLyBhc3N1bWVzIGEgYmFzZSA1OCBhZGRyZXNzIGZvciBvdXIgYWRkcmVzc2VzXG4gICAgaWYgKCFpc0Jhc2U1OEFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGFkZHJlc3MuYWRkcmVzcyArICcgaXMgbm90IGEgdmFsaWQgYmFzZTU4IGFkZHJlc3MuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlS2V5KGtleTogQmFzZUtleSk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBuZXcgS2V5UGFpcih7IHBydjoga2V5LmtleSB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBub3QgdmFsaWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIGNvbnRlbnRzIG9mIGEgcmF3IHRyYW5zYWN0aW9uLiBUaGUgdmFsaWRhdGlvblxuICAgKiBwaGFzZSBpcyB0byBjb21wYXJlIHRoZSByYXctZGF0YS1oZXggdG8gdGhlIHJhdy1kYXRhIG9mIHRoZVxuICAgKiB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogVGhlIGNvbnRlbnRzIHRvIGJlIHZhbGlkYXRlZCBhcmVcbiAgICogMS4gVGhlIHRyYW5zYWN0aW9uIGlkXG4gICAqIDIuIFRoZSBleHBpcmF0aW9uIGRhdGVcbiAgICogMy4gVGhlIHRpbWVzdGFtcFxuICAgKiA0LiBUaGUgY29udHJhY3RcbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblJlY2VpcHQgfCBzdHJpbmd9IHJhd1RyYW5zYWN0aW9uIFRoZSByYXcgdHJhbnNhY3Rpb24gdG8gYmUgdmFsaWRhdGVkXG4gICAqL1xuICB2YWxpZGF0ZVJhd1RyYW5zYWN0aW9uKHJhd1RyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlY2VpcHQgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBUT0RPOiBWYWxpZGF0aW9uIG9mIHNpZ25hdHVyZVxuICAgIGlmICghcmF3VHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignUmF3IHRyYW5zYWN0aW9uIGlzIGVtcHR5Jyk7XG4gICAgfVxuICAgIGxldCBjdXJyVHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVjZWlwdDtcbiAgICAvLyByYXdUcmFuc2FjdGlvbiBjYW4gYmUgZWl0aGVyIFN0cmluZ2lmaWVkIEpTT04gT1JcbiAgICAvLyBpdCBjYW4gYmUgYSByZWd1bGFyIEpTT04gb2JqZWN0IChub3Qgc3RyaW5naWZpZWQpLlxuICAgIGlmICh0eXBlb2YgcmF3VHJhbnNhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjdXJyVHJhbnNhY3Rpb24gPSBKU09OLnBhcnNlKHJhd1RyYW5zYWN0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignVGhlcmUgd2FzIGVycm9yIGluIHBhcnNpbmcgdGhlIEpTT04gc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHJhd1RyYW5zYWN0aW9uKSkge1xuICAgICAgY3VyclRyYW5zYWN0aW9uID0gcmF3VHJhbnNhY3Rpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignVHJhbnNhY3Rpb24gaXMgbm90IGFuIG9iamVjdCBvciBzdHJpbmdpZmllZCBqc29uJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZWRSYXdEYXRhSGV4ID0gZGVjb2RlVHJhbnNhY3Rpb24oY3VyclRyYW5zYWN0aW9uLnJhd19kYXRhX2hleCk7XG4gICAgaWYgKCFjdXJyVHJhbnNhY3Rpb24udHhJRCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBJRCBpcyBlbXB0eScpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGUgdHJhbnNhY3Rpb24gSUQgZnJvbSB0aGUgcmF3IGRhdGEgaGV4XG4gICAgY29uc3QgaGV4QnVmZmVyID0gQnVmZmVyLmZyb20oY3VyclRyYW5zYWN0aW9uLnJhd19kYXRhX2hleCwgJ2hleCcpO1xuICAgIGNvbnN0IGN1cnJUeElEID0gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGhleEJ1ZmZlcikuZGlnZXN0KCdoZXgnKTtcbiAgICBpZiAoY3VyclRyYW5zYWN0aW9uLnR4SUQgIT09IGN1cnJUeElEKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIGhhcyBub3QgaGF2ZSBhIHZhbGlkIGlkJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHRoZSBleHBpcmF0aW9uIHRpbWUgZnJvbSB0aGUgcmF3LWRhdGEtaGV4XG4gICAgaWYgKGN1cnJUcmFuc2FjdGlvbi5yYXdfZGF0YS5leHBpcmF0aW9uICE9PSBkZWNvZGVkUmF3RGF0YUhleC5leHBpcmF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIGhhcyBub3QgaGF2ZSBhIHZhbGlkIGV4cGlyYXRpb24nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgdGhlIHRpbWVzdGFtcCBmcm9tIHRoZSByYXctZGF0YS1oZXhcbiAgICBpZiAoY3VyclRyYW5zYWN0aW9uLnJhd19kYXRhLnRpbWVzdGFtcCAhPT0gZGVjb2RlZFJhd0RhdGFIZXgudGltZXN0YW1wKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIGhhcyBub3QgaGF2ZSBhIHZhbGlkIHRpbWV0YW1wJyk7XG4gICAgfVxuICAgIC8vIFRyYW5zYWN0aW9uIGNvbnRyYWN0IG11c3QgZXhpc3RcbiAgICBpZiAoIWN1cnJUcmFuc2FjdGlvbi5yYXdfZGF0YS5jb250cmFjdCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdUcmFuc2FjdGlvbiBjb250cmFjdHMgYXJlIGVtcHR5Jyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHZhbGlkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgY29uc3QgaGV4QnVmZmVyID0gQnVmZmVyLmZyb20odHJhbnNhY3Rpb24udG9Kc29uKCkucmF3X2RhdGFfaGV4LCAnaGV4Jyk7XG4gICAgY29uc3QgdHhJZCA9IGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShoZXhCdWZmZXIpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmlkICE9PSB0eElkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IodHJhbnNhY3Rpb24uaWQgKyAnIGlzIG5vdCBhIHZhbGlkIHRyYW5zYWN0aW9uIGlkLiBFeHBlY3Rpbmc6ICcgKyB0eElkKTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvbigpOiBUcmFuc2FjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBzZXQgdHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uKSB7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgfVxufVxuIl19