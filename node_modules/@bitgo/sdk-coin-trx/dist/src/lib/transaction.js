"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const crypto_1 = require("crypto");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const tron_1 = require("../../resources/protobuf/tron");
const sdk_core_1 = require("@bitgo/sdk-core");
const enum_1 = require("./enum");
const utils_1 = require("./utils");
/**
 * Tron transaction model.
 */
class Transaction extends sdk_core_1.BaseTransaction {
    /**
     * Public constructor.
     *
     * @param coinConfig
     * @param rawTransaction
     */
    constructor(coinConfig, rawTransaction) {
        super(coinConfig);
        if (rawTransaction) {
            if (!rawTransaction.txID) {
                throw new sdk_core_1.ParseTransactionError('Transaction has no id');
            }
            this._id = rawTransaction.txID;
            this._transaction = rawTransaction;
            this._decodedRawDataHex = utils_1.decodeTransaction(rawTransaction.raw_data_hex);
            // Destination depends on the contract type
            this.recordRawDataFields(this._decodedRawDataHex);
        }
    }
    /**
     * Parse the transaction raw data and record the most important fields.
     *
     * @param rawData Object from a tron transaction
     */
    recordRawDataFields(rawData) {
        // Contract-agnostic fields
        this._validFrom = rawData.timestamp;
        this._validTo = rawData.expiration;
        let output, input;
        // Contract-specific fields
        switch (rawData.contractType) {
            case enum_1.ContractType.Transfer:
                this._type = sdk_core_1.TransactionType.Send;
                const value = new bignumber_js_1.default(rawData.contract[0].parameter.value.amount).toFixed(0);
                output = {
                    address: rawData.contract[0].parameter.value.to_address,
                    value,
                };
                input = {
                    address: rawData.contract[0].parameter.value.owner_address,
                    value,
                };
                break;
            case enum_1.ContractType.AccountPermissionUpdate:
                this._type = sdk_core_1.TransactionType.WalletInitialization;
                output = {
                    address: rawData.contract.owner_address,
                    value: '0',
                };
                input = {
                    address: rawData.contract.owner_address,
                    value: '0',
                };
                break;
            case enum_1.ContractType.TriggerSmartContract:
                this._type = sdk_core_1.TransactionType.ContractCall;
                const contractCallValues = rawData.contract[0].parameter.value;
                const contractAddress = contractCallValues.contract_address;
                if (utils_1.tokenMainnetContractAddresses.includes(contractAddress) ||
                    utils_1.tokenTestnetContractAddresses.includes(contractAddress)) {
                    // this is then a token smart contract transaction and the data must be decoded
                    const types = ['address', 'uint256'];
                    const data = Buffer.from(contractCallValues.data, 'base64').toString('hex');
                    const decodedData = utils_1.decodeDataParams(types, data);
                    const recipient_address = utils_1.getBase58AddressFromHex(decodedData[0]);
                    const value = decodedData[1].toString();
                    output = {
                        address: recipient_address,
                        value,
                    };
                    input = {
                        address: contractCallValues.owner_address,
                        contractAddress,
                        data,
                        value,
                    };
                    break;
                }
                output = {
                    address: contractCallValues.owner_address,
                    value: '0',
                };
                input = {
                    address: contractCallValues.owner_address,
                    contractAddress,
                    data: contractCallValues.data,
                    value: '0',
                };
                break;
            default:
                throw new sdk_core_1.ParseTransactionError('Unsupported contract type');
        }
        this._inputs = [input];
        this._outputs = [output];
    }
    /**
     * Recalculate and update the transaction id. This should be done after changing any transaction
     * field since the the id is a hash of the transaction body.
     */
    updateId() {
        if (!this._transaction) {
            throw new sdk_core_1.ParseTransactionError('Empty transaction');
        }
        const hexBuffer = Buffer.from(this._transaction.raw_data_hex, 'hex');
        const newTxid = crypto_1.createHash('sha256').update(hexBuffer).digest('hex');
        this._transaction.txID = newTxid;
        this._id = newTxid;
    }
    /**
     * Extend the expiration date by the given number of milliseconds.
     *
     * @param extensionMs The number of milliseconds to extend the expiration by
     */
    extendExpiration(extensionMs) {
        if (extensionMs < 0) {
            throw new sdk_core_1.ExtendTransactionError('Invalid extension range. Must be positive a integer');
        }
        if (!this._transaction) {
            throw new sdk_core_1.ExtendTransactionError('Empty transaction');
        }
        if (this._transaction.signature && this._transaction.signature.length > 0) {
            throw new sdk_core_1.ExtendTransactionError('Cannot extend a signed transaction');
        }
        const rawDataHex = this._transaction.raw_data_hex;
        const bytes = Buffer.from(rawDataHex, 'hex');
        let raw;
        try {
            raw = tron_1.protocol.Transaction.raw.decode(bytes);
            const newExpiration = new bignumber_js_1.default(raw.expiration).plus(extensionMs).toNumber();
            raw.expiration = newExpiration;
            const newRawDataHex = Buffer.from(tron_1.protocol.Transaction.raw.encode(raw).finish()).toString('hex');
            // Set the internal variables to account for the new expiration date
            this._transaction.raw_data_hex = newRawDataHex;
            this._transaction.raw_data.expiration = newExpiration;
            this._decodedRawDataHex = utils_1.decodeTransaction(newRawDataHex);
            this.recordRawDataFields(this._decodedRawDataHex);
            this.updateId();
        }
        catch (e) {
            throw new sdk_core_1.ExtendTransactionError('There was an error decoding the initial raw_data_hex from the serialized tx.');
        }
    }
    /**
     * Get the signatures associated with this transaction.
     */
    get signature() {
        if (this._transaction && this._transaction.signature) {
            return this._transaction.signature;
        }
        return [];
    }
    /**
     * Get the time in milliseconds this transaction becomes valid and can be broadcasted to the
     * network.
     */
    get validFrom() {
        return this._validFrom;
    }
    /**
     * Get the expiration time in milliseconds.
     */
    get validTo() {
        return this._validTo;
    }
    /** @inheritdoc */
    get outputs() {
        return this._outputs;
    }
    /** @inheritdoc */
    get inputs() {
        return this._inputs;
    }
    /** @inheritdoc */
    canSign(key) {
        // Tron transaction do not contain the owners account address so it is not possible to check the
        // private key with any but the account main address. This is not enough to fail this check, so
        // it is a no-op.
        return true;
    }
    /**
     * Sets this transaction
     *
     * @param {Transaction} tx transaction
     */
    setTransactionReceipt(tx) {
        this._transaction = tx;
        this.updateId();
    }
    /**
     * Set the transaction type
     *
     * @param {TransactionType} transactionType The transaction type to be set
     */
    setTransactionType(transactionType) {
        this._type = transactionType;
    }
    /** @inheritdoc */
    toJson() {
        if (!this._transaction) {
            throw new sdk_core_1.ParseTransactionError('Empty transaction');
        }
        return this._transaction;
    }
    /** @inheritdoc */
    toBroadcastFormat() {
        return JSON.stringify(this.toJson());
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1DQUFvQztBQUVwQyxnRUFBcUM7QUFDckMsd0RBQXlEO0FBQ3pELDhDQU15QjtBQUN6QixpQ0FBc0M7QUFDdEMsbUNBTWlCO0FBR2pCOztHQUVHO0FBQ0gsTUFBYSxXQUFZLFNBQVEsMEJBQWU7SUFVOUM7Ozs7O09BS0c7SUFDSCxZQUFZLFVBQWdDLEVBQUUsY0FBbUM7UUFDL0UsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xCLElBQUksY0FBYyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFO2dCQUN4QixNQUFNLElBQUksZ0NBQXFCLENBQUMsdUJBQXVCLENBQUMsQ0FBQzthQUMxRDtZQUNELElBQUksQ0FBQyxHQUFHLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQztZQUMvQixJQUFJLENBQUMsWUFBWSxHQUFHLGNBQWMsQ0FBQztZQUNuQyxJQUFJLENBQUMsa0JBQWtCLEdBQUcseUJBQWlCLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBRXpFLDJDQUEyQztZQUMzQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7U0FDbkQ7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLG1CQUFtQixDQUFDLE9BQWdCO1FBQzFDLDJCQUEyQjtRQUMzQixJQUFJLENBQUMsVUFBVSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7UUFDcEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO1FBRW5DLElBQUksTUFBcUIsRUFBRSxLQUFvQixDQUFDO1FBQ2hELDJCQUEyQjtRQUMzQixRQUFRLE9BQU8sQ0FBQyxZQUFZLEVBQUU7WUFDNUIsS0FBSyxtQkFBWSxDQUFDLFFBQVE7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c2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IHByb3RvY29sIH0gZnJvbSAnLi4vLi4vcmVzb3VyY2VzL3Byb3RvYnVmL3Ryb24nO1xuaW1wb3J0IHtcbiAgQmFzZUtleSxcbiAgQmFzZVRyYW5zYWN0aW9uLFxuICBFeHRlbmRUcmFuc2FjdGlvbkVycm9yLFxuICBQYXJzZVRyYW5zYWN0aW9uRXJyb3IsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IENvbnRyYWN0VHlwZSB9IGZyb20gJy4vZW51bSc7XG5pbXBvcnQge1xuICBkZWNvZGVUcmFuc2FjdGlvbixcbiAgZGVjb2RlRGF0YVBhcmFtcyxcbiAgZ2V0QmFzZTU4QWRkcmVzc0Zyb21IZXgsXG4gIHRva2VuTWFpbm5ldENvbnRyYWN0QWRkcmVzc2VzLFxuICB0b2tlblRlc3RuZXRDb250cmFjdEFkZHJlc3Nlcyxcbn0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBDb250cmFjdEVudHJ5LCBSYXdEYXRhLCBUcmFuc2FjdGlvblJlY2VpcHQsIFRyYW5zZmVyQ29udHJhY3QsIFRyaWdnZXJTbWFydENvbnRyYWN0IH0gZnJvbSAnLi9pZmFjZSc7XG5cbi8qKlxuICogVHJvbiB0cmFuc2FjdGlvbiBtb2RlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uIHtcbiAgLy8gVHJvbiBzcGVjaWZpYyBmaWVsZHNcbiAgcHJvdGVjdGVkIF92YWxpZEZyb206IG51bWJlcjtcbiAgcHJvdGVjdGVkIF92YWxpZFRvOiBudW1iZXI7XG4gIHByb3RlY3RlZCBfaW5wdXRzOiBDb250cmFjdEVudHJ5W107XG4gIHByb3RlY3RlZCBfb3V0cHV0czogQ29udHJhY3RFbnRyeVtdO1xuXG4gIHByaXZhdGUgX2RlY29kZWRSYXdEYXRhSGV4OiBSYXdEYXRhO1xuICBwcml2YXRlIF90cmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uUmVjZWlwdDtcblxuICAvKipcbiAgICogUHVibGljIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gY29pbkNvbmZpZ1xuICAgKiBAcGFyYW0gcmF3VHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+LCByYXdUcmFuc2FjdGlvbj86IFRyYW5zYWN0aW9uUmVjZWlwdCkge1xuICAgIHN1cGVyKGNvaW5Db25maWcpO1xuICAgIGlmIChyYXdUcmFuc2FjdGlvbikge1xuICAgICAgaWYgKCFyYXdUcmFuc2FjdGlvbi50eElEKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIGhhcyBubyBpZCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5faWQgPSByYXdUcmFuc2FjdGlvbi50eElEO1xuICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSByYXdUcmFuc2FjdGlvbjtcbiAgICAgIHRoaXMuX2RlY29kZWRSYXdEYXRhSGV4ID0gZGVjb2RlVHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24ucmF3X2RhdGFfaGV4KTtcblxuICAgICAgLy8gRGVzdGluYXRpb24gZGVwZW5kcyBvbiB0aGUgY29udHJhY3QgdHlwZVxuICAgICAgdGhpcy5yZWNvcmRSYXdEYXRhRmllbGRzKHRoaXMuX2RlY29kZWRSYXdEYXRhSGV4KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIHRyYW5zYWN0aW9uIHJhdyBkYXRhIGFuZCByZWNvcmQgdGhlIG1vc3QgaW1wb3J0YW50IGZpZWxkcy5cbiAgICpcbiAgICogQHBhcmFtIHJhd0RhdGEgT2JqZWN0IGZyb20gYSB0cm9uIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcml2YXRlIHJlY29yZFJhd0RhdGFGaWVsZHMocmF3RGF0YTogUmF3RGF0YSkge1xuICAgIC8vIENvbnRyYWN0LWFnbm9zdGljIGZpZWxkc1xuICAgIHRoaXMuX3ZhbGlkRnJvbSA9IHJhd0RhdGEudGltZXN0YW1wO1xuICAgIHRoaXMuX3ZhbGlkVG8gPSByYXdEYXRhLmV4cGlyYXRpb247XG5cbiAgICBsZXQgb3V0cHV0OiBDb250cmFjdEVudHJ5LCBpbnB1dDogQ29udHJhY3RFbnRyeTtcbiAgICAvLyBDb250cmFjdC1zcGVjaWZpYyBmaWVsZHNcbiAgICBzd2l0Y2ggKHJhd0RhdGEuY29udHJhY3RUeXBlKSB7XG4gICAgICBjYXNlIENvbnRyYWN0VHlwZS5UcmFuc2ZlcjpcbiAgICAgICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5TZW5kO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyBCaWdOdW1iZXIoKHJhd0RhdGEuY29udHJhY3RbMF0gYXMgVHJhbnNmZXJDb250cmFjdCkucGFyYW1ldGVyLnZhbHVlLmFtb3VudCkudG9GaXhlZCgwKTtcbiAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgIGFkZHJlc3M6IChyYXdEYXRhLmNvbnRyYWN0WzBdIGFzIFRyYW5zZmVyQ29udHJhY3QpLnBhcmFtZXRlci52YWx1ZS50b19hZGRyZXNzLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICB9O1xuICAgICAgICBpbnB1dCA9IHtcbiAgICAgICAgICBhZGRyZXNzOiAocmF3RGF0YS5jb250cmFjdFswXSBhcyBUcmFuc2ZlckNvbnRyYWN0KS5wYXJhbWV0ZXIudmFsdWUub3duZXJfYWRkcmVzcyxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnRyYWN0VHlwZS5BY2NvdW50UGVybWlzc2lvblVwZGF0ZTpcbiAgICAgICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbjtcbiAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgIGFkZHJlc3M6IChyYXdEYXRhLmNvbnRyYWN0IGFzIGFueSkub3duZXJfYWRkcmVzcyxcbiAgICAgICAgICB2YWx1ZTogJzAnLFxuICAgICAgICB9O1xuICAgICAgICBpbnB1dCA9IHtcbiAgICAgICAgICBhZGRyZXNzOiAocmF3RGF0YS5jb250cmFjdCBhcyBhbnkpLm93bmVyX2FkZHJlc3MsXG4gICAgICAgICAgdmFsdWU6ICcwJyxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnRyYWN0VHlwZS5UcmlnZ2VyU21hcnRDb250cmFjdDpcbiAgICAgICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5Db250cmFjdENhbGw7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0Q2FsbFZhbHVlcyA9IChyYXdEYXRhLmNvbnRyYWN0WzBdIGFzIFRyaWdnZXJTbWFydENvbnRyYWN0KS5wYXJhbWV0ZXIudmFsdWU7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IGNvbnRyYWN0Q2FsbFZhbHVlcy5jb250cmFjdF9hZGRyZXNzO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdG9rZW5NYWlubmV0Q29udHJhY3RBZGRyZXNzZXMuaW5jbHVkZXMoY29udHJhY3RBZGRyZXNzKSB8fFxuICAgICAgICAgIHRva2VuVGVzdG5ldENvbnRyYWN0QWRkcmVzc2VzLmluY2x1ZGVzKGNvbnRyYWN0QWRkcmVzcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGVuIGEgdG9rZW4gc21hcnQgY29udHJhY3QgdHJhbnNhY3Rpb24gYW5kIHRoZSBkYXRhIG11c3QgYmUgZGVjb2RlZFxuICAgICAgICAgIGNvbnN0IHR5cGVzID0gWydhZGRyZXNzJywgJ3VpbnQyNTYnXTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmZyb20oY29udHJhY3RDYWxsVmFsdWVzLmRhdGEsICdiYXNlNjQnKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgICAgY29uc3QgZGVjb2RlZERhdGEgPSBkZWNvZGVEYXRhUGFyYW1zKHR5cGVzLCBkYXRhKTtcbiAgICAgICAgICBjb25zdCByZWNpcGllbnRfYWRkcmVzcyA9IGdldEJhc2U1OEFkZHJlc3NGcm9tSGV4KGRlY29kZWREYXRhWzBdKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlY29kZWREYXRhWzFdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgb3V0cHV0ID0ge1xuICAgICAgICAgICAgYWRkcmVzczogcmVjaXBpZW50X2FkZHJlc3MsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlucHV0ID0ge1xuICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3RDYWxsVmFsdWVzLm93bmVyX2FkZHJlc3MsXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQgPSB7XG4gICAgICAgICAgYWRkcmVzczogY29udHJhY3RDYWxsVmFsdWVzLm93bmVyX2FkZHJlc3MsXG4gICAgICAgICAgdmFsdWU6ICcwJyxcbiAgICAgICAgfTtcbiAgICAgICAgaW5wdXQgPSB7XG4gICAgICAgICAgYWRkcmVzczogY29udHJhY3RDYWxsVmFsdWVzLm93bmVyX2FkZHJlc3MsXG4gICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgIGRhdGE6IGNvbnRyYWN0Q2FsbFZhbHVlcy5kYXRhLFxuICAgICAgICAgIHZhbHVlOiAnMCcsXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignVW5zdXBwb3J0ZWQgY29udHJhY3QgdHlwZScpO1xuICAgIH1cbiAgICB0aGlzLl9pbnB1dHMgPSBbaW5wdXRdO1xuICAgIHRoaXMuX291dHB1dHMgPSBbb3V0cHV0XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZSBhbmQgdXBkYXRlIHRoZSB0cmFuc2FjdGlvbiBpZC4gVGhpcyBzaG91bGQgYmUgZG9uZSBhZnRlciBjaGFuZ2luZyBhbnkgdHJhbnNhY3Rpb25cbiAgICogZmllbGQgc2luY2UgdGhlIHRoZSBpZCBpcyBhIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGJvZHkuXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUlkKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGhleEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRoaXMuX3RyYW5zYWN0aW9uLnJhd19kYXRhX2hleCwgJ2hleCcpO1xuICAgIGNvbnN0IG5ld1R4aWQgPSBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoaGV4QnVmZmVyKS5kaWdlc3QoJ2hleCcpO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uLnR4SUQgPSBuZXdUeGlkO1xuICAgIHRoaXMuX2lkID0gbmV3VHhpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbmQgdGhlIGV4cGlyYXRpb24gZGF0ZSBieSB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAgICpcbiAgICogQHBhcmFtIGV4dGVuc2lvbk1zIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGV4dGVuZCB0aGUgZXhwaXJhdGlvbiBieVxuICAgKi9cbiAgZXh0ZW5kRXhwaXJhdGlvbihleHRlbnNpb25NczogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKGV4dGVuc2lvbk1zIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEV4dGVuZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgZXh0ZW5zaW9uIHJhbmdlLiBNdXN0IGJlIHBvc2l0aXZlIGEgaW50ZWdlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFeHRlbmRUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbi5zaWduYXR1cmUgJiYgdGhpcy5fdHJhbnNhY3Rpb24uc2lnbmF0dXJlLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFeHRlbmRUcmFuc2FjdGlvbkVycm9yKCdDYW5ub3QgZXh0ZW5kIGEgc2lnbmVkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgcmF3RGF0YUhleCA9IHRoaXMuX3RyYW5zYWN0aW9uLnJhd19kYXRhX2hleDtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5mcm9tKHJhd0RhdGFIZXgsICdoZXgnKTtcbiAgICBsZXQgcmF3O1xuICAgIHRyeSB7XG4gICAgICByYXcgPSBwcm90b2NvbC5UcmFuc2FjdGlvbi5yYXcuZGVjb2RlKGJ5dGVzKTtcbiAgICAgIGNvbnN0IG5ld0V4cGlyYXRpb24gPSBuZXcgQmlnTnVtYmVyKHJhdy5leHBpcmF0aW9uKS5wbHVzKGV4dGVuc2lvbk1zKS50b051bWJlcigpO1xuICAgICAgcmF3LmV4cGlyYXRpb24gPSBuZXdFeHBpcmF0aW9uO1xuICAgICAgY29uc3QgbmV3UmF3RGF0YUhleCA9IEJ1ZmZlci5mcm9tKHByb3RvY29sLlRyYW5zYWN0aW9uLnJhdy5lbmNvZGUocmF3KS5maW5pc2goKSkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgLy8gU2V0IHRoZSBpbnRlcm5hbCB2YXJpYWJsZXMgdG8gYWNjb3VudCBmb3IgdGhlIG5ldyBleHBpcmF0aW9uIGRhdGVcbiAgICAgIHRoaXMuX3RyYW5zYWN0aW9uLnJhd19kYXRhX2hleCA9IG5ld1Jhd0RhdGFIZXg7XG4gICAgICB0aGlzLl90cmFuc2FjdGlvbi5yYXdfZGF0YS5leHBpcmF0aW9uID0gbmV3RXhwaXJhdGlvbjtcbiAgICAgIHRoaXMuX2RlY29kZWRSYXdEYXRhSGV4ID0gZGVjb2RlVHJhbnNhY3Rpb24obmV3UmF3RGF0YUhleCk7XG4gICAgICB0aGlzLnJlY29yZFJhd0RhdGFGaWVsZHModGhpcy5fZGVjb2RlZFJhd0RhdGFIZXgpO1xuICAgICAgdGhpcy51cGRhdGVJZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFeHRlbmRUcmFuc2FjdGlvbkVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3IgZGVjb2RpbmcgdGhlIGluaXRpYWwgcmF3X2RhdGFfaGV4IGZyb20gdGhlIHNlcmlhbGl6ZWQgdHguJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2lnbmF0dXJlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGdldCBzaWduYXR1cmUoKTogc3RyaW5nW10ge1xuICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbiAmJiB0aGlzLl90cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbi5zaWduYXR1cmU7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0aGlzIHRyYW5zYWN0aW9uIGJlY29tZXMgdmFsaWQgYW5kIGNhbiBiZSBicm9hZGNhc3RlZCB0byB0aGVcbiAgICogbmV0d29yay5cbiAgICovXG4gIGdldCB2YWxpZEZyb20oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWRGcm9tO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXhwaXJhdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAgICovXG4gIGdldCB2YWxpZFRvKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkVG87XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgZ2V0IG91dHB1dHMoKTogQ29udHJhY3RFbnRyeVtdIHtcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0cztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBnZXQgaW5wdXRzKCk6IENvbnRyYWN0RW50cnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0cztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBjYW5TaWduKGtleTogQmFzZUtleSk6IGJvb2xlYW4ge1xuICAgIC8vIFRyb24gdHJhbnNhY3Rpb24gZG8gbm90IGNvbnRhaW4gdGhlIG93bmVycyBhY2NvdW50IGFkZHJlc3Mgc28gaXQgaXMgbm90IHBvc3NpYmxlIHRvIGNoZWNrIHRoZVxuICAgIC8vIHByaXZhdGUga2V5IHdpdGggYW55IGJ1dCB0aGUgYWNjb3VudCBtYWluIGFkZHJlc3MuIFRoaXMgaXMgbm90IGVub3VnaCB0byBmYWlsIHRoaXMgY2hlY2ssIHNvXG4gICAgLy8gaXQgaXMgYSBuby1vcC5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoaXMgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHggdHJhbnNhY3Rpb25cbiAgICovXG4gIHNldFRyYW5zYWN0aW9uUmVjZWlwdCh0eDogVHJhbnNhY3Rpb25SZWNlaXB0KSB7XG4gICAgdGhpcy5fdHJhbnNhY3Rpb24gPSB0eDtcbiAgICB0aGlzLnVwZGF0ZUlkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB0cmFuc2FjdGlvbiB0eXBlXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25UeXBlfSB0cmFuc2FjdGlvblR5cGUgVGhlIHRyYW5zYWN0aW9uIHR5cGUgdG8gYmUgc2V0XG4gICAqL1xuICBzZXRUcmFuc2FjdGlvblR5cGUodHJhbnNhY3Rpb25UeXBlOiBUcmFuc2FjdGlvblR5cGUpOiB2b2lkIHtcbiAgICB0aGlzLl90eXBlID0gdHJhbnNhY3Rpb25UeXBlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHRvSnNvbigpOiBUcmFuc2FjdGlvblJlY2VpcHQge1xuICAgIGlmICghdGhpcy5fdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB0b0Jyb2FkY2FzdEZvcm1hdCgpOiBhbnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSnNvbigpKTtcbiAgfVxufVxuIl19