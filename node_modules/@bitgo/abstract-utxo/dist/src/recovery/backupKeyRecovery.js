"use strict";
/**
 * @prettier
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.backupKeyRecovery = void 0;
const assert = require("assert");
const _ = require("lodash");
const utxolib = require("@bitgo/utxo-lib");
const { getInternalChainCode, scriptTypeForChain, outputScripts, getExternalChainCode } = utxolib.bitgo;
const unspents_1 = require("@bitgo/unspents");
const sdk_core_1 = require("@bitgo/sdk-core");
const RecoveryProvider_1 = require("./RecoveryProvider");
const mempoolApi_1 = require("./mempoolApi");
const coingeckoApi_1 = require("./coingeckoApi");
const sign_1 = require("../sign");
const utxo_lib_1 = require("@bitgo/utxo-lib");
/**
 * This transforms the txInfo from recover into the format that offline-signing-tool expects
 * @param coinName
 * @param txInfo
 * @param txHex
 * @returns {{txHex: *, txInfo: {unspents: *}, feeInfo: {}, coin: void}}
 */
function formatForOfflineVault(coinName, txInfo, txHex) {
    return {
        txHex,
        txInfo: {
            unspents: txInfo.inputs.map((input) => {
                assert(input.valueString);
                return { ...input, valueString: input.valueString };
            }),
        },
        feeInfo: {},
        coin: coinName,
    };
}
/**
 * Get the current market price from a third party to be used for recovery
 * This function is only intended for non-bitgo recovery transactions, when it is necessary
 * to calculate the rough fee needed to pay to Keyternal. We are okay with approximating,
 * because the resulting price of this function only has less than 1 dollar influence on the
 * fee that needs to be paid to Keyternal.
 *
 * See calculateFeeAmount function:  return Math.round(feeAmountUsd / currentPrice * self.getBaseFactor());
 *
 * This end function should not be used as an accurate endpoint, since some coins' prices are missing from the provider
 */
async function getRecoveryMarketPrice(coin) {
    return await new coingeckoApi_1.CoingeckoApi().getUSDPrice(coin.getFamily());
}
/**
 * Calculates the amount (in base units) to pay a KRS provider when building a recovery transaction
 * @param coin
 * @param params
 * @param params.provider {String} the KRS provider that holds the backup key
 * @returns {*}
 */
async function calculateFeeAmount(coin, params) {
    const krsProvider = sdk_core_1.krsProviders[params.provider];
    if (krsProvider === undefined) {
        throw new Error(`no fee structure specified for provider ${params.provider}`);
    }
    if (krsProvider.feeType === 'flatUsd') {
        const feeAmountUsd = krsProvider.feeAmount;
        const currentPrice = await getRecoveryMarketPrice(coin);
        return Math.round((feeAmountUsd / currentPrice) * coin.getBaseFactor());
    }
    else {
        // we can add more fee structures here as needed for different providers, such as percentage of recovery amount
        throw new Error('Fee structure not implemented');
    }
}
async function queryBlockchainUnspentsPath(coin, params, walletKeys, chain) {
    var _a;
    const scriptType = scriptTypeForChain(chain);
    const fetchPrevTx = !utxolib.bitgo.outputScripts.hasWitnessData(scriptType) && utxo_lib_1.getMainnet(coin.network) !== utxo_lib_1.networks.zcash;
    const recoveryProvider = (_a = params.recoveryProvider) !== null && _a !== void 0 ? _a : RecoveryProvider_1.forCoin(coin.getChain(), params.apiKey);
    const MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS = params.scan || 20;
    let numSequentialAddressesWithoutTxs = 0;
    const prevTxCache = new Map();
    async function getPrevTx(txid) {
        let prevTxHex = prevTxCache.get(txid);
        if (!prevTxHex) {
            prevTxHex = await recoveryProvider.getTransactionHex(txid);
            prevTxCache.set(txid, prevTxHex);
        }
        return prevTxHex;
    }
    async function gatherUnspents(addrIndex) {
        const walletKeysForUnspent = walletKeys.deriveForChainAndIndex(chain, addrIndex);
        const address = coin.createMultiSigAddress(scriptType, 2, walletKeysForUnspent.publicKeys);
        // Blockchair uses cashaddr format when querying the API for address information. Convert legacy addresses to cashaddr
        // before querying the API.
        const formattedAddress = coin.getChain() === 'bch' ? coin.canonicalAddress(address.address, 'cashaddr').split(':')[1] : address.address;
        const addrInfo = await recoveryProvider.getAddressInfo(formattedAddress);
        // we use txCount here because it implies usage - having tx'es means the addr was generated and used
        if (addrInfo.txCount === 0) {
            numSequentialAddressesWithoutTxs++;
        }
        else {
            numSequentialAddressesWithoutTxs = 0;
            if (addrInfo.balance > 0) {
                console.log(`Found an address with balance: ${address.address} with balance ${addrInfo.balance}`);
                const addressUnspents = await recoveryProvider.getUnspentsForAddresses([formattedAddress]);
                const processedUnspents = await Promise.all(addressUnspents.map(async (u) => {
                    const { txid, vout } = utxolib.bitgo.parseOutputId(u.id);
                    let val = BigInt(u.value);
                    if (coin.amountType === 'bigint') {
                        // blockchair returns the number with the correct precision, but in number format
                        // json parse won't parse it correctly, so we requery the txid for the tx hex to decode here
                        if (!Number.isSafeInteger(u.value)) {
                            const txHex = await getPrevTx(txid);
                            const tx = coin.createTransactionFromHex(txHex);
                            val = tx.outs[vout].value;
                        }
                    }
                    // the api may return cashaddr's instead of legacy for BCH and BCHA
                    // downstream processes's only expect legacy addresses
                    u = { ...u, address: coin.canonicalAddress(u.address) };
                    return {
                        ...u,
                        value: val,
                        chain: chain,
                        index: addrIndex,
                        prevTx: fetchPrevTx ? Buffer.from(await getPrevTx(txid), 'hex') : undefined,
                    };
                }));
                walletUnspents.push(...processedUnspents);
            }
        }
        if (numSequentialAddressesWithoutTxs >= MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS) {
            // stop searching for addresses with unspents in them, we've found ${MAX_SEQUENTIAL_ADDRESSES_WITHOUT_TXS} in a row with none
            // we are done
            return;
        }
        return gatherUnspents(addrIndex + 1);
    }
    // get unspents for these addresses
    const walletUnspents = [];
    // This will populate walletAddresses
    await gatherUnspents(0);
    if (walletUnspents.length === 0) {
        // Couldn't find any addresses with funds
        return [];
    }
    return walletUnspents;
}
async function getRecoveryFeePerBytes(coin, { defaultValue }) {
    try {
        return await mempoolApi_1.MempoolApi.forCoin(coin.getChain()).getRecoveryFeePerBytes();
    }
    catch (e) {
        console.dir(e);
        return defaultValue;
    }
}
/**
 * Builds a funds recovery transaction without BitGo.
 *
 * Returns transaction hex in legacy format for unsigned sweep transaction, half signed backup recovery transaction with KRS provider (only keyternal),
 * fully signed backup recovery transaction without a KRS provider.
 *
 * Returns PSBT hex for half signed backup recovery transaction with KRS provider (excluding keyternal)
 * For PSBT hex cases, Unspents are not required in response.
 *
 * @param coin
 * @param bitgo
 * @param params
 * - userKey: [encrypted] xprv, or xpub
 * - backupKey: [encrypted] xprv, or xpub if the xprv is held by a KRS provider
 * - walletPassphrase: necessary if one of the xprvs is encrypted
 * - bitgoKey: xpub
 * - krsProvider: necessary if backup key is held by KRS
 * - recoveryDestination: target address to send recovered funds to
 * - scan: the amount of consecutive addresses without unspents to scan through before stopping
 * - ignoreAddressTypes: (optional) scripts to ignore
 *        for example: ['p2shP2wsh', 'p2wsh'] will prevent code from checking for wrapped-segwit and native-segwit chains on the public block explorers
 */
async function backupKeyRecovery(coin, bitgo, params) {
    if (_.isUndefined(params.userKey)) {
        throw new Error('missing userKey');
    }
    if (_.isUndefined(params.backupKey)) {
        throw new Error('missing backupKey');
    }
    if (_.isUndefined(params.recoveryDestination) ||
        !coin.isValidAddress(params.recoveryDestination, { anyFormat: true })) {
        throw new Error('invalid recoveryDestination');
    }
    if (!_.isUndefined(params.scan) && (!_.isInteger(params.scan) || params.scan < 0)) {
        throw new Error('scan must be a positive integer');
    }
    const isKrsRecovery = sdk_core_1.getIsKrsRecovery(params);
    const isUnsignedSweep = sdk_core_1.getIsUnsignedSweep(params);
    const responseTxFormat = isUnsignedSweep || !isKrsRecovery || params.krsProvider === 'keyternal' ? 'legacy' : 'psbt';
    const krsProvider = isKrsRecovery ? sdk_core_1.getKrsProvider(coin, params.krsProvider) : undefined;
    // check whether key material and password authenticate the users and return parent keys of all three keys of the wallet
    const keys = sdk_core_1.getBip32Keys(bitgo, params, { requireBitGoXpub: true });
    if (!sdk_core_1.isTriple(keys)) {
        throw new Error(`expected key triple`);
    }
    const walletKeys = new utxolib.bitgo.RootWalletKeys(keys, [
        params.userKeyPath || utxolib.bitgo.RootWalletKeys.defaultPrefix,
        utxolib.bitgo.RootWalletKeys.defaultPrefix,
        utxolib.bitgo.RootWalletKeys.defaultPrefix,
    ]);
    const unspents = (await Promise.all(outputScripts.scriptTypes2Of3
        .filter((addressType) => { var _a; return coin.supportsAddressType(addressType) && !((_a = params.ignoreAddressTypes) === null || _a === void 0 ? void 0 : _a.includes(addressType)); })
        .reduce((queries, addressType) => [
        ...queries,
        queryBlockchainUnspentsPath(coin, params, walletKeys, getExternalChainCode(addressType)),
        queryBlockchainUnspentsPath(coin, params, walletKeys, getInternalChainCode(addressType)),
    ], []))).flat();
    // Execute the queries and gather the unspents
    const totalInputAmount = utxolib.bitgo.unspentSum(unspents, 'bigint');
    if (totalInputAmount <= BigInt(0)) {
        throw new sdk_core_1.ErrorNoInputToRecover();
    }
    // Build the psbt
    const psbt = utxolib.bitgo.createPsbtForNetwork({ network: coin.network });
    // xpubs can become handy for many things.
    utxolib.bitgo.addXpubsToPsbt(psbt, walletKeys);
    const txInfo = {};
    const feePerByte = await getRecoveryFeePerBytes(coin, { defaultValue: 100 });
    // KRS recovery transactions have a 2nd output to pay the recovery fee, like paygo fees. Use p2wsh outputs because
    // they are the largest outputs and thus the most conservative estimate to use in calculating fees. Also use
    // segwit overhead size and p2sh inputs for the same reason.
    const outputSize = (isKrsRecovery ? 2 : 1) * unspents_1.VirtualSizes.txP2wshOutputSize;
    const approximateSize = unspents_1.VirtualSizes.txSegOverheadVSize + outputSize + unspents_1.VirtualSizes.txP2shInputSize * unspents.length;
    const approximateFee = BigInt(approximateSize * feePerByte);
    txInfo.inputs =
        responseTxFormat === 'legacy'
            ? unspents.map((u) => ({ ...u, value: Number(u.value), valueString: u.value.toString(), prevTx: undefined }))
            : undefined;
    unspents.forEach((unspent) => {
        utxolib.bitgo.addWalletUnspentToPsbt(psbt, unspent, walletKeys, 'user', 'backup', coin.network);
    });
    let krsFee = BigInt(0);
    if (isKrsRecovery && params.krsProvider) {
        try {
            krsFee = BigInt(await calculateFeeAmount(coin, { provider: params.krsProvider }));
        }
        catch (err) {
            // Don't let this error block the recovery -
            console.dir(err);
        }
    }
    const recoveryAmount = totalInputAmount - approximateFee - krsFee;
    if (recoveryAmount < BigInt(0)) {
        throw new Error(`this wallet\'s balance is too low to pay the fees specified by the KRS provider. 
          Existing balance on wallet: ${totalInputAmount.toString()}. Estimated network fee for the recovery transaction
          : ${approximateFee.toString()}, KRS fee to pay: ${krsFee.toString()}. After deducting fees, your total 
          recoverable balance is ${recoveryAmount.toString()}`);
    }
    const recoveryOutputScript = utxolib.address.toOutputScript(params.recoveryDestination, coin.network);
    psbt.addOutput({ script: recoveryOutputScript, value: recoveryAmount });
    if (krsProvider && krsFee > BigInt(0)) {
        if (!krsProvider.feeAddresses) {
            throw new Error(`keyProvider must define feeAddresses`);
        }
        const krsFeeAddress = krsProvider.feeAddresses[coin.getChain()];
        if (!krsFeeAddress) {
            throw new Error('this KRS provider has not configured their fee structure yet - recovery cannot be completed');
        }
        const krsFeeOutputScript = utxolib.address.toOutputScript(krsFeeAddress, coin.network);
        psbt.addOutput({ script: krsFeeOutputScript, value: krsFee });
    }
    if (isUnsignedSweep) {
        // TODO BTC-317 - When ready to PSBTify OVC, send psbt hex and skip unspents in response.
        const txHex = psbt.getUnsignedTx().toBuffer().toString('hex');
        return formatForOfflineVault(coin.getChain(), txInfo, txHex);
    }
    else {
        sign_1.signAndVerifyPsbt(psbt, walletKeys.user, { isLastSignature: false });
        if (isKrsRecovery) {
            // The KRS provider keyternal solely supports P2SH, P2WSH, and P2SH-P2WSH input script types.
            // It currently uses an outdated BitGoJS SDK, which relies on a legacy transaction builder for cosigning.
            // Unfortunately, upgrading the keyternal code presents challenges,
            // which hinders the integration of the latest BitGoJS SDK with PSBT signing support.
            txInfo.transactionHex =
                params.krsProvider === 'keyternal'
                    ? utxolib.bitgo.extractP2msOnlyHalfSignedTx(psbt).toBuffer().toString('hex')
                    : psbt.toHex();
        }
        else {
            const tx = sign_1.signAndVerifyPsbt(psbt, walletKeys.backup, { isLastSignature: true });
            txInfo.transactionHex = tx.toBuffer().toString('hex');
        }
    }
    if (isKrsRecovery) {
        txInfo.coin = coin.getChain();
        txInfo.backupKey = params.backupKey;
        txInfo.recoveryAmount = Number(recoveryAmount);
        txInfo.recoveryAmountString = recoveryAmount.toString();
    }
    return txInfo;
}
exports.backupKeyRecovery = backupKeyRecovery;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja3VwS2V5UmVjb3ZlcnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcmVjb3ZlcnkvYmFja3VwS2V5UmVjb3ZlcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOztHQUVHOzs7QUFFSCxpQ0FBaUM7QUFDakMsNEJBQTRCO0FBQzVCLDJDQUEyQztBQUMzQyxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsa0JBQWtCLEVBQUUsYUFBYSxFQUFFLG9CQUFvQixFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztBQVV4Ryw4Q0FBK0M7QUFFL0MsOENBU3lCO0FBR3pCLHlEQUErRDtBQUMvRCw2Q0FBMEM7QUFDMUMsaURBQThDO0FBQzlDLGtDQUE0QztBQUM1Qyw4Q0FBdUQ7QUFldkQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxxQkFBcUIsQ0FDNUIsUUFBZ0IsRUFDaEIsTUFBMEIsRUFDMUIsS0FBYTtJQUViLE9BQU87UUFDTCxLQUFLO1FBQ0wsTUFBTSxFQUFFO1lBQ04sUUFBUSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ3BDLE1BQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQzFCLE9BQU8sRUFBRSxHQUFHLEtBQUssRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ3RELENBQUMsQ0FBQztTQUNIO1FBQ0QsT0FBTyxFQUFFLEVBQUU7UUFDWCxJQUFJLEVBQUUsUUFBUTtLQUNmLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7R0FVRztBQUNILEtBQUssVUFBVSxzQkFBc0IsQ0FBQyxJQUFzQjtJQUMxRCxPQUFPLE1BQU0sSUFBSSwyQkFBWSxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0FBQ2hFLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxLQUFLLFVBQVUsa0JB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WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCAqIGFzIGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuY29uc3QgeyBnZXRJbnRlcm5hbENoYWluQ29kZSwgc2NyaXB0VHlwZUZvckNoYWluLCBvdXRwdXRTY3JpcHRzLCBnZXRFeHRlcm5hbENoYWluQ29kZSB9ID0gdXR4b2xpYi5iaXRnbztcblxudHlwZSBDaGFpbkNvZGUgPSB1dHhvbGliLmJpdGdvLkNoYWluQ29kZTtcbnR5cGUgUm9vdFdhbGxldEtleXMgPSB1dHhvbGliLmJpdGdvLlJvb3RXYWxsZXRLZXlzO1xudHlwZSBXYWxsZXRVbnNwZW50PFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+ID0gdXR4b2xpYi5iaXRnby5XYWxsZXRVbnNwZW50PFROdW1iZXI+O1xudHlwZSBXYWxsZXRVbnNwZW50SlNPTiA9IHV0eG9saWIuYml0Z28uV2FsbGV0VW5zcGVudCAmIHtcbiAgdmFsdWVTdHJpbmc6IHN0cmluZztcbn07XG50eXBlIFNjcmlwdFR5cGUyT2YzID0gdXR4b2xpYi5iaXRnby5vdXRwdXRTY3JpcHRzLlNjcmlwdFR5cGUyT2YzO1xuXG5pbXBvcnQgeyBWaXJ0dWFsU2l6ZXMgfSBmcm9tICdAYml0Z28vdW5zcGVudHMnO1xuXG5pbXBvcnQge1xuICBCaXRHb0Jhc2UsXG4gIEVycm9yTm9JbnB1dFRvUmVjb3ZlcixcbiAgZ2V0S3JzUHJvdmlkZXIsXG4gIGdldEJpcDMyS2V5cyxcbiAgZ2V0SXNLcnNSZWNvdmVyeSxcbiAgZ2V0SXNVbnNpZ25lZFN3ZWVwLFxuICBpc1RyaXBsZSxcbiAga3JzUHJvdmlkZXJzLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RVdHhvQ29pbiB9IGZyb20gJy4uL2Fic3RyYWN0VXR4b0NvaW4nO1xuXG5pbXBvcnQgeyBmb3JDb2luLCBSZWNvdmVyeVByb3ZpZGVyIH0gZnJvbSAnLi9SZWNvdmVyeVByb3ZpZGVyJztcbmltcG9ydCB7IE1lbXBvb2xBcGkgfSBmcm9tICcuL21lbXBvb2xBcGknO1xuaW1wb3J0IHsgQ29pbmdlY2tvQXBpIH0gZnJvbSAnLi9jb2luZ2Vja29BcGknO1xuaW1wb3J0IHsgc2lnbkFuZFZlcmlmeVBzYnQgfSBmcm9tICcuLi9zaWduJztcbmltcG9ydCB7IGdldE1haW5uZXQsIG5ldHdvcmtzIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcblxuZXhwb3J0IGludGVyZmFjZSBPZmZsaW5lVmF1bHRUeEluZm8ge1xuICBpbnB1dHM6IFdhbGxldFVuc3BlbnQ8bnVtYmVyPltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdHRlZE9mZmxpbmVWYXVsdFR4SW5mbyB7XG4gIHR4SW5mbzoge1xuICAgIHVuc3BlbnRzOiBXYWxsZXRVbnNwZW50SlNPTltdO1xuICB9O1xuICB0eEhleDogc3RyaW5nO1xuICBmZWVJbmZvOiBSZWNvcmQ8c3RyaW5nLCBuZXZlcj47XG4gIGNvaW46IHN0cmluZztcbn1cblxuLyoqXG4gKiBUaGlzIHRyYW5zZm9ybXMgdGhlIHR4SW5mbyBmcm9tIHJlY292ZXIgaW50byB0aGUgZm9ybWF0IHRoYXQgb2ZmbGluZS1zaWduaW5nLXRvb2wgZXhwZWN0c1xuICogQHBhcmFtIGNvaW5OYW1lXG4gKiBAcGFyYW0gdHhJbmZvXG4gKiBAcGFyYW0gdHhIZXhcbiAqIEByZXR1cm5zIHt7dHhIZXg6ICosIHR4SW5mbzoge3Vuc3BlbnRzOiAqfSwgZmVlSW5mbzoge30sIGNvaW46IHZvaWR9fVxuICovXG5mdW5jdGlvbiBmb3JtYXRGb3JPZmZsaW5lVmF1bHQoXG4gIGNvaW5OYW1lOiBzdHJpbmcsXG4gIHR4SW5mbzogT2ZmbGluZVZhdWx0VHhJbmZvLFxuICB0eEhleDogc3RyaW5nXG4pOiBGb3JtYXR0ZWRPZmZsaW5lVmF1bHRUeEluZm8ge1xuICByZXR1cm4ge1xuICAgIHR4SGV4LFxuICAgIHR4SW5mbzoge1xuICAgICAgdW5zcGVudHM6IHR4SW5mby5pbnB1dHMubWFwKChpbnB1dCkgPT4ge1xuICAgICAgICBhc3NlcnQoaW5wdXQudmFsdWVTdHJpbmcpO1xuICAgICAgICByZXR1cm4geyAuLi5pbnB1dCwgdmFsdWVTdHJpbmc6IGlucHV0LnZhbHVlU3RyaW5nIH07XG4gICAgICB9KSxcbiAgICB9LFxuICAgIGZlZUluZm86IHt9LFxuICAgIGNvaW46IGNvaW5OYW1lLFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBtYXJrZXQgcHJpY2UgZnJvbSBhIHRoaXJkIHBhcnR5IHRvIGJlIHVzZWQgZm9yIHJlY292ZXJ5XG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgaW50ZW5kZWQgZm9yIG5vbi1iaXRnbyByZWNvdmVyeSB0cmFuc2FjdGlvbnMsIHdoZW4gaXQgaXMgbmVjZXNzYXJ5XG4gKiB0byBjYWxjdWxhdGUgdGhlIHJvdWdoIGZlZSBuZWVkZWQgdG8gcGF5IHRvIEtleXRlcm5hbC4gV2UgYXJlIG9rYXkgd2l0aCBhcHByb3hpbWF0aW5nLFxuICogYmVjYXVzZSB0aGUgcmVzdWx0aW5nIHByaWNlIG9mIHRoaXMgZnVuY3Rpb24gb25seSBoYXMgbGVzcyB0aGFuIDEgZG9sbGFyIGluZmx1ZW5jZSBvbiB0aGVcbiAqIGZlZSB0aGF0IG5lZWRzIHRvIGJlIHBhaWQgdG8gS2V5dGVybmFsLlxuICpcbiAqIFNlZSBjYWxjdWxhdGVGZWVBbW91bnQgZnVuY3Rpb246ICByZXR1cm4gTWF0aC5yb3VuZChmZWVBbW91bnRVc2QgLyBjdXJyZW50UHJpY2UgKiBzZWxmLmdldEJhc2VGYWN0b3IoKSk7XG4gKlxuICogVGhpcyBlbmQgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSB1c2VkIGFzIGFuIGFjY3VyYXRlIGVuZHBvaW50LCBzaW5jZSBzb21lIGNvaW5zJyBwcmljZXMgYXJlIG1pc3NpbmcgZnJvbSB0aGUgcHJvdmlkZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVjb3ZlcnlNYXJrZXRQcmljZShjb2luOiBBYnN0cmFjdFV0eG9Db2luKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgcmV0dXJuIGF3YWl0IG5ldyBDb2luZ2Vja29BcGkoKS5nZXRVU0RQcmljZShjb2luLmdldEZhbWlseSgpKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhbW91bnQgKGluIGJhc2UgdW5pdHMpIHRvIHBheSBhIEtSUyBwcm92aWRlciB3aGVuIGJ1aWxkaW5nIGEgcmVjb3ZlcnkgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBjb2luXG4gKiBAcGFyYW0gcGFyYW1zXG4gKiBAcGFyYW0gcGFyYW1zLnByb3ZpZGVyIHtTdHJpbmd9IHRoZSBLUlMgcHJvdmlkZXIgdGhhdCBob2xkcyB0aGUgYmFja3VwIGtleVxuICogQHJldHVybnMgeyp9XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNhbGN1bGF0ZUZlZUFtb3VudChjb2luOiBBYnN0cmFjdFV0eG9Db2luLCBwYXJhbXM6IHsgcHJvdmlkZXI6IHN0cmluZyB9KTogUHJvbWlzZTxudW1iZXI+IHtcbiAgY29uc3Qga3JzUHJvdmlkZXIgPSBrcnNQcm92aWRlcnNbcGFyYW1zLnByb3ZpZGVyXTtcblxuICBpZiAoa3JzUHJvdmlkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbm8gZmVlIHN0cnVjdHVyZSBzcGVjaWZpZWQgZm9yIHByb3ZpZGVyICR7cGFyYW1zLnByb3ZpZGVyfWApO1xuICB9XG5cbiAgaWYgKGtyc1Byb3ZpZGVyLmZlZVR5cGUgPT09ICdmbGF0VXNkJykge1xuICAgIGNvbnN0IGZlZUFtb3VudFVzZCA9IGtyc1Byb3ZpZGVyLmZlZUFtb3VudDtcbiAgICBjb25zdCBjdXJyZW50UHJpY2U6IG51bWJlciA9IGF3YWl0IGdldFJlY292ZXJ5TWFya2V0UHJpY2UoY29pbik7XG5cbiAgICByZXR1cm4gTWF0aC5yb3VuZCgoZmVlQW1vdW50VXNkIC8gY3VycmVudFByaWNlKSAqIGNvaW4uZ2V0QmFzZUZhY3RvcigpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3ZSBjYW4gYWRkIG1vcmUgZmVlIHN0cnVjdHVyZXMgaGVyZSBhcyBuZWVkZWQgZm9yIGRpZmZlcmVudCBwcm92aWRlcnMsIHN1Y2ggYXMgcGVyY2VudGFnZSBvZiByZWNvdmVyeSBhbW91bnRcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZlZSBzdHJ1Y3R1cmUgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWNvdmVyUGFyYW1zIHtcbiAgc2Nhbj86IG51bWJlcjtcbiAgdXNlcktleTogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgYml0Z29LZXk6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xuICBrcnNQcm92aWRlcj86IHN0cmluZztcbiAgaWdub3JlQWRkcmVzc1R5cGVzOiBTY3JpcHRUeXBlMk9mM1tdO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBhcGlLZXk/OiBzdHJpbmc7XG4gIHVzZXJLZXlQYXRoPzogc3RyaW5nO1xuICByZWNvdmVyeVByb3ZpZGVyPzogUmVjb3ZlcnlQcm92aWRlcjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcXVlcnlCbG9ja2NoYWluVW5zcGVudHNQYXRoKFxuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luLFxuICBwYXJhbXM6IFJlY292ZXJQYXJhbXMsXG4gIHdhbGxldEtleXM6IFJvb3RXYWxsZXRLZXlzLFxuICBjaGFpbjogQ2hhaW5Db2RlXG4pOiBQcm9taXNlPFdhbGxldFVuc3BlbnQ8YmlnaW50PltdPiB7XG4gIGNvbnN0IHNjcmlwdFR5cGUgPSBzY3JpcHRUeXBlRm9yQ2hhaW4oY2hhaW4pO1xuICBjb25zdCBmZXRjaFByZXZUeCA9XG4gICAgIXV0eG9saWIuYml0Z28ub3V0cHV0U2NyaXB0cy5oYXNXaXRuZXNzRGF0YShzY3JpcHRUeXBlKSAmJiBnZXRNYWlubmV0KGNvaW4ubmV0d29yaykgIT09IG5ldHdvcmtzLnpjYXNoO1xuICBjb25zdCByZWNvdmVyeVByb3ZpZGVyID0gcGFyYW1zLnJlY292ZXJ5UHJvdmlkZXIgPz8gZm9yQ29pbihjb2luLmdldENoYWluKCksIHBhcmFtcy5hcGlLZXkpO1xuICBjb25zdCBNQVhfU0VRVUVOVElBTF9BRERSRVNTRVNfV0lUSE9VVF9UWFMgPSBwYXJhbXMuc2NhbiB8fCAyMDtcbiAgbGV0IG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzID0gMDtcbiAgY29uc3QgcHJldlR4Q2FjaGUgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFByZXZUeCh0eGlkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGxldCBwcmV2VHhIZXggPSBwcmV2VHhDYWNoZS5nZXQodHhpZCk7XG4gICAgaWYgKCFwcmV2VHhIZXgpIHtcbiAgICAgIHByZXZUeEhleCA9IGF3YWl0IHJlY292ZXJ5UHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25IZXgodHhpZCk7XG4gICAgICBwcmV2VHhDYWNoZS5zZXQodHhpZCwgcHJldlR4SGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZUeEhleDtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGdhdGhlclVuc3BlbnRzKGFkZHJJbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgd2FsbGV0S2V5c0ZvclVuc3BlbnQgPSB3YWxsZXRLZXlzLmRlcml2ZUZvckNoYWluQW5kSW5kZXgoY2hhaW4sIGFkZHJJbmRleCk7XG4gICAgY29uc3QgYWRkcmVzcyA9IGNvaW4uY3JlYXRlTXVsdGlTaWdBZGRyZXNzKHNjcmlwdFR5cGUsIDIsIHdhbGxldEtleXNGb3JVbnNwZW50LnB1YmxpY0tleXMpO1xuICAgIC8vIEJsb2NrY2hhaXIgdXNlcyBjYXNoYWRkciBmb3JtYXQgd2hlbiBxdWVyeWluZyB0aGUgQVBJIGZvciBhZGRyZXNzIGluZm9ybWF0aW9uLiBDb252ZXJ0IGxlZ2FjeSBhZGRyZXNzZXMgdG8gY2FzaGFkZHJcbiAgICAvLyBiZWZvcmUgcXVlcnlpbmcgdGhlIEFQSS5cbiAgICBjb25zdCBmb3JtYXR0ZWRBZGRyZXNzID1cbiAgICAgIGNvaW4uZ2V0Q2hhaW4oKSA9PT0gJ2JjaCcgPyBjb2luLmNhbm9uaWNhbEFkZHJlc3MoYWRkcmVzcy5hZGRyZXNzLCAnY2FzaGFkZHInKS5zcGxpdCgnOicpWzFdIDogYWRkcmVzcy5hZGRyZXNzO1xuICAgIGNvbnN0IGFkZHJJbmZvID0gYXdhaXQgcmVjb3ZlcnlQcm92aWRlci5nZXRBZGRyZXNzSW5mbyhmb3JtYXR0ZWRBZGRyZXNzKTtcbiAgICAvLyB3ZSB1c2UgdHhDb3VudCBoZXJlIGJlY2F1c2UgaXQgaW1wbGllcyB1c2FnZSAtIGhhdmluZyB0eCdlcyBtZWFucyB0aGUgYWRkciB3YXMgZ2VuZXJhdGVkIGFuZCB1c2VkXG4gICAgaWYgKGFkZHJJbmZvLnR4Q291bnQgPT09IDApIHtcbiAgICAgIG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzID0gMDtcblxuICAgICAgaWYgKGFkZHJJbmZvLmJhbGFuY2UgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBhbiBhZGRyZXNzIHdpdGggYmFsYW5jZTogJHthZGRyZXNzLmFkZHJlc3N9IHdpdGggYmFsYW5jZSAke2FkZHJJbmZvLmJhbGFuY2V9YCk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NVbnNwZW50cyA9IGF3YWl0IHJlY292ZXJ5UHJvdmlkZXIuZ2V0VW5zcGVudHNGb3JBZGRyZXNzZXMoW2Zvcm1hdHRlZEFkZHJlc3NdKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkVW5zcGVudHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBhZGRyZXNzVW5zcGVudHMubWFwKGFzeW5jICh1KTogUHJvbWlzZTxXYWxsZXRVbnNwZW50PGJpZ2ludD4+ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHhpZCwgdm91dCB9ID0gdXR4b2xpYi5iaXRnby5wYXJzZU91dHB1dElkKHUuaWQpO1xuICAgICAgICAgICAgbGV0IHZhbCA9IEJpZ0ludCh1LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb2luLmFtb3VudFR5cGUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgIC8vIGJsb2NrY2hhaXIgcmV0dXJucyB0aGUgbnVtYmVyIHdpdGggdGhlIGNvcnJlY3QgcHJlY2lzaW9uLCBidXQgaW4gbnVtYmVyIGZvcm1hdFxuICAgICAgICAgICAgICAvLyBqc29uIHBhcnNlIHdvbid0IHBhcnNlIGl0IGNvcnJlY3RseSwgc28gd2UgcmVxdWVyeSB0aGUgdHhpZCBmb3IgdGhlIHR4IGhleCB0byBkZWNvZGUgaGVyZVxuICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhIZXggPSBhd2FpdCBnZXRQcmV2VHgodHhpZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSBjb2luLmNyZWF0ZVRyYW5zYWN0aW9uRnJvbUhleDxiaWdpbnQ+KHR4SGV4KTtcbiAgICAgICAgICAgICAgICB2YWwgPSB0eC5vdXRzW3ZvdXRdLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgYXBpIG1heSByZXR1cm4gY2FzaGFkZHIncyBpbnN0ZWFkIG9mIGxlZ2FjeSBmb3IgQkNIIGFuZCBCQ0hBXG4gICAgICAgICAgICAvLyBkb3duc3RyZWFtIHByb2Nlc3NlcydzIG9ubHkgZXhwZWN0IGxlZ2FjeSBhZGRyZXNzZXNcbiAgICAgICAgICAgIHUgPSB7IC4uLnUsIGFkZHJlc3M6IGNvaW4uY2Fub25pY2FsQWRkcmVzcyh1LmFkZHJlc3MpIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi51LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgICBjaGFpbjogY2hhaW4sXG4gICAgICAgICAgICAgIGluZGV4OiBhZGRySW5kZXgsXG4gICAgICAgICAgICAgIHByZXZUeDogZmV0Y2hQcmV2VHggPyBCdWZmZXIuZnJvbShhd2FpdCBnZXRQcmV2VHgodHhpZCksICdoZXgnKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0gYXMgV2FsbGV0VW5zcGVudDxiaWdpbnQ+O1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgd2FsbGV0VW5zcGVudHMucHVzaCguLi5wcm9jZXNzZWRVbnNwZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG51bVNlcXVlbnRpYWxBZGRyZXNzZXNXaXRob3V0VHhzID49IE1BWF9TRVFVRU5USUFMX0FERFJFU1NFU19XSVRIT1VUX1RYUykge1xuICAgICAgLy8gc3RvcCBzZWFyY2hpbmcgZm9yIGFkZHJlc3NlcyB3aXRoIHVuc3BlbnRzIGluIHRoZW0sIHdlJ3ZlIGZvdW5kICR7TUFYX1NFUVVFTlRJQUxfQUREUkVTU0VTX1dJVEhPVVRfVFhTfSBpbiBhIHJvdyB3aXRoIG5vbmVcbiAgICAgIC8vIHdlIGFyZSBkb25lXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGdhdGhlclVuc3BlbnRzKGFkZHJJbmRleCArIDEpO1xuICB9XG5cbiAgLy8gZ2V0IHVuc3BlbnRzIGZvciB0aGVzZSBhZGRyZXNzZXNcblxuICBjb25zdCB3YWxsZXRVbnNwZW50czogV2FsbGV0VW5zcGVudDxiaWdpbnQ+W10gPSBbXTtcbiAgLy8gVGhpcyB3aWxsIHBvcHVsYXRlIHdhbGxldEFkZHJlc3Nlc1xuICBhd2FpdCBnYXRoZXJVbnNwZW50cygwKTtcblxuICBpZiAod2FsbGV0VW5zcGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gQ291bGRuJ3QgZmluZCBhbnkgYWRkcmVzc2VzIHdpdGggZnVuZHNcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gd2FsbGV0VW5zcGVudHM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoXG4gIGNvaW46IEFic3RyYWN0VXR4b0NvaW4sXG4gIHsgZGVmYXVsdFZhbHVlIH06IHsgZGVmYXVsdFZhbHVlOiBudW1iZXIgfVxuKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgTWVtcG9vbEFwaS5mb3JDb2luKGNvaW4uZ2V0Q2hhaW4oKSkuZ2V0UmVjb3ZlcnlGZWVQZXJCeXRlcygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5kaXIoZSk7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBCYWNrdXBLZXlSZWNvdmVyeVRyYW5zYW5zYWN0aW9uID0ge1xuICBpbnB1dHM/OiBXYWxsZXRVbnNwZW50PG51bWJlcj5bXTtcbiAgdHJhbnNhY3Rpb25IZXg6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICBiYWNrdXBLZXk6IHN0cmluZztcbiAgcmVjb3ZlcnlBbW91bnQ6IG51bWJlcjtcbiAgcmVjb3ZlcnlBbW91bnRTdHJpbmc6IHN0cmluZztcbn07XG5cbi8qKlxuICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHby5cbiAqXG4gKiBSZXR1cm5zIHRyYW5zYWN0aW9uIGhleCBpbiBsZWdhY3kgZm9ybWF0IGZvciB1bnNpZ25lZCBzd2VlcCB0cmFuc2FjdGlvbiwgaGFsZiBzaWduZWQgYmFja3VwIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGggS1JTIHByb3ZpZGVyIChvbmx5IGtleXRlcm5hbCksXG4gKiBmdWxseSBzaWduZWQgYmFja3VwIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgYSBLUlMgcHJvdmlkZXIuXG4gKlxuICogUmV0dXJucyBQU0JUIGhleCBmb3IgaGFsZiBzaWduZWQgYmFja3VwIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGggS1JTIHByb3ZpZGVyIChleGNsdWRpbmcga2V5dGVybmFsKVxuICogRm9yIFBTQlQgaGV4IGNhc2VzLCBVbnNwZW50cyBhcmUgbm90IHJlcXVpcmVkIGluIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSBjb2luXG4gKiBAcGFyYW0gYml0Z29cbiAqIEBwYXJhbSBwYXJhbXNcbiAqIC0gdXNlcktleTogW2VuY3J5cHRlZF0geHBydiwgb3IgeHB1YlxuICogLSBiYWNrdXBLZXk6IFtlbmNyeXB0ZWRdIHhwcnYsIG9yIHhwdWIgaWYgdGhlIHhwcnYgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSB4cHJ2cyBpcyBlbmNyeXB0ZWRcbiAqIC0gYml0Z29LZXk6IHhwdWJcbiAqIC0ga3JzUHJvdmlkZXI6IG5lY2Vzc2FyeSBpZiBiYWNrdXAga2V5IGlzIGhlbGQgYnkgS1JTXG4gKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gKiAtIHNjYW46IHRoZSBhbW91bnQgb2YgY29uc2VjdXRpdmUgYWRkcmVzc2VzIHdpdGhvdXQgdW5zcGVudHMgdG8gc2NhbiB0aHJvdWdoIGJlZm9yZSBzdG9wcGluZ1xuICogLSBpZ25vcmVBZGRyZXNzVHlwZXM6IChvcHRpb25hbCkgc2NyaXB0cyB0byBpZ25vcmVcbiAqICAgICAgICBmb3IgZXhhbXBsZTogWydwMnNoUDJ3c2gnLCAncDJ3c2gnXSB3aWxsIHByZXZlbnQgY29kZSBmcm9tIGNoZWNraW5nIGZvciB3cmFwcGVkLXNlZ3dpdCBhbmQgbmF0aXZlLXNlZ3dpdCBjaGFpbnMgb24gdGhlIHB1YmxpYyBibG9jayBleHBsb3JlcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhY2t1cEtleVJlY292ZXJ5KFxuICBjb2luOiBBYnN0cmFjdFV0eG9Db2luLFxuICBiaXRnbzogQml0R29CYXNlLFxuICBwYXJhbXM6IFJlY292ZXJQYXJhbXNcbik6IFByb21pc2U8QmFja3VwS2V5UmVjb3ZlcnlUcmFuc2Fuc2FjdGlvbiB8IEZvcm1hdHRlZE9mZmxpbmVWYXVsdFR4SW5mbz4ge1xuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJhbXMudXNlcktleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdXNlcktleScpO1xuICB9XG5cbiAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmJhY2t1cEtleSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmFja3VwS2V5Jyk7XG4gIH1cblxuICBpZiAoXG4gICAgXy5pc1VuZGVmaW5lZChwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikgfHxcbiAgICAhY29pbi5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiwgeyBhbnlGb3JtYXQ6IHRydWUgfSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuc2NhbikgJiYgKCFfLmlzSW50ZWdlcihwYXJhbXMuc2NhbikgfHwgcGFyYW1zLnNjYW4gPCAwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICB9XG5cbiAgY29uc3QgaXNLcnNSZWNvdmVyeSA9IGdldElzS3JzUmVjb3ZlcnkocGFyYW1zKTtcbiAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gZ2V0SXNVbnNpZ25lZFN3ZWVwKHBhcmFtcyk7XG4gIGNvbnN0IHJlc3BvbnNlVHhGb3JtYXQgPSBpc1Vuc2lnbmVkU3dlZXAgfHwgIWlzS3JzUmVjb3ZlcnkgfHwgcGFyYW1zLmtyc1Byb3ZpZGVyID09PSAna2V5dGVybmFsJyA/ICdsZWdhY3knIDogJ3BzYnQnO1xuXG4gIGNvbnN0IGtyc1Byb3ZpZGVyID0gaXNLcnNSZWNvdmVyeSA/IGdldEtyc1Byb3ZpZGVyKGNvaW4sIHBhcmFtcy5rcnNQcm92aWRlcikgOiB1bmRlZmluZWQ7XG5cbiAgLy8gY2hlY2sgd2hldGhlciBrZXkgbWF0ZXJpYWwgYW5kIHBhc3N3b3JkIGF1dGhlbnRpY2F0ZSB0aGUgdXNlcnMgYW5kIHJldHVybiBwYXJlbnQga2V5cyBvZiBhbGwgdGhyZWUga2V5cyBvZiB0aGUgd2FsbGV0XG4gIGNvbnN0IGtleXMgPSBnZXRCaXAzMktleXMoYml0Z28sIHBhcmFtcywgeyByZXF1aXJlQml0R29YcHViOiB0cnVlIH0pO1xuICBpZiAoIWlzVHJpcGxlKGtleXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBrZXkgdHJpcGxlYCk7XG4gIH1cbiAgY29uc3Qgd2FsbGV0S2V5cyA9IG5ldyB1dHhvbGliLmJpdGdvLlJvb3RXYWxsZXRLZXlzKGtleXMsIFtcbiAgICBwYXJhbXMudXNlcktleVBhdGggfHwgdXR4b2xpYi5iaXRnby5Sb290V2FsbGV0S2V5cy5kZWZhdWx0UHJlZml4LFxuICAgIHV0eG9saWIuYml0Z28uUm9vdFdhbGxldEtleXMuZGVmYXVsdFByZWZpeCxcbiAgICB1dHhvbGliLmJpdGdvLlJvb3RXYWxsZXRLZXlzLmRlZmF1bHRQcmVmaXgsXG4gIF0pO1xuXG4gIGNvbnN0IHVuc3BlbnRzOiBXYWxsZXRVbnNwZW50PGJpZ2ludD5bXSA9IChcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG91dHB1dFNjcmlwdHMuc2NyaXB0VHlwZXMyT2YzXG4gICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgKGFkZHJlc3NUeXBlKSA9PiBjb2luLnN1cHBvcnRzQWRkcmVzc1R5cGUoYWRkcmVzc1R5cGUpICYmICFwYXJhbXMuaWdub3JlQWRkcmVzc1R5cGVzPy5pbmNsdWRlcyhhZGRyZXNzVHlwZSlcbiAgICAgICAgKVxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIChxdWVyaWVzLCBhZGRyZXNzVHlwZSkgPT4gW1xuICAgICAgICAgICAgLi4ucXVlcmllcyxcbiAgICAgICAgICAgIHF1ZXJ5QmxvY2tjaGFpblVuc3BlbnRzUGF0aChjb2luLCBwYXJhbXMsIHdhbGxldEtleXMsIGdldEV4dGVybmFsQ2hhaW5Db2RlKGFkZHJlc3NUeXBlKSksXG4gICAgICAgICAgICBxdWVyeUJsb2NrY2hhaW5VbnNwZW50c1BhdGgoY29pbiwgcGFyYW1zLCB3YWxsZXRLZXlzLCBnZXRJbnRlcm5hbENoYWluQ29kZShhZGRyZXNzVHlwZSkpLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgW10gYXMgUHJvbWlzZTxXYWxsZXRVbnNwZW50PGJpZ2ludD5bXT5bXVxuICAgICAgICApXG4gICAgKVxuICApLmZsYXQoKTtcblxuICAvLyBFeGVjdXRlIHRoZSBxdWVyaWVzIGFuZCBnYXRoZXIgdGhlIHVuc3BlbnRzXG4gIGNvbnN0IHRvdGFsSW5wdXRBbW91bnQgPSB1dHhvbGliLmJpdGdvLnVuc3BlbnRTdW0odW5zcGVudHMsICdiaWdpbnQnKTtcbiAgaWYgKHRvdGFsSW5wdXRBbW91bnQgPD0gQmlnSW50KDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yTm9JbnB1dFRvUmVjb3ZlcigpO1xuICB9XG5cbiAgLy8gQnVpbGQgdGhlIHBzYnRcbiAgY29uc3QgcHNidCA9IHV0eG9saWIuYml0Z28uY3JlYXRlUHNidEZvck5ldHdvcmsoeyBuZXR3b3JrOiBjb2luLm5ldHdvcmsgfSk7XG4gIC8vIHhwdWJzIGNhbiBiZWNvbWUgaGFuZHkgZm9yIG1hbnkgdGhpbmdzLlxuICB1dHhvbGliLmJpdGdvLmFkZFhwdWJzVG9Qc2J0KHBzYnQsIHdhbGxldEtleXMpO1xuICBjb25zdCB0eEluZm8gPSB7fSBhcyBCYWNrdXBLZXlSZWNvdmVyeVRyYW5zYW5zYWN0aW9uO1xuXG4gIGNvbnN0IGZlZVBlckJ5dGU6IG51bWJlciA9IGF3YWl0IGdldFJlY292ZXJ5RmVlUGVyQnl0ZXMoY29pbiwgeyBkZWZhdWx0VmFsdWU6IDEwMCB9KTtcblxuICAvLyBLUlMgcmVjb3ZlcnkgdHJhbnNhY3Rpb25zIGhhdmUgYSAybmQgb3V0cHV0IHRvIHBheSB0aGUgcmVjb3ZlcnkgZmVlLCBsaWtlIHBheWdvIGZlZXMuIFVzZSBwMndzaCBvdXRwdXRzIGJlY2F1c2VcbiAgLy8gdGhleSBhcmUgdGhlIGxhcmdlc3Qgb3V0cHV0cyBhbmQgdGh1cyB0aGUgbW9zdCBjb25zZXJ2YXRpdmUgZXN0aW1hdGUgdG8gdXNlIGluIGNhbGN1bGF0aW5nIGZlZXMuIEFsc28gdXNlXG4gIC8vIHNlZ3dpdCBvdmVyaGVhZCBzaXplIGFuZCBwMnNoIGlucHV0cyBmb3IgdGhlIHNhbWUgcmVhc29uLlxuICBjb25zdCBvdXRwdXRTaXplID0gKGlzS3JzUmVjb3ZlcnkgPyAyIDogMSkgKiBWaXJ0dWFsU2l6ZXMudHhQMndzaE91dHB1dFNpemU7XG4gIGNvbnN0IGFwcHJveGltYXRlU2l6ZSA9IFZpcnR1YWxTaXplcy50eFNlZ092ZXJoZWFkVlNpemUgKyBvdXRwdXRTaXplICsgVmlydHVhbFNpemVzLnR4UDJzaElucHV0U2l6ZSAqIHVuc3BlbnRzLmxlbmd0aDtcbiAgY29uc3QgYXBwcm94aW1hdGVGZWUgPSBCaWdJbnQoYXBwcm94aW1hdGVTaXplICogZmVlUGVyQnl0ZSk7XG5cbiAgdHhJbmZvLmlucHV0cyA9XG4gICAgcmVzcG9uc2VUeEZvcm1hdCA9PT0gJ2xlZ2FjeSdcbiAgICAgID8gdW5zcGVudHMubWFwKCh1KSA9PiAoeyAuLi51LCB2YWx1ZTogTnVtYmVyKHUudmFsdWUpLCB2YWx1ZVN0cmluZzogdS52YWx1ZS50b1N0cmluZygpLCBwcmV2VHg6IHVuZGVmaW5lZCB9KSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gIHVuc3BlbnRzLmZvckVhY2goKHVuc3BlbnQpID0+IHtcbiAgICB1dHhvbGliLmJpdGdvLmFkZFdhbGxldFVuc3BlbnRUb1BzYnQocHNidCwgdW5zcGVudCwgd2FsbGV0S2V5cywgJ3VzZXInLCAnYmFja3VwJywgY29pbi5uZXR3b3JrKTtcbiAgfSk7XG5cbiAgbGV0IGtyc0ZlZSA9IEJpZ0ludCgwKTtcbiAgaWYgKGlzS3JzUmVjb3ZlcnkgJiYgcGFyYW1zLmtyc1Byb3ZpZGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGtyc0ZlZSA9IEJpZ0ludChhd2FpdCBjYWxjdWxhdGVGZWVBbW91bnQoY29pbiwgeyBwcm92aWRlcjogcGFyYW1zLmtyc1Byb3ZpZGVyIH0pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIERvbid0IGxldCB0aGlzIGVycm9yIGJsb2NrIHRoZSByZWNvdmVyeSAtXG4gICAgICBjb25zb2xlLmRpcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHJlY292ZXJ5QW1vdW50ID0gdG90YWxJbnB1dEFtb3VudCAtIGFwcHJveGltYXRlRmVlIC0ga3JzRmVlO1xuXG4gIGlmIChyZWNvdmVyeUFtb3VudCA8IEJpZ0ludCgwKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgdGhpcyB3YWxsZXRcXCdzIGJhbGFuY2UgaXMgdG9vIGxvdyB0byBwYXkgdGhlIGZlZXMgc3BlY2lmaWVkIGJ5IHRoZSBLUlMgcHJvdmlkZXIuIFxuICAgICAgICAgIEV4aXN0aW5nIGJhbGFuY2Ugb24gd2FsbGV0OiAke3RvdGFsSW5wdXRBbW91bnQudG9TdHJpbmcoKX0uIEVzdGltYXRlZCBuZXR3b3JrIGZlZSBmb3IgdGhlIHJlY292ZXJ5IHRyYW5zYWN0aW9uXG4gICAgICAgICAgOiAke2FwcHJveGltYXRlRmVlLnRvU3RyaW5nKCl9LCBLUlMgZmVlIHRvIHBheTogJHtrcnNGZWUudG9TdHJpbmcoKX0uIEFmdGVyIGRlZHVjdGluZyBmZWVzLCB5b3VyIHRvdGFsIFxuICAgICAgICAgIHJlY292ZXJhYmxlIGJhbGFuY2UgaXMgJHtyZWNvdmVyeUFtb3VudC50b1N0cmluZygpfWApO1xuICB9XG5cbiAgY29uc3QgcmVjb3ZlcnlPdXRwdXRTY3JpcHQgPSB1dHhvbGliLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sIGNvaW4ubmV0d29yayk7XG4gIHBzYnQuYWRkT3V0cHV0KHsgc2NyaXB0OiByZWNvdmVyeU91dHB1dFNjcmlwdCwgdmFsdWU6IHJlY292ZXJ5QW1vdW50IH0pO1xuXG4gIGlmIChrcnNQcm92aWRlciAmJiBrcnNGZWUgPiBCaWdJbnQoMCkpIHtcbiAgICBpZiAoIWtyc1Byb3ZpZGVyLmZlZUFkZHJlc3Nlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBrZXlQcm92aWRlciBtdXN0IGRlZmluZSBmZWVBZGRyZXNzZXNgKTtcbiAgICB9XG5cbiAgICBjb25zdCBrcnNGZWVBZGRyZXNzID0ga3JzUHJvdmlkZXIuZmVlQWRkcmVzc2VzW2NvaW4uZ2V0Q2hhaW4oKV07XG5cbiAgICBpZiAoIWtyc0ZlZUFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGhpcyBLUlMgcHJvdmlkZXIgaGFzIG5vdCBjb25maWd1cmVkIHRoZWlyIGZlZSBzdHJ1Y3R1cmUgeWV0IC0gcmVjb3ZlcnkgY2Fubm90IGJlIGNvbXBsZXRlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGtyc0ZlZU91dHB1dFNjcmlwdCA9IHV0eG9saWIuYWRkcmVzcy50b091dHB1dFNjcmlwdChrcnNGZWVBZGRyZXNzLCBjb2luLm5ldHdvcmspO1xuICAgIHBzYnQuYWRkT3V0cHV0KHsgc2NyaXB0OiBrcnNGZWVPdXRwdXRTY3JpcHQsIHZhbHVlOiBrcnNGZWUgfSk7XG4gIH1cblxuICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgLy8gVE9ETyBCVEMtMzE3IC0gV2hlbiByZWFkeSB0byBQU0JUaWZ5IE9WQywgc2VuZCBwc2J0IGhleCBhbmQgc2tpcCB1bnNwZW50cyBpbiByZXNwb25zZS5cbiAgICBjb25zdCB0eEhleCA9IHBzYnQuZ2V0VW5zaWduZWRUeCgpLnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiBmb3JtYXRGb3JPZmZsaW5lVmF1bHQoY29pbi5nZXRDaGFpbigpLCB0eEluZm8gYXMgT2ZmbGluZVZhdWx0VHhJbmZvLCB0eEhleCk7XG4gIH0gZWxzZSB7XG4gICAgc2lnbkFuZFZlcmlmeVBzYnQocHNidCwgd2FsbGV0S2V5cy51c2VyLCB7IGlzTGFzdFNpZ25hdHVyZTogZmFsc2UgfSk7XG4gICAgaWYgKGlzS3JzUmVjb3ZlcnkpIHtcbiAgICAgIC8vIFRoZSBLUlMgcHJvdmlkZXIga2V5dGVybmFsIHNvbGVseSBzdXBwb3J0cyBQMlNILCBQMldTSCwgYW5kIFAyU0gtUDJXU0ggaW5wdXQgc2NyaXB0IHR5cGVzLlxuICAgICAgLy8gSXQgY3VycmVudGx5IHVzZXMgYW4gb3V0ZGF0ZWQgQml0R29KUyBTREssIHdoaWNoIHJlbGllcyBvbiBhIGxlZ2FjeSB0cmFuc2FjdGlvbiBidWlsZGVyIGZvciBjb3NpZ25pbmcuXG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB1cGdyYWRpbmcgdGhlIGtleXRlcm5hbCBjb2RlIHByZXNlbnRzIGNoYWxsZW5nZXMsXG4gICAgICAvLyB3aGljaCBoaW5kZXJzIHRoZSBpbnRlZ3JhdGlvbiBvZiB0aGUgbGF0ZXN0IEJpdEdvSlMgU0RLIHdpdGggUFNCVCBzaWduaW5nIHN1cHBvcnQuXG4gICAgICB0eEluZm8udHJhbnNhY3Rpb25IZXggPVxuICAgICAgICBwYXJhbXMua3JzUHJvdmlkZXIgPT09ICdrZXl0ZXJuYWwnXG4gICAgICAgICAgPyB1dHhvbGliLmJpdGdvLmV4dHJhY3RQMm1zT25seUhhbGZTaWduZWRUeChwc2J0KS50b0J1ZmZlcigpLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgICAgIDogcHNidC50b0hleCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eCA9IHNpZ25BbmRWZXJpZnlQc2J0KHBzYnQsIHdhbGxldEtleXMuYmFja3VwLCB7IGlzTGFzdFNpZ25hdHVyZTogdHJ1ZSB9KTtcbiAgICAgIHR4SW5mby50cmFuc2FjdGlvbkhleCA9IHR4LnRvQnVmZmVyKCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0tyc1JlY292ZXJ5KSB7XG4gICAgdHhJbmZvLmNvaW4gPSBjb2luLmdldENoYWluKCk7XG4gICAgdHhJbmZvLmJhY2t1cEtleSA9IHBhcmFtcy5iYWNrdXBLZXk7XG4gICAgdHhJbmZvLnJlY292ZXJ5QW1vdW50ID0gTnVtYmVyKHJlY292ZXJ5QW1vdW50KTtcbiAgICB0eEluZm8ucmVjb3ZlcnlBbW91bnRTdHJpbmcgPSByZWNvdmVyeUFtb3VudC50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHR4SW5mbztcbn1cbiJdfQ==