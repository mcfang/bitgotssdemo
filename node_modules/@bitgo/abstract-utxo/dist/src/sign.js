"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signAndVerifyWalletTransaction = exports.signAndVerifyPsbt = exports.TransactionSigningError = exports.InputSigningError = void 0;
/**
 * @prettier
 */
const utxolib = require("@bitgo/utxo-lib");
const { isWalletUnspent, signInputWithUnspent, toOutput } = utxolib.bitgo;
const debugLib = require("debug");
const replayProtection_1 = require("./replayProtection");
const debug = debugLib('bitgo:v2:utxo');
class InputSigningError extends Error {
    constructor(inputIndex, unspent, reason) {
        super(`signing error at input ${inputIndex}: unspentId=${unspent.id}: ${reason}`);
        this.inputIndex = inputIndex;
        this.unspent = unspent;
        this.reason = reason;
    }
    static expectedWalletUnspent(inputIndex, unspent) {
        return new InputSigningError(inputIndex, unspent, `not a wallet unspent, not a replay protection unspent`);
    }
}
exports.InputSigningError = InputSigningError;
class TransactionSigningError extends Error {
    constructor(signErrors, verifyError) {
        super(`sign errors at inputs: [${signErrors.join(',')}], ` +
            `verify errors at inputs: [${verifyError.join(',')}], see log for details`);
    }
}
exports.TransactionSigningError = TransactionSigningError;
/**
 * Sign all inputs of a psbt and verify signatures after signing.
 * Collects and logs signing errors and verification errors, throws error in the end if any of them
 * failed.
 *
 * If it is the last signature, finalize and extract the transaction from the psbt.
 *
 * This function mirrors signAndVerifyWalletTransaction, but is used for signing PSBTs instead of
 * using TransactionBuilder
 *
 * @param psbt
 * @param signerKeychain
 * @param isLastSignature
 */
function signAndVerifyPsbt(psbt, signerKeychain, { isLastSignature }) {
    const txInputs = psbt.txInputs;
    const outputIds = [];
    const scriptTypes = [];
    const signErrors = psbt.data.inputs
        .map((input, inputIndex) => {
        const outputId = utxolib.bitgo.formatOutputId(utxolib.bitgo.getOutputIdForInput(txInputs[inputIndex]));
        outputIds.push(outputId);
        const scriptType = utxolib.bitgo.getPsbtInputScriptType(input);
        scriptTypes.push(scriptType);
        if (scriptType === 'p2shP2pk') {
            debug('Skipping signature for input %d of %d (RP input?)', inputIndex + 1, psbt.data.inputs.length);
            return;
        }
        try {
            psbt.signInputHD(inputIndex, signerKeychain);
            debug('Successfully signed input %d of %d', inputIndex + 1, psbt.data.inputs.length);
        }
        catch (e) {
            return new InputSigningError(inputIndex, { id: outputId }, e);
        }
    })
        .filter((e) => e !== undefined);
    const verifyErrors = psbt.data.inputs
        .map((input, inputIndex) => {
        const scriptType = scriptTypes[inputIndex];
        if (scriptType === 'p2shP2pk') {
            debug('Skipping input signature %d of %d (unspent from replay protection address which is platform signed only)', inputIndex + 1, psbt.data.inputs.length);
            return;
        }
        const outputId = outputIds[inputIndex];
        try {
            if (!psbt.validateSignaturesOfInputHD(inputIndex, signerKeychain)) {
                return new InputSigningError(inputIndex, { id: outputId }, new Error(`invalid signature`));
            }
        }
        catch (e) {
            debug('Invalid signature');
            return new InputSigningError(inputIndex, { id: outputId }, e);
        }
    })
        .filter((e) => e !== undefined);
    if (signErrors.length || verifyErrors.length) {
        throw new TransactionSigningError(signErrors, verifyErrors);
    }
    if (isLastSignature) {
        psbt.finalizeAllInputs();
        return psbt.extractTransaction();
    }
    return psbt;
}
exports.signAndVerifyPsbt = signAndVerifyPsbt;
/**
 * Sign all inputs of a wallet transaction and verify signatures after signing.
 * Collects and logs signing errors and verification errors, throws error in the end if any of them
 * failed.
 *
 * @param transaction - wallet transaction (builder) to be signed
 * @param unspents - transaction unspents
 * @param walletSigner - signing parameters
 * @param isLastSignature - Returns full-signed transaction when true. Builds half-signed when false.
 */
function signAndVerifyWalletTransaction(transaction, unspents, walletSigner, { isLastSignature }) {
    const network = transaction.network;
    const prevOutputs = unspents.map((u) => toOutput(u, network));
    let txBuilder;
    if (transaction instanceof utxolib.bitgo.UtxoTransaction) {
        txBuilder = utxolib.bitgo.createTransactionBuilderFromTransaction(transaction, prevOutputs);
        if (transaction.ins.length !== unspents.length) {
            throw new Error(`transaction inputs must match unspents`);
        }
    }
    else if (transaction instanceof utxolib.bitgo.UtxoTransactionBuilder) {
        txBuilder = transaction;
    }
    else {
        throw new Error(`must pass UtxoTransaction or UtxoTransactionBuilder`);
    }
    const signErrors = unspents
        .map((unspent, inputIndex) => {
        if (replayProtection_1.isReplayProtectionUnspent(unspent, network)) {
            debug('Skipping signature for input %d of %d (RP input?)', inputIndex + 1, unspents.length);
            return;
        }
        if (!isWalletUnspent(unspent)) {
            return InputSigningError.expectedWalletUnspent(inputIndex, unspent);
        }
        try {
            signInputWithUnspent(txBuilder, inputIndex, unspent, walletSigner);
            debug('Successfully signed input %d of %d', inputIndex + 1, unspents.length);
        }
        catch (e) {
            return new InputSigningError(inputIndex, unspent, e);
        }
    })
        .filter((e) => e !== undefined);
    const signedTransaction = isLastSignature ? txBuilder.build() : txBuilder.buildIncomplete();
    const verifyErrors = signedTransaction.ins
        .map((input, inputIndex) => {
        const unspent = unspents[inputIndex];
        if (replayProtection_1.isReplayProtectionUnspent(unspent, network)) {
            debug('Skipping input signature %d of %d (unspent from replay protection address which is platform signed only)', inputIndex + 1, unspents.length);
            return;
        }
        if (!isWalletUnspent(unspent)) {
            return InputSigningError.expectedWalletUnspent(inputIndex, unspent);
        }
        try {
            const publicKey = walletSigner.deriveForChainAndIndex(unspent.chain, unspent.index).signer.publicKey;
            if (!utxolib.bitgo.verifySignatureWithPublicKey(signedTransaction, inputIndex, prevOutputs, publicKey)) {
                return new InputSigningError(inputIndex, unspent, new Error(`invalid signature`));
            }
        }
        catch (e) {
            debug('Invalid signature');
            return new InputSigningError(inputIndex, unspent, e);
        }
    })
        .filter((e) => e !== undefined);
    if (signErrors.length || verifyErrors.length) {
        throw new TransactionSigningError(signErrors, verifyErrors);
    }
    return signedTransaction;
}
exports.signAndVerifyWalletTransaction = signAndVerifyWalletTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2lnbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaWduLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOztHQUVHO0FBQ0gsMkNBQTJDO0FBQzNDLE1BQU0sRUFBRSxlQUFlLEVBQUUsb0JBQW9CLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQztBQUkxRSxrQ0FBa0M7QUFFbEMseURBQStEO0FBRS9ELE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQztBQVV4QyxNQUFhLGlCQUE0RCxTQUFRLEtBQUs7SUFRcEYsWUFDUyxVQUFrQixFQUNsQixPQUEwQyxFQUMxQyxNQUFzQjtRQUU3QixLQUFLLENBQUMsMEJBQTBCLFVBQVUsZUFBZSxPQUFPLENBQUMsRUFBRSxLQUFLLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFKM0UsZUFBVSxHQUFWLFVBQVUsQ0FBUTtRQUNsQixZQUFPLEdBQVAsT0FBTyxDQUFtQztRQUMxQyxXQUFNLEdBQU4sTUFBTSxDQUFnQjtJQUcvQixDQUFDO0lBYkQsTUFBTSxDQUFDLHFCQUFxQixDQUMxQixVQUFrQixFQUNsQixPQUEwQztRQUUxQyxPQUFPLElBQUksaUJBQWlCLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSx1REFBdUQsQ0FBQyxDQUFDO0lBQzdHLENBQUM7Q0FTRjtBQWZELDhDQWVDO0FBRUQsTUFBYSx1QkFBa0UsU0FBUSxLQUFLO0lBQzFGLFlBQVksVUFBd0MsRUFBRSxXQUF5QztRQUM3RixLQUFLLENBQ0gsMkJBQTJCLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUs7WUFDbEQsNkJBQTZCLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLHdCQUF3QixDQUM3RSxDQUFDO0lBQ0osQ0FBQztDQUNGO0FBUEQsMERBT0M7QUFFRDs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsU0FBZ0IsaUJBQWlCLENBQy9CLElBQTRCLEVBQzVC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Q0FBQztZQUNGLE9BQU87U0FDUjtRQUNELElBQUksQ0FBQyxlQUFlLENBQVUsT0FBTyxDQUFDLEVBQUU7WUFDdEMsT0FBTyxpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBVSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDOUU7UUFDRCxJQUFJO1lBQ0YsTUFBTSxTQUFTLEdBQUcsWUFBWSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7WUFDckcsSUFDRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsNEJBQTRCLENBQVUsaUJBQWlCLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxTQUFTLENBQUMsRUFDM0c7Z0JBQ0EsT0FBTyxJQUFJLGlCQUFpQixDQUFDLFVBQVUsRUFBRSxPQUFPLEVBQUUsSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDO2FBQ25GO1NBQ0Y7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQzNCLE9BQU8sSUFBSSxpQkFBaUIsQ0FBVSxVQUFVLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQy9EO0lBQ0gsQ0FBQyxDQUFDO1NBQ0QsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFtQyxFQUFFLENBQUMsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxDQUFDO0lBRW5FLElBQUksVUFBVSxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMsTUFBTSxFQUFFO1FBQzVDLE1BQU0sSUFBSSx1QkFBdUIsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUM7S0FDN0Q7SUFFRCxPQUFPLGlCQUFpQixDQUFDO0FBQzNCLENBQUM7QUExRUQsd0VBMEVDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcHJldHRpZXJcbiAqL1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuY29uc3QgeyBpc1dhbGxldFVuc3BlbnQsIHNpZ25JbnB1dFdpdGhVbnNwZW50LCB0b091dHB1dCB9ID0gdXR4b2xpYi5iaXRnbztcbnR5cGUgVW5zcGVudDxUTnVtYmVyIGV4dGVuZHMgbnVtYmVyIHwgYmlnaW50ID0gbnVtYmVyPiA9IHV0eG9saWIuYml0Z28uVW5zcGVudDxUTnVtYmVyPjtcbnR5cGUgUm9vdFdhbGxldEtleXMgPSB1dHhvbGliLmJpdGdvLlJvb3RXYWxsZXRLZXlzO1xuXG5pbXBvcnQgKiBhcyBkZWJ1Z0xpYiBmcm9tICdkZWJ1Zyc7XG5cbmltcG9ydCB7IGlzUmVwbGF5UHJvdGVjdGlvblVuc3BlbnQgfSBmcm9tICcuL3JlcGxheVByb3RlY3Rpb24nO1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnTGliKCdiaXRnbzp2Mjp1dHhvJyk7XG5cbnR5cGUgUHNidFBhcnNlZFNjcmlwdFR5cGVzID1cbiAgfCAncDJzaCdcbiAgfCAncDJ3c2gnXG4gIHwgJ3Ayc2hQMndzaCdcbiAgfCAncDJzaFAycGsnXG4gIHwgJ3RhcHJvb3RLZXlQYXRoU3BlbmQnXG4gIHwgJ3RhcHJvb3RTY3JpcHRQYXRoU3BlbmQnO1xuXG5leHBvcnQgY2xhc3MgSW5wdXRTaWduaW5nRXJyb3I8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludCA9IG51bWJlcj4gZXh0ZW5kcyBFcnJvciB7XG4gIHN0YXRpYyBleHBlY3RlZFdhbGxldFVuc3BlbnQ8VE51bWJlciBleHRlbmRzIG51bWJlciB8IGJpZ2ludD4oXG4gICAgaW5wdXRJbmRleDogbnVtYmVyLFxuICAgIHVuc3BlbnQ6IFVuc3BlbnQ8VE51bWJlcj4gfCB7IGlkOiBzdHJpbmcgfVxuICApOiBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPiB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFNpZ25pbmdFcnJvcihpbnB1dEluZGV4LCB1bnNwZW50LCBgbm90IGEgd2FsbGV0IHVuc3BlbnQsIG5vdCBhIHJlcGxheSBwcm90ZWN0aW9uIHVuc3BlbnRgKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBpbnB1dEluZGV4OiBudW1iZXIsXG4gICAgcHVibGljIHVuc3BlbnQ6IFVuc3BlbnQ8VE51bWJlcj4gfCB7IGlkOiBzdHJpbmcgfSxcbiAgICBwdWJsaWMgcmVhc29uOiBFcnJvciB8IHN0cmluZ1xuICApIHtcbiAgICBzdXBlcihgc2lnbmluZyBlcnJvciBhdCBpbnB1dCAke2lucHV0SW5kZXh9OiB1bnNwZW50SWQ9JHt1bnNwZW50LmlkfTogJHtyZWFzb259YCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uU2lnbmluZ0Vycm9yPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQgPSBudW1iZXI+IGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduRXJyb3JzOiBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPltdLCB2ZXJpZnlFcnJvcjogSW5wdXRTaWduaW5nRXJyb3I8VE51bWJlcj5bXSkge1xuICAgIHN1cGVyKFxuICAgICAgYHNpZ24gZXJyb3JzIGF0IGlucHV0czogWyR7c2lnbkVycm9ycy5qb2luKCcsJyl9XSwgYCArXG4gICAgICAgIGB2ZXJpZnkgZXJyb3JzIGF0IGlucHV0czogWyR7dmVyaWZ5RXJyb3Iuam9pbignLCcpfV0sIHNlZSBsb2cgZm9yIGRldGFpbHNgXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFNpZ24gYWxsIGlucHV0cyBvZiBhIHBzYnQgYW5kIHZlcmlmeSBzaWduYXR1cmVzIGFmdGVyIHNpZ25pbmcuXG4gKiBDb2xsZWN0cyBhbmQgbG9ncyBzaWduaW5nIGVycm9ycyBhbmQgdmVyaWZpY2F0aW9uIGVycm9ycywgdGhyb3dzIGVycm9yIGluIHRoZSBlbmQgaWYgYW55IG9mIHRoZW1cbiAqIGZhaWxlZC5cbiAqXG4gKiBJZiBpdCBpcyB0aGUgbGFzdCBzaWduYXR1cmUsIGZpbmFsaXplIGFuZCBleHRyYWN0IHRoZSB0cmFuc2FjdGlvbiBmcm9tIHRoZSBwc2J0LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWlycm9ycyBzaWduQW5kVmVyaWZ5V2FsbGV0VHJhbnNhY3Rpb24sIGJ1dCBpcyB1c2VkIGZvciBzaWduaW5nIFBTQlRzIGluc3RlYWQgb2ZcbiAqIHVzaW5nIFRyYW5zYWN0aW9uQnVpbGRlclxuICpcbiAqIEBwYXJhbSBwc2J0XG4gKiBAcGFyYW0gc2lnbmVyS2V5Y2hhaW5cbiAqIEBwYXJhbSBpc0xhc3RTaWduYXR1cmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25BbmRWZXJpZnlQc2J0KFxuICBwc2J0OiB1dHhvbGliLmJpdGdvLlV0eG9Qc2J0LFxuICBzaWduZXJLZXljaGFpbjogdXR4b2xpYi5CSVAzMkludGVyZmFjZSxcbiAgeyBpc0xhc3RTaWduYXR1cmUgfTogeyBpc0xhc3RTaWduYXR1cmU6IGJvb2xlYW4gfVxuKTogdXR4b2xpYi5iaXRnby5VdHhvUHNidCB8IHV0eG9saWIuYml0Z28uVXR4b1RyYW5zYWN0aW9uPGJpZ2ludD4ge1xuICBjb25zdCB0eElucHV0cyA9IHBzYnQudHhJbnB1dHM7XG4gIGNvbnN0IG91dHB1dElkczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3Qgc2NyaXB0VHlwZXM6IFBzYnRQYXJzZWRTY3JpcHRUeXBlc1tdID0gW107XG5cbiAgY29uc3Qgc2lnbkVycm9yczogSW5wdXRTaWduaW5nRXJyb3I8YmlnaW50PltdID0gcHNidC5kYXRhLmlucHV0c1xuICAgIC5tYXAoKGlucHV0LCBpbnB1dEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dElkID0gdXR4b2xpYi5iaXRnby5mb3JtYXRPdXRwdXRJZCh1dHhvbGliLmJpdGdvLmdldE91dHB1dElkRm9ySW5wdXQodHhJbnB1dHNbaW5wdXRJbmRleF0pKTtcbiAgICAgIG91dHB1dElkcy5wdXNoKG91dHB1dElkKTtcblxuICAgICAgY29uc3Qgc2NyaXB0VHlwZSA9IHV0eG9saWIuYml0Z28uZ2V0UHNidElucHV0U2NyaXB0VHlwZShpbnB1dCk7XG4gICAgICBzY3JpcHRUeXBlcy5wdXNoKHNjcmlwdFR5cGUpO1xuXG4gICAgICBpZiAoc2NyaXB0VHlwZSA9PT0gJ3Ayc2hQMnBrJykge1xuICAgICAgICBkZWJ1ZygnU2tpcHBpbmcgc2lnbmF0dXJlIGZvciBpbnB1dCAlZCBvZiAlZCAoUlAgaW5wdXQ/KScsIGlucHV0SW5kZXggKyAxLCBwc2J0LmRhdGEuaW5wdXRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHNidC5zaWduSW5wdXRIRChpbnB1dEluZGV4LCBzaWduZXJLZXljaGFpbik7XG4gICAgICAgIGRlYnVnKCdTdWNjZXNzZnVsbHkgc2lnbmVkIGlucHV0ICVkIG9mICVkJywgaW5wdXRJbmRleCArIDEsIHBzYnQuZGF0YS5pbnB1dHMubGVuZ3RoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnB1dFNpZ25pbmdFcnJvcjxiaWdpbnQ+KGlucHV0SW5kZXgsIHsgaWQ6IG91dHB1dElkIH0sIGUpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmZpbHRlcigoZSk6IGUgaXMgSW5wdXRTaWduaW5nRXJyb3I8YmlnaW50PiA9PiBlICE9PSB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IHZlcmlmeUVycm9yczogSW5wdXRTaWduaW5nRXJyb3I8YmlnaW50PltdID0gcHNidC5kYXRhLmlucHV0c1xuICAgIC5tYXAoKGlucHV0LCBpbnB1dEluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzY3JpcHRUeXBlID0gc2NyaXB0VHlwZXNbaW5wdXRJbmRleF07XG4gICAgICBpZiAoc2NyaXB0VHlwZSA9PT0gJ3Ayc2hQMnBrJykge1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICAnU2tpcHBpbmcgaW5wdXQgc2lnbmF0dXJlICVkIG9mICVkICh1bnNwZW50IGZyb20gcmVwbGF5IHByb3RlY3Rpb24gYWRkcmVzcyB3aGljaCBpcyBwbGF0Zm9ybSBzaWduZWQgb25seSknLFxuICAgICAgICAgIGlucHV0SW5kZXggKyAxLFxuICAgICAgICAgIHBzYnQuZGF0YS5pbnB1dHMubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0SWQgPSBvdXRwdXRJZHNbaW5wdXRJbmRleF07XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXBzYnQudmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dEhEKGlucHV0SW5kZXgsIHNpZ25lcktleWNoYWluKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgSW5wdXRTaWduaW5nRXJyb3IoaW5wdXRJbmRleCwgeyBpZDogb3V0cHV0SWQgfSwgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZWApKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZygnSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnB1dFNpZ25pbmdFcnJvcjxiaWdpbnQ+KGlucHV0SW5kZXgsIHsgaWQ6IG91dHB1dElkIH0sIGUpO1xuICAgICAgfVxuICAgIH0pXG4gICAgLmZpbHRlcigoZSk6IGUgaXMgSW5wdXRTaWduaW5nRXJyb3I8YmlnaW50PiA9PiBlICE9PSB1bmRlZmluZWQpO1xuXG4gIGlmIChzaWduRXJyb3JzLmxlbmd0aCB8fCB2ZXJpZnlFcnJvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uU2lnbmluZ0Vycm9yKHNpZ25FcnJvcnMsIHZlcmlmeUVycm9ycyk7XG4gIH1cblxuICBpZiAoaXNMYXN0U2lnbmF0dXJlKSB7XG4gICAgcHNidC5maW5hbGl6ZUFsbElucHV0cygpO1xuICAgIHJldHVybiBwc2J0LmV4dHJhY3RUcmFuc2FjdGlvbigpO1xuICB9XG5cbiAgcmV0dXJuIHBzYnQ7XG59XG5cbi8qKlxuICogU2lnbiBhbGwgaW5wdXRzIG9mIGEgd2FsbGV0IHRyYW5zYWN0aW9uIGFuZCB2ZXJpZnkgc2lnbmF0dXJlcyBhZnRlciBzaWduaW5nLlxuICogQ29sbGVjdHMgYW5kIGxvZ3Mgc2lnbmluZyBlcnJvcnMgYW5kIHZlcmlmaWNhdGlvbiBlcnJvcnMsIHRocm93cyBlcnJvciBpbiB0aGUgZW5kIGlmIGFueSBvZiB0aGVtXG4gKiBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gd2FsbGV0IHRyYW5zYWN0aW9uIChidWlsZGVyKSB0byBiZSBzaWduZWRcbiAqIEBwYXJhbSB1bnNwZW50cyAtIHRyYW5zYWN0aW9uIHVuc3BlbnRzXG4gKiBAcGFyYW0gd2FsbGV0U2lnbmVyIC0gc2lnbmluZyBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0gaXNMYXN0U2lnbmF0dXJlIC0gUmV0dXJucyBmdWxsLXNpZ25lZCB0cmFuc2FjdGlvbiB3aGVuIHRydWUuIEJ1aWxkcyBoYWxmLXNpZ25lZCB3aGVuIGZhbHNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbkFuZFZlcmlmeVdhbGxldFRyYW5zYWN0aW9uPFROdW1iZXIgZXh0ZW5kcyBudW1iZXIgfCBiaWdpbnQ+KFxuICB0cmFuc2FjdGlvbjogdXR4b2xpYi5iaXRnby5VdHhvVHJhbnNhY3Rpb248VE51bWJlcj4gfCB1dHhvbGliLmJpdGdvLlV0eG9UcmFuc2FjdGlvbkJ1aWxkZXI8VE51bWJlcj4sXG4gIHVuc3BlbnRzOiBVbnNwZW50PFROdW1iZXI+W10sXG4gIHdhbGxldFNpZ25lcjogdXR4b2xpYi5iaXRnby5XYWxsZXRVbnNwZW50U2lnbmVyPFJvb3RXYWxsZXRLZXlzPixcbiAgeyBpc0xhc3RTaWduYXR1cmUgfTogeyBpc0xhc3RTaWduYXR1cmU6IGJvb2xlYW4gfVxuKTogdXR4b2xpYi5iaXRnby5VdHhvVHJhbnNhY3Rpb248VE51bWJlcj4ge1xuICBjb25zdCBuZXR3b3JrID0gdHJhbnNhY3Rpb24ubmV0d29yayBhcyB1dHhvbGliLk5ldHdvcms7XG4gIGNvbnN0IHByZXZPdXRwdXRzID0gdW5zcGVudHMubWFwKCh1KSA9PiB0b091dHB1dCh1LCBuZXR3b3JrKSk7XG5cbiAgbGV0IHR4QnVpbGRlcjogdXR4b2xpYi5iaXRnby5VdHhvVHJhbnNhY3Rpb25CdWlsZGVyPFROdW1iZXI+O1xuICBpZiAodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiB1dHhvbGliLmJpdGdvLlV0eG9UcmFuc2FjdGlvbikge1xuICAgIHR4QnVpbGRlciA9IHV0eG9saWIuYml0Z28uY3JlYXRlVHJhbnNhY3Rpb25CdWlsZGVyRnJvbVRyYW5zYWN0aW9uPFROdW1iZXI+KHRyYW5zYWN0aW9uLCBwcmV2T3V0cHV0cyk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmlucy5sZW5ndGggIT09IHVuc3BlbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmFuc2FjdGlvbiBpbnB1dHMgbXVzdCBtYXRjaCB1bnNwZW50c2ApO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIHV0eG9saWIuYml0Z28uVXR4b1RyYW5zYWN0aW9uQnVpbGRlcikge1xuICAgIHR4QnVpbGRlciA9IHRyYW5zYWN0aW9uO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVzdCBwYXNzIFV0eG9UcmFuc2FjdGlvbiBvciBVdHhvVHJhbnNhY3Rpb25CdWlsZGVyYCk7XG4gIH1cblxuICBjb25zdCBzaWduRXJyb3JzOiBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPltdID0gdW5zcGVudHNcbiAgICAubWFwKCh1bnNwZW50OiBVbnNwZW50PFROdW1iZXI+LCBpbnB1dEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChpc1JlcGxheVByb3RlY3Rpb25VbnNwZW50PFROdW1iZXI+KHVuc3BlbnQsIG5ldHdvcmspKSB7XG4gICAgICAgIGRlYnVnKCdTa2lwcGluZyBzaWduYXR1cmUgZm9yIGlucHV0ICVkIG9mICVkIChSUCBpbnB1dD8pJywgaW5wdXRJbmRleCArIDEsIHVuc3BlbnRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNXYWxsZXRVbnNwZW50PFROdW1iZXI+KHVuc3BlbnQpKSB7XG4gICAgICAgIHJldHVybiBJbnB1dFNpZ25pbmdFcnJvci5leHBlY3RlZFdhbGxldFVuc3BlbnQ8VE51bWJlcj4oaW5wdXRJbmRleCwgdW5zcGVudCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzaWduSW5wdXRXaXRoVW5zcGVudDxUTnVtYmVyPih0eEJ1aWxkZXIsIGlucHV0SW5kZXgsIHVuc3BlbnQsIHdhbGxldFNpZ25lcik7XG4gICAgICAgIGRlYnVnKCdTdWNjZXNzZnVsbHkgc2lnbmVkIGlucHV0ICVkIG9mICVkJywgaW5wdXRJbmRleCArIDEsIHVuc3BlbnRzLmxlbmd0aCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5wdXRTaWduaW5nRXJyb3I8VE51bWJlcj4oaW5wdXRJbmRleCwgdW5zcGVudCwgZSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKChlKTogZSBpcyBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPiA9PiBlICE9PSB1bmRlZmluZWQpO1xuXG4gIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gaXNMYXN0U2lnbmF0dXJlID8gdHhCdWlsZGVyLmJ1aWxkKCkgOiB0eEJ1aWxkZXIuYnVpbGRJbmNvbXBsZXRlKCk7XG5cbiAgY29uc3QgdmVyaWZ5RXJyb3JzOiBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPltdID0gc2lnbmVkVHJhbnNhY3Rpb24uaW5zXG4gICAgLm1hcCgoaW5wdXQsIGlucHV0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHVuc3BlbnQgPSB1bnNwZW50c1tpbnB1dEluZGV4XSBhcyBVbnNwZW50PFROdW1iZXI+O1xuICAgICAgaWYgKGlzUmVwbGF5UHJvdGVjdGlvblVuc3BlbnQ8VE51bWJlcj4odW5zcGVudCwgbmV0d29yaykpIHtcbiAgICAgICAgZGVidWcoXG4gICAgICAgICAgJ1NraXBwaW5nIGlucHV0IHNpZ25hdHVyZSAlZCBvZiAlZCAodW5zcGVudCBmcm9tIHJlcGxheSBwcm90ZWN0aW9uIGFkZHJlc3Mgd2hpY2ggaXMgcGxhdGZvcm0gc2lnbmVkIG9ubHkpJyxcbiAgICAgICAgICBpbnB1dEluZGV4ICsgMSxcbiAgICAgICAgICB1bnNwZW50cy5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpc1dhbGxldFVuc3BlbnQ8VE51bWJlcj4odW5zcGVudCkpIHtcbiAgICAgICAgcmV0dXJuIElucHV0U2lnbmluZ0Vycm9yLmV4cGVjdGVkV2FsbGV0VW5zcGVudDxUTnVtYmVyPihpbnB1dEluZGV4LCB1bnNwZW50KTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHdhbGxldFNpZ25lci5kZXJpdmVGb3JDaGFpbkFuZEluZGV4KHVuc3BlbnQuY2hhaW4sIHVuc3BlbnQuaW5kZXgpLnNpZ25lci5wdWJsaWNLZXk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhdXR4b2xpYi5iaXRnby52ZXJpZnlTaWduYXR1cmVXaXRoUHVibGljS2V5PFROdW1iZXI+KHNpZ25lZFRyYW5zYWN0aW9uLCBpbnB1dEluZGV4LCBwcmV2T3V0cHV0cywgcHVibGljS2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IElucHV0U2lnbmluZ0Vycm9yKGlucHV0SW5kZXgsIHVuc3BlbnQsIG5ldyBFcnJvcihgaW52YWxpZCBzaWduYXR1cmVgKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICAgIHJldHVybiBuZXcgSW5wdXRTaWduaW5nRXJyb3I8VE51bWJlcj4oaW5wdXRJbmRleCwgdW5zcGVudCwgZSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKChlKTogZSBpcyBJbnB1dFNpZ25pbmdFcnJvcjxUTnVtYmVyPiA9PiBlICE9PSB1bmRlZmluZWQpO1xuXG4gIGlmIChzaWduRXJyb3JzLmxlbmd0aCB8fCB2ZXJpZnlFcnJvcnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uU2lnbmluZ0Vycm9yKHNpZ25FcnJvcnMsIHZlcmlmeUVycm9ycyk7XG4gIH1cblxuICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG59XG4iXX0=