/// <reference types="node" />
import { BaseUtils, TransactionType } from '@bitgo/sdk-core';
import { DecodedTxRaw } from '@cosmjs/proto-signing';
import { Coin } from '@cosmjs/stargate';
import { SignDoc, TxRaw } from 'cosmjs-types/cosmos/tx/v1beta1/tx';
import { AtomTransaction, DelegateOrUndelegeteMessage, FeeData, MessageData, SendMessage, WithdrawDelegatorRewardsMessage } from './iface';
export declare class Utils implements BaseUtils {
    private registry;
    /** @inheritdoc */
    isValidBlockId(hash: string): boolean;
    /** @inheritdoc */
    isValidPrivateKey(key: string): boolean;
    /** @inheritdoc */
    isValidPublicKey(key: string): boolean;
    /** @inheritdoc */
    isValidSignature(signature: string): boolean;
    /** @inheritdoc */
    isValidTransactionId(txId: string): boolean;
    /**
     * Checks if transaction hash is in valid black2b format
     */
    validateBlake2b(hash: string): boolean;
    /**
     * Validates if the address matches with regex @see accountAddressRegex
     *
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidAddress(address: string): boolean;
    /**
     * Validates if the address matches with regex @see accountAddressRegex
     *
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidValidatorAddress(address: string): boolean;
    /**
     * Validates whether amounts are in range
     *
     * @param {number[]} amounts - the amounts to validate
     * @returns {boolean} - the validation result
     */
    isValidAmounts(amounts: number[]): boolean;
    /**
     * Validates whether amount is in range
     * @param {number} amount
     * @returns {boolean} the validation result
     */
    isValidAmount(amount: number): boolean;
    /**
     * Decodes raw tx data into messages, signing info, and fee data
     * @param {string} txHex - raw base64 tx
     * @returns {DecodedTxRaw} Decoded transaction
     */
    getDecodedTxFromRawBase64(txRaw: string): DecodedTxRaw;
    /**
     * Returns the array of messages in the body of the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {EncodeObject[]} messages along with type url
     */
    private getEncodedMessagesFromDecodedTx;
    /**
     * Pulls the sequence number from a DecodedTxRaw AuthInfo property
     * @param {DecodedTxRaw} decodedTx
     * @returns {number} sequence
     */
    getSequenceFromDecodedTx(decodedTx: DecodedTxRaw): number;
    /**
     * Pulls the typeUrl from the encoded message of a DecodedTxRaw
     * @param {DecodedTxRaw} decodedTx
     * @returns {string} cosmos proto type url
     */
    getTypeUrlFromDecodedTx(decodedTx: DecodedTxRaw): string;
    /**
     * Returns the fee data from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {FeeData} fee data
     */
    getGasBudgetFromDecodedTx(decodedTx: DecodedTxRaw): FeeData;
    /**
     * Returns the publicKey from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {string | undefined} publicKey in hex format if it exists, undefined otherwise
     */
    getPublicKeyFromDecodedTx(decodedTx: DecodedTxRaw): string | undefined;
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Send transaction message data
     */
    getSendMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Delegate of undelegate transaction message data
     */
    getDelegateOrUndelegateMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} WithdrawDelegatorRewards transaction message data
     */
    getWithdrawRewardsMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Delegate of undelegate transaction message data
     */
    getWithdrawDelegatorRewardsMessageDataFromDecodedTx(decodedTx: DecodedTxRaw): MessageData[];
    /**
     * Determines bitgo transaction type based on cosmos proto type url
     * @param {string} typeUrl
     * @returns {TransactionType | undefined} TransactionType if url is supported else undefined
     */
    getTransactionTypeFromTypeUrl(typeUrl: string): TransactionType | undefined;
    /**
     * Creates a txRaw from an atom transaction @see AtomTransaction
     * @Precondition atomTransaction.publicKey must be defined
     * @param {AtomTransaction} atomTransaction
     * @returns {TxRaw} Unsigned raw transaction
     */
    createTxRawFromAtomTransaction(atomTransaction: AtomTransaction): TxRaw;
    /**
     * Encodes a signature into a txRaw
     * @param {string} publicKeyHex publicKey in hex encoded string format
     * @param {string} signatureHex signature in hex encoded string format
     * @param {TxRaw} unsignedTx raw transaction
     * @returns {TxRaw} Signed raw transaction
     */
    createSignedTxRaw(publicKeyHex: string, signatureHex: string, unsignedTx: {
        bodyBytes: Uint8Array;
        authInfoBytes: Uint8Array;
    }): TxRaw;
    /**
     * Decodes a raw transaction into a DecodedTxRaw and checks if it has non empty signatures
     * @param {string} rawTransaction
     * @returns {boolean} true if transaction is signed else false
     */
    isSignedRawTx(rawTransaction: string): boolean;
    /**
     * Deserializes base64 enocded raw transaction string into @see AtomTransaction
     * @param {string} rawTx base64 enocded raw transaction string
     * @returns {AtomTransaction} Deserialized atomTransaction
     */
    deserializeAtomTransaction(rawTx: string): AtomTransaction;
    createAtomTransaction(sequence: number, messages: MessageData[], gasBudget: FeeData, publicKey?: string, memo?: string): AtomTransaction;
    createAtomTransactionWithHash(sequence: number, messages: MessageData[], gasBudget: FeeData, publicKey?: string, signature?: Buffer, memo?: string): AtomTransaction;
    validateAtomTransaction(tx: AtomTransaction): void;
    validateMessageData(messageData: MessageData): void;
    validateAmountData(amountArray: Coin[]): void;
    validateAmount(amount: Coin): void;
    validateGasBudget(gasBudget: FeeData): void;
    validateSequence(sequence: number): void;
    validatePublicKey(publicKey: string | undefined): void;
    /**
     * Creates a sign doc from an atom transaction @see AtomTransaction
     * @Precondition atomTransaction.accountNumber and atomTransaction.chainId must be defined
     * @param {AtomTransaction} atomTransaction
     * @returns {SignDoc} sign doc
     */
    createSignDoc(atomTransaction: AtomTransaction, accountNumber: number | undefined, chainId: string | undefined): SignDoc;
    validateDelegateOrUndelegateMessage(delegateMessage: DelegateOrUndelegeteMessage): void;
    validateWithdrawRewardsMessage(withdrawRewardsMessage: WithdrawDelegatorRewardsMessage): void;
    validateSendMessage(sendMessage: SendMessage): void;
    isValidHexString(hexString: string): boolean;
}
declare const utils: Utils;
export default utils;
//# sourceMappingURL=utils.d.ts.map