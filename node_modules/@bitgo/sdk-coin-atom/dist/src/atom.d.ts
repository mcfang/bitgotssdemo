/// <reference types="node" />
import { BaseCoin, BitGoBase, ExplanationResult, KeyPair, MPCAlgorithm, ParsedTransaction, ParseTransactionOptions, SignedTransaction, SignTransactionOptions, VerifyAddressOptions, VerifyTransactionOptions } from '@bitgo/sdk-core';
import { BaseCoin as StaticsBaseCoin, CoinFamily } from '@bitgo/statics';
import { Hash } from 'crypto';
import { TransactionBuilderFactory } from './lib';
import * as request from 'superagent';
import { Buffer } from 'buffer';
/**
 * Atom accounts support memo Id based addresses
 */
interface AddressDetails {
    address: string;
    memoId?: string | undefined;
}
interface RecoveryOptions {
    userKey?: string;
    backupKey?: string;
    bitgoKey: string;
    recoveryDestination: string;
    krsProvider?: string;
    walletPassphrase?: string;
    startingScanIndex?: number;
    scan?: number;
}
interface AtomTx {
    serializedTx: string;
    scanIndex: number;
}
export declare class Atom extends BaseCoin {
    protected readonly _staticsCoin: Readonly<StaticsBaseCoin>;
    protected constructor(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>);
    static createInstance(bitgo: BitGoBase, staticsCoin?: Readonly<StaticsBaseCoin>): BaseCoin;
    /** @inheritDoc **/
    getBaseFactor(): string | number;
    /** @inheritDoc **/
    getChain(): string;
    /** @inheritDoc **/
    getFamily(): CoinFamily;
    /** @inheritDoc **/
    getFullName(): string;
    /** @inheritDoc */
    supportsTss(): boolean;
    /** @inheritDoc **/
    getMPCAlgorithm(): MPCAlgorithm;
    /** @inheritDoc **/
    isValidPub(pub: string): boolean;
    /** @inheritDoc **/
    isValidPrv(prv: string): boolean;
    getBuilder(): TransactionBuilderFactory;
    /** @inheritDoc **/
    isValidAddress(address: string): boolean;
    /** @inheritDoc **/
    verifyTransaction(params: VerifyTransactionOptions): Promise<boolean>;
    /** @inheritDoc **/
    parseTransaction(params: ParseTransactionOptions & {
        txHex: string;
    }): Promise<ParsedTransaction>;
    /** @inheritDoc **/
    explainTransaction(options: {
        txHex: string;
    }): Promise<ExplanationResult>;
    /** @inheritDoc **/
    generateKeyPair(seed?: Buffer): KeyPair;
    /**
     * Sign a transaction with a single private key
     * @param params parameters in the form of { txPrebuild: {txHex}, prv }
     * @returns signed transaction in the form of { txHex }
     */
    signTransaction(params: SignTransactionOptions & {
        txPrebuild: {
            txHex: string;
        };
        prv: string;
    }): Promise<SignedTransaction>;
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {RecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {AtomTx} the serialized transaction hex string and index
     * of the address being swept
     */
    recover(params: RecoveryOptions): Promise<AtomTx>;
    /**
     * Get balance from public node
     */
    protected getBalanceFromNode(senderAddress: string): Promise<request.Response>;
    /**
     * Helper to fetch chainId
     */
    protected getChainId(): Promise<string>;
    /**
     * Get chain id from public node
     */
    protected getChainIdFromNode(): Promise<request.Response>;
    /**
     * Helper to fetch account number
     */
    protected getAccountDetails(senderAddress: string): Promise<string[]>;
    /**
     * Get account number from public node
     */
    protected getAccountFromNode(senderAddress: string): Promise<request.Response>;
    /**
     * Helper to fetch account balance
     */
    protected getAccountBalance(senderAddress: string): Promise<string>;
    /**
     * Get the public node url from the Environments constant we have defined
     */
    protected getPublicNodeUrl(): string;
    getAddressFromPublicKey(pubKey: string): string;
    /** @inheritDoc **/
    isWalletAddress(params: VerifyAddressOptions): Promise<boolean>;
    getHashFunction(): Hash;
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    getAddressDetails(address: string): AddressDetails;
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId: string): boolean;
    private getKeyCombinedFromTssKeyShares;
    private signRecoveryTSS;
}
export {};
//# sourceMappingURL=atom.d.ts.map