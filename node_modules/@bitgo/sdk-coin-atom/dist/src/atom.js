"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Atom = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const statics_1 = require("@bitgo/statics");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bignumber_js_1 = require("bignumber.js");
const crypto_1 = require("crypto");
const _ = __importStar(require("lodash"));
const utils_1 = __importDefault(require("./lib/utils"));
const url_1 = __importDefault(require("url"));
const querystring_1 = __importDefault(require("querystring"));
const lib_1 = require("./lib");
const request = __importStar(require("superagent"));
const buffer_1 = require("buffer");
const constants_1 = require("./lib/constants");
class Atom extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Atom(bitgo, staticsCoin);
    }
    /** @inheritDoc **/
    getBaseFactor() {
        return 1e6;
    }
    /** @inheritDoc **/
    getChain() {
        return this._staticsCoin.name;
    }
    /** @inheritDoc **/
    getFamily() {
        return this._staticsCoin.family;
    }
    /** @inheritDoc **/
    getFullName() {
        return this._staticsCoin.fullName;
    }
    /** @inheritDoc */
    supportsTss() {
        return true;
    }
    /** @inheritDoc **/
    getMPCAlgorithm() {
        return 'ecdsa';
    }
    /** @inheritDoc **/
    isValidPub(pub) {
        return utils_1.default.isValidPublicKey(pub);
    }
    /** @inheritDoc **/
    isValidPrv(prv) {
        return utils_1.default.isValidPrivateKey(prv);
    }
    getBuilder() {
        return new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
    /** @inheritDoc **/
    isValidAddress(address) {
        return utils_1.default.isValidAddress(address) || utils_1.default.isValidValidatorAddress(address);
    }
    /** @inheritDoc **/
    async verifyTransaction(params) {
        var _a;
        let totalAmount = new bignumber_js_1.BigNumber(0);
        const coinConfig = statics_1.coins.get(this.getChain());
        const { txPrebuild, txParams } = params;
        const rawTx = txPrebuild.txHex;
        if (!rawTx) {
            throw new Error('missing required tx prebuild property txHex');
        }
        const transaction = await new lib_1.TransactionBuilderFactory(coinConfig).from(rawTx).build();
        const explainedTx = transaction.explainTransaction();
        if (txParams.recipients && txParams.recipients.length > 0) {
            const filteredRecipients = (_a = txParams.recipients) === null || _a === void 0 ? void 0 : _a.map((recipient) => _.pick(recipient, ['address', 'amount']));
            const filteredOutputs = explainedTx.outputs.map((output) => _.pick(output, ['address', 'amount']));
            if (!_.isEqual(filteredOutputs, filteredRecipients)) {
                throw new Error('Tx outputs does not match with expected txParams recipients');
            }
            // WithdrawDelegatorRewards transaction doesn't have amount
            if (transaction.type !== sdk_core_1.TransactionType.StakingWithdraw) {
                for (const recipients of txParams.recipients) {
                    totalAmount = totalAmount.plus(recipients.amount);
                }
                if (!totalAmount.isEqualTo(explainedTx.outputAmount)) {
                    throw new Error('Tx total amount does not match with expected total amount field');
                }
            }
        }
        return true;
    }
    /** @inheritDoc **/
    async parseTransaction(params) {
        const transactionExplanation = await this.explainTransaction({ txHex: params.txHex });
        if (!transactionExplanation) {
            throw new Error('Invalid transaction');
        }
        if (transactionExplanation.outputs.length <= 0) {
            return {
                inputs: [],
                outputs: [],
            };
        }
        const senderAddress = transactionExplanation.outputs[0].address;
        const feeAmount = new bignumber_js_1.BigNumber(transactionExplanation.fee.fee === '' ? '0' : transactionExplanation.fee.fee);
        const inputs = [
            {
                address: senderAddress,
                amount: new bignumber_js_1.BigNumber(transactionExplanation.outputAmount).plus(feeAmount).toFixed(),
            },
        ];
        const outputs = transactionExplanation.outputs.map((output) => {
            return {
                address: output.address,
                amount: new bignumber_js_1.BigNumber(output.amount).toFixed(),
            };
        });
        return {
            inputs,
            outputs,
        };
    }
    /** @inheritDoc **/
    async explainTransaction(options) {
        if (!options.txHex) {
            throw new Error('missing required txHex parameter');
        }
        try {
            const transactionBuilder = new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain())).from(options.txHex);
            const transaction = await transactionBuilder.build();
            return transaction.explainTransaction();
        }
        catch (e) {
            throw new Error('Invalid transaction: ' + e.message);
        }
    }
    /** @inheritDoc **/
    generateKeyPair(seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        const extendedKey = utxo_lib_1.bip32.fromSeed(seed);
        return {
            pub: extendedKey.neutered().toBase58(),
            prv: extendedKey.toBase58(),
        };
    }
    /**
     * Sign a transaction with a single private key
     * @param params parameters in the form of { txPrebuild: {txHex}, prv }
     * @returns signed transaction in the form of { txHex }
     */
    async signTransaction(params) {
        var _a;
        const txHex = (_a = params === null || params === void 0 ? void 0 : params.txPrebuild) === null || _a === void 0 ? void 0 : _a.txHex;
        const privateKey = params === null || params === void 0 ? void 0 : params.prv;
        if (!txHex) {
            throw new sdk_core_1.SigningError('missing required txPrebuild parameter: params.txPrebuild.txHex');
        }
        if (!privateKey) {
            throw new sdk_core_1.SigningError('missing required prv parameter: params.prv');
        }
        const txBuilder = new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain())).from(params.txPrebuild.txHex);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new sdk_core_1.SigningError('Failed to build signed transaction');
        }
        const serializedTx = transaction.toBroadcastFormat();
        return {
            txHex: serializedTx,
        };
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {RecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {AtomTx} the serialized transaction hex string and index
     * of the address being swept
     */
    async recover(params) {
        // Step 1: Check if params contains the required parameters
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        if (!params.userKey) {
            throw new Error('missing userKey');
        }
        if (!params.backupKey) {
            throw new Error('missing backupKey');
        }
        if (!params.walletPassphrase) {
            throw new Error('missing wallet passphrase');
        }
        // Step 2: Fetch the bitgo key from params
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        // Step 3: Instantiate the ECDSA signer and fetch the address details
        const MPC = new sdk_core_1.Ecdsa();
        const chainId = await this.getChainId();
        const currPath = 'm/0';
        const publicKey = MPC.deriveUnhardened(bitgoKey, currPath).slice(0, 66);
        const senderAddress = this.getAddressFromPublicKey(publicKey);
        // Step 4: Fetch account details such as accountNo, balance and check for sufficient funds once gasAmount has been deducted
        const [accountNumber, sequenceNo] = await this.getAccountDetails(senderAddress);
        const balance = new bignumber_js_1.BigNumber(await this.getAccountBalance(senderAddress));
        const gasBudget = {
            amount: [{ denom: 'uatom', amount: constants_1.GAS_AMOUNT }],
            gasLimit: constants_1.GAS_LIMIT,
        };
        const gasAmount = new bignumber_js_1.BigNumber(gasBudget.amount[0].amount);
        const actualBalance = balance.minus(gasAmount);
        if (actualBalance.isLessThanOrEqualTo(0)) {
            throw new Error('Did not have enough funds to recover');
        }
        // Step 5: Once sufficient funds are present, construct the recover tx messsage
        const amount = [
            {
                denom: 'uatom',
                amount: actualBalance.toFixed(),
            },
        ];
        const sendMessage = [
            {
                fromAddress: senderAddress,
                toAddress: params.recoveryDestination,
                amount: amount,
            },
        ];
        // Step 6: Build the unsigned tx using the constructed message
        const txnBuilder = this.getBuilder().getTransferBuilder();
        txnBuilder
            .messages(sendMessage)
            .gasBudget(gasBudget)
            .publicKey(publicKey)
            .sequence(Number(sequenceNo))
            .accountNumber(Number(accountNumber))
            .chainId(chainId);
        const unsignedTransaction = (await txnBuilder.build());
        let serializedTx = unsignedTransaction.toBroadcastFormat();
        const signableHex = unsignedTransaction.signablePayload.toString('hex');
        const userKey = params.userKey.replace(/\s/g, '');
        const backupKey = params.backupKey.replace(/\s/g, '');
        const [userKeyCombined, backupKeyCombined] = (() => {
            const [userKeyCombined, backupKeyCombined] = this.getKeyCombinedFromTssKeyShares(userKey, backupKey, params.walletPassphrase);
            return [userKeyCombined, backupKeyCombined];
        })();
        if (!userKeyCombined || !backupKeyCombined) {
            throw new Error('Missing combined key shares for user or backup');
        }
        // Step 7: Sign the tx
        const signature = await this.signRecoveryTSS(userKeyCombined, backupKeyCombined, signableHex);
        const signableBuffer = buffer_1.Buffer.from(signableHex, 'hex');
        MPC.verify(signableBuffer, signature, crypto_1.createHash('sha256'));
        const atomKeyPair = new lib_1.KeyPair({ pub: publicKey });
        txnBuilder.addSignature({ pub: atomKeyPair.getKeys().pub }, buffer_1.Buffer.from(signature.r + signature.s, 'hex'));
        const signedTransaction = await txnBuilder.build();
        serializedTx = signedTransaction.toBroadcastFormat();
        return { serializedTx: serializedTx, scanIndex: 0 };
    }
    /**
     * Get balance from public node
     */
    async getBalanceFromNode(senderAddress) {
        const nodeUrl = this.getPublicNodeUrl();
        const getBalancePath = 'cosmos/bank/v1beta1/balances/';
        const fullEndpoint = nodeUrl + getBalancePath + senderAddress;
        try {
            return await request.get(fullEndpoint).send();
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${getBalancePath + senderAddress} from node: ${nodeUrl}`);
    }
    /**
     * Helper to fetch chainId
     */
    async getChainId() {
        const response = await this.getChainIdFromNode();
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.block.header.chain_id;
    }
    /**
     * Get chain id from public node
     */
    async getChainIdFromNode() {
        const nodeUrl = this.getPublicNodeUrl();
        const getLatestBlockPath = 'cosmos/base/tendermint/v1beta1/blocks/latest';
        const fullEndpoint = nodeUrl + getLatestBlockPath;
        try {
            return await request.get(fullEndpoint).send();
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${getLatestBlockPath} from node: ${nodeUrl}`);
    }
    /**
     * Helper to fetch account number
     */
    async getAccountDetails(senderAddress) {
        const response = await this.getAccountFromNode(senderAddress);
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return [response.body.account.account_number, response.body.account.sequence];
    }
    /**
     * Get account number from public node
     */
    async getAccountFromNode(senderAddress) {
        const nodeUrl = this.getPublicNodeUrl();
        const getAccountPath = 'cosmos/auth/v1beta1/accounts/';
        const fullEndpoint = nodeUrl + getAccountPath + senderAddress;
        try {
            return await request.get(fullEndpoint).send();
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${getAccountPath + senderAddress} from node: ${nodeUrl}`);
    }
    /**
     * Helper to fetch account balance
     */
    async getAccountBalance(senderAddress) {
        const response = await this.getBalanceFromNode(senderAddress);
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.balances[0].amount;
    }
    /**
     * Get the public node url from the Environments constant we have defined
     */
    getPublicNodeUrl() {
        return sdk_core_1.Environments[this.bitgo.getEnv()].atomNodeUrl;
    }
    getAddressFromPublicKey(pubKey) {
        return new lib_1.KeyPair({ pub: pubKey }).getAddress();
    }
    /** @inheritDoc **/
    async isWalletAddress(params) {
        const addressDetails = this.getAddressDetails(params.address);
        if (!this.isValidAddress(addressDetails.address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${addressDetails.address}`);
        }
        const rootAddress = params.coinSpecific.rootAddress;
        if (addressDetails.address !== rootAddress) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${addressDetails.address} vs ${rootAddress}`);
        }
        return true;
    }
    getHashFunction() {
        return crypto_1.createHash('sha256');
    }
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    getAddressDetails(address) {
        const destinationDetails = url_1.default.parse(address);
        const destinationAddress = destinationDetails.pathname || '';
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const queryDetails = querystring_1.default.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new sdk_core_1.InvalidAddressError(`memoId may only be given at most once, but found ${queryDetails.memoId.length} instances in address ${address}`);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new sdk_core_1.InvalidAddressError(`invalid address '${address}', must contain exactly one memoId`);
        }
        const [memoId] = _.castArray(queryDetails.memoId) || undefined;
        if (!this.isValidMemoId(memoId)) {
            throw new sdk_core_1.InvalidMemoIdError(`invalid address: '${address}', memoId is not valid`);
        }
        return {
            address: destinationAddress,
            memoId,
        };
    }
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId) {
        let memoIdNumber;
        try {
            memoIdNumber = new bignumber_js_1.BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return memoIdNumber.gte(0);
    }
    getKeyCombinedFromTssKeyShares(userPublicOrPrivateKeyShare, backupPrivateOrPublicKeyShare, walletPassphrase) {
        let backupPrv;
        let userPrv;
        try {
            backupPrv = this.bitgo.decrypt({
                input: backupPrivateOrPublicKeyShare,
                password: walletPassphrase,
            });
            userPrv = this.bitgo.decrypt({
                input: userPublicOrPrivateKeyShare,
                password: walletPassphrase,
            });
        }
        catch (e) {
            throw new Error(`Error decrypting backup keychain: ${e.message}`);
        }
        const userSigningMaterial = JSON.parse(userPrv);
        const backupSigningMaterial = JSON.parse(backupPrv);
        if (!userSigningMaterial.backupNShare) {
            throw new Error('Invalid user key - missing backupNShare');
        }
        if (!backupSigningMaterial.userNShare) {
            throw new Error('Invalid backup key - missing userNShare');
        }
        const MPC = new sdk_core_1.Ecdsa();
        const userKeyCombined = MPC.keyCombine(userSigningMaterial.pShare, [
            userSigningMaterial.bitgoNShare,
            userSigningMaterial.backupNShare,
        ]);
        const userSigningKeyDerived = MPC.keyDerive(userSigningMaterial.pShare, [userSigningMaterial.bitgoNShare, userSigningMaterial.backupNShare], 'm/0');
        const userKeyDerivedCombined = {
            xShare: userSigningKeyDerived.xShare,
            yShares: userKeyCombined.yShares,
        };
        const backupKeyCombined = MPC.keyCombine(backupSigningMaterial.pShare, [
            userSigningKeyDerived.nShares[2],
            backupSigningMaterial.bitgoNShare,
        ]);
        if (userKeyDerivedCombined.xShare.y !== backupKeyCombined.xShare.y ||
            userKeyDerivedCombined.xShare.chaincode !== backupKeyCombined.xShare.chaincode) {
            throw new Error('Common keychains do not match');
        }
        return [userKeyDerivedCombined, backupKeyCombined];
    }
    // TODO(BG-78714): Reduce code duplication between this and eth.ts
    async signRecoveryTSS(userKeyCombined, backupKeyCombined, txHex, { rangeProofChallenge, } = {}) {
        const MPC = new sdk_core_1.Ecdsa();
        const signerOneIndex = userKeyCombined.xShare.i;
        const signerTwoIndex = backupKeyCombined.xShare.i;
        // Since this is a user <> backup signing, we will reuse the same range proof challenge
        rangeProofChallenge =
            rangeProofChallenge !== null && rangeProofChallenge !== void 0 ? rangeProofChallenge : sdk_lib_mpc_1.EcdsaTypes.serializeNtildeWithProofs(await sdk_lib_mpc_1.EcdsaRangeProof.generateNtilde());
        const userToBackupPaillierChallenge = await sdk_lib_mpc_1.EcdsaPaillierProof.generateP(sdk_core_1.hexToBigInt(userKeyCombined.yShares[signerTwoIndex].n));
        const backupToUserPaillierChallenge = await sdk_lib_mpc_1.EcdsaPaillierProof.generateP(sdk_core_1.hexToBigInt(backupKeyCombined.yShares[signerOneIndex].n));
        const userXShare = MPC.appendChallenge(userKeyCombined.xShare, rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: userToBackupPaillierChallenge }));
        const userYShare = MPC.appendChallenge(userKeyCombined.yShares[signerTwoIndex], rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: backupToUserPaillierChallenge }));
        const backupXShare = MPC.appendChallenge(backupKeyCombined.xShare, rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: backupToUserPaillierChallenge }));
        const backupYShare = MPC.appendChallenge(backupKeyCombined.yShares[signerOneIndex], rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: userToBackupPaillierChallenge }));
        const signShares = await MPC.signShare(userXShare, userYShare);
        const signConvertS21 = await MPC.signConvertStep1({
            xShare: backupXShare,
            yShare: backupYShare,
            kShare: signShares.kShare,
        });
        const signConvertS12 = await MPC.signConvertStep2({
            aShare: signConvertS21.aShare,
            wShare: signShares.wShare,
        });
        const signConvertS21_2 = await MPC.signConvertStep3({
            muShare: signConvertS12.muShare,
            bShare: signConvertS21.bShare,
        });
        const [signCombineOne, signCombineTwo] = [
            MPC.signCombine({
                gShare: signConvertS12.gShare,
                signIndex: {
                    i: signConvertS12.muShare.i,
                    j: signConvertS12.muShare.j,
                },
            }),
            MPC.signCombine({
                gShare: signConvertS21_2.gShare,
                signIndex: {
                    i: signConvertS21_2.signIndex.i,
                    j: signConvertS21_2.signIndex.j,
                },
            }),
        ];
        const MESSAGE = buffer_1.Buffer.from(txHex, 'hex');
        const [signA, signB] = [
            MPC.sign(MESSAGE, signCombineOne.oShare, signCombineTwo.dShare, crypto_1.createHash('sha256')),
            MPC.sign(MESSAGE, signCombineTwo.oShare, signCombineOne.dShare, crypto_1.createHash('sha256')),
        ];
        return MPC.constructSignature([signA, signB]);
    }
}
exports.Atom = Atom;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXRvbS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hdG9tLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw4Q0F1QnlCO0FBQ3pCLG9EQUFxRjtBQUNyRiw0Q0FBZ0Y7QUFDaEYsOENBQXdDO0FBQ3hDLCtDQUF5QztBQUN6QyxtQ0FBdUQ7QUFDdkQsMENBQTRCO0FBQzVCLHdEQUFnQztBQUNoQyw4Q0FBc0I7QUFDdEIsOERBQXNDO0FBQ3RDLCtCQUF1RjtBQUN2RixvREFBc0M7QUFDdEMsbUNBQWdDO0FBR2hDLCtDQUF3RDtBQWlDeEQsTUFBYSxJQUFLLFNBQVEsbUJBQVE7SUFFaEMsWUFBc0IsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCLEVBQUUsV0FBdUM7UUFDN0UsT0FBTyxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELG1CQUFtQjtJQUNuQixhQUFhO1FBQ1gsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQsbUJBQW1CO0lBQ25CLFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ2hDLENBQUM7SUFFRCxtQkFBbUI7SUFDbkIsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQUVELG1CQUFtQjtJQUNuQixXQUFXO1FBQ1QsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztJQUNwQyxDQUFDO0lBRUQs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TSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFMUMsTUFBTSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsR0FBRztZQUNyQixHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxNQUFNLEVBQUUsbUJBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNyRixHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsTUFBTSxFQUFFLGNBQWMsQ0FBQyxNQUFNLEVBQUUsbUJBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN0RixDQUFDO1FBRUYsT0FBTyxHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNoRCxDQUFDO0NBQ0Y7QUFobkJELG9CQWduQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQmFzZVRyYW5zYWN0aW9uLFxuICBCaXRHb0Jhc2UsXG4gIEVjZHNhLFxuICBFQ0RTQSxcbiAgRUNEU0FNZXRob2RUeXBlcyxcbiAgRW52aXJvbm1lbnRzLFxuICBFeHBsYW5hdGlvblJlc3VsdCxcbiAgaGV4VG9CaWdJbnQsXG4gIEludmFsaWRBZGRyZXNzRXJyb3IsXG4gIEludmFsaWRNZW1vSWRFcnJvcixcbiAgS2V5UGFpcixcbiAgTVBDQWxnb3JpdGhtLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduaW5nRXJyb3IsXG4gIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgVW5leHBlY3RlZEFkZHJlc3NFcnJvcixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEVjZHNhUGFpbGxpZXJQcm9vZiwgRWNkc2FSYW5nZVByb29mLCBFY2RzYVR5cGVzIH0gZnJvbSAnQGJpdGdvL3Nkay1saWItbXBjJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgQ29pbkZhbWlseSwgY29pbnMgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBiaXAzMiB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaCwgSGFzaCwgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHV0aWxzIGZyb20gJy4vbGliL3V0aWxzJztcbmltcG9ydCB1cmwgZnJvbSAndXJsJztcbmltcG9ydCBxdWVyeXN0cmluZyBmcm9tICdxdWVyeXN0cmluZyc7XG5pbXBvcnQgeyBLZXlQYWlyIGFzIEF0b21LZXlQYWlyLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSB9IGZyb20gJy4vbGliJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHsgRmVlRGF0YSwgU2VuZE1lc3NhZ2UgfSBmcm9tICcuL2xpYi9pZmFjZSc7XG5pbXBvcnQgeyBDb2luIH0gZnJvbSAnQGNvc21qcy9zdGFyZ2F0ZSc7XG5pbXBvcnQgeyBHQVNfQU1PVU5ULCBHQVNfTElNSVQgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEF0b20gYWNjb3VudHMgc3VwcG9ydCBtZW1vIElkIGJhc2VkIGFkZHJlc3Nlc1xuICovXG5pbnRlcmZhY2UgQWRkcmVzc0RldGFpbHMge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIG1lbW9JZD86IHN0cmluZyB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBdG9tIGFjY291bnRzIHN1cHBvcnQgbWVtbyBJZCBiYXNlZCBhZGRyZXNzZXNcbiAqL1xuaW50ZXJmYWNlIEF0b21Db2luU3BlY2lmaWMge1xuICByb290QWRkcmVzczogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlcnlPcHRpb25zIHtcbiAgdXNlcktleT86IHN0cmluZzsgLy8gQm94IEFcbiAgYmFja3VwS2V5Pzogc3RyaW5nOyAvLyBCb3ggQlxuICBiaXRnb0tleTogc3RyaW5nOyAvLyBCb3ggQ1xuICByZWNvdmVyeURlc3RpbmF0aW9uOiBzdHJpbmc7XG4gIGtyc1Byb3ZpZGVyPzogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICBzdGFydGluZ1NjYW5JbmRleD86IG51bWJlcjtcbiAgc2Nhbj86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEF0b21UeCB7XG4gIHNlcmlhbGl6ZWRUeDogc3RyaW5nO1xuICBzY2FuSW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEF0b20gZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfc3RhdGljc0NvaW46IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj47XG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pIHtcbiAgICBzdXBlcihiaXRnbyk7XG5cbiAgICBpZiAoIXN0YXRpY3NDb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29uc3RydWN0b3IgcGFyYW1ldGVyIHN0YXRpY3NDb2luJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGljc0NvaW4gPSBzdGF0aWNzQ29pbjtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBBdG9tKGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGdldEJhc2VGYWN0b3IoKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICByZXR1cm4gMWU2O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgc3VwcG9ydHNUc3MoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGdldE1QQ0FsZ29yaXRobSgpOiBNUENBbGdvcml0aG0ge1xuICAgIHJldHVybiAnZWNkc2EnO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHV0aWxzLmlzVmFsaWRQdWJsaWNLZXkocHViKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB1dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShwcnYpO1xuICB9XG5cbiAgZ2V0QnVpbGRlcigpOiBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5IHtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkoY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSkpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdXRpbHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykgfHwgdXRpbHMuaXNWYWxpZFZhbGlkYXRvckFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGFzeW5jIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgbGV0IHRvdGFsQW1vdW50ID0gbmV3IEJpZ051bWJlcigwKTtcbiAgICBjb25zdCBjb2luQ29uZmlnID0gY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSk7XG4gICAgY29uc3QgeyB0eFByZWJ1aWxkLCB0eFBhcmFtcyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJhd1R4ID0gdHhQcmVidWlsZC50eEhleDtcbiAgICBpZiAoIXJhd1R4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgdHggcHJlYnVpbGQgcHJvcGVydHkgdHhIZXgnKTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCBuZXcgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2luQ29uZmlnKS5mcm9tKHJhd1R4KS5idWlsZCgpO1xuICAgIGNvbnN0IGV4cGxhaW5lZFR4ID0gdHJhbnNhY3Rpb24uZXhwbGFpblRyYW5zYWN0aW9uKCk7XG5cbiAgICBpZiAodHhQYXJhbXMucmVjaXBpZW50cyAmJiB0eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUmVjaXBpZW50cyA9IHR4UGFyYW1zLnJlY2lwaWVudHM/Lm1hcCgocmVjaXBpZW50KSA9PiBfLnBpY2socmVjaXBpZW50LCBbJ2FkZHJlc3MnLCAnYW1vdW50J10pKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkT3V0cHV0cyA9IGV4cGxhaW5lZFR4Lm91dHB1dHMubWFwKChvdXRwdXQpID0+IF8ucGljayhvdXRwdXQsIFsnYWRkcmVzcycsICdhbW91bnQnXSkpO1xuXG4gICAgICBpZiAoIV8uaXNFcXVhbChmaWx0ZXJlZE91dHB1dHMsIGZpbHRlcmVkUmVjaXBpZW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBvdXRwdXRzIGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdHhQYXJhbXMgcmVjaXBpZW50cycpO1xuICAgICAgfVxuICAgICAgLy8gV2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRzIHRyYW5zYWN0aW9uIGRvZXNuJ3QgaGF2ZSBhbW91bnRcbiAgICAgIGlmICh0cmFuc2FjdGlvbi50eXBlICE9PSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1dpdGhkcmF3KSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVjaXBpZW50cyBvZiB0eFBhcmFtcy5yZWNpcGllbnRzKSB7XG4gICAgICAgICAgdG90YWxBbW91bnQgPSB0b3RhbEFtb3VudC5wbHVzKHJlY2lwaWVudHMuYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvdGFsQW1vdW50LmlzRXF1YWxUbyhleHBsYWluZWRUeC5vdXRwdXRBbW91bnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCB0b3RhbCBhbW91bnQgZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0b3RhbCBhbW91bnQgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zICYgeyB0eEhleDogc3RyaW5nIH0pOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IGF3YWl0IHRoaXMuZXhwbGFpblRyYW5zYWN0aW9uKHsgdHhIZXg6IHBhcmFtcy50eEhleCB9KTtcbiAgICBpZiAoIXRyYW5zYWN0aW9uRXhwbGFuYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2FjdGlvbkV4cGxhbmF0aW9uLm91dHB1dHMubGVuZ3RoIDw9IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0czogW10sXG4gICAgICAgIG91dHB1dHM6IFtdLFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24ub3V0cHV0c1swXS5hZGRyZXNzO1xuICAgIGNvbnN0IGZlZUFtb3VudCA9IG5ldyBCaWdOdW1iZXIodHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5mZWUuZmVlID09PSAnJyA/ICcwJyA6IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24uZmVlLmZlZSk7XG4gICAgY29uc3QgaW5wdXRzID0gW1xuICAgICAge1xuICAgICAgICBhZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IG5ldyBCaWdOdW1iZXIodHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5vdXRwdXRBbW91bnQpLnBsdXMoZmVlQW1vdW50KS50b0ZpeGVkKCksXG4gICAgICB9LFxuICAgIF07XG4gICAgY29uc3Qgb3V0cHV0cyA9IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24ub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogb3V0cHV0LmFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogbmV3IEJpZ051bWJlcihvdXRwdXQuYW1vdW50KS50b0ZpeGVkKCksXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpbnB1dHMsXG4gICAgICBvdXRwdXRzLFxuICAgIH07XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihvcHRpb25zOiB7IHR4SGV4OiBzdHJpbmcgfSk6IFByb21pc2U8RXhwbGFuYXRpb25SZXN1bHQ+IHtcbiAgICBpZiAoIW9wdGlvbnMudHhIZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eEhleCBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uQnVpbGRlciA9IG5ldyBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5KGNvaW5zLmdldCh0aGlzLmdldENoYWluKCkpKS5mcm9tKG9wdGlvbnMudHhIZXgpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0cmFuc2FjdGlvbkJ1aWxkZXIuYnVpbGQoKTtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5leHBsYWluVHJhbnNhY3Rpb24oKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246ICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBpZiAoIXNlZWQpIHtcbiAgICAgIC8vIEFuIGV4dGVuZGVkIHByaXZhdGUga2V5IGhhcyBib3RoIGEgbm9ybWFsIDI1NiBiaXQgcHJpdmF0ZSBrZXkgYW5kIGEgMjU2XG4gICAgICAvLyBiaXQgY2hhaW4gY29kZSwgYm90aCBvZiB3aGljaCBtdXN0IGJlIHJhbmRvbS4gNTEyIGJpdHMgaXMgdGhlcmVmb3JlIHRoZVxuICAgICAgLy8gbWF4aW11bSBlbnRyb3B5IGFuZCBnaXZlcyB1cyBtYXhpbXVtIHNlY3VyaXR5IGFnYWluc3QgY3JhY2tpbmcuXG4gICAgICBzZWVkID0gcmFuZG9tQnl0ZXMoNTEyIC8gOCk7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuZGVkS2V5ID0gYmlwMzIuZnJvbVNlZWQoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogZXh0ZW5kZWRLZXkubmV1dGVyZWQoKS50b0Jhc2U1OCgpLFxuICAgICAgcHJ2OiBleHRlbmRlZEtleS50b0Jhc2U1OCgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggYSBzaW5nbGUgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIHBhcmFtcyBwYXJhbWV0ZXJzIGluIHRoZSBmb3JtIG9mIHsgdHhQcmVidWlsZDoge3R4SGV4fSwgcHJ2IH1cbiAgICogQHJldHVybnMgc2lnbmVkIHRyYW5zYWN0aW9uIGluIHRoZSBmb3JtIG9mIHsgdHhIZXggfVxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyAmIHsgdHhQcmVidWlsZDogeyB0eEhleDogc3RyaW5nIH07IHBydjogc3RyaW5nIH1cbiAgKTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zPy50eFByZWJ1aWxkPy50eEhleDtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gcGFyYW1zPy5wcnY7XG4gICAgaWYgKCF0eEhleCkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eFByZWJ1aWxkIHBhcmFtZXRlcjogcGFyYW1zLnR4UHJlYnVpbGQudHhIZXgnKTtcbiAgICB9XG4gICAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBydiBwYXJhbWV0ZXI6IHBhcmFtcy5wcnYnKTtcbiAgICB9XG4gICAgY29uc3QgdHhCdWlsZGVyID0gbmV3IFRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkoY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSkpLmZyb20ocGFyYW1zLnR4UHJlYnVpbGQudHhIZXgpO1xuICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBwYXJhbXMucHJ2IH0pO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBCYXNlVHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdGYWlsZWQgdG8gYnVpbGQgc2lnbmVkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWRUeCA9IHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR4SGV4OiBzZXJpYWxpemVkVHgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvXG4gICAqIEBwYXJhbSB7UmVjb3ZlcnlPcHRpb25zfSBwYXJhbXMgcGFyYW1ldGVycyBuZWVkZWQgdG8gY29uc3RydWN0IGFuZFxuICAgKiAobWF5YmUpIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtBdG9tVHh9IHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGhleCBzdHJpbmcgYW5kIGluZGV4XG4gICAqIG9mIHRoZSBhZGRyZXNzIGJlaW5nIHN3ZXB0XG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxBdG9tVHg+IHtcbiAgICAvLyBTdGVwIDE6IENoZWNrIGlmIHBhcmFtcyBjb250YWlucyB0aGUgcmVxdWlyZWQgcGFyYW1ldGVyc1xuICAgIGlmICghcGFyYW1zLmJpdGdvS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYml0Z29LZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy51c2VyS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdXNlcktleScpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmJhY2t1cEtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJhY2t1cEtleScpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB3YWxsZXQgcGFzc3BocmFzZScpO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgMjogRmV0Y2ggdGhlIGJpdGdvIGtleSBmcm9tIHBhcmFtc1xuICAgIGNvbnN0IGJpdGdvS2V5ID0gcGFyYW1zLmJpdGdvS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgICAvLyBTdGVwIDM6IEluc3RhbnRpYXRlIHRoZSBFQ0RTQSBzaWduZXIgYW5kIGZldGNoIHRoZSBhZGRyZXNzIGRldGFpbHNcbiAgICBjb25zdCBNUEMgPSBuZXcgRWNkc2EoKTtcbiAgICBjb25zdCBjaGFpbklkID0gYXdhaXQgdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgY29uc3QgY3VyclBhdGggPSAnbS8wJztcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBNUEMuZGVyaXZlVW5oYXJkZW5lZChiaXRnb0tleSwgY3VyclBhdGgpLnNsaWNlKDAsIDY2KTtcbiAgICBjb25zdCBzZW5kZXJBZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzRnJvbVB1YmxpY0tleShwdWJsaWNLZXkpO1xuXG4gICAgLy8gU3RlcCA0OiBGZXRjaCBhY2NvdW50IGRldGFpbHMgc3VjaCBhcyBhY2NvdW50Tm8sIGJhbGFuY2UgYW5kIGNoZWNrIGZvciBzdWZmaWNpZW50IGZ1bmRzIG9uY2UgZ2FzQW1vdW50IGhhcyBiZWVuIGRlZHVjdGVkXG4gICAgY29uc3QgW2FjY291bnROdW1iZXIsIHNlcXVlbmNlTm9dID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50RGV0YWlscyhzZW5kZXJBZGRyZXNzKTtcbiAgICBjb25zdCBiYWxhbmNlID0gbmV3IEJpZ051bWJlcihhd2FpdCB0aGlzLmdldEFjY291bnRCYWxhbmNlKHNlbmRlckFkZHJlc3MpKTtcbiAgICBjb25zdCBnYXNCdWRnZXQ6IEZlZURhdGEgPSB7XG4gICAgICBhbW91bnQ6IFt7IGRlbm9tOiAndWF0b20nLCBhbW91bnQ6IEdBU19BTU9VTlQgfV0sXG4gICAgICBnYXNMaW1pdDogR0FTX0xJTUlULFxuICAgIH07XG4gICAgY29uc3QgZ2FzQW1vdW50ID0gbmV3IEJpZ051bWJlcihnYXNCdWRnZXQuYW1vdW50WzBdLmFtb3VudCk7XG4gICAgY29uc3QgYWN0dWFsQmFsYW5jZSA9IGJhbGFuY2UubWludXMoZ2FzQW1vdW50KTtcblxuICAgIGlmIChhY3R1YWxCYWxhbmNlLmlzTGVzc1RoYW5PckVxdWFsVG8oMCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBoYXZlIGVub3VnaCBmdW5kcyB0byByZWNvdmVyJyk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCA1OiBPbmNlIHN1ZmZpY2llbnQgZnVuZHMgYXJlIHByZXNlbnQsIGNvbnN0cnVjdCB0aGUgcmVjb3ZlciB0eCBtZXNzc2FnZVxuICAgIGNvbnN0IGFtb3VudDogQ29pbltdID0gW1xuICAgICAge1xuICAgICAgICBkZW5vbTogJ3VhdG9tJyxcbiAgICAgICAgYW1vdW50OiBhY3R1YWxCYWxhbmNlLnRvRml4ZWQoKSxcbiAgICAgIH0sXG4gICAgXTtcbiAgICBjb25zdCBzZW5kTWVzc2FnZTogU2VuZE1lc3NhZ2VbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgZnJvbUFkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIHRvQWRkcmVzczogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgLy8gU3RlcCA2OiBCdWlsZCB0aGUgdW5zaWduZWQgdHggdXNpbmcgdGhlIGNvbnN0cnVjdGVkIG1lc3NhZ2VcbiAgICBjb25zdCB0eG5CdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZ2V0VHJhbnNmZXJCdWlsZGVyKCk7XG4gICAgdHhuQnVpbGRlclxuICAgICAgLm1lc3NhZ2VzKHNlbmRNZXNzYWdlKVxuICAgICAgLmdhc0J1ZGdldChnYXNCdWRnZXQpXG4gICAgICAucHVibGljS2V5KHB1YmxpY0tleSlcbiAgICAgIC5zZXF1ZW5jZShOdW1iZXIoc2VxdWVuY2VObykpXG4gICAgICAuYWNjb3VudE51bWJlcihOdW1iZXIoYWNjb3VudE51bWJlcikpXG4gICAgICAuY2hhaW5JZChjaGFpbklkKTtcbiAgICBjb25zdCB1bnNpZ25lZFRyYW5zYWN0aW9uID0gKGF3YWl0IHR4bkJ1aWxkZXIuYnVpbGQoKSkgYXMgVHJhbnNhY3Rpb247XG4gICAgbGV0IHNlcmlhbGl6ZWRUeCA9IHVuc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcbiAgICBjb25zdCBzaWduYWJsZUhleCA9IHVuc2lnbmVkVHJhbnNhY3Rpb24uc2lnbmFibGVQYXlsb2FkLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCB1c2VyS2V5ID0gcGFyYW1zLnVzZXJLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBjb25zdCBiYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgW3VzZXJLZXlDb21iaW5lZCwgYmFja3VwS2V5Q29tYmluZWRdID0gKCgpOiBbXG4gICAgICBFQ0RTQU1ldGhvZFR5cGVzLktleUNvbWJpbmVkIHwgdW5kZWZpbmVkLFxuICAgICAgRUNEU0FNZXRob2RUeXBlcy5LZXlDb21iaW5lZCB8IHVuZGVmaW5lZFxuICAgIF0gPT4ge1xuICAgICAgY29uc3QgW3VzZXJLZXlDb21iaW5lZCwgYmFja3VwS2V5Q29tYmluZWRdID0gdGhpcy5nZXRLZXlDb21iaW5lZEZyb21Uc3NLZXlTaGFyZXMoXG4gICAgICAgIHVzZXJLZXksXG4gICAgICAgIGJhY2t1cEtleSxcbiAgICAgICAgcGFyYW1zLndhbGxldFBhc3NwaHJhc2VcbiAgICAgICk7XG4gICAgICByZXR1cm4gW3VzZXJLZXlDb21iaW5lZCwgYmFja3VwS2V5Q29tYmluZWRdO1xuICAgIH0pKCk7XG5cbiAgICBpZiAoIXVzZXJLZXlDb21iaW5lZCB8fCAhYmFja3VwS2V5Q29tYmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBjb21iaW5lZCBrZXkgc2hhcmVzIGZvciB1c2VyIG9yIGJhY2t1cCcpO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgNzogU2lnbiB0aGUgdHhcbiAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCB0aGlzLnNpZ25SZWNvdmVyeVRTUyh1c2VyS2V5Q29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkLCBzaWduYWJsZUhleCk7XG4gICAgY29uc3Qgc2lnbmFibGVCdWZmZXIgPSBCdWZmZXIuZnJvbShzaWduYWJsZUhleCwgJ2hleCcpO1xuICAgIE1QQy52ZXJpZnkoc2lnbmFibGVCdWZmZXIsIHNpZ25hdHVyZSwgY3JlYXRlSGFzaCgnc2hhMjU2JykpO1xuICAgIGNvbnN0IGF0b21LZXlQYWlyID0gbmV3IEF0b21LZXlQYWlyKHsgcHViOiBwdWJsaWNLZXkgfSk7XG4gICAgdHhuQnVpbGRlci5hZGRTaWduYXR1cmUoeyBwdWI6IGF0b21LZXlQYWlyLmdldEtleXMoKS5wdWIgfSwgQnVmZmVyLmZyb20oc2lnbmF0dXJlLnIgKyBzaWduYXR1cmUucywgJ2hleCcpKTtcbiAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbiA9IGF3YWl0IHR4bkJ1aWxkZXIuYnVpbGQoKTtcbiAgICBzZXJpYWxpemVkVHggPSBzaWduZWRUcmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuXG4gICAgcmV0dXJuIHsgc2VyaWFsaXplZFR4OiBzZXJpYWxpemVkVHgsIHNjYW5JbmRleDogMCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBiYWxhbmNlIGZyb20gcHVibGljIG5vZGVcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXRCYWxhbmNlRnJvbU5vZGUoc2VuZGVyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxyZXF1ZXN0LlJlc3BvbnNlPiB7XG4gICAgY29uc3Qgbm9kZVVybCA9IHRoaXMuZ2V0UHVibGljTm9kZVVybCgpO1xuICAgIGNvbnN0IGdldEJhbGFuY2VQYXRoID0gJ2Nvc21vcy9iYW5rL3YxYmV0YTEvYmFsYW5jZXMvJztcbiAgICBjb25zdCBmdWxsRW5kcG9pbnQgPSBub2RlVXJsICsgZ2V0QmFsYW5jZVBhdGggKyBzZW5kZXJBZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5nZXQoZnVsbEVuZHBvaW50KS5zZW5kKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY2FsbCBlbmRwb2ludCAke2dldEJhbGFuY2VQYXRoICsgc2VuZGVyQWRkcmVzc30gZnJvbSBub2RlOiAke25vZGVVcmx9YCk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGZldGNoIGNoYWluSWRcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXRDaGFpbklkKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldENoYWluSWRGcm9tTm9kZSgpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keS5ibG9jay5oZWFkZXIuY2hhaW5faWQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNoYWluIGlkIGZyb20gcHVibGljIG5vZGVcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXRDaGFpbklkRnJvbU5vZGUoKTogUHJvbWlzZTxyZXF1ZXN0LlJlc3BvbnNlPiB7XG4gICAgY29uc3Qgbm9kZVVybCA9IHRoaXMuZ2V0UHVibGljTm9kZVVybCgpO1xuICAgIGNvbnN0IGdldExhdGVzdEJsb2NrUGF0aCA9ICdjb3Ntb3MvYmFzZS90ZW5kZXJtaW50L3YxYmV0YTEvYmxvY2tzL2xhdGVzdCc7XG4gICAgY29uc3QgZnVsbEVuZHBvaW50ID0gbm9kZVVybCArIGdldExhdGVzdEJsb2NrUGF0aDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QuZ2V0KGZ1bGxFbmRwb2ludCkuc2VuZCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGNhbGwgZW5kcG9pbnQgJHtnZXRMYXRlc3RCbG9ja1BhdGh9IGZyb20gbm9kZTogJHtub2RlVXJsfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBmZXRjaCBhY2NvdW50IG51bWJlclxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEFjY291bnREZXRhaWxzKHNlbmRlckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEZyb21Ob2RlKHNlbmRlckFkZHJlc3MpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gW3Jlc3BvbnNlLmJvZHkuYWNjb3VudC5hY2NvdW50X251bWJlciwgcmVzcG9uc2UuYm9keS5hY2NvdW50LnNlcXVlbmNlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWNjb3VudCBudW1iZXIgZnJvbSBwdWJsaWMgbm9kZVxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEFjY291bnRGcm9tTm9kZShzZW5kZXJBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHJlcXVlc3QuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBub2RlVXJsID0gdGhpcy5nZXRQdWJsaWNOb2RlVXJsKCk7XG4gICAgY29uc3QgZ2V0QWNjb3VudFBhdGggPSAnY29zbW9zL2F1dGgvdjFiZXRhMS9hY2NvdW50cy8nO1xuICAgIGNvbnN0IGZ1bGxFbmRwb2ludCA9IG5vZGVVcmwgKyBnZXRBY2NvdW50UGF0aCArIHNlbmRlckFkZHJlc3M7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LmdldChmdWxsRW5kcG9pbnQpLnNlbmQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKGUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjYWxsIGVuZHBvaW50ICR7Z2V0QWNjb3VudFBhdGggKyBzZW5kZXJBZGRyZXNzfSBmcm9tIG5vZGU6ICR7bm9kZVVybH1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZmV0Y2ggYWNjb3VudCBiYWxhbmNlXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QWNjb3VudEJhbGFuY2Uoc2VuZGVyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZUZyb21Ob2RlKHNlbmRlckFkZHJlc3MpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keS5iYWxhbmNlc1swXS5hbW91bnQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWMgbm9kZSB1cmwgZnJvbSB0aGUgRW52aXJvbm1lbnRzIGNvbnN0YW50IHdlIGhhdmUgZGVmaW5lZFxuICAgKi9cbiAgcHJvdGVjdGVkIGdldFB1YmxpY05vZGVVcmwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLmF0b21Ob2RlVXJsO1xuICB9XG5cbiAgZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkocHViS2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBuZXcgQXRvbUtleVBhaXIoeyBwdWI6IHB1YktleSB9KS5nZXRBZGRyZXNzKCk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgYWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKHBhcmFtcy5hZGRyZXNzKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzRGV0YWlscy5hZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzRGV0YWlscy5hZGRyZXNzfWApO1xuICAgIH1cbiAgICBjb25zdCByb290QWRkcmVzcyA9IChwYXJhbXMuY29pblNwZWNpZmljIGFzIEF0b21Db2luU3BlY2lmaWMpLnJvb3RBZGRyZXNzO1xuICAgIGlmIChhZGRyZXNzRGV0YWlscy5hZGRyZXNzICE9PSByb290QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiAke2FkZHJlc3NEZXRhaWxzLmFkZHJlc3N9IHZzICR7cm9vdEFkZHJlc3N9YCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0SGFzaEZ1bmN0aW9uKCk6IEhhc2gge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGFkZHJlc3MgaW50byBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGFkZHJlc3MgYW5kIG1lbW8gaWRcbiAgICovXG4gIGdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3M6IHN0cmluZyk6IEFkZHJlc3NEZXRhaWxzIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSB1cmwucGFyc2UoYWRkcmVzcyk7XG4gICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lIHx8ICcnO1xuXG4gICAgLy8gYWRkcmVzcyBkb2Vzbid0IGhhdmUgYSBtZW1vIGlkXG4gICAgaWYgKGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZSA9PT0gYWRkcmVzcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgbWVtb0lkOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlEZXRhaWxzID0gcXVlcnlzdHJpbmcucGFyc2UoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5RGV0YWlscy5tZW1vSWQpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIHByb3BlcnRpZXMsIHRoZSBxdWVyeSBkZXRhaWxzIG5lZWQgdG8gY29udGFpbiB0aGUgbWVtbyBpZCBwcm9wZXJ0eVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihcbiAgICAgICAgYG1lbW9JZCBtYXkgb25seSBiZSBnaXZlbiBhdCBtb3N0IG9uY2UsIGJ1dCBmb3VuZCAke3F1ZXJ5RGV0YWlscy5tZW1vSWQubGVuZ3RofSBpbnN0YW5jZXMgaW4gYWRkcmVzcyAke2FkZHJlc3N9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSAmJiBxdWVyeURldGFpbHMubWVtb0lkLmxlbmd0aCAhPT0gMSkge1xuICAgICAgLy8gdmFsaWQgYWRkcmVzc2VzIGNhbiBvbmx5IGNvbnRhaW4gb25lIG1lbW8gaWRcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3MgJyR7YWRkcmVzc30nLCBtdXN0IGNvbnRhaW4gZXhhY3RseSBvbmUgbWVtb0lkYCk7XG4gICAgfVxuXG4gICAgY29uc3QgW21lbW9JZF0gPSBfLmNhc3RBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSB8fCB1bmRlZmluZWQ7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRNZW1vSWQobWVtb0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZW1vSWRFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAnJHthZGRyZXNzfScsIG1lbW9JZCBpcyBub3QgdmFsaWRgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgbWVtb0lkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGEgbWVtbyBpZCBpcyB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0gbWVtb0lkIG1lbW8gaWRcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBtZW1vIGlkIGlzIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkTWVtb0lkKG1lbW9JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgbGV0IG1lbW9JZE51bWJlcjtcbiAgICB0cnkge1xuICAgICAgbWVtb0lkTnVtYmVyID0gbmV3IEJpZ051bWJlcihtZW1vSWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW9JZE51bWJlci5ndGUoMCk7XG4gIH1cblxuICBwcml2YXRlIGdldEtleUNvbWJpbmVkRnJvbVRzc0tleVNoYXJlcyhcbiAgICB1c2VyUHVibGljT3JQcml2YXRlS2V5U2hhcmU6IHN0cmluZyxcbiAgICBiYWNrdXBQcml2YXRlT3JQdWJsaWNLZXlTaGFyZTogc3RyaW5nLFxuICAgIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmdcbiAgKTogW0VDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWQsIEVDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWRdIHtcbiAgICBsZXQgYmFja3VwUHJ2O1xuICAgIGxldCB1c2VyUHJ2O1xuICAgIHRyeSB7XG4gICAgICBiYWNrdXBQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDogYmFja3VwUHJpdmF0ZU9yUHVibGljS2V5U2hhcmUsXG4gICAgICAgIHBhc3N3b3JkOiB3YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgfSk7XG4gICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IHVzZXJQdWJsaWNPclByaXZhdGVLZXlTaGFyZSxcbiAgICAgICAgcGFzc3dvcmQ6IHdhbGxldFBhc3NwaHJhc2UsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgYmFja3VwIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZSh1c2VyUHJ2KSBhcyBFQ0RTQU1ldGhvZFR5cGVzLlNpZ25pbmdNYXRlcmlhbDtcbiAgICBjb25zdCBiYWNrdXBTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKGJhY2t1cFBydikgYXMgRUNEU0FNZXRob2RUeXBlcy5TaWduaW5nTWF0ZXJpYWw7XG5cbiAgICBpZiAoIXVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXkgLSBtaXNzaW5nIGJhY2t1cE5TaGFyZScpO1xuICAgIH1cblxuICAgIGlmICghYmFja3VwU2lnbmluZ01hdGVyaWFsLnVzZXJOU2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYWNrdXAga2V5IC0gbWlzc2luZyB1c2VyTlNoYXJlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG5cbiAgICBjb25zdCB1c2VyS2V5Q29tYmluZWQgPSBNUEMua2V5Q29tYmluZSh1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZSwgW1xuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb05TaGFyZSxcbiAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlLFxuICAgIF0pO1xuXG4gICAgY29uc3QgdXNlclNpZ25pbmdLZXlEZXJpdmVkID0gTVBDLmtleURlcml2ZShcbiAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwucFNoYXJlLFxuICAgICAgW3VzZXJTaWduaW5nTWF0ZXJpYWwuYml0Z29OU2hhcmUsIHVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlXSxcbiAgICAgICdtLzAnXG4gICAgKTtcblxuICAgIGNvbnN0IHVzZXJLZXlEZXJpdmVkQ29tYmluZWQgPSB7XG4gICAgICB4U2hhcmU6IHVzZXJTaWduaW5nS2V5RGVyaXZlZC54U2hhcmUsXG4gICAgICB5U2hhcmVzOiB1c2VyS2V5Q29tYmluZWQueVNoYXJlcyxcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwS2V5Q29tYmluZWQgPSBNUEMua2V5Q29tYmluZShiYWNrdXBTaWduaW5nTWF0ZXJpYWwucFNoYXJlLCBbXG4gICAgICB1c2VyU2lnbmluZ0tleURlcml2ZWQublNoYXJlc1syXSxcbiAgICAgIGJhY2t1cFNpZ25pbmdNYXRlcmlhbC5iaXRnb05TaGFyZSxcbiAgICBdKTtcblxuICAgIGlmIChcbiAgICAgIHVzZXJLZXlEZXJpdmVkQ29tYmluZWQueFNoYXJlLnkgIT09IGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZS55IHx8XG4gICAgICB1c2VyS2V5RGVyaXZlZENvbWJpbmVkLnhTaGFyZS5jaGFpbmNvZGUgIT09IGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZS5jaGFpbmNvZGVcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29tbW9uIGtleWNoYWlucyBkbyBub3QgbWF0Y2gnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VzZXJLZXlEZXJpdmVkQ29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXTtcbiAgfVxuXG4gIC8vIFRPRE8oQkctNzg3MTQpOiBSZWR1Y2UgY29kZSBkdXBsaWNhdGlvbiBiZXR3ZWVuIHRoaXMgYW5kIGV0aC50c1xuICBwcml2YXRlIGFzeW5jIHNpZ25SZWNvdmVyeVRTUyhcbiAgICB1c2VyS2V5Q29tYmluZWQ6IEVDRFNBLktleUNvbWJpbmVkLFxuICAgIGJhY2t1cEtleUNvbWJpbmVkOiBFQ0RTQS5LZXlDb21iaW5lZCxcbiAgICB0eEhleDogc3RyaW5nLFxuICAgIHtcbiAgICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2UsXG4gICAgfToge1xuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZT86IEVjZHNhVHlwZXMuU2VyaWFsaXplZE50aWxkZTtcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxFQ0RTQU1ldGhvZFR5cGVzLlNpZ25hdHVyZT4ge1xuICAgIGNvbnN0IE1QQyA9IG5ldyBFY2RzYSgpO1xuICAgIGNvbnN0IHNpZ25lck9uZUluZGV4ID0gdXNlcktleUNvbWJpbmVkLnhTaGFyZS5pO1xuICAgIGNvbnN0IHNpZ25lclR3b0luZGV4ID0gYmFja3VwS2V5Q29tYmluZWQueFNoYXJlLmk7XG5cbiAgICAvLyBTaW5jZSB0aGlzIGlzIGEgdXNlciA8PiBiYWNrdXAgc2lnbmluZywgd2Ugd2lsbCByZXVzZSB0aGUgc2FtZSByYW5nZSBwcm9vZiBjaGFsbGVuZ2VcbiAgICByYW5nZVByb29mQ2hhbGxlbmdlID1cbiAgICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2UgPz8gRWNkc2FUeXBlcy5zZXJpYWxpemVOdGlsZGVXaXRoUHJvb2ZzKGF3YWl0IEVjZHNhUmFuZ2VQcm9vZi5nZW5lcmF0ZU50aWxkZSgpKTtcblxuICAgIGNvbnN0IHVzZXJUb0JhY2t1cFBhaWxsaWVyQ2hhbGxlbmdlID0gYXdhaXQgRWNkc2FQYWlsbGllclByb29mLmdlbmVyYXRlUChcbiAgICAgIGhleFRvQmlnSW50KHVzZXJLZXlDb21iaW5lZC55U2hhcmVzW3NpZ25lclR3b0luZGV4XS5uKVxuICAgICk7XG4gICAgY29uc3QgYmFja3VwVG9Vc2VyUGFpbGxpZXJDaGFsbGVuZ2UgPSBhd2FpdCBFY2RzYVBhaWxsaWVyUHJvb2YuZ2VuZXJhdGVQKFxuICAgICAgaGV4VG9CaWdJbnQoYmFja3VwS2V5Q29tYmluZWQueVNoYXJlc1tzaWduZXJPbmVJbmRleF0ubilcbiAgICApO1xuXG4gICAgY29uc3QgdXNlclhTaGFyZSA9IE1QQy5hcHBlbmRDaGFsbGVuZ2UoXG4gICAgICB1c2VyS2V5Q29tYmluZWQueFNoYXJlLFxuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSxcbiAgICAgIEVjZHNhVHlwZXMuc2VyaWFsaXplUGFpbGxpZXJDaGFsbGVuZ2UoeyBwOiB1c2VyVG9CYWNrdXBQYWlsbGllckNoYWxsZW5nZSB9KVxuICAgICk7XG4gICAgY29uc3QgdXNlcllTaGFyZSA9IE1QQy5hcHBlbmRDaGFsbGVuZ2UoXG4gICAgICB1c2VyS2V5Q29tYmluZWQueVNoYXJlc1tzaWduZXJUd29JbmRleF0sXG4gICAgICByYW5nZVByb29mQ2hhbGxlbmdlLFxuICAgICAgRWNkc2FUeXBlcy5zZXJpYWxpemVQYWlsbGllckNoYWxsZW5nZSh7IHA6IGJhY2t1cFRvVXNlclBhaWxsaWVyQ2hhbGxlbmdlIH0pXG4gICAgKTtcbiAgICBjb25zdCBiYWNrdXBYU2hhcmUgPSBNUEMuYXBwZW5kQ2hhbGxlbmdlKFxuICAgICAgYmFja3VwS2V5Q29tYmluZWQueFNoYXJlLFxuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSxcbiAgICAgIEVjZHNhVHlwZXMuc2VyaWFsaXplUGFpbGxpZXJDaGFsbGVuZ2UoeyBwOiBiYWNrdXBUb1VzZXJQYWlsbGllckNoYWxsZW5nZSB9KVxuICAgICk7XG4gICAgY29uc3QgYmFja3VwWVNoYXJlID0gTVBDLmFwcGVuZENoYWxsZW5nZShcbiAgICAgIGJhY2t1cEtleUNvbWJpbmVkLnlTaGFyZXNbc2lnbmVyT25lSW5kZXhdLFxuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSxcbiAgICAgIEVjZHNhVHlwZXMuc2VyaWFsaXplUGFpbGxpZXJDaGFsbGVuZ2UoeyBwOiB1c2VyVG9CYWNrdXBQYWlsbGllckNoYWxsZW5nZSB9KVxuICAgICk7XG5cbiAgICBjb25zdCBzaWduU2hhcmVzOiBFQ0RTQS5TaWduU2hhcmVSVCA9IGF3YWl0IE1QQy5zaWduU2hhcmUodXNlclhTaGFyZSwgdXNlcllTaGFyZSk7XG5cbiAgICBjb25zdCBzaWduQ29udmVydFMyMSA9IGF3YWl0IE1QQy5zaWduQ29udmVydFN0ZXAxKHtcbiAgICAgIHhTaGFyZTogYmFja3VwWFNoYXJlLFxuICAgICAgeVNoYXJlOiBiYWNrdXBZU2hhcmUsIC8vIFlTaGFyZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBvdGhlciBwYXJ0aWNpcGFudCBzaWduZXJPbmVcbiAgICAgIGtTaGFyZTogc2lnblNoYXJlcy5rU2hhcmUsXG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbkNvbnZlcnRTMTIgPSBhd2FpdCBNUEMuc2lnbkNvbnZlcnRTdGVwMih7XG4gICAgICBhU2hhcmU6IHNpZ25Db252ZXJ0UzIxLmFTaGFyZSxcbiAgICAgIHdTaGFyZTogc2lnblNoYXJlcy53U2hhcmUsXG4gICAgfSk7XG4gICAgY29uc3Qgc2lnbkNvbnZlcnRTMjFfMiA9IGF3YWl0IE1QQy5zaWduQ29udmVydFN0ZXAzKHtcbiAgICAgIG11U2hhcmU6IHNpZ25Db252ZXJ0UzEyLm11U2hhcmUsXG4gICAgICBiU2hhcmU6IHNpZ25Db252ZXJ0UzIxLmJTaGFyZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IFtzaWduQ29tYmluZU9uZSwgc2lnbkNvbWJpbmVUd29dID0gW1xuICAgICAgTVBDLnNpZ25Db21iaW5lKHtcbiAgICAgICAgZ1NoYXJlOiBzaWduQ29udmVydFMxMi5nU2hhcmUsXG4gICAgICAgIHNpZ25JbmRleDoge1xuICAgICAgICAgIGk6IHNpZ25Db252ZXJ0UzEyLm11U2hhcmUuaSxcbiAgICAgICAgICBqOiBzaWduQ29udmVydFMxMi5tdVNoYXJlLmosXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICAgIE1QQy5zaWduQ29tYmluZSh7XG4gICAgICAgIGdTaGFyZTogc2lnbkNvbnZlcnRTMjFfMi5nU2hhcmUsXG4gICAgICAgIHNpZ25JbmRleDoge1xuICAgICAgICAgIGk6IHNpZ25Db252ZXJ0UzIxXzIuc2lnbkluZGV4LmksXG4gICAgICAgICAgajogc2lnbkNvbnZlcnRTMjFfMi5zaWduSW5kZXguaixcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIF07XG5cbiAgICBjb25zdCBNRVNTQUdFID0gQnVmZmVyLmZyb20odHhIZXgsICdoZXgnKTtcblxuICAgIGNvbnN0IFtzaWduQSwgc2lnbkJdID0gW1xuICAgICAgTVBDLnNpZ24oTUVTU0FHRSwgc2lnbkNvbWJpbmVPbmUub1NoYXJlLCBzaWduQ29tYmluZVR3by5kU2hhcmUsIGNyZWF0ZUhhc2goJ3NoYTI1NicpKSxcbiAgICAgIE1QQy5zaWduKE1FU1NBR0UsIHNpZ25Db21iaW5lVHdvLm9TaGFyZSwgc2lnbkNvbWJpbmVPbmUuZFNoYXJlLCBjcmVhdGVIYXNoKCdzaGEyNTYnKSksXG4gICAgXTtcblxuICAgIHJldHVybiBNUEMuY29uc3RydWN0U2lnbmF0dXJlKFtzaWduQSwgc2lnbkJdKTtcbiAgfVxufVxuIl19