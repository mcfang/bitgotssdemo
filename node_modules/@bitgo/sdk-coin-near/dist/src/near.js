"use strict";
/**
 * @prettier
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Near = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const _ = __importStar(require("lodash"));
const base58 = __importStar(require("bs58"));
const statics_1 = require("@bitgo/statics");
const sdk_core_1 = require("@bitgo/sdk-core");
const nearAPI = __importStar(require("near-api-js"));
const request = __importStar(require("superagent"));
const lib_1 = require("./lib");
const utils_1 = __importDefault(require("./lib/utils"));
class Near extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        this.network = this.bitgo.getEnv() === 'prod' ? 'main' : 'test';
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Near(bitgo, staticsCoin);
    }
    allowsAccountConsolidations() {
        return true;
    }
    /**
     * Flag indicating if this coin supports TSS wallets.
     * @returns {boolean} True if TSS Wallets can be created for this coin
     */
    supportsTss() {
        return true;
    }
    getMPCAlgorithm() {
        return 'eddsa';
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getBaseChain() {
        return this.getChain();
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return false;
    }
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? new lib_1.KeyPair({ seed }) : new lib_1.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        return utils_1.default.isValidPublicKey(pub);
    }
    /**
     * Return boolean indicating whether the supplied private key is a valid near private key
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv) {
        return utils_1.default.isValidPrivateKey(prv);
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address) {
        return utils_1.default.isValidAddress(address);
    }
    /** @inheritDoc */
    async signMessage(key, message) {
        const nearKeypair = new lib_1.KeyPair({ prv: key.prv });
        if (Buffer.isBuffer(message)) {
            message = base58.encode(message);
        }
        return Buffer.from(nearKeypair.signMessage(message));
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const factory = this.getBuilder();
        let rebuiltTransaction;
        const txRaw = params.txPrebuild.txHex;
        try {
            const transactionBuilder = factory.from(txRaw);
            rebuiltTransaction = await transactionBuilder.build();
        }
        catch {
            throw new Error('Invalid transaction');
        }
        return rebuiltTransaction.explainTransaction();
    }
    verifySignTransactionParams(params) {
        const prv = params.prv;
        const txHex = params.txPrebuild.txHex;
        if (_.isUndefined(txHex)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isString(txHex)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txHex}`);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        if (!_.has(params.txPrebuild, 'key')) {
            throw new Error('missing public key parameter to sign transaction');
        }
        // if we are receiving addresses do not try to convert them
        const signer = !utils_1.default.isValidAddress(params.txPrebuild.key)
            ? new lib_1.KeyPair({ pub: params.txPrebuild.key }).getAddress()
            : params.txPrebuild.key;
        return { txHex, prv, signer };
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @param callback
     * @returns {Bluebird<SignedTransaction>}
     */
    async signTransaction(params) {
        const factory = this.getBuilder();
        const txBuilder = factory.from(params.txPrebuild.txHex);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid transaction');
        }
        const serializedTx = transaction.toBroadcastFormat();
        return {
            txHex: serializedTx,
        };
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     */
    async recover(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        let startIdx = params.startingScanIndex;
        if (startIdx === undefined) {
            startIdx = 0;
        }
        else if (!Number.isInteger(startIdx) || startIdx < 0) {
            throw new Error('Invalid starting index to scan for addresses');
        }
        let numIteration = params.scan;
        if (numIteration === undefined) {
            numIteration = 20;
        }
        else if (!Number.isInteger(numIteration) || numIteration <= 0) {
            throw new Error('Invalid scanning factor');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        const { storageAmountPerByte, transferCost, receiptConfig } = await this.getProtocolConfig();
        for (let i = startIdx; i < numIteration + startIdx; i++) {
            const currPath = `m/${i}`;
            const accountId = MPC.deriveUnhardened(bitgoKey, currPath).slice(0, 64);
            let availableBalance = new bignumber_js_1.default(0);
            try {
                availableBalance = new bignumber_js_1.default(await this.getAccountBalance(accountId, storageAmountPerByte));
            }
            catch (e) {
                // UNKNOWN_ACCOUNT error indicates that the address has not partake in any transaction so far, so we will
                // treat it as a zero balance address
                if (e.message !== 'UNKNOWN_ACCOUNT') {
                    throw e;
                }
            }
            if (availableBalance.toNumber() <= 0) {
                continue;
            }
            // first build the unsigned txn
            const bs58EncodedPublicKey = nearAPI.utils.serialize.base_encode(new Uint8Array(Buffer.from(accountId, 'hex')));
            const { nonce, blockHash } = await this.getAccessKey({ accountId, bs58EncodedPublicKey });
            const gasPrice = await this.getGasPrice(blockHash);
            const gasPriceFirstBlock = new bignumber_js_1.default(gasPrice);
            const gasPriceSecondBlock = gasPriceFirstBlock.multipliedBy(1.05);
            const totalGasRequired = new bignumber_js_1.default(transferCost.sendSir)
                .plus(receiptConfig.sendSir)
                .multipliedBy(gasPriceFirstBlock)
                .plus(new bignumber_js_1.default(transferCost.execution).plus(receiptConfig.execution).multipliedBy(gasPriceSecondBlock));
            // adding some padding to make sure the gas doesn't go below required gas by network
            const totalGasWithPadding = totalGasRequired.multipliedBy(1.5);
            const feeReserve = bignumber_js_1.default(statics_1.Networks[this.network].near.feeReserve);
            const storageReserve = bignumber_js_1.default(statics_1.Networks[this.network].near.storageReserve);
            const netAmount = availableBalance.minus(totalGasWithPadding).minus(feeReserve).minus(storageReserve);
            if (netAmount.toNumber() <= 0) {
                throw new Error(`Found address ${i} with non-zero fund but fund is insufficient to support a recover ` +
                    `transaction. Please start the next scan at address index ${i + 1}.`);
            }
            const factory = new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
            const txBuilder = factory
                .getTransferBuilder()
                .sender(accountId, accountId)
                .nonce(nonce)
                .receiverId(params.recoveryDestination)
                .recentBlockHash(blockHash)
                .amount(netAmount.toFixed());
            if (!isUnsignedSweep) {
                const unsignedTransaction = (await txBuilder.build());
                // Sign the txn
                /* ***************** START **************************************/
                // TODO(BG-51092): This looks like a common part which can be extracted out too
                if (!params.userKey) {
                    throw new Error('missing userKey');
                }
                if (!params.backupKey) {
                    throw new Error('missing backupKey');
                }
                if (!params.walletPassphrase) {
                    throw new Error('missing wallet passphrase');
                }
                // Clean up whitespace from entered values
                const userKey = params.userKey.replace(/\s/g, '');
                const backupKey = params.backupKey.replace(/\s/g, '');
                // Decrypt private keys from KeyCard values
                let userPrv;
                try {
                    userPrv = this.bitgo.decrypt({
                        input: userKey,
                        password: params.walletPassphrase,
                    });
                }
                catch (e) {
                    throw new Error(`Error decrypting user keychain: ${e.message}`);
                }
                /** TODO BG-52419 Implement Codec for parsing */
                const userSigningMaterial = JSON.parse(userPrv);
                let backupPrv;
                try {
                    backupPrv = this.bitgo.decrypt({
                        input: backupKey,
                        password: params.walletPassphrase,
                    });
                }
                catch (e) {
                    throw new Error(`Error decrypting backup keychain: ${e.message}`);
                }
                const backupSigningMaterial = JSON.parse(backupPrv);
                /* ********************** END ***********************************/
                // add signature
                const signatureHex = await sdk_core_1.EDDSAMethods.getTSSSignature(userSigningMaterial, backupSigningMaterial, currPath, unsignedTransaction);
                const publicKeyObj = { pub: accountId };
                txBuilder.addSignature(publicKeyObj, signatureHex);
            }
            const completedTransaction = await txBuilder.build();
            const serializedTx = completedTransaction.toBroadcastFormat();
            return { serializedTx: serializedTx, scanIndex: i };
        }
        throw new Error('Did not find an address with funds to recover');
    }
    /**
     * Make a request to one of the public EOS nodes available
     * @param params.payload
     */
    async getDataFromNode(params) {
        const nodeUrls = this.getPublicNodeUrls();
        for (const nodeUrl of nodeUrls) {
            try {
                return await request.post(nodeUrl).send(params.payload);
            }
            catch (e) {
                console.debug(e);
            }
        }
        throw new Error(`Unable to call endpoint: '/' from nodes: ${_.join(nodeUrls, ', ')}`);
    }
    async getAccessKey({ accountId, bs58EncodedPublicKey, }) {
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: 'dontcare',
                method: 'query',
                params: {
                    request_type: 'view_access_key',
                    finality: 'final',
                    account_id: accountId,
                    public_key: bs58EncodedPublicKey,
                },
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        const accessKey = response.body.result;
        return { nonce: accessKey.nonce + 1, blockHash: accessKey.block_hash };
    }
    async getAccountBalance(accountId, storageAmountPerByte) {
        var _a;
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: 'dontcare',
                method: 'query',
                params: {
                    request_type: 'view_account',
                    finality: 'final',
                    account_id: accountId,
                },
            },
        });
        if (response.status !== 200) {
            throw new Error('Failed to query account information');
        }
        const errorCause = (_a = response.body.error) === null || _a === void 0 ? void 0 : _a.cause.name;
        if (errorCause !== undefined) {
            throw new Error(errorCause);
        }
        const account = response.body.result;
        const costPerByte = new bignumber_js_1.default(storageAmountPerByte);
        const stateStaked = new bignumber_js_1.default(account.storage_usage).multipliedBy(costPerByte);
        const staked = new bignumber_js_1.default(account.locked);
        const totalBalance = new bignumber_js_1.default(account.amount).plus(staked);
        const availableBalance = totalBalance.minus(bignumber_js_1.default.max(staked, stateStaked));
        return availableBalance.toString();
    }
    async getProtocolConfig() {
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: 'dontcare',
                method: 'EXPERIMENTAL_protocol_config',
                params: {
                    finality: 'final',
                },
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        const config = response.body.result;
        const storageAmountPerByte = config.runtime_config.storage_amount_per_byte;
        const transferCostFromNetwork = config.runtime_config.transaction_costs.action_creation_config.transfer_cost;
        const transferCost = {
            sendSir: transferCostFromNetwork.send_sir,
            sendNotSir: transferCostFromNetwork.send_not_sir,
            execution: transferCostFromNetwork.execution,
        };
        const receiptConfigFromNetwork = config.runtime_config.transaction_costs.action_receipt_creation_config;
        const receiptConfig = {
            sendSir: receiptConfigFromNetwork.send_sir,
            sendNotSir: receiptConfigFromNetwork.send_not_sir,
            execution: receiptConfigFromNetwork.execution,
        };
        return { storageAmountPerByte, transferCost, receiptConfig };
    }
    async getGasPrice(blockHash) {
        const response = await this.getDataFromNode({
            payload: {
                jsonrpc: '2.0',
                id: 'dontcare',
                method: 'gas_price',
                params: [blockHash],
            },
        });
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.result.gas_price;
    }
    getPublicNodeUrls() {
        return sdk_core_1.Environments[this.bitgo.getEnv()].nearNodeUrls;
    }
    async parseTransaction(params) {
        const transactionExplanation = await this.explainTransaction({
            txPrebuild: params.txPrebuild,
            publicKey: params.publicKey,
            feeInfo: params.feeInfo,
        });
        if (!transactionExplanation) {
            throw new Error('Invalid transaction');
        }
        const nearTransaction = transactionExplanation;
        if (nearTransaction.outputs.length <= 0) {
            return {
                inputs: [],
                outputs: [],
            };
        }
        const senderAddress = nearTransaction.outputs[0].address;
        const feeAmount = new bignumber_js_1.default(nearTransaction.fee.fee === '' ? '0' : nearTransaction.fee.fee);
        // assume 1 sender, who is also the fee payer
        const inputs = [
            {
                address: senderAddress,
                amount: new bignumber_js_1.default(nearTransaction.outputAmount).plus(feeAmount).toFixed(),
            },
        ];
        const outputs = nearTransaction.outputs.map((output) => {
            return {
                address: output.address,
                amount: new bignumber_js_1.default(output.amount).toFixed(),
            };
        });
        return {
            inputs,
            outputs,
        };
    }
    async isWalletAddress(params) {
        throw new sdk_core_1.MethodNotImplementedError();
    }
    async verifyTransaction(params) {
        var _a;
        let totalAmount = new bignumber_js_1.default(0);
        const coinConfig = statics_1.coins.get(this.getChain());
        const { txPrebuild: txPrebuild, txParams: txParams } = params;
        const transaction = new lib_1.Transaction(coinConfig);
        const rawTx = txPrebuild.txHex;
        if (!rawTx) {
            throw new Error('missing required tx prebuild property txHex');
        }
        transaction.fromRawTransaction(rawTx);
        const explainedTx = transaction.explainTransaction();
        // users do not input recipients for consolidation requests as they are generated by the server
        if (txParams.recipients !== undefined) {
            const filteredRecipients = (_a = txParams.recipients) === null || _a === void 0 ? void 0 : _a.map((recipient) => _.pick(recipient, ['address', 'amount']));
            const filteredOutputs = explainedTx.outputs.map((output) => _.pick(output, ['address', 'amount']));
            if (!_.isEqual(filteredOutputs, filteredRecipients)) {
                throw new Error('Tx outputs does not match with expected txParams recipients');
            }
            for (const recipients of txParams.recipients) {
                totalAmount = totalAmount.plus(recipients.amount);
            }
            if (!totalAmount.isEqualTo(explainedTx.outputAmount)) {
                throw new Error('Tx total amount does not match with expected total amount field');
            }
        }
        return true;
    }
    getBuilder() {
        return new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getBaseChain()));
    }
}
exports.Near = Near;
Near.initialized = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmVhci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9uZWFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVILGdFQUFxQztBQUNyQywwQ0FBNEI7QUFDNUIsNkNBQStCO0FBQy9CLDRDQUEwRjtBQUUxRiw4Q0FtQnlCO0FBQ3pCLHFEQUF1QztBQUN2QyxvREFBc0M7QUFFdEMsK0JBQXVGO0FBQ3ZGLHdEQUFvQztBQXNGcEMsTUFBYSxJQUFLLFNBQVEsbUJBQVE7SUFHaEMsWUFBWSxLQUFnQixFQUFFLFdBQXVDO1FBQ25FLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztRQVVMLFlBQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFUbkUsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0lBTUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFnQixFQUFFLFdBQXVDO1FBQzdFLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCwyQkFBMkI7UUFDekIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsV0FBVztRQUNULE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELGVBQWU7UUFDYixPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRUQsUUFBUTtRQUNOLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUM7SUFDaEMsQ0FBQztJQUVELFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQyxRQUFRLEVB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QUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7O0FBN2hCSCxvQkE4aEJDO0FBbGhCa0IsZ0JBQVcsR0FBRyxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwcmV0dGllclxuICovXG5cbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGJhc2U1OCBmcm9tICdiczU4JztcbmltcG9ydCB7IE5ldHdvcmtzLCBCYXNlQ29pbiBhcyBTdGF0aWNzQmFzZUNvaW4sIENvaW5GYW1pbHksIGNvaW5zIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQml0R29CYXNlLFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIEtleVBhaXIsXG4gIE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBFZGRzYSxcbiAgUHVibGljS2V5LFxuICBFbnZpcm9ubWVudHMsXG4gIE1QQ0FsZ29yaXRobSxcbiAgRUREU0FNZXRob2RzLFxuICBFRERTQU1ldGhvZFR5cGVzLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0ICogYXMgbmVhckFQSSBmcm9tICduZWFyLWFwaS1qcyc7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuXG5pbXBvcnQgeyBLZXlQYWlyIGFzIE5lYXJLZXlQYWlyLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSB9IGZyb20gJy4vbGliJztcbmltcG9ydCBuZWFyVXRpbHMgZnJvbSAnLi9saWIvdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uUHJlYnVpbGQge1xuICB0eEhleDogc3RyaW5nO1xuICBrZXk6IHN0cmluZztcbiAgYmxvY2tIYXNoOiBzdHJpbmc7XG4gIG5vbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHB1YmxpY0tleTogc3RyaW5nO1xuICBmZWVJbmZvOiB7XG4gICAgZmVlOiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZpZWRUcmFuc2FjdGlvblBhcmFtZXRlcnMge1xuICB0eEhleDogc3RyaW5nO1xuICBwcnY6IHN0cmluZztcbiAgc2lnbmVyOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmVhclBhcnNlVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVBhcnNlVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHVibGljS2V5OiBzdHJpbmc7XG4gIGZlZUluZm86IHtcbiAgICBmZWU6IHN0cmluZztcbiAgfTtcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3V0cHV0IHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBhbW91bnQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlY292ZXJ5T3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZzsgLy8gQm94IEFcbiAgYmFja3VwS2V5OiBzdHJpbmc7IC8vIEJveCBCXG4gIGJpdGdvS2V5OiBzdHJpbmc7IC8vIEJveCBDXG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZztcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U6IHN0cmluZztcbiAgc3RhcnRpbmdTY2FuSW5kZXg/OiBudW1iZXI7XG4gIHNjYW4/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBOZWFyVHgge1xuICBzZXJpYWxpemVkVHg6IHN0cmluZztcbiAgc2NhbkluZGV4OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBOZWFyVHhCdWlsZGVyUGFyYW1zRnJvbU5vZGUge1xuICBub25jZTogbnVtYmVyO1xuICBibG9ja0hhc2g6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE5lYXJGZWVDb25maWcge1xuICBzZW5kU2lyOiBudW1iZXI7XG4gIHNlbmROb3RTaXI6IG51bWJlcjtcbiAgZXhlY3V0aW9uOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBQcm90b2NvbENvbmZpZ091dHB1dCB7XG4gIHN0b3JhZ2VBbW91bnRQZXJCeXRlOiBudW1iZXI7XG4gIHRyYW5zZmVyQ29zdDogTmVhckZlZUNvbmZpZztcbiAgcmVjZWlwdENvbmZpZzogTmVhckZlZUNvbmZpZztcbn1cblxudHlwZSBUcmFuc2FjdGlvbklucHV0ID0gVHJhbnNhY3Rpb25PdXRwdXQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmVhclBhcnNlZFRyYW5zYWN0aW9uIGV4dGVuZHMgUGFyc2VkVHJhbnNhY3Rpb24ge1xuICAvLyB0b3RhbCBhc3NldHMgYmVpbmcgbW92ZWQsIGluY2x1ZGluZyBmZWVzXG4gIGlucHV0czogVHJhbnNhY3Rpb25JbnB1dFtdO1xuXG4gIC8vIHdoZXJlIGFzc2V0cyBhcmUgbW92ZWQgdG9cbiAgb3V0cHV0czogVHJhbnNhY3Rpb25PdXRwdXRbXTtcbn1cblxuZXhwb3J0IHR5cGUgTmVhclRyYW5zYWN0aW9uRXhwbGFuYXRpb24gPSBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uO1xuXG5leHBvcnQgY2xhc3MgTmVhciBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIGluaXRpYWxpemVkID0gZmFsc2U7XG4gIHByb3RlY3RlZCBzdGF0aWMgTVBDOiBFZGRzYTtcbiAgcHJvdGVjdGVkIG5ldHdvcmsgPSB0aGlzLmJpdGdvLmdldEVudigpID09PSAncHJvZCcgPyAnbWFpbicgOiAndGVzdCc7XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IE5lYXIoYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIGFsbG93c0FjY291bnRDb25zb2xpZGF0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBjb2luIHN1cHBvcnRzIFRTUyB3YWxsZXRzLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBUU1MgV2FsbGV0cyBjYW4gYmUgY3JlYXRlZCBmb3IgdGhpcyBjb2luXG4gICAqL1xuICBzdXBwb3J0c1RzcygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldE1QQ0FsZ29yaXRobSgpOiBNUENBbGdvcml0aG0ge1xuICAgIHJldHVybiAnZWRkc2EnO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuXG4gIGdldEJhc2VDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldENoYWluKCk7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZ1bGxOYW1lO1xuICB9XG5cbiAgZ2V0QmFzZUZhY3RvcigpOiBhbnkge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhdGljc0NvaW4uZGVjaW1hbFBsYWNlcyk7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZWQyNTUxOSBrZXkgcGFpclxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViLCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlZWQgPyBuZXcgTmVhcktleVBhaXIoeyBzZWVkIH0pIDogbmV3IE5lYXJLZXlQYWlyKCk7XG4gICAgY29uc3Qga2V5cyA9IGtleVBhaXIuZ2V0S2V5cygpO1xuICAgIGlmICgha2V5cy5wcnYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcnYgaW4ga2V5IGdlbmVyYXRpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwdWI6IGtleXMucHViLFxuICAgICAgcHJ2OiBrZXlzLnBydixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwdWJsaWMga2V5IGZvciB0aGUgY29pbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHB1YiB0aGUgcHViIHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuZWFyVXRpbHMuaXNWYWxpZFB1YmxpY0tleShwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3VwcGxpZWQgcHJpdmF0ZSBrZXkgaXMgYSB2YWxpZCBuZWFyIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcnYgdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQcnYocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbmVhclV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KHBydik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbmVhclV0aWxzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBjb25zdCBuZWFyS2V5cGFpciA9IG5ldyBOZWFyS2V5UGFpcih7IHBydjoga2V5LnBydiB9KTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICBtZXNzYWdlID0gYmFzZTU4LmVuY29kZShtZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQnVmZmVyLmZyb20obmVhcktleXBhaXIuc2lnbk1lc3NhZ2UobWVzc2FnZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4vcGFyc2UgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8TmVhclRyYW5zYWN0aW9uRXhwbGFuYXRpb24+IHtcbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5nZXRCdWlsZGVyKCk7XG4gICAgbGV0IHJlYnVpbHRUcmFuc2FjdGlvbjogQmFzZVRyYW5zYWN0aW9uO1xuICAgIGNvbnN0IHR4UmF3ID0gcGFyYW1zLnR4UHJlYnVpbGQudHhIZXg7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25CdWlsZGVyID0gZmFjdG9yeS5mcm9tKHR4UmF3KTtcbiAgICAgIHJlYnVpbHRUcmFuc2FjdGlvbiA9IGF3YWl0IHRyYW5zYWN0aW9uQnVpbGRlci5idWlsZCgpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlYnVpbHRUcmFuc2FjdGlvbi5leHBsYWluVHJhbnNhY3Rpb24oKTtcbiAgfVxuXG4gIHZlcmlmeVNpZ25UcmFuc2FjdGlvblBhcmFtcyhwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBWZXJpZmllZFRyYW5zYWN0aW9uUGFyYW1ldGVycyB7XG4gICAgY29uc3QgcHJ2ID0gcGFyYW1zLnBydjtcblxuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4UHJlYnVpbGQudHhIZXg7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh0eEhleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0eFByZWJ1aWxkIHBhcmFtZXRlcicpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyh0eEhleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IHR5cGUgJHt0eXBlb2YgdHhIZXh9YCk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHBydiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghXy5pc1N0cmluZyhwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBydiBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgdHlwZSAke3R5cGVvZiBwcnZ9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmhhcyhwYXJhbXMudHhQcmVidWlsZCwgJ2tleScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHVibGljIGtleSBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGFyZSByZWNlaXZpbmcgYWRkcmVzc2VzIGRvIG5vdCB0cnkgdG8gY29udmVydCB0aGVtXG4gICAgY29uc3Qgc2lnbmVyID0gIW5lYXJVdGlscy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMudHhQcmVidWlsZC5rZXkpXG4gICAgICA/IG5ldyBOZWFyS2V5UGFpcih7IHB1YjogcGFyYW1zLnR4UHJlYnVpbGQua2V5IH0pLmdldEFkZHJlc3MoKVxuICAgICAgOiBwYXJhbXMudHhQcmVidWlsZC5rZXk7XG4gICAgcmV0dXJuIHsgdHhIZXgsIHBydiwgc2lnbmVyIH07XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB7VHJhbnNhY3Rpb25QcmVidWlsZH0gcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHVzZXIgcHJ2XG4gICAqIEBwYXJhbSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7Qmx1ZWJpcmQ8U2lnbmVkVHJhbnNhY3Rpb24+fVxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5nZXRCdWlsZGVyKCk7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5mcm9tKHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4KTtcbiAgICB0eEJ1aWxkZXIuc2lnbih7IGtleTogcGFyYW1zLnBydiB9KTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbjogQmFzZVRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJpYWxpemVkVHggPSAodHJhbnNhY3Rpb24gYXMgQmFzZVRyYW5zYWN0aW9uKS50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR4SGV4OiBzZXJpYWxpemVkVHgsXG4gICAgfSBhcyBhbnk7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxOZWFyVHg+IHtcbiAgICBpZiAoIXBhcmFtcy5iaXRnb0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJpdGdvS2V5Jyk7XG4gICAgfVxuICAgIGlmICghcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24gfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3MocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVjb3ZlcnlEZXN0aW5hdGlvbicpO1xuICAgIH1cbiAgICBsZXQgc3RhcnRJZHggPSBwYXJhbXMuc3RhcnRpbmdTY2FuSW5kZXg7XG4gICAgaWYgKHN0YXJ0SWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YXJ0SWR4ID0gMDtcbiAgICB9IGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHN0YXJ0SWR4KSB8fCBzdGFydElkeCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGFydGluZyBpbmRleCB0byBzY2FuIGZvciBhZGRyZXNzZXMnKTtcbiAgICB9XG4gICAgbGV0IG51bUl0ZXJhdGlvbiA9IHBhcmFtcy5zY2FuO1xuICAgIGlmIChudW1JdGVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbnVtSXRlcmF0aW9uID0gMjA7XG4gICAgfSBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW1JdGVyYXRpb24pIHx8IG51bUl0ZXJhdGlvbiA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2Nhbm5pbmcgZmFjdG9yJyk7XG4gICAgfVxuICAgIGNvbnN0IGJpdGdvS2V5ID0gcGFyYW1zLmJpdGdvS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gIXBhcmFtcy51c2VyS2V5ICYmICFwYXJhbXMuYmFja3VwS2V5ICYmICFwYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcbiAgICBjb25zdCBNUEMgPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0SW5pdGlhbGl6ZWRNcGNJbnN0YW5jZSgpO1xuICAgIGNvbnN0IHsgc3RvcmFnZUFtb3VudFBlckJ5dGUsIHRyYW5zZmVyQ29zdCwgcmVjZWlwdENvbmZpZyB9ID0gYXdhaXQgdGhpcy5nZXRQcm90b2NvbENvbmZpZygpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SWR4OyBpIDwgbnVtSXRlcmF0aW9uICsgc3RhcnRJZHg7IGkrKykge1xuICAgICAgY29uc3QgY3VyclBhdGggPSBgbS8ke2l9YDtcbiAgICAgIGNvbnN0IGFjY291bnRJZCA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGJpdGdvS2V5LCBjdXJyUGF0aCkuc2xpY2UoMCwgNjQpO1xuICAgICAgbGV0IGF2YWlsYWJsZUJhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKDApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXZhaWxhYmxlQmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoYXdhaXQgdGhpcy5nZXRBY2NvdW50QmFsYW5jZShhY2NvdW50SWQsIHN0b3JhZ2VBbW91bnRQZXJCeXRlKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFVOS05PV05fQUNDT1VOVCBlcnJvciBpbmRpY2F0ZXMgdGhhdCB0aGUgYWRkcmVzcyBoYXMgbm90IHBhcnRha2UgaW4gYW55IHRyYW5zYWN0aW9uIHNvIGZhciwgc28gd2Ugd2lsbFxuICAgICAgICAvLyB0cmVhdCBpdCBhcyBhIHplcm8gYmFsYW5jZSBhZGRyZXNzXG4gICAgICAgIGlmIChlLm1lc3NhZ2UgIT09ICdVTktOT1dOX0FDQ09VTlQnKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGF2YWlsYWJsZUJhbGFuY2UudG9OdW1iZXIoKSA8PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBmaXJzdCBidWlsZCB0aGUgdW5zaWduZWQgdHhuXG4gICAgICBjb25zdCBiczU4RW5jb2RlZFB1YmxpY0tleSA9IG5lYXJBUEkudXRpbHMuc2VyaWFsaXplLmJhc2VfZW5jb2RlKG5ldyBVaW50OEFycmF5KEJ1ZmZlci5mcm9tKGFjY291bnRJZCwgJ2hleCcpKSk7XG4gICAgICBjb25zdCB7IG5vbmNlLCBibG9ja0hhc2ggfSA9IGF3YWl0IHRoaXMuZ2V0QWNjZXNzS2V5KHsgYWNjb3VudElkLCBiczU4RW5jb2RlZFB1YmxpY0tleSB9KTtcbiAgICAgIGNvbnN0IGdhc1ByaWNlID0gYXdhaXQgdGhpcy5nZXRHYXNQcmljZShibG9ja0hhc2gpO1xuICAgICAgY29uc3QgZ2FzUHJpY2VGaXJzdEJsb2NrID0gbmV3IEJpZ051bWJlcihnYXNQcmljZSk7XG4gICAgICBjb25zdCBnYXNQcmljZVNlY29uZEJsb2NrID0gZ2FzUHJpY2VGaXJzdEJsb2NrLm11bHRpcGxpZWRCeSgxLjA1KTtcbiAgICAgIGNvbnN0IHRvdGFsR2FzUmVxdWlyZWQgPSBuZXcgQmlnTnVtYmVyKHRyYW5zZmVyQ29zdC5zZW5kU2lyKVxuICAgICAgICAucGx1cyhyZWNlaXB0Q29uZmlnLnNlbmRTaXIpXG4gICAgICAgIC5tdWx0aXBsaWVkQnkoZ2FzUHJpY2VGaXJzdEJsb2NrKVxuICAgICAgICAucGx1cyhuZXcgQmlnTnVtYmVyKHRyYW5zZmVyQ29zdC5leGVjdXRpb24pLnBsdXMocmVjZWlwdENvbmZpZy5leGVjdXRpb24pLm11bHRpcGxpZWRCeShnYXNQcmljZVNlY29uZEJsb2NrKSk7XG4gICAgICAvLyBhZGRpbmcgc29tZSBwYWRkaW5nIHRvIG1ha2Ugc3VyZSB0aGUgZ2FzIGRvZXNuJ3QgZ28gYmVsb3cgcmVxdWlyZWQgZ2FzIGJ5IG5ldHdvcmtcbiAgICAgIGNvbnN0IHRvdGFsR2FzV2l0aFBhZGRpbmcgPSB0b3RhbEdhc1JlcXVpcmVkLm11bHRpcGxpZWRCeSgxLjUpO1xuICAgICAgY29uc3QgZmVlUmVzZXJ2ZSA9IEJpZ051bWJlcihOZXR3b3Jrc1t0aGlzLm5ldHdvcmtdLm5lYXIuZmVlUmVzZXJ2ZSk7XG4gICAgICBjb25zdCBzdG9yYWdlUmVzZXJ2ZSA9IEJpZ051bWJlcihOZXR3b3Jrc1t0aGlzLm5ldHdvcmtdLm5lYXIuc3RvcmFnZVJlc2VydmUpO1xuICAgICAgY29uc3QgbmV0QW1vdW50ID0gYXZhaWxhYmxlQmFsYW5jZS5taW51cyh0b3RhbEdhc1dpdGhQYWRkaW5nKS5taW51cyhmZWVSZXNlcnZlKS5taW51cyhzdG9yYWdlUmVzZXJ2ZSk7XG4gICAgICBpZiAobmV0QW1vdW50LnRvTnVtYmVyKCkgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZvdW5kIGFkZHJlc3MgJHtpfSB3aXRoIG5vbi16ZXJvIGZ1bmQgYnV0IGZ1bmQgaXMgaW5zdWZmaWNpZW50IHRvIHN1cHBvcnQgYSByZWNvdmVyIGAgK1xuICAgICAgICAgICAgYHRyYW5zYWN0aW9uLiBQbGVhc2Ugc3RhcnQgdGhlIG5leHQgc2NhbiBhdCBhZGRyZXNzIGluZGV4ICR7aSArIDF9LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZhY3RvcnkgPSBuZXcgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRDaGFpbigpKSk7XG4gICAgICBjb25zdCB0eEJ1aWxkZXIgPSBmYWN0b3J5XG4gICAgICAgIC5nZXRUcmFuc2ZlckJ1aWxkZXIoKVxuICAgICAgICAuc2VuZGVyKGFjY291bnRJZCwgYWNjb3VudElkKVxuICAgICAgICAubm9uY2Uobm9uY2UpXG4gICAgICAgIC5yZWNlaXZlcklkKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKVxuICAgICAgICAucmVjZW50QmxvY2tIYXNoKGJsb2NrSGFzaClcbiAgICAgICAgLmFtb3VudChuZXRBbW91bnQudG9GaXhlZCgpKTtcblxuICAgICAgaWYgKCFpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgICAgY29uc3QgdW5zaWduZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKSkgYXMgVHJhbnNhY3Rpb247XG4gICAgICAgIC8vIFNpZ24gdGhlIHR4blxuICAgICAgICAvKiAqKioqKioqKioqKioqKioqKiBTVEFSVCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgLy8gVE9ETyhCRy01MTA5Mik6IFRoaXMgbG9va3MgbGlrZSBhIGNvbW1vbiBwYXJ0IHdoaWNoIGNhbiBiZSBleHRyYWN0ZWQgb3V0IHRvb1xuICAgICAgICBpZiAoIXBhcmFtcy51c2VyS2V5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXJLZXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcy5iYWNrdXBLZXkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmFja3VwS2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbXMud2FsbGV0UGFzc3BocmFzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB3YWxsZXQgcGFzc3BocmFzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgd2hpdGVzcGFjZSBmcm9tIGVudGVyZWQgdmFsdWVzXG4gICAgICAgIGNvbnN0IHVzZXJLZXkgPSBwYXJhbXMudXNlcktleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgICAgICBjb25zdCBiYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgICAgICAgLy8gRGVjcnlwdCBwcml2YXRlIGtleXMgZnJvbSBLZXlDYXJkIHZhbHVlc1xuICAgICAgICBsZXQgdXNlclBydjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICAgIGlucHV0OiB1c2VyS2V5LFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNyeXB0aW5nIHVzZXIga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUT0RPIEJHLTUyNDE5IEltcGxlbWVudCBDb2RlYyBmb3IgcGFyc2luZyAqL1xuICAgICAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZSh1c2VyUHJ2KSBhcyBFRERTQU1ldGhvZFR5cGVzLlVzZXJTaWduaW5nTWF0ZXJpYWw7XG5cbiAgICAgICAgbGV0IGJhY2t1cFBydjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiYWNrdXBQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgICAgaW5wdXQ6IGJhY2t1cEtleSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyBiYWNrdXAga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhY2t1cFNpZ25pbmdNYXRlcmlhbCA9IEpTT04ucGFyc2UoYmFja3VwUHJ2KSBhcyBFRERTQU1ldGhvZFR5cGVzLkJhY2t1cFNpZ25pbmdNYXRlcmlhbDtcbiAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKiBFTkQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLy8gYWRkIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCBzaWduYXR1cmVIZXggPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0VFNTU2lnbmF0dXJlKFxuICAgICAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwsXG4gICAgICAgICAgYmFja3VwU2lnbmluZ01hdGVyaWFsLFxuICAgICAgICAgIGN1cnJQYXRoLFxuICAgICAgICAgIHVuc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5T2JqID0geyBwdWI6IGFjY291bnRJZCB9O1xuICAgICAgICB0eEJ1aWxkZXIuYWRkU2lnbmF0dXJlKHB1YmxpY0tleU9iaiBhcyBQdWJsaWNLZXksIHNpZ25hdHVyZUhleCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlZFRyYW5zYWN0aW9uID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgICBjb25zdCBzZXJpYWxpemVkVHggPSBjb21wbGV0ZWRUcmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHsgc2VyaWFsaXplZFR4OiBzZXJpYWxpemVkVHgsIHNjYW5JbmRleDogaSB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBhbiBhZGRyZXNzIHdpdGggZnVuZHMgdG8gcmVjb3ZlcicpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSByZXF1ZXN0IHRvIG9uZSBvZiB0aGUgcHVibGljIEVPUyBub2RlcyBhdmFpbGFibGVcbiAgICogQHBhcmFtIHBhcmFtcy5wYXlsb2FkXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0RGF0YUZyb21Ob2RlKHBhcmFtczogeyBwYXlsb2FkPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfSk6IFByb21pc2U8cmVxdWVzdC5SZXNwb25zZT4ge1xuICAgIGNvbnN0IG5vZGVVcmxzID0gdGhpcy5nZXRQdWJsaWNOb2RlVXJscygpO1xuICAgIGZvciAoY29uc3Qgbm9kZVVybCBvZiBub2RlVXJscykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QucG9zdChub2RlVXJsKS5zZW5kKHBhcmFtcy5wYXlsb2FkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY2FsbCBlbmRwb2ludDogJy8nIGZyb20gbm9kZXM6ICR7Xy5qb2luKG5vZGVVcmxzLCAnLCAnKX1gKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRBY2Nlc3NLZXkoe1xuICAgIGFjY291bnRJZCxcbiAgICBiczU4RW5jb2RlZFB1YmxpY0tleSxcbiAgfToge1xuICAgIGFjY291bnRJZDogc3RyaW5nO1xuICAgIGJzNThFbmNvZGVkUHVibGljS2V5OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPE5lYXJUeEJ1aWxkZXJQYXJhbXNGcm9tTm9kZT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXREYXRhRnJvbU5vZGUoe1xuICAgICAgcGF5bG9hZDoge1xuICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgaWQ6ICdkb250Y2FyZScsXG4gICAgICAgIG1ldGhvZDogJ3F1ZXJ5JyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19hY2Nlc3Nfa2V5JyxcbiAgICAgICAgICBmaW5hbGl0eTogJ2ZpbmFsJyxcbiAgICAgICAgICBhY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgICAgICAgcHVibGljX2tleTogYnM1OEVuY29kZWRQdWJsaWNLZXksXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBhY2Nlc3NLZXkgPSByZXNwb25zZS5ib2R5LnJlc3VsdDtcbiAgICByZXR1cm4geyBub25jZTogYWNjZXNzS2V5Lm5vbmNlICsgMSwgYmxvY2tIYXNoOiBhY2Nlc3NLZXkuYmxvY2tfaGFzaCB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEFjY291bnRCYWxhbmNlKGFjY291bnRJZDogc3RyaW5nLCBzdG9yYWdlQW1vdW50UGVyQnl0ZTogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0RGF0YUZyb21Ob2RlKHtcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIGlkOiAnZG9udGNhcmUnLFxuICAgICAgICBtZXRob2Q6ICdxdWVyeScsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHJlcXVlc3RfdHlwZTogJ3ZpZXdfYWNjb3VudCcsXG4gICAgICAgICAgZmluYWxpdHk6ICdmaW5hbCcsXG4gICAgICAgICAgYWNjb3VudF9pZDogYWNjb3VudElkLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHF1ZXJ5IGFjY291bnQgaW5mb3JtYXRpb24nKTtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JDYXVzZSA9IHJlc3BvbnNlLmJvZHkuZXJyb3I/LmNhdXNlLm5hbWU7XG4gICAgaWYgKGVycm9yQ2F1c2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yQ2F1c2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY291bnQgPSByZXNwb25zZS5ib2R5LnJlc3VsdDtcbiAgICBjb25zdCBjb3N0UGVyQnl0ZSA9IG5ldyBCaWdOdW1iZXIoc3RvcmFnZUFtb3VudFBlckJ5dGUpO1xuICAgIGNvbnN0IHN0YXRlU3Rha2VkID0gbmV3IEJpZ051bWJlcihhY2NvdW50LnN0b3JhZ2VfdXNhZ2UpLm11bHRpcGxpZWRCeShjb3N0UGVyQnl0ZSk7XG4gICAgY29uc3Qgc3Rha2VkID0gbmV3IEJpZ051bWJlcihhY2NvdW50LmxvY2tlZCk7XG4gICAgY29uc3QgdG90YWxCYWxhbmNlID0gbmV3IEJpZ051bWJlcihhY2NvdW50LmFtb3VudCkucGx1cyhzdGFrZWQpO1xuICAgIGNvbnN0IGF2YWlsYWJsZUJhbGFuY2UgPSB0b3RhbEJhbGFuY2UubWludXMoQmlnTnVtYmVyLm1heChzdGFrZWQsIHN0YXRlU3Rha2VkKSk7XG4gICAgcmV0dXJuIGF2YWlsYWJsZUJhbGFuY2UudG9TdHJpbmcoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRQcm90b2NvbENvbmZpZygpOiBQcm9taXNlPFByb3RvY29sQ29uZmlnT3V0cHV0PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogJ2RvbnRjYXJlJyxcbiAgICAgICAgbWV0aG9kOiAnRVhQRVJJTUVOVEFMX3Byb3RvY29sX2NvbmZpZycsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGZpbmFsaXR5OiAnZmluYWwnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb25maWcgPSByZXNwb25zZS5ib2R5LnJlc3VsdDtcbiAgICBjb25zdCBzdG9yYWdlQW1vdW50UGVyQnl0ZSA9IGNvbmZpZy5ydW50aW1lX2NvbmZpZy5zdG9yYWdlX2Ftb3VudF9wZXJfYnl0ZTtcbiAgICBjb25zdCB0cmFuc2ZlckNvc3RGcm9tTmV0d29yayA9IGNvbmZpZy5ydW50aW1lX2NvbmZpZy50cmFuc2FjdGlvbl9jb3N0cy5hY3Rpb25fY3JlYXRpb25fY29uZmlnLnRyYW5zZmVyX2Nvc3Q7XG4gICAgY29uc3QgdHJhbnNmZXJDb3N0OiBOZWFyRmVlQ29uZmlnID0ge1xuICAgICAgc2VuZFNpcjogdHJhbnNmZXJDb3N0RnJvbU5ldHdvcmsuc2VuZF9zaXIsXG4gICAgICBzZW5kTm90U2lyOiB0cmFuc2ZlckNvc3RGcm9tTmV0d29yay5zZW5kX25vdF9zaXIsXG4gICAgICBleGVjdXRpb246IHRyYW5zZmVyQ29zdEZyb21OZXR3b3JrLmV4ZWN1dGlvbixcbiAgICB9O1xuXG4gICAgY29uc3QgcmVjZWlwdENvbmZpZ0Zyb21OZXR3b3JrID0gY29uZmlnLnJ1bnRpbWVfY29uZmlnLnRyYW5zYWN0aW9uX2Nvc3RzLmFjdGlvbl9yZWNlaXB0X2NyZWF0aW9uX2NvbmZpZztcbiAgICBjb25zdCByZWNlaXB0Q29uZmlnOiBOZWFyRmVlQ29uZmlnID0ge1xuICAgICAgc2VuZFNpcjogcmVjZWlwdENvbmZpZ0Zyb21OZXR3b3JrLnNlbmRfc2lyLFxuICAgICAgc2VuZE5vdFNpcjogcmVjZWlwdENvbmZpZ0Zyb21OZXR3b3JrLnNlbmRfbm90X3NpcixcbiAgICAgIGV4ZWN1dGlvbjogcmVjZWlwdENvbmZpZ0Zyb21OZXR3b3JrLmV4ZWN1dGlvbixcbiAgICB9O1xuICAgIHJldHVybiB7IHN0b3JhZ2VBbW91bnRQZXJCeXRlLCB0cmFuc2ZlckNvc3QsIHJlY2VpcHRDb25maWcgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRHYXNQcmljZShibG9ja0hhc2g6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldERhdGFGcm9tTm9kZSh7XG4gICAgICBwYXlsb2FkOiB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogJ2RvbnRjYXJlJyxcbiAgICAgICAgbWV0aG9kOiAnZ2FzX3ByaWNlJyxcbiAgICAgICAgcGFyYW1zOiBbYmxvY2tIYXNoXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5ib2R5LnJlc3VsdC5nYXNfcHJpY2U7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0UHVibGljTm9kZVVybHMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBFbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0ubmVhck5vZGVVcmxzO1xuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IE5lYXJQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8TmVhclBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IGF3YWl0IHRoaXMuZXhwbGFpblRyYW5zYWN0aW9uKHtcbiAgICAgIHR4UHJlYnVpbGQ6IHBhcmFtcy50eFByZWJ1aWxkLFxuICAgICAgcHVibGljS2V5OiBwYXJhbXMucHVibGljS2V5LFxuICAgICAgZmVlSW5mbzogcGFyYW1zLmZlZUluZm8sXG4gICAgfSk7XG5cbiAgICBpZiAoIXRyYW5zYWN0aW9uRXhwbGFuYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IG5lYXJUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uRXhwbGFuYXRpb24gYXMgTmVhclRyYW5zYWN0aW9uRXhwbGFuYXRpb247XG4gICAgaWYgKG5lYXJUcmFuc2FjdGlvbi5vdXRwdXRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc2VuZGVyQWRkcmVzcyA9IG5lYXJUcmFuc2FjdGlvbi5vdXRwdXRzWzBdLmFkZHJlc3M7XG4gICAgY29uc3QgZmVlQW1vdW50ID0gbmV3IEJpZ051bWJlcihuZWFyVHJhbnNhY3Rpb24uZmVlLmZlZSA9PT0gJycgPyAnMCcgOiBuZWFyVHJhbnNhY3Rpb24uZmVlLmZlZSk7XG5cbiAgICAvLyBhc3N1bWUgMSBzZW5kZXIsIHdobyBpcyBhbHNvIHRoZSBmZWUgcGF5ZXJcbiAgICBjb25zdCBpbnB1dHMgPSBbXG4gICAgICB7XG4gICAgICAgIGFkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogbmV3IEJpZ051bWJlcihuZWFyVHJhbnNhY3Rpb24ub3V0cHV0QW1vdW50KS5wbHVzKGZlZUFtb3VudCkudG9GaXhlZCgpLFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgY29uc3Qgb3V0cHV0czogVHJhbnNhY3Rpb25PdXRwdXRbXSA9IG5lYXJUcmFuc2FjdGlvbi5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBvdXRwdXQuYWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKG91dHB1dC5hbW91bnQpLnRvRml4ZWQoKSxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRzLFxuICAgICAgb3V0cHV0cyxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgaXNXYWxsZXRBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsZXQgdG90YWxBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApO1xuICAgIGNvbnN0IGNvaW5Db25maWcgPSBjb2lucy5nZXQodGhpcy5nZXRDaGFpbigpKTtcbiAgICBjb25zdCB7IHR4UHJlYnVpbGQ6IHR4UHJlYnVpbGQsIHR4UGFyYW1zOiB0eFBhcmFtcyB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGNvaW5Db25maWcpO1xuICAgIGNvbnN0IHJhd1R4ID0gdHhQcmVidWlsZC50eEhleDtcbiAgICBpZiAoIXJhd1R4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgdHggcHJlYnVpbGQgcHJvcGVydHkgdHhIZXgnKTtcbiAgICB9XG5cbiAgICB0cmFuc2FjdGlvbi5mcm9tUmF3VHJhbnNhY3Rpb24ocmF3VHgpO1xuICAgIGNvbnN0IGV4cGxhaW5lZFR4ID0gdHJhbnNhY3Rpb24uZXhwbGFpblRyYW5zYWN0aW9uKCk7XG5cbiAgICAvLyB1c2VycyBkbyBub3QgaW5wdXQgcmVjaXBpZW50cyBmb3IgY29uc29saWRhdGlvbiByZXF1ZXN0cyBhcyB0aGV5IGFyZSBnZW5lcmF0ZWQgYnkgdGhlIHNlcnZlclxuICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUmVjaXBpZW50cyA9IHR4UGFyYW1zLnJlY2lwaWVudHM/Lm1hcCgocmVjaXBpZW50KSA9PiBfLnBpY2socmVjaXBpZW50LCBbJ2FkZHJlc3MnLCAnYW1vdW50J10pKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkT3V0cHV0cyA9IGV4cGxhaW5lZFR4Lm91dHB1dHMubWFwKChvdXRwdXQpID0+IF8ucGljayhvdXRwdXQsIFsnYWRkcmVzcycsICdhbW91bnQnXSkpO1xuXG4gICAgICBpZiAoIV8uaXNFcXVhbChmaWx0ZXJlZE91dHB1dHMsIGZpbHRlcmVkUmVjaXBpZW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCBvdXRwdXRzIGRvZXMgbm90IG1hdGNoIHdpdGggZXhwZWN0ZWQgdHhQYXJhbXMgcmVjaXBpZW50cycpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCByZWNpcGllbnRzIG9mIHR4UGFyYW1zLnJlY2lwaWVudHMpIHtcbiAgICAgICAgdG90YWxBbW91bnQgPSB0b3RhbEFtb3VudC5wbHVzKHJlY2lwaWVudHMuYW1vdW50KTtcbiAgICAgIH1cbiAgICAgIGlmICghdG90YWxBbW91bnQuaXNFcXVhbFRvKGV4cGxhaW5lZFR4Lm91dHB1dEFtb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCB0b3RhbCBhbW91bnQgZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0b3RhbCBhbW91bnQgZmllbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIGdldEJ1aWxkZXIoKTogVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5KGNvaW5zLmdldCh0aGlzLmdldEJhc2VDaGFpbigpKSk7XG4gIH1cbn1cbiJdfQ==