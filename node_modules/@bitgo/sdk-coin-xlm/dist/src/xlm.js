"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Xlm = void 0;
const assert_1 = __importDefault(require("assert"));
const _ = __importStar(require("lodash"));
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const querystring = __importStar(require("querystring"));
const url = __importStar(require("url"));
const request = __importStar(require("superagent"));
const stellar = __importStar(require("stellar-sdk"));
const bignumber_js_1 = require("bignumber.js");
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_api_1 = require("@bitgo/sdk-api");
const getStellarKeys_1 = require("./getStellarKeys");
class Xlm extends sdk_core_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
        this.homeDomain = 'bitgo.com'; // used for reverse federation lookup
    }
    static createInstance(bitgo) {
        return new Xlm(bitgo);
    }
    getStellarNetwork() {
        return stellar.Networks.PUBLIC;
    }
    /**
     * Factor between the base unit and its smallest subdivison
     */
    getBaseFactor() {
        return 1e7;
    }
    /**
     * Identifier for the blockchain which supports this coin
     */
    getChain() {
        return 'xlm';
    }
    /**
     * Identifier for the coin family
     */
    getFamily() {
        return 'xlm';
    }
    /**
     * Complete human-readable name of this coin
     */
    getFullName() {
        return 'Stellar';
    }
    /**
     * Url at which the stellar federation server can be reached
     */
    getFederationServerUrl() {
        return sdk_core_1.common.Environments[this.bitgo.getEnv()].stellarFederationServerUrl;
    }
    /**
     * Url at which horizon can be reached
     */
    getHorizonUrl() {
        return 'https://horizon.stellar.org';
    }
    /**
     * Generate a new key pair on the ed25519 curve
     * @param seed
     * @returns generated pub and prv
     */
    generateKeyPair(seed) {
        const pair = seed ? stellar.Keypair.fromRawEd25519Seed(seed) : stellar.Keypair.random();
        return {
            pub: pair.publicKey(),
            prv: pair.secret(),
        };
    }
    /**
     * Get decoded ed25519 public key from raw data
     *
     * @param pub Raw public key
     * @returns Encoded public key
     */
    getPubFromRaw(pub) {
        return stellar.StrKey.encodeEd25519PublicKey(Buffer.from(pub, 'hex'));
    }
    /**
     * Get decoded ed25519 private key from raw data
     *
     * @param prv Raw private key
     * @returns Encoded private key
     */
    getPrvFromRaw(prv) {
        return stellar.StrKey.encodeEd25519SecretSeed(Buffer.from(prv, 'hex'));
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param pub the pub to be checked
     * @returns is it valid?
     */
    isValidPub(pub) {
        return stellar.StrKey.isValidEd25519PublicKey(pub);
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        return stellar.StrKey.isValidEd25519SecretSeed(prv);
    }
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId) {
        let memoIdNumber;
        try {
            stellar.Memo.id(memoId); // throws if the value is not valid memo id
            memoIdNumber = new bignumber_js_1.BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return memoIdNumber.gte(0) && memoIdNumber.lt(Xlm.maxMemoId);
    }
    /**
     * Evaluates whether a memo is valid
     *
     * @param value value of the memo
     * @param type type of the memo
     * @returns true if value and type are a valid
     */
    isValidMemo({ value, type }) {
        if (!value || !type) {
            return false;
        }
        try {
            // throws if the value is not valid for the type
            // valid types are: 'id', 'text', 'hash', 'return'
            // See https://www.stellar.org/developers/guides/concepts/transactions.html#memo
            stellar.Memo[type](value);
        }
        catch (e) {
            return false;
        }
        return true;
    }
    /**
     * Create instance of stellar.MuxedAccount from M address
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     */
    getMuxedAccount(address) {
        try {
            return stellar.MuxedAccount.fromAddress(address, '0');
        }
        catch (e) {
            throw new Error(`invalid muxed address: ${address}`);
        }
    }
    /**
     * Return boolean indicating whether a muxed address is valid
     * See: https://developers.stellar.org/docs/glossary/muxed-accounts
     *
     * @param address
     * @returns {boolean}
     */
    isValidMuxedAddress(address) {
        if (!_.isString(address) || !address.startsWith('M')) {
            return false;
        }
        try {
            // return true if muxed account is valid or throw
            return !!stellar.MuxedAccount.fromAddress(address, '0');
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Minimum balance of a 2-of-3 multisig wallet
     * @returns minimum balance in stroops
     */
    async getMinimumReserve() {
        const server = new stellar.Server(this.getHorizonUrl());
        const horizonLedgerInfo = await server.ledgers().order('desc').limit(1).call();
        if (!horizonLedgerInfo) {
            throw new Error('unable to connect to Horizon for reserve requirement data');
        }
        const baseReserve = horizonLedgerInfo.records[0].base_reserve_in_stroops;
        // 2-of-3 wallets have a minimum reserve of 5x the base reserve
        return 5 * baseReserve;
    }
    /**
     * Transaction fee for each operation
     * @returns transaction fee in stroops
     */
    async getBaseTransactionFee() {
        const server = new stellar.Server(this.getHorizonUrl());
        const horizonLedgerInfo = await server.ledgers().order('desc').limit(1).call();
        if (!horizonLedgerInfo) {
            throw new Error('unable to connect to Horizon for reserve requirement data');
        }
        return horizonLedgerInfo.records[0].base_fee_in_stroops;
    }
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    getAddressDetails(address) {
        if (address.startsWith('M')) {
            if (this.isValidMuxedAddress(address)) {
                const muxedAccount = this.getMuxedAccount(address);
                return {
                    baseAddress: muxedAccount.baseAccount().accountId(),
                    address,
                    id: muxedAccount.id(),
                    memoId: undefined,
                };
            }
            else {
                throw new sdk_core_1.InvalidAddressError(`invalid muxed address: ${address}`);
            }
        }
        const destinationDetails = url.parse(address);
        const destinationAddress = destinationDetails.pathname || '';
        if (!destinationAddress || !stellar.StrKey.isValidEd25519PublicKey(destinationAddress)) {
            throw new Error(`invalid address: ${address}`);
        }
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                baseAddress: address,
                address: address,
                id: undefined,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new sdk_core_1.InvalidAddressError(`memoId may only be given at most once, but found ${queryDetails.memoId.length} instances in address ${address}`);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new sdk_core_1.InvalidAddressError(`invalid address '${address}', must contain exactly one memoId`);
        }
        const [memoId] = _.castArray(queryDetails.memoId) || undefined;
        if (!this.isValidMemoId(memoId)) {
            throw new sdk_core_1.InvalidMemoIdError(`invalid address: '${address}', memoId is not valid`);
        }
        return {
            baseAddress: destinationAddress,
            address: destinationAddress,
            id: undefined,
            memoId,
        };
    }
    /**
     * Validate and return address with appended memo id or muxed address
     *
     * @param address address
     * @param memoId memo id
     * @returns address with memo id
     */
    normalizeAddress({ address, memoId }) {
        if (this.isValidMuxedAddress(address)) {
            return address;
        }
        if (!stellar.StrKey.isValidEd25519PublicKey(address)) {
            throw new Error(`invalid address details: ${address}`);
        }
        if (memoId && this.isValidMemoId(memoId)) {
            return `${address}?memoId=${memoId}`;
        }
        return address;
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param address the pub to be checked
     * @returns is it valid?
     */
    isValidAddress(address) {
        try {
            const addressDetails = this.getAddressDetails(address);
            return address === this.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return a Stellar Asset in coin:token form (i.e. (t)xlm:<code>-<issuer>)
     * If the asset is XLM, return the chain
     * @param {stellar.Asset} asset - instance of Stellar Asset
     */
    getTokenNameFromStellarAsset(asset) {
        const code = asset.getCode();
        const issuer = asset.getIssuer();
        if (asset.isNative()) {
            return this.getChain();
        }
        return `${this.getChain()}${sdk_core_1.BaseCoin.coinTokenPatternSeparator}${code}${Xlm.tokenPatternSeparator}${issuer}`;
    }
    /**
     * Evaluate whether a stellar username has valid format
     * This method is used by the client when a stellar address is being added to a wallet
     * Example of a common stellar username: foo@bar.baz
     * The above example would result in the Stellar address: foo@bar.baz*bitgo.com
     *
     * @param username - stellar username
     * @return true if stellar username is valid
     */
    isValidStellarUsername(username) {
        return /^[a-z0-9\-_.+@]+$/.test(username);
    }
    /**
     * Get an instance of FederationServer for BitGo lookups
     *
     * @returns instance of BitGo Federation Server
     */
    getBitGoFederationServer() {
        // Identify the URI scheme in case we need to allow connecting to HTTP server.
        const isNonSecureEnv = !_.startsWith(sdk_core_1.common.Environments[this.bitgo.env].uri, 'https');
        const federationServerOptions = { allowHttp: isNonSecureEnv };
        return new stellar.FederationServer(this.getFederationServerUrl(), 'bitgo.com', federationServerOptions);
    }
    /**
     * Perform federation lookups
     * Our federation server handles lookups for bitgo as well as for other federation domains
     *
     * @param {String} [address] - address to look up
     * @param {String} [accountId] - account id to look up
     */
    async federationLookup({ address, accountId, }) {
        try {
            const federationServer = this.getBitGoFederationServer();
            if (address) {
                return await federationServer.resolveAddress(address);
            }
            else if (accountId) {
                return await federationServer.resolveAccountId(accountId);
            }
            else {
                throw new Error('invalid argument - must provide Stellar address or account id');
            }
        }
        catch (e) {
            const error = _.get(e, 'response.data.detail');
            if (error) {
                throw new sdk_core_1.StellarFederationUserNotFoundError(error);
            }
            else {
                throw e;
            }
        }
    }
    /**
     * Attempt to resolve a stellar address into a stellar account
     *
     * @param {String} address - stellar address to look for
     */
    async federationLookupByName(address) {
        if (!address) {
            throw new Error('invalid Stellar address');
        }
        return this.federationLookup({ address });
    }
    /**
     * Attempt to resolve an account id into a stellar account
     * Only works for accounts that can be resolved by our federation server
     *
     * @param {String} accountId - stellar account id
     */
    async federationLookupByAccountId(accountId) {
        if (!accountId) {
            throw new Error('invalid Stellar account');
        }
        return this.federationLookup({ accountId });
    }
    /**
     * Check if address is a valid XLM address, and then make sure it matches the root address.
     *
     * @param address {String} the address to verify
     * @param rootAddress {String} the wallet's root address
     */
    async isWalletAddress({ address, rootAddress }) {
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const addressDetails = this.getAddressDetails(address);
        const rootAddressDetails = this.getAddressDetails(rootAddress);
        if (addressDetails.baseAddress !== rootAddressDetails.address) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${addressDetails.baseAddress} vs ${rootAddressDetails.address}`);
        }
        return true;
    }
    /**
     * Get extra parameters for prebuilding a tx
     * Set empty recipients array in trustline txs
     */
    async getExtraPrebuildParams(buildParams) {
        const params = {};
        if (buildParams.type === 'trustline') {
            params.recipients = [];
        }
        return params;
    }
    /**
     * @deprecated
     */
    initiateRecovery(params) {
        throw new Error('deprecated method');
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * - userKey: [encrypted] Stellar private key
     * - backupKey: [encrypted] Stellar private key, or public key if the private key is held by a KRS provider
     * - walletPassphrase: necessary if one of the private keys is encrypted
     * - rootAddress: base address of the wallet to recover funds from
     * - krsProvider: necessary if backup key is held by KRS
     * - recoveryDestination: target address to send recovered funds to
     */
    async recover(params) {
        // Stellar's Ed25519 public keys start with a G, while private keys start with an S
        const isKrsRecovery = params.backupKey.startsWith('G') && !params.userKey.startsWith('G');
        const isUnsignedSweep = params.backupKey.startsWith('G') && params.userKey.startsWith('G');
        if (isKrsRecovery) {
            sdk_core_1.checkKrsProvider(this, params.krsProvider);
        }
        if (!this.isValidAddress(params.recoveryDestination)) {
            throw new sdk_core_1.InvalidAddressError('Invalid destination address!');
        }
        const [userKey, backupKey] = getStellarKeys_1.getStellarKeys(this.bitgo, params);
        if (!params.rootAddress || !stellar.StrKey.isValidEd25519PublicKey(params.rootAddress)) {
            throw new Error(`Invalid wallet address: ${params.rootAddress}`);
        }
        const accountDataUrl = `${this.getHorizonUrl()}/accounts/${params.rootAddress}`;
        const destinationUrl = `${this.getHorizonUrl()}/accounts/${params.recoveryDestination}`;
        let accountData;
        try {
            accountData = await sdk_api_1.toBitgoRequest(request.get(accountDataUrl)).result();
        }
        catch (e) {
            throw new Error('Unable to reach the Stellar network via Horizon.');
        }
        // Now check if the destination account is empty or not
        let unfundedDestination = false;
        try {
            await request.get(destinationUrl);
        }
        catch (e) {
            if (e.status === 404) {
                // If the destination account does not yet exist, horizon responds with 404
                unfundedDestination = true;
            }
        }
        if (!accountData.sequence || !accountData.balances) {
            throw new Error('Horizon server error - unable to retrieve sequence ID or account balance');
        }
        const account = new stellar.Account(params.rootAddress, accountData.sequence);
        // Stellar supports multiple assets on chain, we're only interested in the balances entry whose type is "native" (XLM)
        const nativeBalanceInfo = accountData.balances.find((assetBalance) => assetBalance['asset_type'] === 'native');
        if (!nativeBalanceInfo) {
            throw new Error('Provided wallet has a balance of 0 XLM, recovery aborted');
        }
        const walletBalance = Number(this.bigUnitsToBaseUnits(nativeBalanceInfo.balance));
        const minimumReserve = await this.getMinimumReserve();
        const baseTxFee = await this.getBaseTransactionFee();
        const recoveryAmount = walletBalance - minimumReserve - baseTxFee;
        const formattedRecoveryAmount = this.baseUnitsToBigUnits(recoveryAmount).toString();
        const txBuilder = new stellar.TransactionBuilder(account, {
            fee: baseTxFee.toFixed(0),
            networkPassphrase: this.getStellarNetwork(),
        });
        const operation = unfundedDestination
            ? // In this case, we need to create the account
                stellar.Operation.createAccount({
                    destination: params.recoveryDestination,
                    startingBalance: formattedRecoveryAmount,
                })
            : // Otherwise if the account already exists, we do a normal send
                stellar.Operation.payment({
                    destination: params.recoveryDestination,
                    asset: stellar.Asset.native(),
                    amount: formattedRecoveryAmount,
                });
        const tx = txBuilder.addOperation(operation).setTimeout(stellar.TimeoutInfinite).build();
        if (!isUnsignedSweep) {
            tx.sign(userKey);
        }
        if (!isKrsRecovery && !isUnsignedSweep) {
            tx.sign(backupKey);
        }
        const transaction = {
            tx: Xlm.txToString(tx),
            recoveryAmount,
        };
        if (isKrsRecovery) {
            transaction.backupKey = params.backupKey;
            transaction.coin = this.getChain();
        }
        return transaction;
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {Object} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<HalfSignedTransaction>}
     */
    async signTransaction(params) {
        var _a, _b;
        const { txPrebuild, prv } = params;
        if (_.isUndefined(txPrebuild)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isObject(txPrebuild)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txPrebuild}`);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        const keyPair = stellar.Keypair.fromSecret(prv);
        const tx = new stellar.Transaction(txPrebuild.txBase64, this.getStellarNetwork());
        tx.sign(keyPair);
        const txBase64 = Xlm.txToString(tx);
        const type = (_a = txPrebuild === null || txPrebuild === void 0 ? void 0 : txPrebuild.buildParams) === null || _a === void 0 ? void 0 : _a.type;
        const recipients = (_b = txPrebuild === null || txPrebuild === void 0 ? void 0 : txPrebuild.buildParams) === null || _b === void 0 ? void 0 : _b.recipients;
        if (type === 'enabletoken') {
            return {
                halfSigned: { txBase64 },
                type,
                recipients,
            };
        }
        else {
            return { halfSigned: { txBase64 } };
        }
    }
    /**
     * Extend walletParams with extra params required for generating an XLM wallet
     *
     * Stellar wallets have three keychains on them. Two are generated by the platform, and the last is generated by the user.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root prv is not provided, a random one is generated.
     */
    async supplementGenerateWallet(walletParams) {
        let seed;
        const rootPrv = walletParams.rootPrivateKey;
        if (rootPrv) {
            if (!this.isValidPrv(rootPrv)) {
                throw new Error('rootPrivateKey needs to be valid ed25519 secret seed');
            }
            seed = stellar.StrKey.decodeEd25519SecretSeed(rootPrv);
        }
        const keyPair = this.generateKeyPair(seed);
        // extend the wallet initialization params
        walletParams.rootPrivateKey = keyPair.prv;
        return walletParams;
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        if (!this.isValidPrv(key.prv)) {
            throw new Error(`invalid prv: ${key.prv}`);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        const keypair = stellar.Keypair.fromSecret(key.prv);
        return keypair.sign(message);
    }
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub public key
     * @param message signed message
     * @param signature signature to verify
     * @returns true if signature is valid.
     */
    verifySignature(pub, message, signature) {
        if (!this.isValidPub(pub)) {
            throw new Error(`invalid pub: ${pub}`);
        }
        if (!Buffer.isBuffer(message)) {
            message = Buffer.from(message);
        }
        const keyPair = stellar.Keypair.fromPublicKey(pub);
        return keyPair.verify(message, signature);
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const { txHex, txBase64 } = params;
        let tx = undefined;
        if (!txHex && !txBase64) {
            throw new Error('explainTransaction missing txHex or txBase64 parameter, must have at least one');
        }
        try {
            if (txHex) {
                tx = new stellar.Transaction(Buffer.from(txHex, 'hex').toString('base64'), this.getStellarNetwork());
            }
            else if (txBase64) {
                tx = new stellar.Transaction(txBase64, this.getStellarNetwork());
            }
        }
        catch (e) {
            throw new Error('txBase64 needs to be a valid tx encoded as base64 string');
        }
        if (!tx) {
            throw new Error('tx needs to be defined in order to explain transaction');
        }
        const id = tx.hash().toString('hex');
        // In a Stellar tx, the _memo property is an object with the methods:
        // value() and arm() that provide memo value and type, respectively.
        const memo = _.result(tx, '_memo.value') && _.result(tx, '_memo.arm')
            ? {
                value: _.result(tx, '_memo.value').toString(),
                type: _.result(tx, '_memo.arm'),
            }
            : {};
        let spendAmount = new bignumber_js_1.BigNumber(0); // amount of XLM used in XLM-only txs
        const spendAmounts = {}; // track both xlm and token amounts
        if (_.isEmpty(tx.operations)) {
            throw new Error('missing operations');
        }
        const outputs = [];
        const operations = []; // non-payment operations
        _.forEach(tx.operations, (op) => {
            if (op.type === 'createAccount' || op.type === 'payment') {
                // TODO Remove memoId from address
                // Get memo to attach to address, if type is 'id'
                const memoId = _.get(memo, 'type') === 'id' && !_.get(memo, 'value') ? `?memoId=${memo.value}` : '';
                let asset;
                if (op.type === 'payment') {
                    if (op.asset.getAssetType() === 'liquidity_pool_shares') {
                        throw new Error('Invalid asset type');
                    }
                    asset = op.asset;
                }
                else {
                    asset = stellar.Asset.native();
                }
                const coin = this.getTokenNameFromStellarAsset(asset); // coin or token id
                const output = {
                    amount: this.bigUnitsToBaseUnits(op.startingBalance || op.amount),
                    address: op.destination + memoId,
                    coin,
                };
                if (!_.isUndefined(spendAmounts[coin])) {
                    spendAmounts[coin] = spendAmounts[coin].plus(output.amount);
                }
                else {
                    spendAmounts[coin] = new bignumber_js_1.BigNumber(output.amount);
                }
                if (asset.isNative()) {
                    spendAmount = spendAmount.plus(output.amount);
                }
                outputs.push(output);
            }
            else if (op.type === 'changeTrust') {
                if (op.line.getAssetType() === 'liquidity_pool_shares') {
                    throw new Error('Invalid asset type');
                }
                const asset = op.line;
                operations.push({
                    type: op.type,
                    coin: this.getTokenNameFromStellarAsset(asset),
                    asset,
                    limit: this.bigUnitsToBaseUnits(op.limit),
                });
            }
        });
        const outputAmount = spendAmount.toFixed(0);
        const outputAmounts = _.mapValues(spendAmounts, (amount) => amount.toFixed(0));
        const fee = {
            fee: new bignumber_js_1.BigNumber(tx.fee).toFixed(0),
            feeRate: null,
            size: null,
        };
        return {
            displayOrder: [
                'id',
                'outputAmount',
                'outputAmounts',
                'changeAmount',
                'outputs',
                'changeOutputs',
                'fee',
                'memo',
                'operations',
            ],
            id,
            outputs,
            outputAmount,
            outputAmounts,
            changeOutputs: [],
            changeAmount: '0',
            memo,
            fee,
            operations,
        };
    }
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    verifyEnableTokenTxOperations(operations, txParams) {
        const trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'recipients', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, (op) => {
            if (op.type !== 'changeTrust') {
                throw new Error('Invalid asset type');
            }
            if (op.line.getAssetType() === 'liquidity_pool_shares') {
                throw new Error('Invalid asset type');
            }
            const asset = op.line;
            const opToken = this.getTokenNameFromStellarAsset(asset);
            const tokenTrustline = _.find(txParams.recipients, (recipient) => {
                // trustline params use limits in base units
                const opLimitBaseUnits = this.bigUnitsToBaseUnits(op.limit);
                // Enable token limit is set to Xlm.maxTrustlineLimit by default
                return recipient.tokenName === opToken && opLimitBaseUnits === Xlm.maxTrustlineLimit;
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    }
    /**
     * Verify that a tx prebuild's operations comply with the original intention
     * @param {stellar.Operation} operations - tx operations
     * @param {TransactionParams} txParams - params used to build the tx
     */
    verifyTrustlineTxOperations(operations, txParams) {
        const trustlineOperations = _.filter(operations, ['type', 'changeTrust']);
        if (trustlineOperations.length !== _.get(txParams, 'trustlines', []).length) {
            throw new Error('transaction prebuild does not match expected trustline operations');
        }
        _.forEach(trustlineOperations, (op) => {
            if (op.type !== 'changeTrust') {
                throw new Error('Invalid asset type');
            }
            if (op.line.getAssetType() === 'liquidity_pool_shares') {
                throw new Error('Invalid asset type');
            }
            const asset = op.line;
            const opToken = this.getTokenNameFromStellarAsset(asset);
            const tokenTrustline = _.find(txParams.trustlines, (trustline) => {
                // trustline params use limits in base units
                const opLimitBaseUnits = this.bigUnitsToBaseUnits(op.limit);
                // Prepare the conditions to check for
                // Limit will always be set in the operation, even if it was omitted from txParams in the following cases:
                // 1. Action is 'add' - limit is set to Xlm.maxTrustlineLimit by default
                // 2. Action is 'remove' - limit is set to '0'
                const noLimit = _.isUndefined(trustline.limit);
                const addTrustlineWithDefaultLimit = trustline.action === 'add' && opLimitBaseUnits === Xlm.maxTrustlineLimit;
                const removeTrustline = trustline.action === 'remove' && opLimitBaseUnits === '0';
                return (trustline.token === opToken &&
                    (trustline.limit === opLimitBaseUnits || (noLimit && (addTrustlineWithDefaultLimit || removeTrustline))));
            });
            if (!tokenTrustline) {
                throw new Error('transaction prebuild does not match expected trustline tokens');
            }
        });
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param options
     * @param options.txPrebuild prebuild object returned by platform
     * @param options.txPrebuild.txBase64 prebuilt transaction encoded as base64 string
     * @param options.wallet wallet object to obtain keys to verify against
     * @param options.verification specifying some verification parameters
     * @param options.verification.disableNetworking Disallow fetching any data from the internet for verification purposes
     * @param options.verification.keychains Pass keychains manually rather than fetching them by id
     */
    async verifyTransaction(options) {
        // TODO BG-5600 Add parseTransaction / improve verification
        const { txParams, txPrebuild, wallet, verification = {} } = options;
        const disableNetworking = !!verification.disableNetworking;
        if (!txPrebuild.txBase64) {
            throw new Error('missing required tx prebuild property txBase64');
        }
        const tx = new stellar.Transaction(txPrebuild.txBase64, this.getStellarNetwork());
        if (txParams.recipients && txParams.recipients.length > 1) {
            throw new Error('cannot specify more than 1 recipient');
        }
        // Stellar txs are made up of operations. We only care about Create Account and Payment for sending funds.
        const outputOperations = _.filter(tx.operations, (operation) => operation.type === 'createAccount' || operation.type === 'payment');
        if (txParams.type === 'enabletoken') {
            this.verifyEnableTokenTxOperations(tx.operations, txParams);
        }
        else if (txParams.type === 'trustline') {
            this.verifyTrustlineTxOperations(tx.operations, txParams);
        }
        else {
            if (_.isEmpty(outputOperations)) {
                throw new Error('transaction prebuild does not have any operations');
            }
            _.forEach(txParams.recipients, (expectedOutput, index) => {
                const expectedOutputAddressDetails = this.getAddressDetails(expectedOutput.address);
                // for muxed accounts, the destination will be the baseAddress
                const expectedOutputAddress = expectedOutputAddressDetails.baseAddress;
                const output = outputOperations[index];
                if (output.destination !== expectedOutputAddress) {
                    throw new Error('transaction prebuild does not match expected recipient');
                }
                const expectedOutputAmount = new bignumber_js_1.BigNumber(expectedOutput.amount);
                // The output amount is expressed as startingBalance in createAccount operations and as amount in payment operations.
                const outputAmountString = output.type === 'createAccount' ? output.startingBalance : output.amount;
                const outputAmount = new bignumber_js_1.BigNumber(this.bigUnitsToBaseUnits(outputAmountString));
                if (!outputAmount.eq(expectedOutputAmount)) {
                    throw new Error('transaction prebuild does not match expected amount');
                }
            });
        }
        // Verify the user signature, if the tx is half-signed
        if (!_.isEmpty(tx.signatures)) {
            const userSignature = tx.signatures[0].signature();
            // obtain the keychains and key signatures
            let keychains = verification.keychains;
            if (!keychains && disableNetworking) {
                throw new Error('cannot fetch keychains without networking');
            }
            else if (!keychains) {
                keychains = await sdk_core_1.promiseProps({
                    user: this.keychains().get({ id: wallet.keyIds()[sdk_core_1.KeyIndices.USER] }),
                    backup: this.keychains().get({ id: wallet.keyIds()[sdk_core_1.KeyIndices.BACKUP] }),
                });
            }
            if (!keychains || !keychains.backup || !keychains.user) {
                throw new Error('keychains are required, but could not be fetched');
            }
            assert_1.default(keychains.backup.pub);
            if (this.verifySignature(keychains.backup.pub, tx.hash(), userSignature)) {
                throw new Error('transaction signed with wrong key');
            }
            assert_1.default(keychains.user.pub);
            if (!this.verifySignature(keychains.user.pub, tx.hash(), userSignature)) {
                throw new Error('transaction signature invalid');
            }
        }
        return true;
    }
    /**
     * Derive a hardened child public key from a master key seed using an additional seed for randomness.
     *
     * Due to technical differences between keypairs on the ed25519 curve and the secp256k1 curve,
     * only hardened private key derivation is supported.
     *
     * @param key seed for the master key. Note: Not the public key or encoded private key. This is the raw seed.
     * @param entropySeed random seed which is hashed to generate the derivation path
     */
    deriveKeyWithSeed({ key, seed }) {
        const derivationPathInput = utxolib.crypto.hash256(Buffer.from(seed, 'utf8')).toString('hex');
        const derivationPathParts = [
            999999,
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        const derivationPath = 'm/' + derivationPathParts.map((part) => `${part}'`).join('/');
        const derivedKey = sdk_core_1.Ed25519KeyDeriver.derivePath(derivationPath, key).key;
        const keypair = stellar.Keypair.fromRawEd25519Seed(derivedKey);
        return {
            key: keypair.publicKey(),
            derivationPath,
        };
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: true,
            supportsMultipleTokenEnablements: false,
        };
    }
}
exports.Xlm = Xlm;
Xlm.tokenPatternSeparator = '-'; // separator for token code and issuer
Xlm.maxMemoId = '0xFFFFFFFFFFFFFFFF'; // max unsigned 64-bit number = 18446744073709551615
// max int64 number supported by the network (2^63)-1
// See: https://www.stellar.org/developers/guides/concepts/assets.html#amount-precision-and-representation
Xlm.maxTrustlineLimit = '9223372036854775807';
/**
 * stellar-sdk has two overloads for toXDR, and typescript can't seem to figure out the
 * correct one to use, so we have to be very explicit as to which one we want.
 * @param tx transaction to convert
 */
Xlm.txToString = (tx) => tx.toEnvelope().toXDR('base64');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieGxtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3hsbS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0RBQTRCO0FBQzVCLDBDQUE0QjtBQUM1Qix5REFBMkM7QUFDM0MseURBQTJDO0FBQzNDLHlDQUEyQjtBQUMzQixvREFBc0M7QUFDdEMscURBQXVDO0FBQ3ZDLCtDQUF5QztBQUV6Qyw4Q0EwQnlCO0FBQ3pCLDRDQUFnRDtBQUNoRCxxREFBa0Q7QUErR2xELE1BQWEsR0FBSSxTQUFRLG1CQUFRO0lBUS9CLFlBQVksS0FBZ0I7UUFDMUIsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2IsSUFBSSxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxxQ0FBcUM7SUFDdEUsQ0FBQztJQUVELE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBZ0I7UUFDcEMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRVMsaUJBQWlCO1FBQ3pCLE9BQU8sT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDakMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsYUFBYTtRQUNYLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsUUFBUTtRQUNOLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsU0FBUztRQUNQLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsV0FBVztRQUNULE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRDs7T0FFRztJQUNILHNCQUFzQjtRQUNwQixPQUFPLGlCQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQywwQkFBMEIsQ0FBQztJQUM3RSxDQUFDO0lBRUQ7O09BRUc7SUFDSCxhQUFhO1FBQ1gsT0FB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RUFBRTtZQUN4QixjQUFjO1NBQ2YsQ0FBQztJQUNKLENBQUM7SUFVRCxLQUFLLENBQUMsZ0JBQWdCLENBQUMsTUFBK0I7UUFDcEQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCx3QkFBd0I7UUFDdEIsT0FBTztZQUNMLHVCQUF1QixFQUFFLElBQUk7WUFDN0IsZ0NBQWdDLEVBQUUsS0FBSztTQUN4QyxDQUFDO0lBQ0osQ0FBQzs7QUF2L0JILGtCQXcvQkM7QUF0L0J3Qix5QkFBcUIsR0FBRyxHQUFHLENBQUMsQ0FBQyxzQ0FBc0M7QUFDMUUsYUFBUyxHQUFXLG9CQUFvQixDQUFDLENBQUMsb0RBQW9EO0FBQzlHLHFEQUFxRDtBQUNyRCwwR0FBMEc7QUFDMUYscUJBQWlCLEdBQVcscUJBQXFCLENBQUM7QUEwOUJsRTs7OztHQUlHO0FBQ2MsY0FBVSxHQUFHLENBQUMsRUFBdUIsRUFBVSxFQUFFLENBQy9ELEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxLQUErQixDQUFDLFFBQVEsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgdXR4b2xpYiBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuaW1wb3J0ICogYXMgdXJsIGZyb20gJ3VybCc7XG5pbXBvcnQgKiBhcyByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0ICogYXMgc3RlbGxhciBmcm9tICdzdGVsbGFyLXNkayc7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQml0R29CYXNlLFxuICBjaGVja0tyc1Byb3ZpZGVyLFxuICBjb21tb24sXG4gIEVkMjU1MTlLZXlEZXJpdmVyLFxuICBFeHRyYVByZWJ1aWxkUGFyYW1zT3B0aW9ucyxcbiAgSW52YWxpZEFkZHJlc3NFcnJvcixcbiAgSW52YWxpZE1lbW9JZEVycm9yLFxuICBJVHJhbnNhY3Rpb25SZWNpcGllbnQsXG4gIEtleUluZGljZXMsXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgcHJvbWlzZVByb3BzLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTdGVsbGFyRmVkZXJhdGlvblVzZXJOb3RGb3VuZEVycm9yLFxuICBUb2tlbkVuYWJsZW1lbnRDb25maWcsXG4gIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gYXMgQmFzZVRyYW5zYWN0aW9uRXhwbGFuYXRpb24sXG4gIFRyYW5zYWN0aW9uUGFyYW1zIGFzIEJhc2VUcmFuc2FjdGlvblBhcmFtcyxcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCBhcyBCYXNlVHJhbnNhY3Rpb25QcmVidWlsZCxcbiAgVHJhbnNhY3Rpb25SZWNpcGllbnQgYXMgQmFzZVRyYW5zYWN0aW9uT3V0cHV0LFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyBhcyBCYXNlVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxuICBXYWxsZXQsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyB0b0JpdGdvUmVxdWVzdCB9IGZyb20gJ0BiaXRnby9zZGstYXBpJztcbmltcG9ydCB7IGdldFN0ZWxsYXJLZXlzIH0gZnJvbSAnLi9nZXRTdGVsbGFyS2V5cyc7XG5cbi8qKlxuICogWExNIGFjY291bnRzIHN1cHBvcnQgdmlydHVhbCAobXV4ZWQpIGFkZHJlc3Nlc1xuICogQSBiYXNlIGFkZHJlc3Mgc3RhcnRzIHdpdGggXCJHXCIgYW5kIGlzIHRpZWQgdG8gdGhlIHVuZGVybHlpbmcgXCJyZWFsXCIgYWNjb3VudFxuICogQSBtdXhlZCBhZGRyZXNzIHN0YXJ0cyB3aXRoIFwiTVwiIGFuZCBjb21iaW5lcyB0aGUgYmFzZSBhZGRyZXNzIHdpdGggYSA2NC1iaXQgaW50ZWdlciBJRCBpbiBvcmRlciB0byBwcm92aWRlXG4gKiBhbiBhbHRlcm5hdGl2ZSB0byBtZW1vIGlkcy5cbiAqL1xuaW50ZXJmYWNlIEFkZHJlc3NEZXRhaWxzIHtcbiAgYmFzZUFkZHJlc3M6IHN0cmluZztcbiAgYWRkcmVzczogc3RyaW5nO1xuICBpZD86IHN0cmluZztcbiAgbWVtb0lkPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xufVxuXG5pbnRlcmZhY2UgTWVtbyB7XG4gIHR5cGU6IHN0ZWxsYXIuTWVtb1R5cGU7XG4gIHZhbHVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyB7XG4gIHVzZXJLZXk6IHN0cmluZztcbiAgYmFja3VwS2V5OiBzdHJpbmc7XG4gIHJlY292ZXJ5RGVzdGluYXRpb246IHN0cmluZztcbiAga3JzUHJvdmlkZXI/OiBzdHJpbmc7XG4gIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZWNvdmVyeU9wdGlvbnMgZXh0ZW5kcyBJbml0aWF0ZVJlY292ZXJ5T3B0aW9ucyB7XG4gIHJvb3RBZGRyZXNzPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVjb3ZlcnlUcmFuc2FjdGlvbiB7XG4gIHR4OiBzdHJpbmc7XG4gIHJlY292ZXJ5QW1vdW50OiBudW1iZXI7XG4gIGJhY2t1cEtleT86IHN0cmluZztcbiAgY29pbj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEJ1aWxkT3B0aW9ucyB7XG4gIHdhbGxldD86IFdhbGxldDtcbiAgcmVjaXBpZW50cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5bXTtcbiAgdHlwZT86IHN0cmluZztcbiAgd2FsbGV0UGFzc3BocmFzZT86IHN0cmluZztcbiAgW2luZGV4OiBzdHJpbmddOiB1bmtub3duO1xufVxuXG5pbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhCYXNlNjQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHBydjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4QmFzZTY0OiBzdHJpbmc7XG4gIH07XG4gIHJlY2lwaWVudHM/OiBJVHJhbnNhY3Rpb25SZWNpcGllbnRbXTtcbiAgdHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnMge1xuICByb290UHJpdmF0ZUtleT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eEhleD86IHN0cmluZztcbiAgdHhCYXNlNjQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk1lbW8ge1xuICB2YWx1ZT86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3BlcmF0aW9uIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGxpbWl0Pzogc3RyaW5nO1xuICBhc3NldD86IHN0ZWxsYXIuQXNzZXQ7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk91dHB1dCBleHRlbmRzIEJhc2VUcmFuc2FjdGlvbk91dHB1dCB7XG4gIGNvaW46IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uRXhwbGFuYXRpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiB7XG4gIG1lbW86IFRyYW5zYWN0aW9uTWVtbztcbn1cblxuaW50ZXJmYWNlIFZlcmlmeUFkZHJlc3NPcHRpb25zIGV4dGVuZHMgQmFzZVZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRydXN0bGluZU9wdGlvbnMge1xuICB0b2tlbjogc3RyaW5nO1xuICBhY3Rpb246IHN0cmluZztcbiAgbGltaXQ/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvblBhcmFtcyBleHRlbmRzIEJhc2VUcmFuc2FjdGlvblBhcmFtcyB7XG4gIHRydXN0bGluZXM/OiBUcnVzdGxpbmVPcHRpb25zW107XG59XG5cbmludGVyZmFjZSBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zO1xufVxuXG5leHBvcnQgY2xhc3MgWGxtIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwdWJsaWMgcmVhZG9ubHkgaG9tZURvbWFpbjogc3RyaW5nO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IHRva2VuUGF0dGVyblNlcGFyYXRvciA9ICctJzsgLy8gc2VwYXJhdG9yIGZvciB0b2tlbiBjb2RlIGFuZCBpc3N1ZXJcbiAgc3RhdGljIHJlYWRvbmx5IG1heE1lbW9JZDogc3RyaW5nID0gJzB4RkZGRkZGRkZGRkZGRkZGRic7IC8vIG1heCB1bnNpZ25lZCA2NC1iaXQgbnVtYmVyID0gMTg0NDY3NDQwNzM3MDk1NTE2MTVcbiAgLy8gbWF4IGludDY0IG51bWJlciBzdXBwb3J0ZWQgYnkgdGhlIG5ldHdvcmsgKDJeNjMpLTFcbiAgLy8gU2VlOiBodHRwczovL3d3dy5zdGVsbGFyLm9yZy9kZXZlbG9wZXJzL2d1aWRlcy9jb25jZXB0cy9hc3NldHMuaHRtbCNhbW91bnQtcHJlY2lzaW9uLWFuZC1yZXByZXNlbnRhdGlvblxuICBzdGF0aWMgcmVhZG9ubHkgbWF4VHJ1c3RsaW5lTGltaXQ6IHN0cmluZyA9ICc5MjIzMzcyMDM2ODU0Nzc1ODA3JztcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlKSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICAgIHRoaXMuaG9tZURvbWFpbiA9ICdiaXRnby5jb20nOyAvLyB1c2VkIGZvciByZXZlcnNlIGZlZGVyYXRpb24gbG9va3VwXG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IFhsbShiaXRnbyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0U3RlbGxhck5ldHdvcmsoKTogc3RlbGxhci5OZXR3b3JrcyB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuTmV0d29ya3MuUFVCTElDO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvciBiZXR3ZWVuIHRoZSBiYXNlIHVuaXQgYW5kIGl0cyBzbWFsbGVzdCBzdWJkaXZpc29uXG4gICAqL1xuICBnZXRCYXNlRmFjdG9yKCkge1xuICAgIHJldHVybiAxZTc7XG4gIH1cblxuICAvKipcbiAgICogSWRlbnRpZmllciBmb3IgdGhlIGJsb2NrY2hhaW4gd2hpY2ggc3VwcG9ydHMgdGhpcyBjb2luXG4gICAqL1xuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAneGxtJztcbiAgfVxuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIGZvciB0aGUgY29pbiBmYW1pbHlcbiAgICovXG4gIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAneGxtJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZSBodW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoaXMgY29pblxuICAgKi9cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ1N0ZWxsYXInO1xuICB9XG5cbiAgLyoqXG4gICAqIFVybCBhdCB3aGljaCB0aGUgc3RlbGxhciBmZWRlcmF0aW9uIHNlcnZlciBjYW4gYmUgcmVhY2hlZFxuICAgKi9cbiAgZ2V0RmVkZXJhdGlvblNlcnZlclVybCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLnN0ZWxsYXJGZWRlcmF0aW9uU2VydmVyVXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFVybCBhdCB3aGljaCBob3Jpem9uIGNhbiBiZSByZWFjaGVkXG4gICAqL1xuICBnZXRIb3Jpem9uVXJsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdodHRwczovL2hvcml6b24uc3RlbGxhci5vcmcnO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IGtleSBwYWlyIG9uIHRoZSBlZDI1NTE5IGN1cnZlXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ6IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGNvbnN0IHBhaXIgPSBzZWVkID8gc3RlbGxhci5LZXlwYWlyLmZyb21SYXdFZDI1NTE5U2VlZChzZWVkKSA6IHN0ZWxsYXIuS2V5cGFpci5yYW5kb20oKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBwYWlyLnB1YmxpY0tleSgpLFxuICAgICAgcHJ2OiBwYWlyLnNlY3JldCgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRlY29kZWQgZWQyNTUxOSBwdWJsaWMga2V5IGZyb20gcmF3IGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHB1YiBSYXcgcHVibGljIGtleVxuICAgKiBAcmV0dXJucyBFbmNvZGVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGdldFB1YkZyb21SYXcocHViOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5lbmNvZGVFZDI1NTE5UHVibGljS2V5KEJ1ZmZlci5mcm9tKHB1YiwgJ2hleCcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGVjb2RlZCBlZDI1NTE5IHByaXZhdGUga2V5IGZyb20gcmF3IGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHBydiBSYXcgcHJpdmF0ZSBrZXlcbiAgICogQHJldHVybnMgRW5jb2RlZCBwcml2YXRlIGtleVxuICAgKi9cbiAgZ2V0UHJ2RnJvbVJhdyhwcnY6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuU3RyS2V5LmVuY29kZUVkMjU1MTlTZWNyZXRTZWVkKEJ1ZmZlci5mcm9tKHBydiwgJ2hleCcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW4uXG4gICAqXG4gICAqIEBwYXJhbSBwdWIgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzdGVsbGFyLlN0cktleS5pc1ZhbGlkRWQyNTUxOVB1YmxpY0tleShwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwcml2YXRlIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5U2VjcmV0U2VlZChwcnYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIG1lbW8gaWQgaXMgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIG1lbW9JZCBtZW1vIGlkXG4gICAqIEByZXR1cm5zIHRydWUgaWYgbWVtbyBpZCBpcyB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZE1lbW9JZChtZW1vSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGxldCBtZW1vSWROdW1iZXI7XG4gICAgdHJ5IHtcbiAgICAgIHN0ZWxsYXIuTWVtby5pZChtZW1vSWQpOyAvLyB0aHJvd3MgaWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZCBtZW1vIGlkXG4gICAgICBtZW1vSWROdW1iZXIgPSBuZXcgQmlnTnVtYmVyKG1lbW9JZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vSWROdW1iZXIuZ3RlKDApICYmIG1lbW9JZE51bWJlci5sdChYbG0ubWF4TWVtb0lkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgd2hldGhlciBhIG1lbW8gaXMgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIHRoZSBtZW1vXG4gICAqIEBwYXJhbSB0eXBlIHR5cGUgb2YgdGhlIG1lbW9cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBhbmQgdHlwZSBhcmUgYSB2YWxpZFxuICAgKi9cbiAgaXNWYWxpZE1lbW8oeyB2YWx1ZSwgdHlwZSB9OiBNZW1vKTogYm9vbGVhbiB7XG4gICAgaWYgKCF2YWx1ZSB8fCAhdHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQgZm9yIHRoZSB0eXBlXG4gICAgICAvLyB2YWxpZCB0eXBlcyBhcmU6ICdpZCcsICd0ZXh0JywgJ2hhc2gnLCAncmV0dXJuJ1xuICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnN0ZWxsYXIub3JnL2RldmVsb3BlcnMvZ3VpZGVzL2NvbmNlcHRzL3RyYW5zYWN0aW9ucy5odG1sI21lbW9cbiAgICAgIHN0ZWxsYXIuTWVtb1t0eXBlXSh2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgaW5zdGFuY2Ugb2Ygc3RlbGxhci5NdXhlZEFjY291bnQgZnJvbSBNIGFkZHJlc3NcbiAgICogU2VlOiBodHRwczovL2RldmVsb3BlcnMuc3RlbGxhci5vcmcvZG9jcy9nbG9zc2FyeS9tdXhlZC1hY2NvdW50c1xuICAgKi9cbiAgZ2V0TXV4ZWRBY2NvdW50KGFkZHJlc3M6IHN0cmluZyk6IHN0ZWxsYXIuTXV4ZWRBY2NvdW50IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN0ZWxsYXIuTXV4ZWRBY2NvdW50LmZyb21BZGRyZXNzKGFkZHJlc3MsICcwJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG11eGVkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGEgbXV4ZWQgYWRkcmVzcyBpcyB2YWxpZFxuICAgKiBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVycy5zdGVsbGFyLm9yZy9kb2NzL2dsb3NzYXJ5L211eGVkLWFjY291bnRzXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNWYWxpZE11eGVkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIV8uaXNTdHJpbmcoYWRkcmVzcykgfHwgIWFkZHJlc3Muc3RhcnRzV2l0aCgnTScpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHJldHVybiB0cnVlIGlmIG11eGVkIGFjY291bnQgaXMgdmFsaWQgb3IgdGhyb3dcbiAgICAgIHJldHVybiAhIXN0ZWxsYXIuTXV4ZWRBY2NvdW50LmZyb21BZGRyZXNzKGFkZHJlc3MsICcwJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNaW5pbXVtIGJhbGFuY2Ugb2YgYSAyLW9mLTMgbXVsdGlzaWcgd2FsbGV0XG4gICAqIEByZXR1cm5zIG1pbmltdW0gYmFsYW5jZSBpbiBzdHJvb3BzXG4gICAqL1xuICBhc3luYyBnZXRNaW5pbXVtUmVzZXJ2ZSgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IHNlcnZlciA9IG5ldyBzdGVsbGFyLlNlcnZlcih0aGlzLmdldEhvcml6b25VcmwoKSk7XG5cbiAgICBjb25zdCBob3Jpem9uTGVkZ2VySW5mbyA9IGF3YWl0IHNlcnZlci5sZWRnZXJzKCkub3JkZXIoJ2Rlc2MnKS5saW1pdCgxKS5jYWxsKCk7XG5cbiAgICBpZiAoIWhvcml6b25MZWRnZXJJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBjb25uZWN0IHRvIEhvcml6b24gZm9yIHJlc2VydmUgcmVxdWlyZW1lbnQgZGF0YScpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhc2VSZXNlcnZlID0gaG9yaXpvbkxlZGdlckluZm8ucmVjb3Jkc1swXS5iYXNlX3Jlc2VydmVfaW5fc3Ryb29wcztcblxuICAgIC8vIDItb2YtMyB3YWxsZXRzIGhhdmUgYSBtaW5pbXVtIHJlc2VydmUgb2YgNXggdGhlIGJhc2UgcmVzZXJ2ZVxuICAgIHJldHVybiA1ICogYmFzZVJlc2VydmU7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNhY3Rpb24gZmVlIGZvciBlYWNoIG9wZXJhdGlvblxuICAgKiBAcmV0dXJucyB0cmFuc2FjdGlvbiBmZWUgaW4gc3Ryb29wc1xuICAgKi9cbiAgYXN5bmMgZ2V0QmFzZVRyYW5zYWN0aW9uRmVlKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3Qgc2VydmVyID0gbmV3IHN0ZWxsYXIuU2VydmVyKHRoaXMuZ2V0SG9yaXpvblVybCgpKTtcblxuICAgIGNvbnN0IGhvcml6b25MZWRnZXJJbmZvID0gYXdhaXQgc2VydmVyLmxlZGdlcnMoKS5vcmRlcignZGVzYycpLmxpbWl0KDEpLmNhbGwoKTtcblxuICAgIGlmICghaG9yaXpvbkxlZGdlckluZm8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGNvbm5lY3QgdG8gSG9yaXpvbiBmb3IgcmVzZXJ2ZSByZXF1aXJlbWVudCBkYXRhJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvcml6b25MZWRnZXJJbmZvLnJlY29yZHNbMF0uYmFzZV9mZWVfaW5fc3Ryb29wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGFkZHJlc3MgaW50byBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGFkZHJlc3MgYW5kIG1lbW8gaWRcbiAgICovXG4gIGdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3M6IHN0cmluZyk6IEFkZHJlc3NEZXRhaWxzIHtcbiAgICBpZiAoYWRkcmVzcy5zdGFydHNXaXRoKCdNJykpIHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRNdXhlZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgY29uc3QgbXV4ZWRBY2NvdW50ID0gdGhpcy5nZXRNdXhlZEFjY291bnQoYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmFzZUFkZHJlc3M6IG11eGVkQWNjb3VudC5iYXNlQWNjb3VudCgpLmFjY291bnRJZCgpLFxuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgaWQ6IG11eGVkQWNjb3VudC5pZCgpLFxuICAgICAgICAgIG1lbW9JZDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgbXV4ZWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRlc3RpbmF0aW9uRGV0YWlscyA9IHVybC5wYXJzZShhZGRyZXNzKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3MgPSBkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWUgfHwgJyc7XG4gICAgaWYgKCFkZXN0aW5hdGlvbkFkZHJlc3MgfHwgIXN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIC8vIGFkZHJlc3MgZG9lc24ndCBoYXZlIGEgbWVtbyBpZFxuICAgIGlmIChkZXN0aW5hdGlvbkRldGFpbHMucGF0aG5hbWUgPT09IGFkZHJlc3MpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VBZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICBpZDogdW5kZWZpbmVkLFxuICAgICAgICBtZW1vSWQ6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeURldGFpbHMgPSBxdWVyeXN0cmluZy5wYXJzZShkZXN0aW5hdGlvbkRldGFpbHMucXVlcnkpO1xuICAgIGlmICghcXVlcnlEZXRhaWxzLm1lbW9JZCkge1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgcHJvcGVydGllcywgdGhlIHF1ZXJ5IGRldGFpbHMgbmVlZCB0byBjb250YWluIHRoZSBtZW1vIGlkIHByb3BlcnR5XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocXVlcnlEZXRhaWxzLm1lbW9JZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKFxuICAgICAgICBgbWVtb0lkIG1heSBvbmx5IGJlIGdpdmVuIGF0IG1vc3Qgb25jZSwgYnV0IGZvdW5kICR7cXVlcnlEZXRhaWxzLm1lbW9JZC5sZW5ndGh9IGluc3RhbmNlcyBpbiBhZGRyZXNzICR7YWRkcmVzc31gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpICYmIHF1ZXJ5RGV0YWlscy5tZW1vSWQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAvLyB2YWxpZCBhZGRyZXNzZXMgY2FuIG9ubHkgY29udGFpbiBvbmUgbWVtbyBpZFxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzcyAnJHthZGRyZXNzfScsIG11c3QgY29udGFpbiBleGFjdGx5IG9uZSBtZW1vSWRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBbbWVtb0lkXSA9IF8uY2FzdEFycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpIHx8IHVuZGVmaW5lZDtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZE1lbW9JZChtZW1vSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZE1lbW9JZEVycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICcke2FkZHJlc3N9JywgbWVtb0lkIGlzIG5vdCB2YWxpZGApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlQWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgaWQ6IHVuZGVmaW5lZCxcbiAgICAgIG1lbW9JZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGFuZCByZXR1cm4gYWRkcmVzcyB3aXRoIGFwcGVuZGVkIG1lbW8gaWQgb3IgbXV4ZWQgYWRkcmVzc1xuICAgKlxuICAgKiBAcGFyYW0gYWRkcmVzcyBhZGRyZXNzXG4gICAqIEBwYXJhbSBtZW1vSWQgbWVtbyBpZFxuICAgKiBAcmV0dXJucyBhZGRyZXNzIHdpdGggbWVtbyBpZFxuICAgKi9cbiAgbm9ybWFsaXplQWRkcmVzcyh7IGFkZHJlc3MsIG1lbW9JZCB9OiBBZGRyZXNzRGV0YWlscyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZE11eGVkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfVxuICAgIGlmICghc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhZGRyZXNzIGRldGFpbHM6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gICAgaWYgKG1lbW9JZCAmJiB0aGlzLmlzVmFsaWRNZW1vSWQobWVtb0lkKSkge1xuICAgICAgcmV0dXJuIGAke2FkZHJlc3N9P21lbW9JZD0ke21lbW9JZH1gO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIGlzIGl0IHZhbGlkP1xuICAgKi9cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICAgIHJldHVybiBhZGRyZXNzID09PSB0aGlzLm5vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzc0RldGFpbHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgU3RlbGxhciBBc3NldCBpbiBjb2luOnRva2VuIGZvcm0gKGkuZS4gKHQpeGxtOjxjb2RlPi08aXNzdWVyPilcbiAgICogSWYgdGhlIGFzc2V0IGlzIFhMTSwgcmV0dXJuIHRoZSBjaGFpblxuICAgKiBAcGFyYW0ge3N0ZWxsYXIuQXNzZXR9IGFzc2V0IC0gaW5zdGFuY2Ugb2YgU3RlbGxhciBBc3NldFxuICAgKi9cbiAgZ2V0VG9rZW5OYW1lRnJvbVN0ZWxsYXJBc3NldChhc3NldDogc3RlbGxhci5Bc3NldCk6IHN0cmluZyB7XG4gICAgY29uc3QgY29kZSA9IGFzc2V0LmdldENvZGUoKTtcbiAgICBjb25zdCBpc3N1ZXIgPSBhc3NldC5nZXRJc3N1ZXIoKTtcbiAgICBpZiAoYXNzZXQuaXNOYXRpdmUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hhaW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RoaXMuZ2V0Q2hhaW4oKX0ke0Jhc2VDb2luLmNvaW5Ub2tlblBhdHRlcm5TZXBhcmF0b3J9JHtjb2RlfSR7WGxtLnRva2VuUGF0dGVyblNlcGFyYXRvcn0ke2lzc3Vlcn1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHdoZXRoZXIgYSBzdGVsbGFyIHVzZXJuYW1lIGhhcyB2YWxpZCBmb3JtYXRcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCBieSB0aGUgY2xpZW50IHdoZW4gYSBzdGVsbGFyIGFkZHJlc3MgaXMgYmVpbmcgYWRkZWQgdG8gYSB3YWxsZXRcbiAgICogRXhhbXBsZSBvZiBhIGNvbW1vbiBzdGVsbGFyIHVzZXJuYW1lOiBmb29AYmFyLmJhelxuICAgKiBUaGUgYWJvdmUgZXhhbXBsZSB3b3VsZCByZXN1bHQgaW4gdGhlIFN0ZWxsYXIgYWRkcmVzczogZm9vQGJhci5iYXoqYml0Z28uY29tXG4gICAqXG4gICAqIEBwYXJhbSB1c2VybmFtZSAtIHN0ZWxsYXIgdXNlcm5hbWVcbiAgICogQHJldHVybiB0cnVlIGlmIHN0ZWxsYXIgdXNlcm5hbWUgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRTdGVsbGFyVXNlcm5hbWUodXNlcm5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvXlthLXowLTlcXC1fLitAXSskLy50ZXN0KHVzZXJuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gaW5zdGFuY2Ugb2YgRmVkZXJhdGlvblNlcnZlciBmb3IgQml0R28gbG9va3Vwc1xuICAgKlxuICAgKiBAcmV0dXJucyBpbnN0YW5jZSBvZiBCaXRHbyBGZWRlcmF0aW9uIFNlcnZlclxuICAgKi9cbiAgZ2V0Qml0R29GZWRlcmF0aW9uU2VydmVyKCk6IHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlciB7XG4gICAgLy8gSWRlbnRpZnkgdGhlIFVSSSBzY2hlbWUgaW4gY2FzZSB3ZSBuZWVkIHRvIGFsbG93IGNvbm5lY3RpbmcgdG8gSFRUUCBzZXJ2ZXIuXG4gICAgY29uc3QgaXNOb25TZWN1cmVFbnYgPSAhXy5zdGFydHNXaXRoKGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5lbnZdLnVyaSwgJ2h0dHBzJyk7XG4gICAgY29uc3QgZmVkZXJhdGlvblNlcnZlck9wdGlvbnMgPSB7IGFsbG93SHR0cDogaXNOb25TZWN1cmVFbnYgfTtcbiAgICByZXR1cm4gbmV3IHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlcih0aGlzLmdldEZlZGVyYXRpb25TZXJ2ZXJVcmwoKSwgJ2JpdGdvLmNvbScsIGZlZGVyYXRpb25TZXJ2ZXJPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGZlZGVyYXRpb24gbG9va3Vwc1xuICAgKiBPdXIgZmVkZXJhdGlvbiBzZXJ2ZXIgaGFuZGxlcyBsb29rdXBzIGZvciBiaXRnbyBhcyB3ZWxsIGFzIGZvciBvdGhlciBmZWRlcmF0aW9uIGRvbWFpbnNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFthZGRyZXNzXSAtIGFkZHJlc3MgdG8gbG9vayB1cFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FjY291bnRJZF0gLSBhY2NvdW50IGlkIHRvIGxvb2sgdXBcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmVkZXJhdGlvbkxvb2t1cCh7XG4gICAgYWRkcmVzcyxcbiAgICBhY2NvdW50SWQsXG4gIH06IHtcbiAgICBhZGRyZXNzPzogc3RyaW5nO1xuICAgIGFjY291bnRJZD86IHN0cmluZztcbiAgfSk6IFByb21pc2U8c3RlbGxhci5GZWRlcmF0aW9uU2VydmVyLlJlY29yZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBmZWRlcmF0aW9uU2VydmVyID0gdGhpcy5nZXRCaXRHb0ZlZGVyYXRpb25TZXJ2ZXIoKTtcbiAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmZWRlcmF0aW9uU2VydmVyLnJlc29sdmVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgfSBlbHNlIGlmIChhY2NvdW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZlZGVyYXRpb25TZXJ2ZXIucmVzb2x2ZUFjY291bnRJZChhY2NvdW50SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFyZ3VtZW50IC0gbXVzdCBwcm92aWRlIFN0ZWxsYXIgYWRkcmVzcyBvciBhY2NvdW50IGlkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyb3IgPSBfLmdldChlLCAncmVzcG9uc2UuZGF0YS5kZXRhaWwnKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgU3RlbGxhckZlZGVyYXRpb25Vc2VyTm90Rm91bmRFcnJvcihlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHJlc29sdmUgYSBzdGVsbGFyIGFkZHJlc3MgaW50byBhIHN0ZWxsYXIgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIHN0ZWxsYXIgYWRkcmVzcyB0byBsb29rIGZvclxuICAgKi9cbiAgYXN5bmMgZmVkZXJhdGlvbkxvb2t1cEJ5TmFtZShhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+IHtcbiAgICBpZiAoIWFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTdGVsbGFyIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5mZWRlcmF0aW9uTG9va3VwKHsgYWRkcmVzcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHJlc29sdmUgYW4gYWNjb3VudCBpZCBpbnRvIGEgc3RlbGxhciBhY2NvdW50XG4gICAqIE9ubHkgd29ya3MgZm9yIGFjY291bnRzIHRoYXQgY2FuIGJlIHJlc29sdmVkIGJ5IG91ciBmZWRlcmF0aW9uIHNlcnZlclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIC0gc3RlbGxhciBhY2NvdW50IGlkXG4gICAqL1xuICBhc3luYyBmZWRlcmF0aW9uTG9va3VwQnlBY2NvdW50SWQoYWNjb3VudElkOiBzdHJpbmcpOiBQcm9taXNlPHN0ZWxsYXIuRmVkZXJhdGlvblNlcnZlci5SZWNvcmQ+IHtcbiAgICBpZiAoIWFjY291bnRJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFN0ZWxsYXIgYWNjb3VudCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mZWRlcmF0aW9uTG9va3VwKHsgYWNjb3VudElkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFkZHJlc3MgaXMgYSB2YWxpZCBYTE0gYWRkcmVzcywgYW5kIHRoZW4gbWFrZSBzdXJlIGl0IG1hdGNoZXMgdGhlIHJvb3QgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3Mge1N0cmluZ30gdGhlIGFkZHJlc3MgdG8gdmVyaWZ5XG4gICAqIEBwYXJhbSByb290QWRkcmVzcyB7U3RyaW5nfSB0aGUgd2FsbGV0J3Mgcm9vdCBhZGRyZXNzXG4gICAqL1xuICBhc3luYyBpc1dhbGxldEFkZHJlc3MoeyBhZGRyZXNzLCByb290QWRkcmVzcyB9OiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICBjb25zdCByb290QWRkcmVzc0RldGFpbHMgPSB0aGlzLmdldEFkZHJlc3NEZXRhaWxzKHJvb3RBZGRyZXNzKTtcbiAgICBpZiAoYWRkcmVzc0RldGFpbHMuYmFzZUFkZHJlc3MgIT09IHJvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihcbiAgICAgICAgYGFkZHJlc3MgdmFsaWRhdGlvbiBmYWlsdXJlOiAke2FkZHJlc3NEZXRhaWxzLmJhc2VBZGRyZXNzfSB2cyAke3Jvb3RBZGRyZXNzRGV0YWlscy5hZGRyZXNzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGV4dHJhIHBhcmFtZXRlcnMgZm9yIHByZWJ1aWxkaW5nIGEgdHhcbiAgICogU2V0IGVtcHR5IHJlY2lwaWVudHMgYXJyYXkgaW4gdHJ1c3RsaW5lIHR4c1xuICAgKi9cbiAgYXN5bmMgZ2V0RXh0cmFQcmVidWlsZFBhcmFtcyhidWlsZFBhcmFtczogRXh0cmFQcmVidWlsZFBhcmFtc09wdGlvbnMpOiBQcm9taXNlPEJ1aWxkT3B0aW9ucz4ge1xuICAgIGNvbnN0IHBhcmFtczogeyByZWNpcGllbnRzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPltdIH0gPSB7fTtcbiAgICBpZiAoYnVpbGRQYXJhbXMudHlwZSA9PT0gJ3RydXN0bGluZScpIHtcbiAgICAgIHBhcmFtcy5yZWNpcGllbnRzID0gW107XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGluaXRpYXRlUmVjb3ZlcnkocGFyYW1zOiBSZWNvdmVyeU9wdGlvbnMpOiBuZXZlciB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkZXByZWNhdGVkIG1ldGhvZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiAtIHVzZXJLZXk6IFtlbmNyeXB0ZWRdIFN0ZWxsYXIgcHJpdmF0ZSBrZXlcbiAgICogLSBiYWNrdXBLZXk6IFtlbmNyeXB0ZWRdIFN0ZWxsYXIgcHJpdmF0ZSBrZXksIG9yIHB1YmxpYyBrZXkgaWYgdGhlIHByaXZhdGUga2V5IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAgICogLSB3YWxsZXRQYXNzcGhyYXNlOiBuZWNlc3NhcnkgaWYgb25lIG9mIHRoZSBwcml2YXRlIGtleXMgaXMgZW5jcnlwdGVkXG4gICAqIC0gcm9vdEFkZHJlc3M6IGJhc2UgYWRkcmVzcyBvZiB0aGUgd2FsbGV0IHRvIHJlY292ZXIgZnVuZHMgZnJvbVxuICAgKiAtIGtyc1Byb3ZpZGVyOiBuZWNlc3NhcnkgaWYgYmFja3VwIGtleSBpcyBoZWxkIGJ5IEtSU1xuICAgKiAtIHJlY292ZXJ5RGVzdGluYXRpb246IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxSZWNvdmVyeVRyYW5zYWN0aW9uPiB7XG4gICAgLy8gU3RlbGxhcidzIEVkMjU1MTkgcHVibGljIGtleXMgc3RhcnQgd2l0aCBhIEcsIHdoaWxlIHByaXZhdGUga2V5cyBzdGFydCB3aXRoIGFuIFNcbiAgICBjb25zdCBpc0tyc1JlY292ZXJ5ID0gcGFyYW1zLmJhY2t1cEtleS5zdGFydHNXaXRoKCdHJykgJiYgIXBhcmFtcy51c2VyS2V5LnN0YXJ0c1dpdGgoJ0cnKTtcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBwYXJhbXMuYmFja3VwS2V5LnN0YXJ0c1dpdGgoJ0cnKSAmJiBwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCdHJyk7XG5cbiAgICBpZiAoaXNLcnNSZWNvdmVyeSkge1xuICAgICAgY2hlY2tLcnNQcm92aWRlcih0aGlzLCBwYXJhbXMua3JzUHJvdmlkZXIpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCdJbnZhbGlkIGRlc3RpbmF0aW9uIGFkZHJlc3MhJyk7XG4gICAgfVxuXG4gICAgY29uc3QgW3VzZXJLZXksIGJhY2t1cEtleV0gPSBnZXRTdGVsbGFyS2V5cyh0aGlzLmJpdGdvLCBwYXJhbXMpO1xuXG4gICAgaWYgKCFwYXJhbXMucm9vdEFkZHJlc3MgfHwgIXN0ZWxsYXIuU3RyS2V5LmlzVmFsaWRFZDI1NTE5UHVibGljS2V5KHBhcmFtcy5yb290QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB3YWxsZXQgYWRkcmVzczogJHtwYXJhbXMucm9vdEFkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudERhdGFVcmwgPSBgJHt0aGlzLmdldEhvcml6b25VcmwoKX0vYWNjb3VudHMvJHtwYXJhbXMucm9vdEFkZHJlc3N9YDtcbiAgICBjb25zdCBkZXN0aW5hdGlvblVybCA9IGAke3RoaXMuZ2V0SG9yaXpvblVybCgpfS9hY2NvdW50cy8ke3BhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9ufWA7XG5cbiAgICBsZXQgYWNjb3VudERhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGFjY291bnREYXRhID0gYXdhaXQgdG9CaXRnb1JlcXVlc3QocmVxdWVzdC5nZXQoYWNjb3VudERhdGFVcmwpKS5yZXN1bHQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZWFjaCB0aGUgU3RlbGxhciBuZXR3b3JrIHZpYSBIb3Jpem9uLicpO1xuICAgIH1cblxuICAgIC8vIE5vdyBjaGVjayBpZiB0aGUgZGVzdGluYXRpb24gYWNjb3VudCBpcyBlbXB0eSBvciBub3RcbiAgICBsZXQgdW5mdW5kZWREZXN0aW5hdGlvbiA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCByZXF1ZXN0LmdldChkZXN0aW5hdGlvblVybCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGRlc3RpbmF0aW9uIGFjY291bnQgZG9lcyBub3QgeWV0IGV4aXN0LCBob3Jpem9uIHJlc3BvbmRzIHdpdGggNDA0XG4gICAgICAgIHVuZnVuZGVkRGVzdGluYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYWNjb3VudERhdGEuc2VxdWVuY2UgfHwgIWFjY291bnREYXRhLmJhbGFuY2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hvcml6b24gc2VydmVyIGVycm9yIC0gdW5hYmxlIHRvIHJldHJpZXZlIHNlcXVlbmNlIElEIG9yIGFjY291bnQgYmFsYW5jZScpO1xuICAgIH1cblxuICAgIGNvbnN0IGFjY291bnQgPSBuZXcgc3RlbGxhci5BY2NvdW50KHBhcmFtcy5yb290QWRkcmVzcywgYWNjb3VudERhdGEuc2VxdWVuY2UpO1xuXG4gICAgLy8gU3RlbGxhciBzdXBwb3J0cyBtdWx0aXBsZSBhc3NldHMgb24gY2hhaW4sIHdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgYmFsYW5jZXMgZW50cnkgd2hvc2UgdHlwZSBpcyBcIm5hdGl2ZVwiIChYTE0pXG4gICAgY29uc3QgbmF0aXZlQmFsYW5jZUluZm8gPSBhY2NvdW50RGF0YS5iYWxhbmNlcy5maW5kKChhc3NldEJhbGFuY2UpID0+IGFzc2V0QmFsYW5jZVsnYXNzZXRfdHlwZSddID09PSAnbmF0aXZlJyk7XG5cbiAgICBpZiAoIW5hdGl2ZUJhbGFuY2VJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHdhbGxldCBoYXMgYSBiYWxhbmNlIG9mIDAgWExNLCByZWNvdmVyeSBhYm9ydGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgd2FsbGV0QmFsYW5jZSA9IE51bWJlcih0aGlzLmJpZ1VuaXRzVG9CYXNlVW5pdHMobmF0aXZlQmFsYW5jZUluZm8uYmFsYW5jZSkpO1xuICAgIGNvbnN0IG1pbmltdW1SZXNlcnZlID0gYXdhaXQgdGhpcy5nZXRNaW5pbXVtUmVzZXJ2ZSgpO1xuICAgIGNvbnN0IGJhc2VUeEZlZSA9IGF3YWl0IHRoaXMuZ2V0QmFzZVRyYW5zYWN0aW9uRmVlKCk7XG4gICAgY29uc3QgcmVjb3ZlcnlBbW91bnQgPSB3YWxsZXRCYWxhbmNlIC0gbWluaW11bVJlc2VydmUgLSBiYXNlVHhGZWU7XG4gICAgY29uc3QgZm9ybWF0dGVkUmVjb3ZlcnlBbW91bnQgPSB0aGlzLmJhc2VVbml0c1RvQmlnVW5pdHMocmVjb3ZlcnlBbW91bnQpLnRvU3RyaW5nKCk7XG5cbiAgICBjb25zdCB0eEJ1aWxkZXIgPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbkJ1aWxkZXIoYWNjb3VudCwge1xuICAgICAgZmVlOiBiYXNlVHhGZWUudG9GaXhlZCgwKSxcbiAgICAgIG5ldHdvcmtQYXNzcGhyYXNlOiB0aGlzLmdldFN0ZWxsYXJOZXR3b3JrKCksXG4gICAgfSk7XG4gICAgY29uc3Qgb3BlcmF0aW9uID0gdW5mdW5kZWREZXN0aW5hdGlvblxuICAgICAgPyAvLyBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBhY2NvdW50XG4gICAgICAgIHN0ZWxsYXIuT3BlcmF0aW9uLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICAgIGRlc3RpbmF0aW9uOiBwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbixcbiAgICAgICAgICBzdGFydGluZ0JhbGFuY2U6IGZvcm1hdHRlZFJlY292ZXJ5QW1vdW50LFxuICAgICAgICB9KVxuICAgICAgOiAvLyBPdGhlcndpc2UgaWYgdGhlIGFjY291bnQgYWxyZWFkeSBleGlzdHMsIHdlIGRvIGEgbm9ybWFsIHNlbmRcbiAgICAgICAgc3RlbGxhci5PcGVyYXRpb24ucGF5bWVudCh7XG4gICAgICAgICAgZGVzdGluYXRpb246IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLFxuICAgICAgICAgIGFzc2V0OiBzdGVsbGFyLkFzc2V0Lm5hdGl2ZSgpLFxuICAgICAgICAgIGFtb3VudDogZm9ybWF0dGVkUmVjb3ZlcnlBbW91bnQsXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHR4ID0gdHhCdWlsZGVyLmFkZE9wZXJhdGlvbihvcGVyYXRpb24pLnNldFRpbWVvdXQoc3RlbGxhci5UaW1lb3V0SW5maW5pdGUpLmJ1aWxkKCk7XG5cbiAgICBpZiAoIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgdHguc2lnbih1c2VyS2V5KTtcbiAgICB9XG5cbiAgICBpZiAoIWlzS3JzUmVjb3ZlcnkgJiYgIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgdHguc2lnbihiYWNrdXBLZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBSZWNvdmVyeVRyYW5zYWN0aW9uID0ge1xuICAgICAgdHg6IFhsbS50eFRvU3RyaW5nKHR4KSxcbiAgICAgIHJlY292ZXJ5QW1vdW50LFxuICAgIH07XG5cbiAgICBpZiAoaXNLcnNSZWNvdmVyeSkge1xuICAgICAgdHJhbnNhY3Rpb24uYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleTtcbiAgICAgIHRyYW5zYWN0aW9uLmNvaW4gPSB0aGlzLmdldENoYWluKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnR4UHJlYnVpbGQge09iamVjdH0gcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHVzZXIgcHJ2XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEhhbGZTaWduZWRUcmFuc2FjdGlvbj59XG4gICAqL1xuICBhc3luYyBzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxIYWxmU2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCB7IHR4UHJlYnVpbGQsIHBydiB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhQcmVidWlsZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB0eFByZWJ1aWxkIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNPYmplY3QodHhQcmVidWlsZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHhQcmVidWlsZCBtdXN0IGJlIGFuIG9iamVjdCwgZ290IHR5cGUgJHt0eXBlb2YgdHhQcmVidWlsZH1gKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGlmICghXy5pc1N0cmluZyhwcnYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHBydiBtdXN0IGJlIGEgc3RyaW5nLCBnb3QgdHlwZSAke3R5cGVvZiBwcnZ9YCk7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5UGFpciA9IHN0ZWxsYXIuS2V5cGFpci5mcm9tU2VjcmV0KHBydik7XG4gICAgY29uc3QgdHggPSBuZXcgc3RlbGxhci5UcmFuc2FjdGlvbih0eFByZWJ1aWxkLnR4QmFzZTY0LCB0aGlzLmdldFN0ZWxsYXJOZXR3b3JrKCkpO1xuICAgIHR4LnNpZ24oa2V5UGFpcik7XG4gICAgY29uc3QgdHhCYXNlNjQgPSBYbG0udHhUb1N0cmluZyh0eCk7XG5cbiAgICBjb25zdCB0eXBlID0gdHhQcmVidWlsZD8uYnVpbGRQYXJhbXM/LnR5cGU7XG4gICAgY29uc3QgcmVjaXBpZW50cyA9IHR4UHJlYnVpbGQ/LmJ1aWxkUGFyYW1zPy5yZWNpcGllbnRzO1xuICAgIGlmICh0eXBlID09PSAnZW5hYmxldG9rZW4nKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYWxmU2lnbmVkOiB7IHR4QmFzZTY0IH0sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJlY2lwaWVudHMsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHR4QmFzZTY0IH0gfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kIHdhbGxldFBhcmFtcyB3aXRoIGV4dHJhIHBhcmFtcyByZXF1aXJlZCBmb3IgZ2VuZXJhdGluZyBhbiBYTE0gd2FsbGV0XG4gICAqXG4gICAqIFN0ZWxsYXIgd2FsbGV0cyBoYXZlIHRocmVlIGtleWNoYWlucyBvbiB0aGVtLiBUd28gYXJlIGdlbmVyYXRlZCBieSB0aGUgcGxhdGZvcm0sIGFuZCB0aGUgbGFzdCBpcyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXIuXG4gICAqIEluaXRpYWxseSwgd2UgbmVlZCBhIHJvb3QgcHJ2IHRvIGdlbmVyYXRlIHRoZSBhY2NvdW50LCB3aGljaCBtdXN0IGJlIGRpc3RpbmN0IGZyb20gYWxsIHRocmVlIGtleWNoYWlucyBvbiB0aGUgd2FsbGV0LlxuICAgKiBJZiBhIHJvb3QgcHJ2IGlzIG5vdCBwcm92aWRlZCwgYSByYW5kb20gb25lIGlzIGdlbmVyYXRlZC5cbiAgICovXG4gIGFzeW5jIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldChcbiAgICB3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnNcbiAgKTogUHJvbWlzZTxTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zPiB7XG4gICAgbGV0IHNlZWQ7XG4gICAgY29uc3Qgcm9vdFBydiA9IHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleTtcbiAgICBpZiAocm9vdFBydikge1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRQcnYocm9vdFBydikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyb290UHJpdmF0ZUtleSBuZWVkcyB0byBiZSB2YWxpZCBlZDI1NTE5IHNlY3JldCBzZWVkJyk7XG4gICAgICB9XG4gICAgICBzZWVkID0gc3RlbGxhci5TdHJLZXkuZGVjb2RlRWQyNTUxOVNlY3JldFNlZWQocm9vdFBydik7XG4gICAgfVxuICAgIGNvbnN0IGtleVBhaXIgPSB0aGlzLmdlbmVyYXRlS2V5UGFpcihzZWVkKTtcbiAgICAvLyBleHRlbmQgdGhlIHdhbGxldCBpbml0aWFsaXphdGlvbiBwYXJhbXNcbiAgICB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkgPSBrZXlQYWlyLnBydjtcbiAgICByZXR1cm4gd2FsbGV0UGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZFBydihrZXkucHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHBydjogJHtrZXkucHJ2fWApO1xuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBrZXlwYWlyID0gc3RlbGxhci5LZXlwYWlyLmZyb21TZWNyZXQoa2V5LnBydik7XG4gICAgcmV0dXJuIGtleXBhaXIuc2lnbihtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyBpZiBzaWduYXR1cmUgZm9yIG1lc3NhZ2UgaXMgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSBwdWIgcHVibGljIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZSBzaWduZWQgbWVzc2FnZVxuICAgKiBAcGFyYW0gc2lnbmF0dXJlIHNpZ25hdHVyZSB0byB2ZXJpZnlcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBzaWduYXR1cmUgaXMgdmFsaWQuXG4gICAqL1xuICB2ZXJpZnlTaWduYXR1cmUocHViOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlciwgc2lnbmF0dXJlOiBCdWZmZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZFB1YihwdWIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcHViOiAke3B1Yn1gKTtcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobWVzc2FnZSkpIHtcbiAgICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3Qga2V5UGFpciA9IHN0ZWxsYXIuS2V5cGFpci5mcm9tUHVibGljS2V5KHB1Yik7XG4gICAgcmV0dXJuIGtleVBhaXIudmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbi9wYXJzZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgY29uc3QgeyB0eEhleCwgdHhCYXNlNjQgfSA9IHBhcmFtcztcbiAgICBsZXQgdHg6IHN0ZWxsYXIuVHJhbnNhY3Rpb24gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXR4SGV4ICYmICF0eEJhc2U2NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBsYWluVHJhbnNhY3Rpb24gbWlzc2luZyB0eEhleCBvciB0eEJhc2U2NCBwYXJhbWV0ZXIsIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR4SGV4KSB7XG4gICAgICAgIHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24oQnVmZmVyLmZyb20odHhIZXgsICdoZXgnKS50b1N0cmluZygnYmFzZTY0JyksIHRoaXMuZ2V0U3RlbGxhck5ldHdvcmsoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR4QmFzZTY0KSB7XG4gICAgICAgIHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24odHhCYXNlNjQsIHRoaXMuZ2V0U3RlbGxhck5ldHdvcmsoKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eEJhc2U2NCBuZWVkcyB0byBiZSBhIHZhbGlkIHR4IGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHggbmVlZHMgdG8gYmUgZGVmaW5lZCBpbiBvcmRlciB0byBleHBsYWluIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gdHguaGFzaCgpLnRvU3RyaW5nKCdoZXgnKTtcblxuICAgIC8vIEluIGEgU3RlbGxhciB0eCwgdGhlIF9tZW1vIHByb3BlcnR5IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBtZXRob2RzOlxuICAgIC8vIHZhbHVlKCkgYW5kIGFybSgpIHRoYXQgcHJvdmlkZSBtZW1vIHZhbHVlIGFuZCB0eXBlLCByZXNwZWN0aXZlbHkuXG4gICAgY29uc3QgbWVtbzogVHJhbnNhY3Rpb25NZW1vID1cbiAgICAgIF8ucmVzdWx0KHR4LCAnX21lbW8udmFsdWUnKSAmJiBfLnJlc3VsdCh0eCwgJ19tZW1vLmFybScpXG4gICAgICAgID8ge1xuICAgICAgICAgICAgdmFsdWU6IChfLnJlc3VsdCh0eCwgJ19tZW1vLnZhbHVlJykgYXMgYW55KS50b1N0cmluZygpLFxuICAgICAgICAgICAgdHlwZTogXy5yZXN1bHQodHgsICdfbWVtby5hcm0nKSxcbiAgICAgICAgICB9XG4gICAgICAgIDoge307XG5cbiAgICBsZXQgc3BlbmRBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApOyAvLyBhbW91bnQgb2YgWExNIHVzZWQgaW4gWExNLW9ubHkgdHhzXG4gICAgY29uc3Qgc3BlbmRBbW91bnRzID0ge307IC8vIHRyYWNrIGJvdGggeGxtIGFuZCB0b2tlbiBhbW91bnRzXG4gICAgaWYgKF8uaXNFbXB0eSh0eC5vcGVyYXRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIG9wZXJhdGlvbnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRzOiBUcmFuc2FjdGlvbk91dHB1dFtdID0gW107XG4gICAgY29uc3Qgb3BlcmF0aW9uczogVHJhbnNhY3Rpb25PcGVyYXRpb25bXSA9IFtdOyAvLyBub24tcGF5bWVudCBvcGVyYXRpb25zXG5cbiAgICBfLmZvckVhY2godHgub3BlcmF0aW9ucywgKG9wOiBzdGVsbGFyLk9wZXJhdGlvbikgPT4ge1xuICAgICAgaWYgKG9wLnR5cGUgPT09ICdjcmVhdGVBY2NvdW50JyB8fCBvcC50eXBlID09PSAncGF5bWVudCcpIHtcbiAgICAgICAgLy8gVE9ETyBSZW1vdmUgbWVtb0lkIGZyb20gYWRkcmVzc1xuICAgICAgICAvLyBHZXQgbWVtbyB0byBhdHRhY2ggdG8gYWRkcmVzcywgaWYgdHlwZSBpcyAnaWQnXG4gICAgICAgIGNvbnN0IG1lbW9JZCA9IF8uZ2V0KG1lbW8sICd0eXBlJykgPT09ICdpZCcgJiYgIV8uZ2V0KG1lbW8sICd2YWx1ZScpID8gYD9tZW1vSWQ9JHttZW1vLnZhbHVlfWAgOiAnJztcbiAgICAgICAgbGV0IGFzc2V0O1xuICAgICAgICBpZiAob3AudHlwZSA9PT0gJ3BheW1lbnQnKSB7XG4gICAgICAgICAgaWYgKG9wLmFzc2V0LmdldEFzc2V0VHlwZSgpID09PSAnbGlxdWlkaXR5X3Bvb2xfc2hhcmVzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFzc2V0IHR5cGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXQgPSBvcC5hc3NldCBhcyBzdGVsbGFyLkFzc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2V0ID0gc3RlbGxhci5Bc3NldC5uYXRpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2luID0gdGhpcy5nZXRUb2tlbk5hbWVGcm9tU3RlbGxhckFzc2V0KGFzc2V0KTsgLy8gY29pbiBvciB0b2tlbiBpZFxuICAgICAgICBjb25zdCBvdXRwdXQ6IFRyYW5zYWN0aW9uT3V0cHV0ID0ge1xuICAgICAgICAgIGFtb3VudDogdGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKFxuICAgICAgICAgICAgKG9wIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLkNyZWF0ZUFjY291bnQpLnN0YXJ0aW5nQmFsYW5jZSB8fCAob3AgYXMgc3RlbGxhci5PcGVyYXRpb24uUGF5bWVudCkuYW1vdW50XG4gICAgICAgICAgKSxcbiAgICAgICAgICBhZGRyZXNzOiBvcC5kZXN0aW5hdGlvbiArIG1lbW9JZCxcbiAgICAgICAgICBjb2luLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChzcGVuZEFtb3VudHNbY29pbl0pKSB7XG4gICAgICAgICAgc3BlbmRBbW91bnRzW2NvaW5dID0gc3BlbmRBbW91bnRzW2NvaW5dLnBsdXMob3V0cHV0LmFtb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BlbmRBbW91bnRzW2NvaW5dID0gbmV3IEJpZ051bWJlcihvdXRwdXQuYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNzZXQuaXNOYXRpdmUoKSkge1xuICAgICAgICAgIHNwZW5kQW1vdW50ID0gc3BlbmRBbW91bnQucGx1cyhvdXRwdXQuYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXRzLnB1c2gob3V0cHV0KTtcbiAgICAgIH0gZWxzZSBpZiAob3AudHlwZSA9PT0gJ2NoYW5nZVRydXN0Jykge1xuICAgICAgICBpZiAob3AubGluZS5nZXRBc3NldFR5cGUoKSA9PT0gJ2xpcXVpZGl0eV9wb29sX3NoYXJlcycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzZXQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gb3AubGluZSBhcyBzdGVsbGFyLkFzc2V0O1xuXG4gICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogb3AudHlwZSxcbiAgICAgICAgICBjb2luOiB0aGlzLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQpLFxuICAgICAgICAgIGFzc2V0LFxuICAgICAgICAgIGxpbWl0OiB0aGlzLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3AubGltaXQpLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG91dHB1dEFtb3VudCA9IHNwZW5kQW1vdW50LnRvRml4ZWQoMCk7XG4gICAgY29uc3Qgb3V0cHV0QW1vdW50cyA9IF8ubWFwVmFsdWVzKHNwZW5kQW1vdW50cywgKGFtb3VudDogQmlnTnVtYmVyKSA9PiBhbW91bnQudG9GaXhlZCgwKSk7XG4gICAgY29uc3QgZmVlID0ge1xuICAgICAgZmVlOiBuZXcgQmlnTnVtYmVyKHR4LmZlZSkudG9GaXhlZCgwKSxcbiAgICAgIGZlZVJhdGU6IG51bGwsXG4gICAgICBzaXplOiBudWxsLFxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGxheU9yZGVyOiBbXG4gICAgICAgICdpZCcsXG4gICAgICAgICdvdXRwdXRBbW91bnQnLFxuICAgICAgICAnb3V0cHV0QW1vdW50cycsXG4gICAgICAgICdjaGFuZ2VBbW91bnQnLFxuICAgICAgICAnb3V0cHV0cycsXG4gICAgICAgICdjaGFuZ2VPdXRwdXRzJyxcbiAgICAgICAgJ2ZlZScsXG4gICAgICAgICdtZW1vJyxcbiAgICAgICAgJ29wZXJhdGlvbnMnLFxuICAgICAgXSxcbiAgICAgIGlkLFxuICAgICAgb3V0cHV0cyxcbiAgICAgIG91dHB1dEFtb3VudCxcbiAgICAgIG91dHB1dEFtb3VudHMsXG4gICAgICBjaGFuZ2VPdXRwdXRzOiBbXSxcbiAgICAgIGNoYW5nZUFtb3VudDogJzAnLFxuICAgICAgbWVtbyxcbiAgICAgIGZlZSxcbiAgICAgIG9wZXJhdGlvbnMsXG4gICAgfSBhcyBhbnk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0eCBwcmVidWlsZCdzIG9wZXJhdGlvbnMgY29tcGx5IHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKiBAcGFyYW0ge3N0ZWxsYXIuT3BlcmF0aW9ufSBvcGVyYXRpb25zIC0gdHggb3BlcmF0aW9uc1xuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUGFyYW1zfSB0eFBhcmFtcyAtIHBhcmFtcyB1c2VkIHRvIGJ1aWxkIHRoZSB0eFxuICAgKi9cbiAgdmVyaWZ5RW5hYmxlVG9rZW5UeE9wZXJhdGlvbnMob3BlcmF0aW9uczogc3RlbGxhci5PcGVyYXRpb25bXSwgdHhQYXJhbXM6IFRyYW5zYWN0aW9uUGFyYW1zKTogdm9pZCB7XG4gICAgY29uc3QgdHJ1c3RsaW5lT3BlcmF0aW9ucyA9IF8uZmlsdGVyKG9wZXJhdGlvbnMsIFsndHlwZScsICdjaGFuZ2VUcnVzdCddKSBhcyBzdGVsbGFyLk9wZXJhdGlvbi5DaGFuZ2VUcnVzdFtdO1xuICAgIGlmICh0cnVzdGxpbmVPcGVyYXRpb25zLmxlbmd0aCAhPT0gXy5nZXQodHhQYXJhbXMsICdyZWNpcGllbnRzJywgW10pLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCB0cnVzdGxpbmUgb3BlcmF0aW9ucycpO1xuICAgIH1cbiAgICBfLmZvckVhY2godHJ1c3RsaW5lT3BlcmF0aW9ucywgKG9wOiBzdGVsbGFyLk9wZXJhdGlvbikgPT4ge1xuICAgICAgaWYgKG9wLnR5cGUgIT09ICdjaGFuZ2VUcnVzdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFzc2V0IHR5cGUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcC5saW5lLmdldEFzc2V0VHlwZSgpID09PSAnbGlxdWlkaXR5X3Bvb2xfc2hhcmVzJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzZXQgdHlwZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgYXNzZXQgPSBvcC5saW5lIGFzIHN0ZWxsYXIuQXNzZXQ7XG4gICAgICBjb25zdCBvcFRva2VuID0gdGhpcy5nZXRUb2tlbk5hbWVGcm9tU3RlbGxhckFzc2V0KGFzc2V0KTtcbiAgICAgIGNvbnN0IHRva2VuVHJ1c3RsaW5lID0gXy5maW5kKHR4UGFyYW1zLnJlY2lwaWVudHMsIChyZWNpcGllbnQpID0+IHtcbiAgICAgICAgLy8gdHJ1c3RsaW5lIHBhcmFtcyB1c2UgbGltaXRzIGluIGJhc2UgdW5pdHNcbiAgICAgICAgY29uc3Qgb3BMaW1pdEJhc2VVbml0cyA9IHRoaXMuYmlnVW5pdHNUb0Jhc2VVbml0cyhvcC5saW1pdCk7XG4gICAgICAgIC8vIEVuYWJsZSB0b2tlbiBsaW1pdCBpcyBzZXQgdG8gWGxtLm1heFRydXN0bGluZUxpbWl0IGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIHJlY2lwaWVudC50b2tlbk5hbWUgPT09IG9wVG9rZW4gJiYgb3BMaW1pdEJhc2VVbml0cyA9PT0gWGxtLm1heFRydXN0bGluZUxpbWl0O1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRva2VuVHJ1c3RsaW5lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgdHJ1c3RsaW5lIHRva2VucycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSB0aGF0IGEgdHggcHJlYnVpbGQncyBvcGVyYXRpb25zIGNvbXBseSB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICogQHBhcmFtIHtzdGVsbGFyLk9wZXJhdGlvbn0gb3BlcmF0aW9ucyAtIHR4IG9wZXJhdGlvbnNcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvblBhcmFtc30gdHhQYXJhbXMgLSBwYXJhbXMgdXNlZCB0byBidWlsZCB0aGUgdHhcbiAgICovXG4gIHZlcmlmeVRydXN0bGluZVR4T3BlcmF0aW9ucyhvcGVyYXRpb25zOiBzdGVsbGFyLk9wZXJhdGlvbltdLCB0eFBhcmFtczogVHJhbnNhY3Rpb25QYXJhbXMpOiB2b2lkIHtcbiAgICBjb25zdCB0cnVzdGxpbmVPcGVyYXRpb25zID0gXy5maWx0ZXIob3BlcmF0aW9ucywgWyd0eXBlJywgJ2NoYW5nZVRydXN0J10pIGFzIHN0ZWxsYXIuT3BlcmF0aW9uLkNoYW5nZVRydXN0W107XG4gICAgaWYgKHRydXN0bGluZU9wZXJhdGlvbnMubGVuZ3RoICE9PSBfLmdldCh0eFBhcmFtcywgJ3RydXN0bGluZXMnLCBbXSkubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHRydXN0bGluZSBvcGVyYXRpb25zJyk7XG4gICAgfVxuICAgIF8uZm9yRWFjaCh0cnVzdGxpbmVPcGVyYXRpb25zLCAob3A6IHN0ZWxsYXIuT3BlcmF0aW9uKSA9PiB7XG4gICAgICBpZiAob3AudHlwZSAhPT0gJ2NoYW5nZVRydXN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXNzZXQgdHlwZScpO1xuICAgICAgfVxuICAgICAgaWYgKG9wLmxpbmUuZ2V0QXNzZXRUeXBlKCkgPT09ICdsaXF1aWRpdHlfcG9vbF9zaGFyZXMnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhc3NldCB0eXBlJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBhc3NldCA9IG9wLmxpbmUgYXMgc3RlbGxhci5Bc3NldDtcbiAgICAgIGNvbnN0IG9wVG9rZW4gPSB0aGlzLmdldFRva2VuTmFtZUZyb21TdGVsbGFyQXNzZXQoYXNzZXQpO1xuICAgICAgY29uc3QgdG9rZW5UcnVzdGxpbmUgPSBfLmZpbmQodHhQYXJhbXMudHJ1c3RsaW5lcywgKHRydXN0bGluZSkgPT4ge1xuICAgICAgICAvLyB0cnVzdGxpbmUgcGFyYW1zIHVzZSBsaW1pdHMgaW4gYmFzZSB1bml0c1xuICAgICAgICBjb25zdCBvcExpbWl0QmFzZVVuaXRzID0gdGhpcy5iaWdVbml0c1RvQmFzZVVuaXRzKG9wLmxpbWl0KTtcbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgY29uZGl0aW9ucyB0byBjaGVjayBmb3JcbiAgICAgICAgLy8gTGltaXQgd2lsbCBhbHdheXMgYmUgc2V0IGluIHRoZSBvcGVyYXRpb24sIGV2ZW4gaWYgaXQgd2FzIG9taXR0ZWQgZnJvbSB0eFBhcmFtcyBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgICAgICAvLyAxLiBBY3Rpb24gaXMgJ2FkZCcgLSBsaW1pdCBpcyBzZXQgdG8gWGxtLm1heFRydXN0bGluZUxpbWl0IGJ5IGRlZmF1bHRcbiAgICAgICAgLy8gMi4gQWN0aW9uIGlzICdyZW1vdmUnIC0gbGltaXQgaXMgc2V0IHRvICcwJ1xuICAgICAgICBjb25zdCBub0xpbWl0ID0gXy5pc1VuZGVmaW5lZCh0cnVzdGxpbmUubGltaXQpO1xuICAgICAgICBjb25zdCBhZGRUcnVzdGxpbmVXaXRoRGVmYXVsdExpbWl0ID0gdHJ1c3RsaW5lLmFjdGlvbiA9PT0gJ2FkZCcgJiYgb3BMaW1pdEJhc2VVbml0cyA9PT0gWGxtLm1heFRydXN0bGluZUxpbWl0O1xuICAgICAgICBjb25zdCByZW1vdmVUcnVzdGxpbmUgPSB0cnVzdGxpbmUuYWN0aW9uID09PSAncmVtb3ZlJyAmJiBvcExpbWl0QmFzZVVuaXRzID09PSAnMCc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdHJ1c3RsaW5lLnRva2VuID09PSBvcFRva2VuICYmXG4gICAgICAgICAgKHRydXN0bGluZS5saW1pdCA9PT0gb3BMaW1pdEJhc2VVbml0cyB8fCAobm9MaW1pdCAmJiAoYWRkVHJ1c3RsaW5lV2l0aERlZmF1bHRMaW1pdCB8fCByZW1vdmVUcnVzdGxpbmUpKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0b2tlblRydXN0bGluZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zYWN0aW9uIHByZWJ1aWxkIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkIHRydXN0bGluZSB0b2tlbnMnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgdGhhdCBhIHRyYW5zYWN0aW9uIHByZWJ1aWxkIGNvbXBsaWVzIHdpdGggdGhlIG9yaWdpbmFsIGludGVudGlvblxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0gb3B0aW9ucy50eFByZWJ1aWxkLnR4QmFzZTY0IHByZWJ1aWx0IHRyYW5zYWN0aW9uIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0gb3B0aW9ucy53YWxsZXQgd2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcGFyYW0gb3B0aW9ucy52ZXJpZmljYXRpb24gc3BlY2lmeWluZyBzb21lIHZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5kaXNhYmxlTmV0d29ya2luZyBEaXNhbGxvdyBmZXRjaGluZyBhbnkgZGF0YSBmcm9tIHRoZSBpbnRlcm5ldCBmb3IgdmVyaWZpY2F0aW9uIHB1cnBvc2VzXG4gICAqIEBwYXJhbSBvcHRpb25zLnZlcmlmaWNhdGlvbi5rZXljaGFpbnMgUGFzcyBrZXljaGFpbnMgbWFudWFsbHkgcmF0aGVyIHRoYW4gZmV0Y2hpbmcgdGhlbSBieSBpZFxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ob3B0aW9uczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gVE9ETyBCRy01NjAwIEFkZCBwYXJzZVRyYW5zYWN0aW9uIC8gaW1wcm92ZSB2ZXJpZmljYXRpb25cbiAgICBjb25zdCB7IHR4UGFyYW1zLCB0eFByZWJ1aWxkLCB3YWxsZXQsIHZlcmlmaWNhdGlvbiA9IHt9IH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGRpc2FibGVOZXR3b3JraW5nID0gISF2ZXJpZmljYXRpb24uZGlzYWJsZU5ldHdvcmtpbmc7XG5cbiAgICBpZiAoIXR4UHJlYnVpbGQudHhCYXNlNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eCBwcmVidWlsZCBwcm9wZXJ0eSB0eEJhc2U2NCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHR4ID0gbmV3IHN0ZWxsYXIuVHJhbnNhY3Rpb24odHhQcmVidWlsZC50eEJhc2U2NCwgdGhpcy5nZXRTdGVsbGFyTmV0d29yaygpKTtcblxuICAgIGlmICh0eFBhcmFtcy5yZWNpcGllbnRzICYmIHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3BlY2lmeSBtb3JlIHRoYW4gMSByZWNpcGllbnQnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVsbGFyIHR4cyBhcmUgbWFkZSB1cCBvZiBvcGVyYXRpb25zLiBXZSBvbmx5IGNhcmUgYWJvdXQgQ3JlYXRlIEFjY291bnQgYW5kIFBheW1lbnQgZm9yIHNlbmRpbmcgZnVuZHMuXG4gICAgY29uc3Qgb3V0cHV0T3BlcmF0aW9ucyA9IF8uZmlsdGVyKFxuICAgICAgdHgub3BlcmF0aW9ucyxcbiAgICAgIChvcGVyYXRpb24pID0+IG9wZXJhdGlvbi50eXBlID09PSAnY3JlYXRlQWNjb3VudCcgfHwgb3BlcmF0aW9uLnR5cGUgPT09ICdwYXltZW50J1xuICAgICk7XG5cbiAgICBpZiAodHhQYXJhbXMudHlwZSA9PT0gJ2VuYWJsZXRva2VuJykge1xuICAgICAgdGhpcy52ZXJpZnlFbmFibGVUb2tlblR4T3BlcmF0aW9ucyh0eC5vcGVyYXRpb25zLCB0eFBhcmFtcyk7XG4gICAgfSBlbHNlIGlmICh0eFBhcmFtcy50eXBlID09PSAndHJ1c3RsaW5lJykge1xuICAgICAgdGhpcy52ZXJpZnlUcnVzdGxpbmVUeE9wZXJhdGlvbnModHgub3BlcmF0aW9ucywgdHhQYXJhbXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoXy5pc0VtcHR5KG91dHB1dE9wZXJhdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgaGF2ZSBhbnkgb3BlcmF0aW9ucycpO1xuICAgICAgfVxuXG4gICAgICBfLmZvckVhY2godHhQYXJhbXMucmVjaXBpZW50cywgKGV4cGVjdGVkT3V0cHV0LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBleHBlY3RlZE91dHB1dEFkZHJlc3NEZXRhaWxzID0gdGhpcy5nZXRBZGRyZXNzRGV0YWlscyhleHBlY3RlZE91dHB1dC5hZGRyZXNzKTtcbiAgICAgICAgLy8gZm9yIG11eGVkIGFjY291bnRzLCB0aGUgZGVzdGluYXRpb24gd2lsbCBiZSB0aGUgYmFzZUFkZHJlc3NcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRPdXRwdXRBZGRyZXNzID0gZXhwZWN0ZWRPdXRwdXRBZGRyZXNzRGV0YWlscy5iYXNlQWRkcmVzcztcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0T3BlcmF0aW9uc1tpbmRleF0gYXMgc3RlbGxhci5PcGVyYXRpb24uUGF5bWVudCB8IHN0ZWxsYXIuT3BlcmF0aW9uLkNyZWF0ZUFjY291bnQ7XG4gICAgICAgIGlmIChvdXRwdXQuZGVzdGluYXRpb24gIT09IGV4cGVjdGVkT3V0cHV0QWRkcmVzcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNhY3Rpb24gcHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgcmVjaXBpZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBleHBlY3RlZE91dHB1dEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoZXhwZWN0ZWRPdXRwdXQuYW1vdW50KTtcbiAgICAgICAgLy8gVGhlIG91dHB1dCBhbW91bnQgaXMgZXhwcmVzc2VkIGFzIHN0YXJ0aW5nQmFsYW5jZSBpbiBjcmVhdGVBY2NvdW50IG9wZXJhdGlvbnMgYW5kIGFzIGFtb3VudCBpbiBwYXltZW50IG9wZXJhdGlvbnMuXG4gICAgICAgIGNvbnN0IG91dHB1dEFtb3VudFN0cmluZyA9IG91dHB1dC50eXBlID09PSAnY3JlYXRlQWNjb3VudCcgPyBvdXRwdXQuc3RhcnRpbmdCYWxhbmNlIDogb3V0cHV0LmFtb3VudDtcbiAgICAgICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gbmV3IEJpZ051bWJlcih0aGlzLmJpZ1VuaXRzVG9CYXNlVW5pdHMob3V0cHV0QW1vdW50U3RyaW5nKSk7XG5cbiAgICAgICAgaWYgKCFvdXRwdXRBbW91bnQuZXEoZXhwZWN0ZWRPdXRwdXRBbW91bnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBwcmVidWlsZCBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBhbW91bnQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IHRoZSB1c2VyIHNpZ25hdHVyZSwgaWYgdGhlIHR4IGlzIGhhbGYtc2lnbmVkXG4gICAgaWYgKCFfLmlzRW1wdHkodHguc2lnbmF0dXJlcykpIHtcbiAgICAgIGNvbnN0IHVzZXJTaWduYXR1cmUgPSB0eC5zaWduYXR1cmVzWzBdLnNpZ25hdHVyZSgpO1xuXG4gICAgICAvLyBvYnRhaW4gdGhlIGtleWNoYWlucyBhbmQga2V5IHNpZ25hdHVyZXNcbiAgICAgIGxldCBrZXljaGFpbnMgPSB2ZXJpZmljYXRpb24ua2V5Y2hhaW5zO1xuICAgICAgaWYgKCFrZXljaGFpbnMgJiYgZGlzYWJsZU5ldHdvcmtpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmV0Y2gga2V5Y2hhaW5zIHdpdGhvdXQgbmV0d29ya2luZycpO1xuICAgICAgfSBlbHNlIGlmICgha2V5Y2hhaW5zKSB7XG4gICAgICAgIGtleWNoYWlucyA9IGF3YWl0IHByb21pc2VQcm9wcyh7XG4gICAgICAgICAgdXNlcjogdGhpcy5rZXljaGFpbnMoKS5nZXQoeyBpZDogd2FsbGV0LmtleUlkcygpW0tleUluZGljZXMuVVNFUl0gfSksXG4gICAgICAgICAgYmFja3VwOiB0aGlzLmtleWNoYWlucygpLmdldCh7IGlkOiB3YWxsZXQua2V5SWRzKClbS2V5SW5kaWNlcy5CQUNLVVBdIH0pLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFrZXljaGFpbnMgfHwgIWtleWNoYWlucy5iYWNrdXAgfHwgIWtleWNoYWlucy51c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5Y2hhaW5zIGFyZSByZXF1aXJlZCwgYnV0IGNvdWxkIG5vdCBiZSBmZXRjaGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChrZXljaGFpbnMuYmFja3VwLnB1Yik7XG4gICAgICBpZiAodGhpcy52ZXJpZnlTaWduYXR1cmUoa2V5Y2hhaW5zLmJhY2t1cC5wdWIsIHR4Lmhhc2goKSwgdXNlclNpZ25hdHVyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBzaWduZWQgd2l0aCB3cm9uZyBrZXknKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChrZXljaGFpbnMudXNlci5wdWIpO1xuICAgICAgaWYgKCF0aGlzLnZlcmlmeVNpZ25hdHVyZShrZXljaGFpbnMudXNlci5wdWIsIHR4Lmhhc2goKSwgdXNlclNpZ25hdHVyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc2FjdGlvbiBzaWduYXR1cmUgaW52YWxpZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIGhhcmRlbmVkIGNoaWxkIHB1YmxpYyBrZXkgZnJvbSBhIG1hc3RlciBrZXkgc2VlZCB1c2luZyBhbiBhZGRpdGlvbmFsIHNlZWQgZm9yIHJhbmRvbW5lc3MuXG4gICAqXG4gICAqIER1ZSB0byB0ZWNobmljYWwgZGlmZmVyZW5jZXMgYmV0d2VlbiBrZXlwYWlycyBvbiB0aGUgZWQyNTUxOSBjdXJ2ZSBhbmQgdGhlIHNlY3AyNTZrMSBjdXJ2ZSxcbiAgICogb25seSBoYXJkZW5lZCBwcml2YXRlIGtleSBkZXJpdmF0aW9uIGlzIHN1cHBvcnRlZC5cbiAgICpcbiAgICogQHBhcmFtIGtleSBzZWVkIGZvciB0aGUgbWFzdGVyIGtleS4gTm90ZTogTm90IHRoZSBwdWJsaWMga2V5IG9yIGVuY29kZWQgcHJpdmF0ZSBrZXkuIFRoaXMgaXMgdGhlIHJhdyBzZWVkLlxuICAgKiBAcGFyYW0gZW50cm9weVNlZWQgcmFuZG9tIHNlZWQgd2hpY2ggaXMgaGFzaGVkIHRvIGdlbmVyYXRlIHRoZSBkZXJpdmF0aW9uIHBhdGhcbiAgICovXG4gIGRlcml2ZUtleVdpdGhTZWVkKHsga2V5LCBzZWVkIH06IHsga2V5OiBzdHJpbmc7IHNlZWQ6IHN0cmluZyB9KTogeyBkZXJpdmF0aW9uUGF0aDogc3RyaW5nOyBrZXk6IHN0cmluZyB9IHtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aElucHV0ID0gdXR4b2xpYi5jcnlwdG8uaGFzaDI1NihCdWZmZXIuZnJvbShzZWVkLCAndXRmOCcpKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGhQYXJ0cyA9IFtcbiAgICAgIDk5OTk5OSxcbiAgICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoMCwgNyksIDE2KSxcbiAgICAgIHBhcnNlSW50KGRlcml2YXRpb25QYXRoSW5wdXQuc2xpY2UoNywgMTQpLCAxNiksXG4gICAgXTtcbiAgICBjb25zdCBkZXJpdmF0aW9uUGF0aCA9ICdtLycgKyBkZXJpdmF0aW9uUGF0aFBhcnRzLm1hcCgocGFydCkgPT4gYCR7cGFydH0nYCkuam9pbignLycpO1xuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBFZDI1NTE5S2V5RGVyaXZlci5kZXJpdmVQYXRoKGRlcml2YXRpb25QYXRoLCBrZXkpLmtleTtcbiAgICBjb25zdCBrZXlwYWlyID0gc3RlbGxhci5LZXlwYWlyLmZyb21SYXdFZDI1NTE5U2VlZChkZXJpdmVkS2V5KTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBrZXlwYWlyLnB1YmxpY0tleSgpLFxuICAgICAgZGVyaXZhdGlvblBhdGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzdGVsbGFyLXNkayBoYXMgdHdvIG92ZXJsb2FkcyBmb3IgdG9YRFIsIGFuZCB0eXBlc2NyaXB0IGNhbid0IHNlZW0gdG8gZmlndXJlIG91dCB0aGVcbiAgICogY29ycmVjdCBvbmUgdG8gdXNlLCBzbyB3ZSBoYXZlIHRvIGJlIHZlcnkgZXhwbGljaXQgYXMgdG8gd2hpY2ggb25lIHdlIHdhbnQuXG4gICAqIEBwYXJhbSB0eCB0cmFuc2FjdGlvbiB0byBjb252ZXJ0XG4gICAqL1xuICBwcm90ZWN0ZWQgc3RhdGljIHR4VG9TdHJpbmcgPSAodHg6IHN0ZWxsYXIuVHJhbnNhY3Rpb24pOiBzdHJpbmcgPT5cbiAgICAodHgudG9FbnZlbG9wZSgpLnRvWERSIGFzIChfOiBzdHJpbmcpID0+IHN0cmluZykoJ2Jhc2U2NCcpO1xuXG4gIGFzeW5jIHBhcnNlVHJhbnNhY3Rpb24ocGFyYW1zOiBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBjb25maWcgZm9yIGhvdyB0b2tlbiBlbmFibGVtZW50cyB3b3JrIGZvciB0aGlzIGNvaW5cbiAgICogQHJldHVybnNcbiAgICogICAgcmVxdWlyZXNUb2tlbkVuYWJsZW1lbnQ6IFRydWUgaWYgdG9rZW5zIG5lZWQgdG8gYmUgZW5hYmxlZCBmb3IgdGhpcyBjb2luXG4gICAqICAgIHN1cHBvcnRzTXVsdGlwbGVUb2tlbkVuYWJsZW1lbnRzOiBUcnVlIGlmIG11bHRpcGxlIHRva2VucyBjYW4gYmUgZW5hYmxlZCBpbiBvbmUgdHJhbnNhY3Rpb25cbiAgICovXG4gIGdldFRva2VuRW5hYmxlbWVudENvbmZpZygpOiBUb2tlbkVuYWJsZW1lbnRDb25maWcge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlc1Rva2VuRW5hYmxlbWVudDogdHJ1ZSxcbiAgICAgIHN1cHBvcnRzTXVsdGlwbGVUb2tlbkVuYWJsZW1lbnRzOiBmYWxzZSxcbiAgICB9O1xuICB9XG59XG4iXX0=