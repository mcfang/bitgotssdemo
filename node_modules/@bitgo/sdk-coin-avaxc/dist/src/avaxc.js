"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvaxC = void 0;
/**
 * @prettier
 */
const bignumber_js_1 = require("bignumber.js");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const keccak_1 = __importDefault(require("keccak"));
const secp256k1 = __importStar(require("secp256k1"));
const _ = __importStar(require("lodash"));
const statics_1 = require("@bitgo/statics");
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_coin_eth_1 = require("@bitgo/sdk-coin-eth");
const utils_1 = require("./lib/utils");
const lib_1 = require("./lib");
const superagent_1 = __importDefault(require("superagent"));
const ethereumjs_util_1 = require("ethereumjs-util");
const buffer_1 = require("buffer");
const sdk_coin_avaxp_1 = require("@bitgo/sdk-coin-avaxp");
class AvaxC extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new AvaxC(bitgo, staticsCoin);
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    getChain() {
        return this._staticsCoin.name;
    }
    /**
     * Get the base chain that the coin exists on.
     */
    getBaseChain() {
        return this.getChain();
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    valuelessTransferAllowed() {
        return true;
    }
    isValidAddress(address) {
        // also validate p-chain address for cross-chain txs
        return !!address && (utils_1.isValidEthAddress(address) || sdk_coin_avaxp_1.AvaxpLib.Utils.isValidAddress(address));
    }
    isToken() {
        return false;
    }
    generateKeyPair(seed) {
        const avaxKeyPair = seed ? new lib_1.KeyPair({ seed }) : new lib_1.KeyPair();
        const extendedKeys = avaxKeyPair.getExtendedKeys();
        return {
            pub: extendedKeys.xpub,
            prv: extendedKeys.xprv,
        };
    }
    async parseTransaction(params) {
        return {};
    }
    async verifyAddress({ address }) {
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        return true;
    }
    /**
     * Verify that a transaction prebuild complies with the original intention
     *
     * @param params
     * @param params.txParams params object passed to send
     * @param params.txPrebuild prebuild object returned by server
     * @param params.wallet Wallet object to obtain keys to verify against
     * @returns {boolean}
     */
    async verifyTransaction(params) {
        const { txParams, txPrebuild, wallet } = params;
        if (!(txParams === null || txParams === void 0 ? void 0 : txParams.recipients) || !(txPrebuild === null || txPrebuild === void 0 ? void 0 : txPrebuild.recipients) || !wallet) {
            throw new Error(`missing params`);
        }
        if (txParams.hop && txParams.recipients.length > 1) {
            throw new Error(`tx cannot be both a batch and hop transaction`);
        }
        if (txPrebuild.recipients.length !== 1) {
            throw new Error(`txPrebuild should only have 1 recipient but ${txPrebuild.recipients.length} found`);
        }
        if (txParams.hop && txPrebuild.hopTransaction) {
            // Check recipient amount for hop transaction
            if (txParams.recipients.length !== 1) {
                throw new Error(`hop transaction only supports 1 recipient but ${txParams.recipients.length} found`);
            }
            // Check tx sends to hop address
            let expectedHopAddress;
            if (txPrebuild.hopTransaction.type === 'Export') {
                const decodedHopTx = await this.explainAtomicTransaction(txPrebuild.hopTransaction.tx);
                expectedHopAddress = sdk_coin_eth_1.optionalDeps.ethUtil.stripHexPrefix(decodedHopTx.inputs[0].address);
            }
            else {
                const decodedHopTx = sdk_coin_eth_1.optionalDeps.EthTx.TransactionFactory.fromSerializedData(sdk_coin_eth_1.optionalDeps.ethUtil.toBuffer(txPrebuild.hopTransaction.tx));
                expectedHopAddress = sdk_coin_eth_1.optionalDeps.ethUtil.stripHexPrefix(decodedHopTx.getSenderAddress().toString());
            }
            const actualHopAddress = sdk_coin_eth_1.optionalDeps.ethUtil.stripHexPrefix(txPrebuild.recipients[0].address);
            if (expectedHopAddress.toLowerCase() !== actualHopAddress.toLowerCase()) {
                throw new Error('recipient address of txPrebuild does not match hop address');
            }
            // Convert TransactionRecipient array to Recipient array
            const recipients = txParams.recipients.map((r) => {
                return {
                    address: r.address,
                    amount: typeof r.amount === 'number' ? r.amount.toString() : r.amount,
                };
            });
            // Check destination address and amount
            await this.validateHopPrebuild(wallet, txPrebuild.hopTransaction, { recipients });
        }
        else if (txParams.recipients.length > 1) {
            // Check total amount for batch transaction
            let expectedTotalAmount = new bignumber_js_1.BigNumber(0);
            for (let i = 0; i < txParams.recipients.length; i++) {
                expectedTotalAmount = expectedTotalAmount.plus(txParams.recipients[i].amount);
            }
            if (!expectedTotalAmount.isEqualTo(txPrebuild.recipients[0].amount)) {
                throw new Error('batch transaction amount in txPrebuild received from BitGo servers does not match txParams supplied by client');
            }
        }
        else {
            // Check recipient address and amount for normal transaction
            if (txParams.recipients.length !== 1) {
                throw new Error(`normal transaction only supports 1 recipient but ${txParams.recipients.length} found`);
            }
            const expectedAmount = new bignumber_js_1.BigNumber(txParams.recipients[0].amount);
            if (!expectedAmount.isEqualTo(txPrebuild.recipients[0].amount)) {
                throw new Error('normal transaction amount in txPrebuild received from BitGo servers does not match txParams supplied by client');
            }
            if (AvaxC.isAVAXCAddress(txParams.recipients[0].address) &&
                txParams.recipients[0].address !== txPrebuild.recipients[0].address) {
                throw new Error('destination address in normal txPrebuild does not match that in txParams supplied by client');
            }
        }
        // Check coin is correct for all transaction types
        if (!this.verifyCoin(txPrebuild)) {
            throw new Error(`coin in txPrebuild did not match that in txParams supplied by client`);
        }
        return true;
    }
    static isAVAXCAddress(address) {
        return !!address.match(/0x[a-fA-F0-9]{40}/);
    }
    verifyCoin(txPrebuild) {
        return txPrebuild.coin === this.getChain();
    }
    isValidPub(pub) {
        let valid = true;
        try {
            new lib_1.KeyPair({ pub });
        }
        catch (e) {
            valid = false;
        }
        return valid;
    }
    /**
     * Check whether gas limit passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param {number} userGasLimit - user defined gas limit
     * @returns {number} the gas limit to use for this transaction
     */
    setGasLimit(userGasLimit) {
        if (!userGasLimit) {
            return statics_1.ethGasConfigs.defaultGasLimit;
        }
        const gasLimitMax = statics_1.ethGasConfigs.maximumGasLimit;
        const gasLimitMin = statics_1.ethGasConfigs.minimumGasLimit;
        if (userGasLimit < gasLimitMin || userGasLimit > gasLimitMax) {
            throw new Error(`Gas limit must be between ${gasLimitMin} and ${gasLimitMax}`);
        }
        return userGasLimit;
    }
    /**
     * Check whether the gas price passed in by user are within our max and min bounds
     * If they are not set, set them to the defaults
     * @param {number} userGasPrice - user defined gas price
     * @returns the gas price to use for this transaction
     */
    setGasPrice(userGasPrice) {
        if (!userGasPrice) {
            return statics_1.ethGasConfigs.defaultGasPrice;
        }
        const gasPriceMax = statics_1.ethGasConfigs.maximumGasPrice;
        const gasPriceMin = statics_1.ethGasConfigs.minimumGasPrice;
        if (userGasPrice < gasPriceMin || userGasPrice > gasPriceMax) {
            throw new Error(`Gas price must be between ${gasPriceMin} and ${gasPriceMax}`);
        }
        return userGasPrice;
    }
    /**
     * Make a query to Snowtrace for information such as balance, token balance, solidity calls
     * @param {Object} query — key-value pairs of parameters to append after /api
     * @returns {Promise<Object>} response from Snowtrace
     */
    async recoveryBlockchainExplorerQuery(query) {
        const token = sdk_core_1.common.Environments[this.bitgo.getEnv()].snowtraceApiToken;
        if (token) {
            query.apikey = token;
        }
        const response = await superagent_1.default.get(sdk_core_1.common.Environments[this.bitgo.getEnv()].snowtraceBaseUrl + '/api').query(query);
        if (!response.ok) {
            throw new Error('could not reach Snowtrace');
        }
        if (response.body.status === '0' && response.body.message === 'NOTOK') {
            throw new Error('Snowtrace rate limit reached');
        }
        return response.body;
    }
    /**
     * Queries public block explorer to get the next nonce that should be used for
     * the given AVAXC address
     * @param {string} address — address to fetch for
     * @returns {number} address nonce
     */
    async getAddressNonce(address) {
        // Get nonce for backup key (should be 0)
        let nonce = 0;
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'account',
            action: 'txlist',
            address,
        });
        if (!result || !Array.isArray(result.result)) {
            throw new Error('Unable to find next nonce from Snowtrace, got: ' + JSON.stringify(result));
        }
        const backupKeyTxList = result.result;
        if (backupKeyTxList.length > 0) {
            // Calculate last nonce used
            const outgoingTxs = backupKeyTxList.filter((tx) => tx.from === address);
            nonce = outgoingTxs.length;
        }
        return nonce;
    }
    /**
     * Queries Snowtrace for the balance of an address
     * @param {string} address - the AVAXC address
     * @returns {Promise<BigNumber>} address balance
     */
    async queryAddressBalance(address) {
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'account',
            action: 'balance',
            address: address,
        });
        // throw if the result does not exist or the result is not a valid number
        if (!result || !result.result || isNaN(result.result)) {
            throw new Error(`Could not obtain address balance for ${address} from Snowtrace, got: ${result.result}`);
        }
        return new sdk_coin_eth_1.optionalDeps.ethUtil.BN(result.result, 10);
    }
    /**
     * Queries the contract (via Snowtrace) for the next sequence ID
     * @param {string} address - address of the contract
     * @returns {Promise<number>} sequence ID
     */
    async querySequenceId(address) {
        // Get sequence ID using contract call
        const sequenceIdMethodSignature = sdk_coin_eth_1.optionalDeps.ethAbi.methodID('getNextSequenceId', []);
        const sequenceIdArgs = sdk_coin_eth_1.optionalDeps.ethAbi.rawEncode([], []);
        const sequenceIdData = buffer_1.Buffer.concat([sequenceIdMethodSignature, sequenceIdArgs]).toString('hex');
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'proxy',
            action: 'eth_call',
            to: address,
            data: sequenceIdData,
            tag: 'latest',
        });
        if (!result || !result.result) {
            throw new Error('Could not obtain sequence ID from Snowtrace, got: ' + result.result);
        }
        const sequenceIdHex = result.result;
        return new sdk_coin_eth_1.optionalDeps.ethUtil.BN(sequenceIdHex.slice(2), 16).toNumber();
    }
    /**
     * @param {Object} recipient - recipient info
     * @param {number} expireTime - expiry time
     * @param {number} contractSequenceId - sequence id
     * @returns {(string|Array)} operation array
     */
    getOperation(recipient, expireTime, contractSequenceId) {
        return [
            ['string', 'address', 'uint', 'bytes', 'uint', 'uint'],
            [
                'ETHER',
                new sdk_coin_eth_1.optionalDeps.ethUtil.BN(sdk_coin_eth_1.optionalDeps.ethUtil.stripHexPrefix(recipient.address), 16),
                recipient.amount,
                buffer_1.Buffer.from(sdk_coin_eth_1.optionalDeps.ethUtil.stripHexPrefix(sdk_coin_eth_1.optionalDeps.ethUtil.padToEven(recipient.data || '')), 'hex'),
                expireTime,
                contractSequenceId,
            ],
        ];
    }
    /**
     * Calculate the operation hash in the same way solidity would
     * @param {Recipient[]} recipients - tx recipients
     * @param {number} expireTime - expiration time
     * @param {number} contractSequenceId - contract sequence id
     * @returns {string} operation hash
     */
    getOperationSha3ForExecuteAndConfirm(recipients, expireTime, contractSequenceId) {
        if (!recipients || !Array.isArray(recipients)) {
            throw new Error('expecting array of recipients');
        }
        // Right now we only support 1 recipient
        if (recipients.length !== 1) {
            throw new Error('must send to exactly 1 recipient');
        }
        if (!_.isNumber(expireTime)) {
            throw new Error('expireTime must be number of seconds since epoch');
        }
        if (!_.isNumber(contractSequenceId)) {
            throw new Error('contractSequenceId must be number');
        }
        // Check inputs
        recipients.forEach(function (recipient) {
            if (!_.isString(recipient.address) ||
                !sdk_coin_eth_1.optionalDeps.ethUtil.isValidAddress(sdk_coin_eth_1.optionalDeps.ethUtil.addHexPrefix(recipient.address))) {
                throw new Error('Invalid address: ' + recipient.address);
            }
            let amount;
            try {
                amount = new bignumber_js_1.BigNumber(recipient.amount);
            }
            catch (e) {
                throw new Error('Invalid amount for: ' + recipient.address + ' - should be numeric');
            }
            recipient.amount = amount.toFixed(0);
            if (recipient.data && !_.isString(recipient.data)) {
                throw new Error('Data for recipient ' + recipient.address + ' - should be of type hex string');
            }
        });
        const recipient = recipients[0];
        return sdk_coin_eth_1.optionalDeps.ethUtil.bufferToHex(sdk_coin_eth_1.optionalDeps.ethAbi.soliditySHA3(...this.getOperation(recipient, expireTime, contractSequenceId)));
    }
    /**
     * Default expire time for a contract call (1 week)
     * @returns {number} Time in seconds
     */
    getDefaultExpireTime() {
        return Math.floor(new Date().getTime() / 1000) + 60 * 60 * 24 * 7;
    }
    /**
     * Build arguments to call the send method on the wallet contract
     * @param {Object} txInfo - data for send method args
     * @returns {SendMethodArgs[]}
     */
    getSendMethodArgs(txInfo) {
        // Method signature is
        // sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature)
        return [
            {
                name: 'toAddress',
                type: 'address',
                value: txInfo.recipient.address,
            },
            {
                name: 'value',
                type: 'uint',
                value: txInfo.recipient.amount,
            },
            {
                name: 'data',
                type: 'bytes',
                value: sdk_coin_eth_1.optionalDeps.ethUtil.toBuffer(sdk_coin_eth_1.optionalDeps.ethUtil.addHexPrefix(txInfo.recipient.data || '')),
            },
            {
                name: 'expireTime',
                type: 'uint',
                value: txInfo.expireTime,
            },
            {
                name: 'sequenceId',
                type: 'uint',
                value: txInfo.contractSequenceId,
            },
            {
                name: 'signature',
                type: 'bytes',
                value: sdk_coin_eth_1.optionalDeps.ethUtil.toBuffer(sdk_coin_eth_1.optionalDeps.ethUtil.addHexPrefix(txInfo.signature)),
            },
        ];
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * Steps:
     * 1) Node query - how much money is in the account
     * 2) Build transaction - build our transaction for the amount
     * 3) Send signed build - send our signed build to a public node
     * @param {Object} params The options with which to recover
     * @param {string} params.userKey - [encrypted] xprv
     * @param {string} params.backupKey - [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param {string} params.walletPassphrase - used to decrypt userKey and backupKey
     * @param {string} params.walletContractAddress - the AVAXC address of the wallet contract
     * @param {string} params.recoveryDestination - target address to send recovered funds to
     * @returns {Promise<RecoveryInfo>} - recovery tx info
     */
    async recover(params) {
        if (_.isUndefined(params.userKey)) {
            throw new Error('missing userKey');
        }
        if (_.isUndefined(params.backupKey)) {
            throw new Error('missing backupKey');
        }
        if (_.isUndefined(params.walletPassphrase) && !params.userKey.startsWith('xpub')) {
            throw new Error('missing wallet passphrase');
        }
        if (_.isUndefined(params.walletContractAddress) || !this.isValidAddress(params.walletContractAddress)) {
            throw new Error('invalid walletContractAddress');
        }
        if (_.isUndefined(params.recoveryDestination) || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        // TODO (BG-56531): add support for krs
        const isUnsignedSweep = sdk_core_1.getIsUnsignedSweep(params);
        // Clean up whitespace from entered values
        let userKey = params.userKey.replace(/\s/g, '');
        const backupKey = params.backupKey.replace(/\s/g, '');
        // Set new tx fees (using default config values from platform)
        const gasLimit = new sdk_coin_eth_1.optionalDeps.ethUtil.BN(this.setGasLimit(params.gasLimit));
        const gasPrice = params.eip1559
            ? new sdk_coin_eth_1.optionalDeps.ethUtil.BN(params.eip1559.maxFeePerGas)
            : new sdk_coin_eth_1.optionalDeps.ethUtil.BN(this.setGasPrice(params.gasPrice));
        if (!userKey.startsWith('xpub') && !userKey.startsWith('xprv')) {
            try {
                userKey = this.bitgo.decrypt({
                    input: userKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting user keychain: ${e.message}`);
            }
        }
        let backupKeyAddress;
        let backupSigningKey;
        if (isUnsignedSweep) {
            const backupKeyPair = new lib_1.KeyPair({ pub: backupKey });
            backupKeyAddress = backupKeyPair.getAddress();
        }
        else {
            // Decrypt backup private key and get address
            let backupPrv;
            try {
                backupPrv = this.bitgo.decrypt({
                    input: backupKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting backup keychain: ${e.message}`);
            }
            const keyPair = new lib_1.KeyPair({ prv: backupPrv });
            backupSigningKey = keyPair.getKeys().prv;
            if (!backupSigningKey) {
                throw new Error('no private key');
            }
            backupKeyAddress = keyPair.getAddress();
        }
        const backupKeyNonce = await this.getAddressNonce(backupKeyAddress);
        // get balance of backupKey to ensure funds are available to pay fees
        const backupKeyBalance = await this.queryAddressBalance(backupKeyAddress);
        const totalGasNeeded = gasPrice.mul(gasLimit);
        const weiToGwei = 10 ** 9;
        if (backupKeyBalance.lt(totalGasNeeded)) {
            throw new Error(`Backup key address ${backupKeyAddress} has balance ${(backupKeyBalance / weiToGwei).toString()} Gwei.` +
                `This address must have a balance of at least ${(totalGasNeeded / weiToGwei).toString()}` +
                ` Gwei to perform recoveries. Try sending some AVAX to this address then retry.`);
        }
        // get balance of wallet and deduct fees to get transaction amount
        const txAmount = await this.queryAddressBalance(params.walletContractAddress);
        // build recipients object
        const recipients = [
            {
                address: params.recoveryDestination,
                amount: txAmount.toString(10),
            },
        ];
        // Get sequence ID using contract call
        // we need to wait between making two snowtrace calls to avoid getting banned
        await new Promise((resolve) => setTimeout(resolve, 1000));
        const sequenceId = await this.querySequenceId(params.walletContractAddress);
        let operationHash, signature;
        // Get operation hash and sign it
        if (!isUnsignedSweep) {
            operationHash = this.getOperationSha3ForExecuteAndConfirm(recipients, this.getDefaultExpireTime(), sequenceId);
            signature = sdk_core_1.Util.ethSignMsgHash(operationHash, sdk_core_1.Util.xprvToEthPrivateKey(userKey));
            try {
                sdk_core_1.Util.ecRecoverEthAddress(operationHash, signature);
            }
            catch (e) {
                throw new Error('Invalid signature');
            }
        }
        const txInfo = {
            recipient: recipients[0],
            expireTime: this.getDefaultExpireTime(),
            contractSequenceId: sequenceId,
            operationHash,
            signature,
            gasLimit: gasLimit.toString(10),
        };
        const txBuilder = this.getTransactionBuilder();
        txBuilder.counter(backupKeyNonce);
        txBuilder.contract(params.walletContractAddress);
        let txFee;
        if (params.eip1559) {
            txFee = {
                eip1559: {
                    maxPriorityFeePerGas: params.eip1559.maxPriorityFeePerGas,
                    maxFeePerGas: params.eip1559.maxFeePerGas,
                },
            };
        }
        else {
            txFee = { fee: gasPrice.toString() };
        }
        txBuilder.fee({
            ...txFee,
            gasLimit: gasLimit.toString(),
        });
        txBuilder
            .transfer()
            .amount(recipients[0].amount)
            .contractSequenceId(sequenceId)
            .expirationTime(this.getDefaultExpireTime())
            .to(params.recoveryDestination);
        if (isUnsignedSweep) {
            const tx = await txBuilder.build();
            const response = {
                txHex: tx.toBroadcastFormat(),
                userKey,
                backupKey,
                coin: this.getChain(),
                gasPrice: sdk_coin_eth_1.optionalDeps.ethUtil.bufferToInt(gasPrice).toFixed(),
                gasLimit,
                recipients: [txInfo.recipient],
                walletContractAddress: tx.toJson().to,
                amount: txInfo.recipient.amount,
                backupKeyNonce,
                eip1559: params.eip1559,
            };
            _.extend(response, txInfo);
            response.nextContractSequenceId = response.contractSequenceId;
            return response;
        }
        const userKeyPair = new lib_1.KeyPair({ prv: userKey });
        txBuilder.transfer().key(userKeyPair.getKeys().prv);
        txBuilder.sign({ key: backupSigningKey });
        const signedTx = await txBuilder.build();
        return {
            id: signedTx.toJson().id,
            tx: signedTx.toBroadcastFormat(),
        };
    }
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    getTransactionBuilder() {
        return new lib_1.TransactionBuilder(statics_1.coins.get(this.getBaseChain()));
    }
    getAtomicBuilder() {
        return new sdk_coin_avaxp_1.AvaxpLib.TransactionBuilderFactory(statics_1.coins.get(this.getAvaxP()));
    }
    /**
     * Explain a transaction from txHex, overriding BaseCoins
     * transaction can be either atomic or eth txn.
     * @param params The options with which to explain the transaction
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex) {
            throw new Error('missing txHex in explain tx parameters');
        }
        if (params.crossChainType) {
            return this.explainAtomicTransaction(txHex);
        }
        if (!params.feeInfo) {
            throw new Error('missing feeInfo in explain tx parameters');
        }
        const txBuilder = this.getTransactionBuilder();
        txBuilder.from(txHex);
        const tx = await txBuilder.build();
        return Object.assign(this.explainEVMTransaction(tx), { fee: params.feeInfo });
    }
    /**
     * Explains an atomic transaction using atomic builder.
     * @param txHex
     * @private
     */
    async explainAtomicTransaction(txHex) {
        const txBuilder = this.getAtomicBuilder().from(txHex);
        const tx = await txBuilder.build();
        return tx.explainTransaction();
    }
    /**
     * Verify signature for an atomic transaction using atomic builder.
     * @param txHex
     * @return true if signature is from the input address
     * @private
     */
    async verifySignatureForAtomicTransaction(txHex) {
        const txBuilder = this.getAtomicBuilder().from(txHex);
        const tx = await txBuilder.build();
        const payload = tx.signablePayload;
        const signatures = tx.signature.map((s) => buffer_1.Buffer.from(s, 'hex'));
        const network = _.get(tx, '_network');
        const recoverPubky = signatures.map((s) => sdk_coin_avaxp_1.AvaxpLib.Utils.recoverySignature(network, payload, s));
        const expectedSenders = recoverPubky.map((r) => ethereumjs_util_1.pubToAddress(r, true));
        const senders = tx.inputs.map((i) => sdk_coin_avaxp_1.AvaxpLib.Utils.parseAddress(i.address));
        return expectedSenders.every((e) => senders.some((sender) => e.equals(sender)));
    }
    /**
     * Explains an EVM transaction using regular eth txn builder
     * @param tx
     * @private
     */
    explainEVMTransaction(tx) {
        const outputs = tx.outputs.map((output) => {
            return {
                address: output.address,
                amount: output.value,
            };
        });
        const displayOrder = ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'];
        return {
            displayOrder,
            id: tx.id,
            outputs: outputs,
            outputAmount: outputs
                .reduce((accumulator, output) => accumulator.plus(output.amount), new bignumber_js_1.BigNumber('0'))
                .toFixed(0),
            changeOutputs: [],
            changeAmount: '0', // account base does not make change
        };
    }
    /**
     * Above is standard BaseCoins functions
     * ================================================================================================================
     * ================================================================================================================
     * Below is transaction functions
     */
    /**
     * Coin-specific things done before signing a transaction, i.e. verification
     * @param params
     */
    async presignTransaction(params) {
        if (!_.isUndefined(params.hopTransaction) && !_.isUndefined(params.wallet) && !_.isUndefined(params.buildParams)) {
            await this.validateHopPrebuild(params.wallet, params.hopTransaction);
        }
        return params;
    }
    /**
     * Modify prebuild after receiving it from the server. Add things like nlocktime
     */
    async postProcessPrebuild(params) {
        if (!_.isUndefined(params.hopTransaction) && !_.isUndefined(params.wallet) && !_.isUndefined(params.buildParams)) {
            await this.validateHopPrebuild(params.wallet, params.hopTransaction, params.buildParams);
        }
        return params;
    }
    /**
     * Validates that the hop prebuild from the HSM is valid and correct
     * @param wallet The wallet that the prebuild is for
     * @param hopPrebuild The prebuild to validate
     * @param originalParams The original parameters passed to prebuildTransaction
     * @returns void
     * @throws Error if The prebuild is invalid
     */
    async validateHopPrebuild(wallet, hopPrebuild, originalParams) {
        const { tx, id, signature } = hopPrebuild;
        // first, validate the HSM signature
        const serverXpub = sdk_core_1.common.Environments[this.bitgo.getEnv()].hsmXpub;
        const serverPubkeyBuffer = utxo_lib_1.bip32.fromBase58(serverXpub).publicKey;
        const signatureBuffer = buffer_1.Buffer.from(sdk_coin_eth_1.optionalDeps.ethUtil.stripHexPrefix(signature), 'hex');
        const messageBuffer = hopPrebuild.type === 'Export' ? AvaxC.getTxHash(tx) : buffer_1.Buffer.from(sdk_coin_eth_1.optionalDeps.ethUtil.stripHexPrefix(id), 'hex');
        const sig = new Uint8Array(signatureBuffer.length === 64 ? signatureBuffer : signatureBuffer.slice(1));
        const isValidSignature = secp256k1.ecdsaVerify(sig, messageBuffer, serverPubkeyBuffer);
        if (!isValidSignature) {
            throw new Error(`Hop txid signature invalid`);
        }
        if (hopPrebuild.type === 'Export') {
            const explainHopExportTx = await this.explainAtomicTransaction(tx);
            // If original params are given, we can check them against the transaction prebuild params
            if (!_.isNil(originalParams)) {
                const { recipients } = originalParams;
                // Then validate that the tx params actually equal the requested params to nano avax plus import tx fee.
                const originalAmount = new bignumber_js_1.BigNumber(recipients[0].amount).div(1e9).plus(1e6).toFixed(0);
                const originalDestination = recipients[0].address;
                const hopAmount = explainHopExportTx.outputAmount;
                const hopDestination = explainHopExportTx.outputs[0].address;
                if (originalAmount !== hopAmount) {
                    throw new Error(`Hop amount: ${hopAmount} does not equal original amount: ${originalAmount}`);
                }
                if (originalDestination && hopDestination.toLowerCase() !== originalDestination.toLowerCase()) {
                    throw new Error(`Hop destination: ${hopDestination} does not equal original recipient: ${originalDestination}`);
                }
            }
            if (!(await this.verifySignatureForAtomicTransaction(tx))) {
                throw new Error(`Invalid hop transaction signature, txid: ${id}`);
            }
        }
        else {
            const builtHopTx = sdk_coin_eth_1.optionalDeps.EthTx.TransactionFactory.fromSerializedData(sdk_coin_eth_1.optionalDeps.ethUtil.toBuffer(tx));
            // If original params are given, we can check them against the transaction prebuild params
            if (!_.isNil(originalParams)) {
                const { recipients } = originalParams;
                // Then validate that the tx params actually equal the requested params
                const originalAmount = new bignumber_js_1.BigNumber(recipients[0].amount);
                const originalDestination = recipients[0].address;
                const hopAmount = new bignumber_js_1.BigNumber(sdk_coin_eth_1.optionalDeps.ethUtil.bufferToHex(builtHopTx.value));
                if (!builtHopTx.to) {
                    throw new Error(`Transaction does not have a destination address`);
                }
                const hopDestination = builtHopTx.to.toString();
                if (!hopAmount.eq(originalAmount)) {
                    throw new Error(`Hop amount: ${hopAmount} does not equal original amount: ${originalAmount}`);
                }
                if (hopDestination.toLowerCase() !== originalDestination.toLowerCase()) {
                    throw new Error(`Hop destination: ${hopDestination} does not equal original recipient: ${hopDestination}`);
                }
            }
            if (!builtHopTx.verifySignature()) {
                // We dont want to continue at all in this case, at risk of AVAX being stuck on the hop address
                throw new Error(`Invalid hop transaction signature, txid: ${id}`);
            }
            if (sdk_coin_eth_1.optionalDeps.ethUtil.addHexPrefix(builtHopTx.hash().toString('hex')) !== id) {
                throw new Error(`Signed hop txid does not equal actual txid`);
            }
        }
    }
    /**
     * Helper function for signTransaction for the rare case that SDK is doing the second signature
     * Note: we are expecting this to be called from the offline vault
     * @param params.txPrebuild
     * @param params.prv
     * @returns {{txHex: string}}
     */
    async signFinal(params) {
        const keyPair = new lib_1.KeyPair({ prv: params.prv });
        const signingKey = keyPair.getKeys().prv;
        if (_.isUndefined(signingKey)) {
            throw new Error('missing private key');
        }
        const txBuilder = this.getTransactionBuilder();
        try {
            txBuilder.from(params.txPrebuild.halfSigned.txHex);
        }
        catch (e) {
            throw new Error('invalid half-signed transaction');
        }
        txBuilder.sign({ key: signingKey });
        const tx = await txBuilder.build();
        return {
            txHex: tx.toBroadcastFormat(),
        };
    }
    /**
     * Assemble half-sign prebuilt transaction
     * @param params
     */
    async signTransaction(params) {
        // Normally the SDK provides the first signature for an AVAXC tx,
        // but for unsigned sweep recoveries it can provide the second and final one.
        if (params.isLastSignature) {
            // In this case when we're doing the second (final) signature, the logic is different.
            return await this.signFinal(params);
        }
        const txBuilder = this.getTransactionBuilder();
        txBuilder.from(params.txPrebuild.txHex);
        txBuilder.transfer().key(new lib_1.KeyPair({ prv: params.prv }).getKeys().prv);
        const transaction = await txBuilder.build();
        const recipients = transaction.outputs.map((output) => ({ address: output.address, amount: output.value }));
        const txParams = {
            eip1559: params.txPrebuild.eip1559,
            txHex: transaction.toBroadcastFormat(),
            recipients: recipients,
            expireTime: params.txPrebuild.expireTime,
            hopTransaction: params.txPrebuild.hopTransaction,
            custodianTransactionId: params.custodianTransactionId,
        };
        return { halfSigned: txParams };
    }
    /**
     * Modify prebuild before sending it to the server. Add things like hop transaction params
     * @param buildParams The whitelisted parameters for this prebuild
     * @param buildParams.hop True if this should prebuild a hop tx, else false
     * @param buildParams.recipients The recipients array of this transaction
     * @param buildParams.wallet The wallet sending this tx
     * @param buildParams.walletPassphrase the passphrase for this wallet
     */
    async getExtraPrebuildParams(buildParams) {
        if (!_.isUndefined(buildParams.hop) &&
            buildParams.hop &&
            !_.isUndefined(buildParams.wallet) &&
            !_.isUndefined(buildParams.recipients)) {
            if (this.isToken()) {
                throw new Error(`Hop transactions are not enabled for AVAXC tokens, nor are they necessary. Please remove the 'hop' parameter and try again.`);
            }
            return (await this.createHopTransactionParams({
                recipients: buildParams.recipients,
                type: buildParams.type,
            }));
        }
        return {};
    }
    /**
     * Creates the extra parameters needed to build a hop transaction
     * @param {HopTransactionBuildOptions} The original build parameters
     * @returns extra parameters object to merge with the original build parameters object and send to the platform
     */
    async createHopTransactionParams({ recipients, type }) {
        if (!recipients || !Array.isArray(recipients)) {
            throw new Error('expecting array of recipients');
        }
        // Right now we only support 1 recipient
        if (recipients.length !== 1) {
            throw new Error('must send to exactly 1 recipient');
        }
        const recipientAddress = recipients[0].address;
        const recipientAmount = recipients[0].amount;
        const feeEstimateParams = {
            recipient: recipientAddress,
            amount: recipientAmount,
            hop: true,
            type,
        };
        const feeEstimate = await this.feeEstimate(feeEstimateParams);
        const gasLimit = feeEstimate.gasLimitEstimate;
        const gasPrice = Math.round(feeEstimate.feeEstimate / gasLimit);
        const gasPriceMax = gasPrice * 5;
        // Payment id a random number so its different for every tx
        const paymentId = Math.floor(Math.random() * 10000000000).toString();
        // TODO(BG-62671): after completed [Wallet-platform] Remove use of userReqSig for avaxc hop transaction
        const userReqSig = '0x';
        return {
            hopParams: {
                userReqSig,
                gasPriceMax,
                paymentId,
            },
            gasLimit,
        };
    }
    /**
     * Fetch fee estimate information from the server
     * @param {Object} params The params passed into the function
     * @param {Boolean} [params.hop] True if we should estimate fee for a hop transaction
     * @param {String} [params.recipient] The recipient of the transaction to estimate a send to
     * @param {String} [params.data] The ETH tx data to estimate a send for
     * @returns {Object} The fee info returned from the server
     */
    async feeEstimate(params) {
        const query = {};
        if (params && params.hop) {
            query.hop = params.hop;
        }
        if (params && params.recipient) {
            query.recipient = params.recipient;
        }
        if (params && params.data) {
            query.data = params.data;
        }
        if (params && params.amount) {
            query.amount = params.amount;
        }
        if (params && params.type) {
            query.type = params.type;
        }
        return await this.bitgo.get(this.url('/tx/fee')).query(query).result();
    }
    /**
     * Gets the hop digest for the user to sign. This is validated in the HSM to prove that the user requested this tx
     * @param paramsArr The parameters to hash together for the digest
     */
    static getHopDigest(paramsArr) {
        const hash = keccak_1.default('keccak256');
        hash.update([AvaxC.hopTransactionSalt, ...paramsArr].join('$'));
        return hash.digest();
    }
    /**
     * Calculate tx hash like evm from tx hex.
     * @param {string} tx
     * @returns {Buffer} tx hash
     */
    static getTxHash(tx) {
        const hash = keccak_1.default('keccak256');
        hash.update(sdk_coin_eth_1.optionalDeps.ethUtil.stripHexPrefix(tx), 'hex');
        return hash.digest();
    }
    async isWalletAddress(params) {
        // TODO: Fix this later
        return true;
    }
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params) {
        // We always need params object, since either enterprise or newFeeAddress is required
        if (!_.isObject(params)) {
            throw new Error(`preCreateBitGo must be passed a params object. Got ${params} (type ${typeof params})`);
        }
        if (_.isUndefined(params.enterprise) && _.isUndefined(params.newFeeAddress)) {
            throw new Error('expecting enterprise when adding BitGo key. If you want to create a new AVAX bitgo key, set the newFeeAddress parameter to true.');
        }
        // Check whether key should be an enterprise key or a BitGo key for a new fee address
        if (!_.isUndefined(params.enterprise) && !_.isUndefined(params.newFeeAddress)) {
            throw new Error(`Incompatible arguments - cannot pass both enterprise and newFeeAddress parameter.`);
        }
        if (!_.isUndefined(params.enterprise) && !_.isString(params.enterprise)) {
            throw new Error(`enterprise should be a string - got ${params.enterprise} (type ${typeof params.enterprise})`);
        }
        if (!_.isUndefined(params.newFeeAddress) && !_.isBoolean(params.newFeeAddress)) {
            throw new Error(`newFeeAddress should be a boolean - got ${params.newFeeAddress} (type ${typeof params.newFeeAddress})`);
        }
    }
    getAvaxP() {
        return this.getChain().toString() === 'avaxc' ? 'avaxp' : 'tavaxp';
    }
}
exports.AvaxC = AvaxC;
AvaxC.hopTransactionSalt = 'bitgoHopAddressRequestSalt';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXZheGMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXZheGMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztHQUVHO0FBQ0gsK0NBQXlDO0FBQ3pDLDhDQUF3QztBQUN4QyxvREFBNEI7QUFDNUIscURBQXVDO0FBQ3ZDLDBDQUE0QjtBQUM1Qiw0Q0FBaUg7QUFDakgsOENBaUJ5QjtBQUN6QixzREFRNkI7QUFDN0IsdUNBQWdEO0FBQ2hELCtCQUFvRTtBQUNwRSw0REFBaUM7QUFDakMscURBQStDO0FBQy9DLG1DQUFnQztBQWdCaEMsMERBQWlEO0FBRWpELE1BQWEsS0FBTSxTQUFRLG1CQUFRO0lBS2pDLFlBQXNCLEtBQWdCLEVBQUUsV0FBdUM7UUFDN0UsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWIsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFnQixFQUFFLFdBQXVDO1FBQzdFLE9BQU8sSUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVELFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFB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Q0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQUU7WUFDOUUsTUFBTSxJQUFJLEtBQUssQ0FDYiwyQ0FBMkMsTUFBTSxDQUFDLGFBQWEsVUFBVSxPQUFPLE1BQU0sQ0FBQyxhQUFhLEdBQUcsQ0FDeEcsQ0FBQztTQUNIO0lBQ0gsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsS0FBSyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0lBQ3JFLENBQUM7O0FBM2hDSCxzQkE0aENDO0FBM2hDUSx3QkFBa0IsR0FBRyw0QkFBNEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBiaXAzMiB9IGZyb20gJ0BiaXRnby91dHhvLWxpYic7XG5pbXBvcnQgS2VjY2FrIGZyb20gJ2tlY2Nhayc7XG5pbXBvcnQgKiBhcyBzZWNwMjU2azEgZnJvbSAnc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEF2YWxhbmNoZU5ldHdvcmssIEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgQ29pbkZhbWlseSwgY29pbnMsIGV0aEdhc0NvbmZpZ3MgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQmFzZVRyYW5zYWN0aW9uLFxuICBCaXRHb0Jhc2UsXG4gIGNvbW1vbixcbiAgRmVlRXN0aW1hdGVPcHRpb25zLFxuICBGdWxseVNpZ25lZFRyYW5zYWN0aW9uLFxuICBnZXRJc1Vuc2lnbmVkU3dlZXAsXG4gIEludmFsaWRBZGRyZXNzRXJyb3IsXG4gIElXYWxsZXQsXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgUmVjaXBpZW50LFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBVdGlsLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7XG4gIEdldFNlbmRNZXRob2RBcmdzT3B0aW9ucyxcbiAgb3B0aW9uYWxEZXBzLFxuICBSZWNvdmVyT3B0aW9ucyxcbiAgUmVjb3ZlcnlJbmZvLFxuICBTZW5kTWV0aG9kQXJncyxcbiAgVHJhbnNhY3Rpb25CdWlsZGVyIGFzIEV0aFRyYW5zYWN0aW9uQnVpbGRlcixcbiAgVHJhbnNhY3Rpb25QcmVidWlsZCxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb2luLWV0aCc7XG5pbXBvcnQgeyBpc1ZhbGlkRXRoQWRkcmVzcyB9IGZyb20gJy4vbGliL3V0aWxzJztcbmltcG9ydCB7IEtleVBhaXIgYXMgQXZheGNLZXlQYWlyLCBUcmFuc2FjdGlvbkJ1aWxkZXIgfSBmcm9tICcuL2xpYic7XG5pbXBvcnQgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCB7IHB1YlRvQWRkcmVzcyB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHtcbiAgQXZheFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIEJ1aWxkT3B0aW9ucyxcbiAgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgRmVlRXN0aW1hdGUsXG4gIEhvcFBhcmFtcyxcbiAgSG9wUHJlYnVpbGQsXG4gIEhvcFRyYW5zYWN0aW9uQnVpbGRPcHRpb25zLFxuICBPZmZsaW5lVmF1bHRUeEluZm8sXG4gIFByZWNyZWF0ZUJpdEdvT3B0aW9ucyxcbiAgUHJlc2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgU2lnbmVkVHJhbnNhY3Rpb24sXG4gIFNpZ25GaW5hbE9wdGlvbnMsXG4gIFZlcmlmeUF2YXhjVHJhbnNhY3Rpb25PcHRpb25zLFxufSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEF2YXhwTGliIH0gZnJvbSAnQGJpdGdvL3Nkay1jb2luLWF2YXhwJztcblxuZXhwb3J0IGNsYXNzIEF2YXhDIGV4dGVuZHMgQmFzZUNvaW4ge1xuICBzdGF0aWMgaG9wVHJhbnNhY3Rpb25TYWx0ID0gJ2JpdGdvSG9wQWRkcmVzc1JlcXVlc3RTYWx0JztcblxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pIHtcbiAgICBzdXBlcihiaXRnbyk7XG5cbiAgICBpZiAoIXN0YXRpY3NDb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29uc3RydWN0b3IgcGFyYW1ldGVyIHN0YXRpY3NDb2luJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGljc0NvaW4gPSBzdGF0aWNzQ29pbjtcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pOiBCYXNlQ29pbiB7XG4gICAgcmV0dXJuIG5ldyBBdmF4QyhiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgZ2V0QmFzZUZhY3RvcigpOiBudW1iZXIge1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhdGljc0NvaW4uZGVjaW1hbFBsYWNlcyk7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYmFzZSBjaGFpbiB0aGF0IHRoZSBjb2luIGV4aXN0cyBvbi5cbiAgICovXG4gIGdldEJhc2VDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldENoYWluKCk7XG4gIH1cblxuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZ1bGxOYW1lO1xuICB9XG5cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gYWxzbyB2YWxpZGF0ZSBwLWNoYWluIGFkZHJlc3MgZm9yIGNyb3NzLWNoYWluIHR4c1xuICAgIHJldHVybiAhIWFkZHJlc3MgJiYgKGlzVmFsaWRFdGhBZGRyZXNzKGFkZHJlc3MpIHx8IEF2YXhwTGliLlV0aWxzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKTtcbiAgfVxuXG4gIGlzVG9rZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBhdmF4S2V5UGFpciA9IHNlZWQgPyBuZXcgQXZheGNLZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBBdmF4Y0tleVBhaXIoKTtcbiAgICBjb25zdCBleHRlbmRlZEtleXMgPSBhdmF4S2V5UGFpci5nZXRFeHRlbmRlZEtleXMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBleHRlbmRlZEtleXMueHB1YixcbiAgICAgIHBydjogZXh0ZW5kZWRLZXlzLnhwcnYhLFxuICAgIH07XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5QWRkcmVzcyh7IGFkZHJlc3MgfTogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3M6ICR7YWRkcmVzc31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgYSB0cmFuc2FjdGlvbiBwcmVidWlsZCBjb21wbGllcyB3aXRoIHRoZSBvcmlnaW5hbCBpbnRlbnRpb25cbiAgICpcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0gcGFyYW1zLnR4UGFyYW1zIHBhcmFtcyBvYmplY3QgcGFzc2VkIHRvIHNlbmRcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBzZXJ2ZXJcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXQgV2FsbGV0IG9iamVjdCB0byBvYnRhaW4ga2V5cyB0byB2ZXJpZnkgYWdhaW5zdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGFzeW5jIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5QXZheGNUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCB7IHR4UGFyYW1zLCB0eFByZWJ1aWxkLCB3YWxsZXQgfSA9IHBhcmFtcztcbiAgICBpZiAoIXR4UGFyYW1zPy5yZWNpcGllbnRzIHx8ICF0eFByZWJ1aWxkPy5yZWNpcGllbnRzIHx8ICF3YWxsZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyBwYXJhbXNgKTtcbiAgICB9XG4gICAgaWYgKHR4UGFyYW1zLmhvcCAmJiB0eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdHggY2Fubm90IGJlIGJvdGggYSBiYXRjaCBhbmQgaG9wIHRyYW5zYWN0aW9uYCk7XG4gICAgfVxuICAgIGlmICh0eFByZWJ1aWxkLnJlY2lwaWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgc2hvdWxkIG9ubHkgaGF2ZSAxIHJlY2lwaWVudCBidXQgJHt0eFByZWJ1aWxkLnJlY2lwaWVudHMubGVuZ3RofSBmb3VuZGApO1xuICAgIH1cbiAgICBpZiAodHhQYXJhbXMuaG9wICYmIHR4UHJlYnVpbGQuaG9wVHJhbnNhY3Rpb24pIHtcbiAgICAgIC8vIENoZWNrIHJlY2lwaWVudCBhbW91bnQgZm9yIGhvcCB0cmFuc2FjdGlvblxuICAgICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaG9wIHRyYW5zYWN0aW9uIG9ubHkgc3VwcG9ydHMgMSByZWNpcGllbnQgYnV0ICR7dHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGh9IGZvdW5kYCk7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayB0eCBzZW5kcyB0byBob3AgYWRkcmVzc1xuICAgICAgbGV0IGV4cGVjdGVkSG9wQWRkcmVzcztcbiAgICAgIGlmICh0eFByZWJ1aWxkLmhvcFRyYW5zYWN0aW9uLnR5cGUgPT09ICdFeHBvcnQnKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRIb3BUeCA9IGF3YWl0IHRoaXMuZXhwbGFpbkF0b21pY1RyYW5zYWN0aW9uKHR4UHJlYnVpbGQuaG9wVHJhbnNhY3Rpb24udHgpO1xuICAgICAgICBleHBlY3RlZEhvcEFkZHJlc3MgPSBvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChkZWNvZGVkSG9wVHguaW5wdXRzWzBdLmFkZHJlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZEhvcFR4ID0gb3B0aW9uYWxEZXBzLkV0aFR4LlRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tU2VyaWFsaXplZERhdGEoXG4gICAgICAgICAgb3B0aW9uYWxEZXBzLmV0aFV0aWwudG9CdWZmZXIodHhQcmVidWlsZC5ob3BUcmFuc2FjdGlvbi50eClcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0ZWRIb3BBZGRyZXNzID0gb3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoZGVjb2RlZEhvcFR4LmdldFNlbmRlckFkZHJlc3MoKS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdHVhbEhvcEFkZHJlc3MgPSBvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeCh0eFByZWJ1aWxkLnJlY2lwaWVudHNbMF0uYWRkcmVzcyk7XG4gICAgICBpZiAoZXhwZWN0ZWRIb3BBZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGFjdHVhbEhvcEFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY2lwaWVudCBhZGRyZXNzIG9mIHR4UHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggaG9wIGFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29udmVydCBUcmFuc2FjdGlvblJlY2lwaWVudCBhcnJheSB0byBSZWNpcGllbnQgYXJyYXlcbiAgICAgIGNvbnN0IHJlY2lwaWVudHM6IFJlY2lwaWVudFtdID0gdHhQYXJhbXMucmVjaXBpZW50cy5tYXAoKHIpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhZGRyZXNzOiByLmFkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiB0eXBlb2Ygci5hbW91bnQgPT09ICdudW1iZXInID8gci5hbW91bnQudG9TdHJpbmcoKSA6IHIuYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENoZWNrIGRlc3RpbmF0aW9uIGFkZHJlc3MgYW5kIGFtb3VudFxuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUhvcFByZWJ1aWxkKHdhbGxldCwgdHhQcmVidWlsZC5ob3BUcmFuc2FjdGlvbiwgeyByZWNpcGllbnRzIH0pO1xuICAgIH0gZWxzZSBpZiAodHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBDaGVjayB0b3RhbCBhbW91bnQgZm9yIGJhdGNoIHRyYW5zYWN0aW9uXG4gICAgICBsZXQgZXhwZWN0ZWRUb3RhbEFtb3VudCA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4UGFyYW1zLnJlY2lwaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhwZWN0ZWRUb3RhbEFtb3VudCA9IGV4cGVjdGVkVG90YWxBbW91bnQucGx1cyh0eFBhcmFtcy5yZWNpcGllbnRzW2ldLmFtb3VudCk7XG4gICAgICB9XG4gICAgICBpZiAoIWV4cGVjdGVkVG90YWxBbW91bnQuaXNFcXVhbFRvKHR4UHJlYnVpbGQucmVjaXBpZW50c1swXS5hbW91bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnYmF0Y2ggdHJhbnNhY3Rpb24gYW1vdW50IGluIHR4UHJlYnVpbGQgcmVjZWl2ZWQgZnJvbSBCaXRHbyBzZXJ2ZXJzIGRvZXMgbm90IG1hdGNoIHR4UGFyYW1zIHN1cHBsaWVkIGJ5IGNsaWVudCdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hlY2sgcmVjaXBpZW50IGFkZHJlc3MgYW5kIGFtb3VudCBmb3Igbm9ybWFsIHRyYW5zYWN0aW9uXG4gICAgICBpZiAodHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3JtYWwgdHJhbnNhY3Rpb24gb25seSBzdXBwb3J0cyAxIHJlY2lwaWVudCBidXQgJHt0eFBhcmFtcy5yZWNpcGllbnRzLmxlbmd0aH0gZm91bmRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4cGVjdGVkQW1vdW50ID0gbmV3IEJpZ051bWJlcih0eFBhcmFtcy5yZWNpcGllbnRzWzBdLmFtb3VudCk7XG4gICAgICBpZiAoIWV4cGVjdGVkQW1vdW50LmlzRXF1YWxUbyh0eFByZWJ1aWxkLnJlY2lwaWVudHNbMF0uYW1vdW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ25vcm1hbCB0cmFuc2FjdGlvbiBhbW91bnQgaW4gdHhQcmVidWlsZCByZWNlaXZlZCBmcm9tIEJpdEdvIHNlcnZlcnMgZG9lcyBub3QgbWF0Y2ggdHhQYXJhbXMgc3VwcGxpZWQgYnkgY2xpZW50J1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBBdmF4Qy5pc0FWQVhDQWRkcmVzcyh0eFBhcmFtcy5yZWNpcGllbnRzWzBdLmFkZHJlc3MpICYmXG4gICAgICAgIHR4UGFyYW1zLnJlY2lwaWVudHNbMF0uYWRkcmVzcyAhPT0gdHhQcmVidWlsZC5yZWNpcGllbnRzWzBdLmFkZHJlc3NcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlc3RpbmF0aW9uIGFkZHJlc3MgaW4gbm9ybWFsIHR4UHJlYnVpbGQgZG9lcyBub3QgbWF0Y2ggdGhhdCBpbiB0eFBhcmFtcyBzdXBwbGllZCBieSBjbGllbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgY29pbiBpcyBjb3JyZWN0IGZvciBhbGwgdHJhbnNhY3Rpb24gdHlwZXNcbiAgICBpZiAoIXRoaXMudmVyaWZ5Q29pbih0eFByZWJ1aWxkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb2luIGluIHR4UHJlYnVpbGQgZGlkIG5vdCBtYXRjaCB0aGF0IGluIHR4UGFyYW1zIHN1cHBsaWVkIGJ5IGNsaWVudGApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGlzQVZBWENBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIWFkZHJlc3MubWF0Y2goLzB4W2EtZkEtRjAtOV17NDB9Lyk7XG4gIH1cblxuICB2ZXJpZnlDb2luKHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHhQcmVidWlsZC5jb2luID09PSB0aGlzLmdldENoYWluKCk7XG4gIH1cblxuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgbmV3IEF2YXhjS2V5UGFpcih7IHB1YiB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBnYXMgbGltaXQgcGFzc2VkIGluIGJ5IHVzZXIgYXJlIHdpdGhpbiBvdXIgbWF4IGFuZCBtaW4gYm91bmRzXG4gICAqIElmIHRoZXkgYXJlIG5vdCBzZXQsIHNldCB0aGVtIHRvIHRoZSBkZWZhdWx0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gdXNlckdhc0xpbWl0IC0gdXNlciBkZWZpbmVkIGdhcyBsaW1pdFxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgZ2FzIGxpbWl0IHRvIHVzZSBmb3IgdGhpcyB0cmFuc2FjdGlvblxuICAgKi9cbiAgc2V0R2FzTGltaXQodXNlckdhc0xpbWl0PzogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoIXVzZXJHYXNMaW1pdCkge1xuICAgICAgcmV0dXJuIGV0aEdhc0NvbmZpZ3MuZGVmYXVsdEdhc0xpbWl0O1xuICAgIH1cbiAgICBjb25zdCBnYXNMaW1pdE1heCA9IGV0aEdhc0NvbmZpZ3MubWF4aW11bUdhc0xpbWl0O1xuICAgIGNvbnN0IGdhc0xpbWl0TWluID0gZXRoR2FzQ29uZmlncy5taW5pbXVtR2FzTGltaXQ7XG4gICAgaWYgKHVzZXJHYXNMaW1pdCA8IGdhc0xpbWl0TWluIHx8IHVzZXJHYXNMaW1pdCA+IGdhc0xpbWl0TWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdhcyBsaW1pdCBtdXN0IGJlIGJldHdlZW4gJHtnYXNMaW1pdE1pbn0gYW5kICR7Z2FzTGltaXRNYXh9YCk7XG4gICAgfVxuICAgIHJldHVybiB1c2VyR2FzTGltaXQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2FzIHByaWNlIHBhc3NlZCBpbiBieSB1c2VyIGFyZSB3aXRoaW4gb3VyIG1heCBhbmQgbWluIGJvdW5kc1xuICAgKiBJZiB0aGV5IGFyZSBub3Qgc2V0LCBzZXQgdGhlbSB0byB0aGUgZGVmYXVsdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHVzZXJHYXNQcmljZSAtIHVzZXIgZGVmaW5lZCBnYXMgcHJpY2VcbiAgICogQHJldHVybnMgdGhlIGdhcyBwcmljZSB0byB1c2UgZm9yIHRoaXMgdHJhbnNhY3Rpb25cbiAgICovXG4gIHNldEdhc1ByaWNlKHVzZXJHYXNQcmljZT86IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKCF1c2VyR2FzUHJpY2UpIHtcbiAgICAgIHJldHVybiBldGhHYXNDb25maWdzLmRlZmF1bHRHYXNQcmljZTtcbiAgICB9XG5cbiAgICBjb25zdCBnYXNQcmljZU1heCA9IGV0aEdhc0NvbmZpZ3MubWF4aW11bUdhc1ByaWNlO1xuICAgIGNvbnN0IGdhc1ByaWNlTWluID0gZXRoR2FzQ29uZmlncy5taW5pbXVtR2FzUHJpY2U7XG4gICAgaWYgKHVzZXJHYXNQcmljZSA8IGdhc1ByaWNlTWluIHx8IHVzZXJHYXNQcmljZSA+IGdhc1ByaWNlTWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdhcyBwcmljZSBtdXN0IGJlIGJldHdlZW4gJHtnYXNQcmljZU1pbn0gYW5kICR7Z2FzUHJpY2VNYXh9YCk7XG4gICAgfVxuICAgIHJldHVybiB1c2VyR2FzUHJpY2U7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIHF1ZXJ5IHRvIFNub3d0cmFjZSBmb3IgaW5mb3JtYXRpb24gc3VjaCBhcyBiYWxhbmNlLCB0b2tlbiBiYWxhbmNlLCBzb2xpZGl0eSBjYWxsc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcXVlcnkg4oCUIGtleS12YWx1ZSBwYWlycyBvZiBwYXJhbWV0ZXJzIHRvIGFwcGVuZCBhZnRlciAvYXBpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IHJlc3BvbnNlIGZyb20gU25vd3RyYWNlXG4gICAqL1xuICBhc3luYyByZWNvdmVyeUJsb2NrY2hhaW5FeHBsb3JlclF1ZXJ5KHF1ZXJ5OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB0b2tlbiA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0uc25vd3RyYWNlQXBpVG9rZW47XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBxdWVyeS5hcGlrZXkgPSB0b2tlbjtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LmdldChjb21tb24uRW52aXJvbm1lbnRzW3RoaXMuYml0Z28uZ2V0RW52KCldLnNub3d0cmFjZUJhc2VVcmwgKyAnL2FwaScpLnF1ZXJ5KHF1ZXJ5KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWNoIFNub3d0cmFjZScpO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5ib2R5LnN0YXR1cyA9PT0gJzAnICYmIHJlc3BvbnNlLmJvZHkubWVzc2FnZSA9PT0gJ05PVE9LJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTbm93dHJhY2UgcmF0ZSBsaW1pdCByZWFjaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5ib2R5O1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgcHVibGljIGJsb2NrIGV4cGxvcmVyIHRvIGdldCB0aGUgbmV4dCBub25jZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvclxuICAgKiB0aGUgZ2l2ZW4gQVZBWEMgYWRkcmVzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyDigJQgYWRkcmVzcyB0byBmZXRjaCBmb3JcbiAgICogQHJldHVybnMge251bWJlcn0gYWRkcmVzcyBub25jZVxuICAgKi9cbiAgYXN5bmMgZ2V0QWRkcmVzc05vbmNlKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgLy8gR2V0IG5vbmNlIGZvciBiYWNrdXAga2V5IChzaG91bGQgYmUgMClcbiAgICBsZXQgbm9uY2UgPSAwO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWNvdmVyeUJsb2NrY2hhaW5FeHBsb3JlclF1ZXJ5KHtcbiAgICAgIG1vZHVsZTogJ2FjY291bnQnLFxuICAgICAgYWN0aW9uOiAndHhsaXN0JyxcbiAgICAgIGFkZHJlc3MsXG4gICAgfSk7XG4gICAgaWYgKCFyZXN1bHQgfHwgIUFycmF5LmlzQXJyYXkocmVzdWx0LnJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbmV4dCBub25jZSBmcm9tIFNub3d0cmFjZSwgZ290OiAnICsgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgfVxuICAgIGNvbnN0IGJhY2t1cEtleVR4TGlzdCA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgaWYgKGJhY2t1cEtleVR4TGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBDYWxjdWxhdGUgbGFzdCBub25jZSB1c2VkXG4gICAgICBjb25zdCBvdXRnb2luZ1R4cyA9IGJhY2t1cEtleVR4TGlzdC5maWx0ZXIoKHR4KSA9PiB0eC5mcm9tID09PSBhZGRyZXNzKTtcbiAgICAgIG5vbmNlID0gb3V0Z29pbmdUeHMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gbm9uY2U7XG4gIH1cblxuICAvKipcbiAgICogUXVlcmllcyBTbm93dHJhY2UgZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSB0aGUgQVZBWEMgYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCaWdOdW1iZXI+fSBhZGRyZXNzIGJhbGFuY2VcbiAgICovXG4gIGFzeW5jIHF1ZXJ5QWRkcmVzc0JhbGFuY2UoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkoe1xuICAgICAgbW9kdWxlOiAnYWNjb3VudCcsXG4gICAgICBhY3Rpb246ICdiYWxhbmNlJyxcbiAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgfSk7XG4gICAgLy8gdGhyb3cgaWYgdGhlIHJlc3VsdCBkb2VzIG5vdCBleGlzdCBvciB0aGUgcmVzdWx0IGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQucmVzdWx0IHx8IGlzTmFOKHJlc3VsdC5yZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBvYnRhaW4gYWRkcmVzcyBiYWxhbmNlIGZvciAke2FkZHJlc3N9IGZyb20gU25vd3RyYWNlLCBnb3Q6ICR7cmVzdWx0LnJlc3VsdH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihyZXN1bHQucmVzdWx0LCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogUXVlcmllcyB0aGUgY29udHJhY3QgKHZpYSBTbm93dHJhY2UpIGZvciB0aGUgbmV4dCBzZXF1ZW5jZSBJRFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IHNlcXVlbmNlIElEXG4gICAqL1xuICBhc3luYyBxdWVyeVNlcXVlbmNlSWQoYWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBHZXQgc2VxdWVuY2UgSUQgdXNpbmcgY29udHJhY3QgY2FsbFxuICAgIGNvbnN0IHNlcXVlbmNlSWRNZXRob2RTaWduYXR1cmUgPSBvcHRpb25hbERlcHMuZXRoQWJpLm1ldGhvZElEKCdnZXROZXh0U2VxdWVuY2VJZCcsIFtdKTtcbiAgICBjb25zdCBzZXF1ZW5jZUlkQXJncyA9IG9wdGlvbmFsRGVwcy5ldGhBYmkucmF3RW5jb2RlKFtdLCBbXSk7XG4gICAgY29uc3Qgc2VxdWVuY2VJZERhdGEgPSBCdWZmZXIuY29uY2F0KFtzZXF1ZW5jZUlkTWV0aG9kU2lnbmF0dXJlLCBzZXF1ZW5jZUlkQXJnc10pLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlY292ZXJ5QmxvY2tjaGFpbkV4cGxvcmVyUXVlcnkoe1xuICAgICAgbW9kdWxlOiAncHJveHknLFxuICAgICAgYWN0aW9uOiAnZXRoX2NhbGwnLFxuICAgICAgdG86IGFkZHJlc3MsXG4gICAgICBkYXRhOiBzZXF1ZW5jZUlkRGF0YSxcbiAgICAgIHRhZzogJ2xhdGVzdCcsXG4gICAgfSk7XG4gICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5yZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IG9idGFpbiBzZXF1ZW5jZSBJRCBmcm9tIFNub3d0cmFjZSwgZ290OiAnICsgcmVzdWx0LnJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IHNlcXVlbmNlSWRIZXggPSByZXN1bHQucmVzdWx0O1xuICAgIHJldHVybiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4oc2VxdWVuY2VJZEhleC5zbGljZSgyKSwgMTYpLnRvTnVtYmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlY2lwaWVudCAtIHJlY2lwaWVudCBpbmZvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBleHBpcmVUaW1lIC0gZXhwaXJ5IHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvbnRyYWN0U2VxdWVuY2VJZCAtIHNlcXVlbmNlIGlkXG4gICAqIEByZXR1cm5zIHsoc3RyaW5nfEFycmF5KX0gb3BlcmF0aW9uIGFycmF5XG4gICAqL1xuICBnZXRPcGVyYXRpb24ocmVjaXBpZW50OiBSZWNpcGllbnQsIGV4cGlyZVRpbWU6IG51bWJlciwgY29udHJhY3RTZXF1ZW5jZUlkOiBudW1iZXIpOiAoc3RyaW5nIHwgQnVmZmVyKVtdW10ge1xuICAgIHJldHVybiBbXG4gICAgICBbJ3N0cmluZycsICdhZGRyZXNzJywgJ3VpbnQnLCAnYnl0ZXMnLCAndWludCcsICd1aW50J10sXG4gICAgICBbXG4gICAgICAgICdFVEhFUicsXG4gICAgICAgIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChyZWNpcGllbnQuYWRkcmVzcyksIDE2KSxcbiAgICAgICAgcmVjaXBpZW50LmFtb3VudCxcbiAgICAgICAgQnVmZmVyLmZyb20ob3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgob3B0aW9uYWxEZXBzLmV0aFV0aWwucGFkVG9FdmVuKHJlY2lwaWVudC5kYXRhIHx8ICcnKSksICdoZXgnKSxcbiAgICAgICAgZXhwaXJlVGltZSxcbiAgICAgICAgY29udHJhY3RTZXF1ZW5jZUlkLFxuICAgICAgXSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgb3BlcmF0aW9uIGhhc2ggaW4gdGhlIHNhbWUgd2F5IHNvbGlkaXR5IHdvdWxkXG4gICAqIEBwYXJhbSB7UmVjaXBpZW50W119IHJlY2lwaWVudHMgLSB0eCByZWNpcGllbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBleHBpcmVUaW1lIC0gZXhwaXJhdGlvbiB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb250cmFjdFNlcXVlbmNlSWQgLSBjb250cmFjdCBzZXF1ZW5jZSBpZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBvcGVyYXRpb24gaGFzaFxuICAgKi9cbiAgZ2V0T3BlcmF0aW9uU2hhM0ZvckV4ZWN1dGVBbmRDb25maXJtKFxuICAgIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdLFxuICAgIGV4cGlyZVRpbWU6IG51bWJlcixcbiAgICBjb250cmFjdFNlcXVlbmNlSWQ6IG51bWJlclxuICApOiBzdHJpbmcge1xuICAgIGlmICghcmVjaXBpZW50cyB8fCAhQXJyYXkuaXNBcnJheShyZWNpcGllbnRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgYXJyYXkgb2YgcmVjaXBpZW50cycpO1xuICAgIH1cblxuICAgIC8vIFJpZ2h0IG5vdyB3ZSBvbmx5IHN1cHBvcnQgMSByZWNpcGllbnRcbiAgICBpZiAocmVjaXBpZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBzZW5kIHRvIGV4YWN0bHkgMSByZWNpcGllbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNOdW1iZXIoZXhwaXJlVGltZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwaXJlVGltZSBtdXN0IGJlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIGVwb2NoJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzTnVtYmVyKGNvbnRyYWN0U2VxdWVuY2VJZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29udHJhY3RTZXF1ZW5jZUlkIG11c3QgYmUgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaW5wdXRzXG4gICAgcmVjaXBpZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNpcGllbnQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIV8uaXNTdHJpbmcocmVjaXBpZW50LmFkZHJlc3MpIHx8XG4gICAgICAgICFvcHRpb25hbERlcHMuZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyhvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgocmVjaXBpZW50LmFkZHJlc3MpKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzOiAnICsgcmVjaXBpZW50LmFkZHJlc3MpO1xuICAgICAgfVxuXG4gICAgICBsZXQgYW1vdW50O1xuICAgICAgdHJ5IHtcbiAgICAgICAgYW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnQuYW1vdW50KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFtb3VudCBmb3I6ICcgKyByZWNpcGllbnQuYWRkcmVzcyArICcgLSBzaG91bGQgYmUgbnVtZXJpYycpO1xuICAgICAgfVxuXG4gICAgICByZWNpcGllbnQuYW1vdW50ID0gYW1vdW50LnRvRml4ZWQoMCk7XG5cbiAgICAgIGlmIChyZWNpcGllbnQuZGF0YSAmJiAhXy5pc1N0cmluZyhyZWNpcGllbnQuZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGZvciByZWNpcGllbnQgJyArIHJlY2lwaWVudC5hZGRyZXNzICsgJyAtIHNob3VsZCBiZSBvZiB0eXBlIGhleCBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHJlY2lwaWVudCA9IHJlY2lwaWVudHNbMF07XG4gICAgcmV0dXJuIG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSGV4KFxuICAgICAgb3B0aW9uYWxEZXBzLmV0aEFiaS5zb2xpZGl0eVNIQTMoLi4udGhpcy5nZXRPcGVyYXRpb24ocmVjaXBpZW50LCBleHBpcmVUaW1lLCBjb250cmFjdFNlcXVlbmNlSWQpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBleHBpcmUgdGltZSBmb3IgYSBjb250cmFjdCBjYWxsICgxIHdlZWspXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRpbWUgaW4gc2Vjb25kc1xuICAgKi9cbiAgZ2V0RGVmYXVsdEV4cGlyZVRpbWUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgNjAgKiA2MCAqIDI0ICogNztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhcmd1bWVudHMgdG8gY2FsbCB0aGUgc2VuZCBtZXRob2Qgb24gdGhlIHdhbGxldCBjb250cmFjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gdHhJbmZvIC0gZGF0YSBmb3Igc2VuZCBtZXRob2QgYXJnc1xuICAgKiBAcmV0dXJucyB7U2VuZE1ldGhvZEFyZ3NbXX1cbiAgICovXG4gIGdldFNlbmRNZXRob2RBcmdzKHR4SW5mbzogR2V0U2VuZE1ldGhvZEFyZ3NPcHRpb25zKTogU2VuZE1ldGhvZEFyZ3NbXSB7XG4gICAgLy8gTWV0aG9kIHNpZ25hdHVyZSBpc1xuICAgIC8vIHNlbmRNdWx0aVNpZyhhZGRyZXNzIHRvQWRkcmVzcywgdWludCB2YWx1ZSwgYnl0ZXMgZGF0YSwgdWludCBleHBpcmVUaW1lLCB1aW50IHNlcXVlbmNlSWQsIGJ5dGVzIHNpZ25hdHVyZSlcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBuYW1lOiAndG9BZGRyZXNzJyxcbiAgICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICAgICAgICB2YWx1ZTogdHhJbmZvLnJlY2lwaWVudC5hZGRyZXNzLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgICAgdHlwZTogJ3VpbnQnLFxuICAgICAgICB2YWx1ZTogdHhJbmZvLnJlY2lwaWVudC5hbW91bnQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnZGF0YScsXG4gICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgIHZhbHVlOiBvcHRpb25hbERlcHMuZXRoVXRpbC50b0J1ZmZlcihvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgodHhJbmZvLnJlY2lwaWVudC5kYXRhIHx8ICcnKSksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnZXhwaXJlVGltZScsXG4gICAgICAgIHR5cGU6ICd1aW50JyxcbiAgICAgICAgdmFsdWU6IHR4SW5mby5leHBpcmVUaW1lLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3NlcXVlbmNlSWQnLFxuICAgICAgICB0eXBlOiAndWludCcsXG4gICAgICAgIHZhbHVlOiB0eEluZm8uY29udHJhY3RTZXF1ZW5jZUlkLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3NpZ25hdHVyZScsXG4gICAgICAgIHR5cGU6ICdieXRlcycsXG4gICAgICAgIHZhbHVlOiBvcHRpb25hbERlcHMuZXRoVXRpbC50b0J1ZmZlcihvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgodHhJbmZvLnNpZ25hdHVyZSkpLFxuICAgICAgfSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogU3RlcHM6XG4gICAqIDEpIE5vZGUgcXVlcnkgLSBob3cgbXVjaCBtb25leSBpcyBpbiB0aGUgYWNjb3VudFxuICAgKiAyKSBCdWlsZCB0cmFuc2FjdGlvbiAtIGJ1aWxkIG91ciB0cmFuc2FjdGlvbiBmb3IgdGhlIGFtb3VudFxuICAgKiAzKSBTZW5kIHNpZ25lZCBidWlsZCAtIHNlbmQgb3VyIHNpZ25lZCBidWlsZCB0byBhIHB1YmxpYyBub2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIG9wdGlvbnMgd2l0aCB3aGljaCB0byByZWNvdmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXNlcktleSAtIFtlbmNyeXB0ZWRdIHhwcnZcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5iYWNrdXBLZXkgLSBbZW5jcnlwdGVkXSB4cHJ2IG9yIHhwdWIgaWYgdGhlIHhwcnYgaXMgaGVsZCBieSBhIEtSUyBwcm92aWRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLndhbGxldFBhc3NwaHJhc2UgLSB1c2VkIHRvIGRlY3J5cHQgdXNlcktleSBhbmQgYmFja3VwS2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzIC0gdGhlIEFWQVhDIGFkZHJlc3Mgb2YgdGhlIHdhbGxldCBjb250cmFjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24gLSB0YXJnZXQgYWRkcmVzcyB0byBzZW5kIHJlY292ZXJlZCBmdW5kcyB0b1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWNvdmVyeUluZm8+fSAtIHJlY292ZXJ5IHR4IGluZm9cbiAgICovXG4gIGFzeW5jIHJlY292ZXIocGFyYW1zOiBSZWNvdmVyT3B0aW9ucyk6IFByb21pc2U8UmVjb3ZlcnlJbmZvIHwgT2ZmbGluZVZhdWx0VHhJbmZvPiB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnVzZXJLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdXNlcktleScpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5iYWNrdXBLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgYmFja3VwS2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldFBhc3NwaHJhc2UpICYmICFwYXJhbXMudXNlcktleS5zdGFydHNXaXRoKCd4cHViJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyB3YWxsZXQgcGFzc3BocmFzZScpO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2FsbGV0Q29udHJhY3RBZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24pIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIChCRy01NjUzMSk6IGFkZCBzdXBwb3J0IGZvciBrcnNcbiAgICBjb25zdCBpc1Vuc2lnbmVkU3dlZXAgPSBnZXRJc1Vuc2lnbmVkU3dlZXAocGFyYW1zKTtcblxuICAgIC8vIENsZWFuIHVwIHdoaXRlc3BhY2UgZnJvbSBlbnRlcmVkIHZhbHVlc1xuICAgIGxldCB1c2VyS2V5ID0gcGFyYW1zLnVzZXJLZXkucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICBjb25zdCBiYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgICAvLyBTZXQgbmV3IHR4IGZlZXMgKHVzaW5nIGRlZmF1bHQgY29uZmlnIHZhbHVlcyBmcm9tIHBsYXRmb3JtKVxuICAgIGNvbnN0IGdhc0xpbWl0ID0gbmV3IG9wdGlvbmFsRGVwcy5ldGhVdGlsLkJOKHRoaXMuc2V0R2FzTGltaXQocGFyYW1zLmdhc0xpbWl0KSk7XG4gICAgY29uc3QgZ2FzUHJpY2UgPSBwYXJhbXMuZWlwMTU1OVxuICAgICAgPyBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocGFyYW1zLmVpcDE1NTkubWF4RmVlUGVyR2FzKVxuICAgICAgOiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4odGhpcy5zZXRHYXNQcmljZShwYXJhbXMuZ2FzUHJpY2UpKTtcbiAgICBpZiAoIXVzZXJLZXkuc3RhcnRzV2l0aCgneHB1YicpICYmICF1c2VyS2V5LnN0YXJ0c1dpdGgoJ3hwcnYnKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXNlcktleSA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNyeXB0aW5nIHVzZXIga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBiYWNrdXBLZXlBZGRyZXNzO1xuICAgIGxldCBiYWNrdXBTaWduaW5nS2V5O1xuICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIGNvbnN0IGJhY2t1cEtleVBhaXIgPSBuZXcgQXZheGNLZXlQYWlyKHsgcHViOiBiYWNrdXBLZXkgfSk7XG4gICAgICBiYWNrdXBLZXlBZGRyZXNzID0gYmFja3VwS2V5UGFpci5nZXRBZGRyZXNzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlY3J5cHQgYmFja3VwIHByaXZhdGUga2V5IGFuZCBnZXQgYWRkcmVzc1xuICAgICAgbGV0IGJhY2t1cFBydjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgYmFja3VwUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgICBpbnB1dDogYmFja3VwS2V5LFxuICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjcnlwdGluZyBiYWNrdXAga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBrZXlQYWlyID0gbmV3IEF2YXhjS2V5UGFpcih7IHBydjogYmFja3VwUHJ2IH0pO1xuICAgICAgYmFja3VwU2lnbmluZ0tleSA9IGtleVBhaXIuZ2V0S2V5cygpLnBydjtcbiAgICAgIGlmICghYmFja3VwU2lnbmluZ0tleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHByaXZhdGUga2V5Jyk7XG4gICAgICB9XG4gICAgICBiYWNrdXBLZXlBZGRyZXNzID0ga2V5UGFpci5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIGNvbnN0IGJhY2t1cEtleU5vbmNlID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzTm9uY2UoYmFja3VwS2V5QWRkcmVzcyk7XG5cbiAgICAvLyBnZXQgYmFsYW5jZSBvZiBiYWNrdXBLZXkgdG8gZW5zdXJlIGZ1bmRzIGFyZSBhdmFpbGFibGUgdG8gcGF5IGZlZXNcbiAgICBjb25zdCBiYWNrdXBLZXlCYWxhbmNlID0gYXdhaXQgdGhpcy5xdWVyeUFkZHJlc3NCYWxhbmNlKGJhY2t1cEtleUFkZHJlc3MpO1xuXG4gICAgY29uc3QgdG90YWxHYXNOZWVkZWQgPSBnYXNQcmljZS5tdWwoZ2FzTGltaXQpO1xuICAgIGNvbnN0IHdlaVRvR3dlaSA9IDEwICoqIDk7XG4gICAgaWYgKGJhY2t1cEtleUJhbGFuY2UubHQodG90YWxHYXNOZWVkZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYWNrdXAga2V5IGFkZHJlc3MgJHtiYWNrdXBLZXlBZGRyZXNzfSBoYXMgYmFsYW5jZSAkeyhiYWNrdXBLZXlCYWxhbmNlIC8gd2VpVG9Hd2VpKS50b1N0cmluZygpfSBHd2VpLmAgK1xuICAgICAgICAgIGBUaGlzIGFkZHJlc3MgbXVzdCBoYXZlIGEgYmFsYW5jZSBvZiBhdCBsZWFzdCAkeyh0b3RhbEdhc05lZWRlZCAvIHdlaVRvR3dlaSkudG9TdHJpbmcoKX1gICtcbiAgICAgICAgICBgIEd3ZWkgdG8gcGVyZm9ybSByZWNvdmVyaWVzLiBUcnkgc2VuZGluZyBzb21lIEFWQVggdG8gdGhpcyBhZGRyZXNzIHRoZW4gcmV0cnkuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYmFsYW5jZSBvZiB3YWxsZXQgYW5kIGRlZHVjdCBmZWVzIHRvIGdldCB0cmFuc2FjdGlvbiBhbW91bnRcbiAgICBjb25zdCB0eEFtb3VudCA9IGF3YWl0IHRoaXMucXVlcnlBZGRyZXNzQmFsYW5jZShwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKTtcblxuICAgIC8vIGJ1aWxkIHJlY2lwaWVudHMgb2JqZWN0XG4gICAgY29uc3QgcmVjaXBpZW50cyA9IFtcbiAgICAgIHtcbiAgICAgICAgYWRkcmVzczogcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb24sXG4gICAgICAgIGFtb3VudDogdHhBbW91bnQudG9TdHJpbmcoMTApLFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgLy8gR2V0IHNlcXVlbmNlIElEIHVzaW5nIGNvbnRyYWN0IGNhbGxcbiAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgYmV0d2VlbiBtYWtpbmcgdHdvIHNub3d0cmFjZSBjYWxscyB0byBhdm9pZCBnZXR0aW5nIGJhbm5lZFxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICBjb25zdCBzZXF1ZW5jZUlkID0gYXdhaXQgdGhpcy5xdWVyeVNlcXVlbmNlSWQocGFyYW1zLndhbGxldENvbnRyYWN0QWRkcmVzcyk7XG5cbiAgICBsZXQgb3BlcmF0aW9uSGFzaCwgc2lnbmF0dXJlO1xuICAgIC8vIEdldCBvcGVyYXRpb24gaGFzaCBhbmQgc2lnbiBpdFxuICAgIGlmICghaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICBvcGVyYXRpb25IYXNoID0gdGhpcy5nZXRPcGVyYXRpb25TaGEzRm9yRXhlY3V0ZUFuZENvbmZpcm0ocmVjaXBpZW50cywgdGhpcy5nZXREZWZhdWx0RXhwaXJlVGltZSgpLCBzZXF1ZW5jZUlkKTtcbiAgICAgIHNpZ25hdHVyZSA9IFV0aWwuZXRoU2lnbk1zZ0hhc2gob3BlcmF0aW9uSGFzaCwgVXRpbC54cHJ2VG9FdGhQcml2YXRlS2V5KHVzZXJLZXkpKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgVXRpbC5lY1JlY292ZXJFdGhBZGRyZXNzKG9wZXJhdGlvbkhhc2gsIHNpZ25hdHVyZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0eEluZm8gPSB7XG4gICAgICByZWNpcGllbnQ6IHJlY2lwaWVudHNbMF0sXG4gICAgICBleHBpcmVUaW1lOiB0aGlzLmdldERlZmF1bHRFeHBpcmVUaW1lKCksXG4gICAgICBjb250cmFjdFNlcXVlbmNlSWQ6IHNlcXVlbmNlSWQsXG4gICAgICBvcGVyYXRpb25IYXNoLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgZ2FzTGltaXQ6IGdhc0xpbWl0LnRvU3RyaW5nKDEwKSxcbiAgICB9O1xuXG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRUcmFuc2FjdGlvbkJ1aWxkZXIoKSBhcyBUcmFuc2FjdGlvbkJ1aWxkZXI7XG4gICAgdHhCdWlsZGVyLmNvdW50ZXIoYmFja3VwS2V5Tm9uY2UpO1xuICAgIHR4QnVpbGRlci5jb250cmFjdChwYXJhbXMud2FsbGV0Q29udHJhY3RBZGRyZXNzKTtcbiAgICBsZXQgdHhGZWU7XG4gICAgaWYgKHBhcmFtcy5laXAxNTU5KSB7XG4gICAgICB0eEZlZSA9IHtcbiAgICAgICAgZWlwMTU1OToge1xuICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBwYXJhbXMuZWlwMTU1OS5tYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICBtYXhGZWVQZXJHYXM6IHBhcmFtcy5laXAxNTU5Lm1heEZlZVBlckdhcyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4RmVlID0geyBmZWU6IGdhc1ByaWNlLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgdHhCdWlsZGVyLmZlZSh7XG4gICAgICAuLi50eEZlZSxcbiAgICAgIGdhc0xpbWl0OiBnYXNMaW1pdC50b1N0cmluZygpLFxuICAgIH0pO1xuICAgIHR4QnVpbGRlclxuICAgICAgLnRyYW5zZmVyKClcbiAgICAgIC5hbW91bnQocmVjaXBpZW50c1swXS5hbW91bnQpXG4gICAgICAuY29udHJhY3RTZXF1ZW5jZUlkKHNlcXVlbmNlSWQpXG4gICAgICAuZXhwaXJhdGlvblRpbWUodGhpcy5nZXREZWZhdWx0RXhwaXJlVGltZSgpKVxuICAgICAgLnRvKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKTtcblxuICAgIGlmIChpc1Vuc2lnbmVkU3dlZXApIHtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgICBjb25zdCByZXNwb25zZTogT2ZmbGluZVZhdWx0VHhJbmZvID0ge1xuICAgICAgICB0eEhleDogdHgudG9Ccm9hZGNhc3RGb3JtYXQoKSxcbiAgICAgICAgdXNlcktleSxcbiAgICAgICAgYmFja3VwS2V5LFxuICAgICAgICBjb2luOiB0aGlzLmdldENoYWluKCksXG4gICAgICAgIGdhc1ByaWNlOiBvcHRpb25hbERlcHMuZXRoVXRpbC5idWZmZXJUb0ludChnYXNQcmljZSkudG9GaXhlZCgpLFxuICAgICAgICBnYXNMaW1pdCxcbiAgICAgICAgcmVjaXBpZW50czogW3R4SW5mby5yZWNpcGllbnRdLFxuICAgICAgICB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHR4LnRvSnNvbigpLnRvLFxuICAgICAgICBhbW91bnQ6IHR4SW5mby5yZWNpcGllbnQuYW1vdW50LFxuICAgICAgICBiYWNrdXBLZXlOb25jZSxcbiAgICAgICAgZWlwMTU1OTogcGFyYW1zLmVpcDE1NTksXG4gICAgICB9O1xuICAgICAgXy5leHRlbmQocmVzcG9uc2UsIHR4SW5mbyk7XG4gICAgICByZXNwb25zZS5uZXh0Q29udHJhY3RTZXF1ZW5jZUlkID0gcmVzcG9uc2UuY29udHJhY3RTZXF1ZW5jZUlkO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJLZXlQYWlyID0gbmV3IEF2YXhjS2V5UGFpcih7IHBydjogdXNlcktleSB9KTtcbiAgICB0eEJ1aWxkZXIudHJhbnNmZXIoKS5rZXkodXNlcktleVBhaXIuZ2V0S2V5cygpLnBydiEpO1xuICAgIHR4QnVpbGRlci5zaWduKHsga2V5OiBiYWNrdXBTaWduaW5nS2V5IH0pO1xuICAgIGNvbnN0IHNpZ25lZFR4ID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHNpZ25lZFR4LnRvSnNvbigpLmlkLFxuICAgICAgdHg6IHNpZ25lZFR4LnRvQnJvYWRjYXN0Rm9ybWF0KCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gYnVpbGRlciBmb3IgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICogQHJldHVybiBhIG5ldyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VHJhbnNhY3Rpb25CdWlsZGVyKCk6IEV0aFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkJ1aWxkZXIoY29pbnMuZ2V0KHRoaXMuZ2V0QmFzZUNoYWluKCkpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRBdG9taWNCdWlsZGVyKCk6IEF2YXhwTGliLlRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICAgIHJldHVybiBuZXcgQXZheHBMaWIuVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRBdmF4UCgpKSk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbiBhIHRyYW5zYWN0aW9uIGZyb20gdHhIZXgsIG92ZXJyaWRpbmcgQmFzZUNvaW5zXG4gICAqIHRyYW5zYWN0aW9uIGNhbiBiZSBlaXRoZXIgYXRvbWljIG9yIGV0aCB0eG4uXG4gICAqIEBwYXJhbSBwYXJhbXMgVGhlIG9wdGlvbnMgd2l0aCB3aGljaCB0byBleHBsYWluIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKHBhcmFtczogRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8VHJhbnNhY3Rpb25FeHBsYW5hdGlvbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4SGV4IHx8IChwYXJhbXMuaGFsZlNpZ25lZCAmJiBwYXJhbXMuaGFsZlNpZ25lZC50eEhleCk7XG4gICAgaWYgKCF0eEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHR4SGV4IGluIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmNyb3NzQ2hhaW5UeXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBsYWluQXRvbWljVHJhbnNhY3Rpb24odHhIZXgpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5mZWVJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgZmVlSW5mbyBpbiBleHBsYWluIHR4IHBhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRUcmFuc2FjdGlvbkJ1aWxkZXIoKTtcbiAgICB0eEJ1aWxkZXIuZnJvbSh0eEhleCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLmV4cGxhaW5FVk1UcmFuc2FjdGlvbih0eCksIHsgZmVlOiBwYXJhbXMuZmVlSW5mbyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWlucyBhbiBhdG9taWMgdHJhbnNhY3Rpb24gdXNpbmcgYXRvbWljIGJ1aWxkZXIuXG4gICAqIEBwYXJhbSB0eEhleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBleHBsYWluQXRvbWljVHJhbnNhY3Rpb24odHhIZXg6IHN0cmluZykge1xuICAgIGNvbnN0IHR4QnVpbGRlciA9IHRoaXMuZ2V0QXRvbWljQnVpbGRlcigpLmZyb20odHhIZXgpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgdHhCdWlsZGVyLmJ1aWxkKCk7XG4gICAgcmV0dXJuIHR4LmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBzaWduYXR1cmUgZm9yIGFuIGF0b21pYyB0cmFuc2FjdGlvbiB1c2luZyBhdG9taWMgYnVpbGRlci5cbiAgICogQHBhcmFtIHR4SGV4XG4gICAqIEByZXR1cm4gdHJ1ZSBpZiBzaWduYXR1cmUgaXMgZnJvbSB0aGUgaW5wdXQgYWRkcmVzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2ZXJpZnlTaWduYXR1cmVGb3JBdG9taWNUcmFuc2FjdGlvbih0eEhleDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRBdG9taWNCdWlsZGVyKCkuZnJvbSh0eEhleCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCBwYXlsb2FkID0gdHguc2lnbmFibGVQYXlsb2FkO1xuICAgIGNvbnN0IHNpZ25hdHVyZXMgPSB0eC5zaWduYXR1cmUubWFwKChzKSA9PiBCdWZmZXIuZnJvbShzLCAnaGV4JykpO1xuICAgIGNvbnN0IG5ldHdvcmsgPSBfLmdldCh0eCwgJ19uZXR3b3JrJyk7XG4gICAgY29uc3QgcmVjb3ZlclB1Ymt5ID0gc2lnbmF0dXJlcy5tYXAoKHMpID0+XG4gICAgICBBdmF4cExpYi5VdGlscy5yZWNvdmVyeVNpZ25hdHVyZShuZXR3b3JrIGFzIHVua25vd24gYXMgQXZhbGFuY2hlTmV0d29yaywgcGF5bG9hZCwgcylcbiAgICApO1xuICAgIGNvbnN0IGV4cGVjdGVkU2VuZGVycyA9IHJlY292ZXJQdWJreS5tYXAoKHIpID0+IHB1YlRvQWRkcmVzcyhyLCB0cnVlKSk7XG4gICAgY29uc3Qgc2VuZGVycyA9IHR4LmlucHV0cy5tYXAoKGkpID0+IEF2YXhwTGliLlV0aWxzLnBhcnNlQWRkcmVzcyhpLmFkZHJlc3MpKTtcbiAgICByZXR1cm4gZXhwZWN0ZWRTZW5kZXJzLmV2ZXJ5KChlKSA9PiBzZW5kZXJzLnNvbWUoKHNlbmRlcikgPT4gZS5lcXVhbHMoc2VuZGVyKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW5zIGFuIEVWTSB0cmFuc2FjdGlvbiB1c2luZyByZWd1bGFyIGV0aCB0eG4gYnVpbGRlclxuICAgKiBAcGFyYW0gdHhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgZXhwbGFpbkVWTVRyYW5zYWN0aW9uKHR4OiBCYXNlVHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBvdXRwdXRzID0gdHgub3V0cHV0cy5tYXAoKG91dHB1dCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogb3V0cHV0LmFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogb3V0cHV0LnZhbHVlLFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBkaXNwbGF5T3JkZXIgPSBbJ2lkJywgJ291dHB1dEFtb3VudCcsICdjaGFuZ2VBbW91bnQnLCAnb3V0cHV0cycsICdjaGFuZ2VPdXRwdXRzJywgJ2ZlZSddO1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5T3JkZXIsXG4gICAgICBpZDogdHguaWQsXG4gICAgICBvdXRwdXRzOiBvdXRwdXRzLFxuICAgICAgb3V0cHV0QW1vdW50OiBvdXRwdXRzXG4gICAgICAgIC5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBvdXRwdXQpID0+IGFjY3VtdWxhdG9yLnBsdXMob3V0cHV0LmFtb3VudCksIG5ldyBCaWdOdW1iZXIoJzAnKSlcbiAgICAgICAgLnRvRml4ZWQoMCksXG4gICAgICBjaGFuZ2VPdXRwdXRzOiBbXSwgLy8gYWNjb3VudCBiYXNlZCBkb2VzIG5vdCB1c2UgY2hhbmdlIG91dHB1dHNcbiAgICAgIGNoYW5nZUFtb3VudDogJzAnLCAvLyBhY2NvdW50IGJhc2UgZG9lcyBub3QgbWFrZSBjaGFuZ2VcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFib3ZlIGlzIHN0YW5kYXJkIEJhc2VDb2lucyBmdW5jdGlvbnNcbiAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAqIEJlbG93IGlzIHRyYW5zYWN0aW9uIGZ1bmN0aW9uc1xuICAgKi9cblxuICAvKipcbiAgICogQ29pbi1zcGVjaWZpYyB0aGluZ3MgZG9uZSBiZWZvcmUgc2lnbmluZyBhIHRyYW5zYWN0aW9uLCBpLmUuIHZlcmlmaWNhdGlvblxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBhc3luYyBwcmVzaWduVHJhbnNhY3Rpb24ocGFyYW1zOiBQcmVzaWduVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQcmVzaWduVHJhbnNhY3Rpb25PcHRpb25zPiB7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5ob3BUcmFuc2FjdGlvbikgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldCkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLmJ1aWxkUGFyYW1zKSkge1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUhvcFByZWJ1aWxkKHBhcmFtcy53YWxsZXQsIHBhcmFtcy5ob3BUcmFuc2FjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZ5IHByZWJ1aWxkIGFmdGVyIHJlY2VpdmluZyBpdCBmcm9tIHRoZSBzZXJ2ZXIuIEFkZCB0aGluZ3MgbGlrZSBubG9ja3RpbWVcbiAgICovXG4gIGFzeW5jIHBvc3RQcm9jZXNzUHJlYnVpbGQocGFyYW1zOiBUcmFuc2FjdGlvblByZWJ1aWxkKTogUHJvbWlzZTxUcmFuc2FjdGlvblByZWJ1aWxkPiB7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHBhcmFtcy5ob3BUcmFuc2FjdGlvbikgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLndhbGxldCkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLmJ1aWxkUGFyYW1zKSkge1xuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUhvcFByZWJ1aWxkKHBhcmFtcy53YWxsZXQsIHBhcmFtcy5ob3BUcmFuc2FjdGlvbiwgcGFyYW1zLmJ1aWxkUGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgaG9wIHByZWJ1aWxkIGZyb20gdGhlIEhTTSBpcyB2YWxpZCBhbmQgY29ycmVjdFxuICAgKiBAcGFyYW0gd2FsbGV0IFRoZSB3YWxsZXQgdGhhdCB0aGUgcHJlYnVpbGQgaXMgZm9yXG4gICAqIEBwYXJhbSBob3BQcmVidWlsZCBUaGUgcHJlYnVpbGQgdG8gdmFsaWRhdGVcbiAgICogQHBhcmFtIG9yaWdpbmFsUGFyYW1zIFRoZSBvcmlnaW5hbCBwYXJhbWV0ZXJzIHBhc3NlZCB0byBwcmVidWlsZFRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHZvaWRcbiAgICogQHRocm93cyBFcnJvciBpZiBUaGUgcHJlYnVpbGQgaXMgaW52YWxpZFxuICAgKi9cbiAgYXN5bmMgdmFsaWRhdGVIb3BQcmVidWlsZChcbiAgICB3YWxsZXQ6IElXYWxsZXQsXG4gICAgaG9wUHJlYnVpbGQ6IEhvcFByZWJ1aWxkLFxuICAgIG9yaWdpbmFsUGFyYW1zPzogeyByZWNpcGllbnRzOiBSZWNpcGllbnRbXSB9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgdHgsIGlkLCBzaWduYXR1cmUgfSA9IGhvcFByZWJ1aWxkO1xuXG4gICAgLy8gZmlyc3QsIHZhbGlkYXRlIHRoZSBIU00gc2lnbmF0dXJlXG4gICAgY29uc3Qgc2VydmVyWHB1YiA9IGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0uaHNtWHB1YjtcbiAgICBjb25zdCBzZXJ2ZXJQdWJrZXlCdWZmZXI6IEJ1ZmZlciA9IGJpcDMyLmZyb21CYXNlNTgoc2VydmVyWHB1YikucHVibGljS2V5O1xuICAgIGNvbnN0IHNpZ25hdHVyZUJ1ZmZlcjogQnVmZmVyID0gQnVmZmVyLmZyb20ob3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoc2lnbmF0dXJlKSwgJ2hleCcpO1xuICAgIGNvbnN0IG1lc3NhZ2VCdWZmZXI6IEJ1ZmZlciA9XG4gICAgICBob3BQcmVidWlsZC50eXBlID09PSAnRXhwb3J0JyA/IEF2YXhDLmdldFR4SGFzaCh0eCkgOiBCdWZmZXIuZnJvbShvcHRpb25hbERlcHMuZXRoVXRpbC5zdHJpcEhleFByZWZpeChpZCksICdoZXgnKTtcblxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZUJ1ZmZlci5sZW5ndGggPT09IDY0ID8gc2lnbmF0dXJlQnVmZmVyIDogc2lnbmF0dXJlQnVmZmVyLnNsaWNlKDEpKTtcbiAgICBjb25zdCBpc1ZhbGlkU2lnbmF0dXJlOiBib29sZWFuID0gc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KHNpZywgbWVzc2FnZUJ1ZmZlciwgc2VydmVyUHVia2V5QnVmZmVyKTtcbiAgICBpZiAoIWlzVmFsaWRTaWduYXR1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSG9wIHR4aWQgc2lnbmF0dXJlIGludmFsaWRgKTtcbiAgICB9XG5cbiAgICBpZiAoaG9wUHJlYnVpbGQudHlwZSA9PT0gJ0V4cG9ydCcpIHtcbiAgICAgIGNvbnN0IGV4cGxhaW5Ib3BFeHBvcnRUeCA9IGF3YWl0IHRoaXMuZXhwbGFpbkF0b21pY1RyYW5zYWN0aW9uKHR4KTtcbiAgICAgIC8vIElmIG9yaWdpbmFsIHBhcmFtcyBhcmUgZ2l2ZW4sIHdlIGNhbiBjaGVjayB0aGVtIGFnYWluc3QgdGhlIHRyYW5zYWN0aW9uIHByZWJ1aWxkIHBhcmFtc1xuICAgICAgaWYgKCFfLmlzTmlsKG9yaWdpbmFsUGFyYW1zKSkge1xuICAgICAgICBjb25zdCB7IHJlY2lwaWVudHMgfSA9IG9yaWdpbmFsUGFyYW1zO1xuXG4gICAgICAgIC8vIFRoZW4gdmFsaWRhdGUgdGhhdCB0aGUgdHggcGFyYW1zIGFjdHVhbGx5IGVxdWFsIHRoZSByZXF1ZXN0ZWQgcGFyYW1zIHRvIG5hbm8gYXZheCBwbHVzIGltcG9ydCB0eCBmZWUuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnRzWzBdLmFtb3VudCkuZGl2KDFlOSkucGx1cygxZTYpLnRvRml4ZWQoMCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGVzdGluYXRpb246IHN0cmluZyB8IHVuZGVmaW5lZCA9IHJlY2lwaWVudHNbMF0uYWRkcmVzcztcbiAgICAgICAgY29uc3QgaG9wQW1vdW50ID0gZXhwbGFpbkhvcEV4cG9ydFR4Lm91dHB1dEFtb3VudDtcbiAgICAgICAgY29uc3QgaG9wRGVzdGluYXRpb24gPSBleHBsYWluSG9wRXhwb3J0VHgub3V0cHV0c1swXS5hZGRyZXNzO1xuICAgICAgICBpZiAob3JpZ2luYWxBbW91bnQgIT09IGhvcEFtb3VudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSG9wIGFtb3VudDogJHtob3BBbW91bnR9IGRvZXMgbm90IGVxdWFsIG9yaWdpbmFsIGFtb3VudDogJHtvcmlnaW5hbEFtb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luYWxEZXN0aW5hdGlvbiAmJiBob3BEZXN0aW5hdGlvbi50b0xvd2VyQ2FzZSgpICE9PSBvcmlnaW5hbERlc3RpbmF0aW9uLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSG9wIGRlc3RpbmF0aW9uOiAke2hvcERlc3RpbmF0aW9ufSBkb2VzIG5vdCBlcXVhbCBvcmlnaW5hbCByZWNpcGllbnQ6ICR7b3JpZ2luYWxEZXN0aW5hdGlvbn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCEoYXdhaXQgdGhpcy52ZXJpZnlTaWduYXR1cmVGb3JBdG9taWNUcmFuc2FjdGlvbih0eCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3AgdHJhbnNhY3Rpb24gc2lnbmF0dXJlLCB0eGlkOiAke2lkfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBidWlsdEhvcFR4ID0gb3B0aW9uYWxEZXBzLkV0aFR4LlRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tU2VyaWFsaXplZERhdGEob3B0aW9uYWxEZXBzLmV0aFV0aWwudG9CdWZmZXIodHgpKTtcbiAgICAgIC8vIElmIG9yaWdpbmFsIHBhcmFtcyBhcmUgZ2l2ZW4sIHdlIGNhbiBjaGVjayB0aGVtIGFnYWluc3QgdGhlIHRyYW5zYWN0aW9uIHByZWJ1aWxkIHBhcmFtc1xuICAgICAgaWYgKCFfLmlzTmlsKG9yaWdpbmFsUGFyYW1zKSkge1xuICAgICAgICBjb25zdCB7IHJlY2lwaWVudHMgfSA9IG9yaWdpbmFsUGFyYW1zO1xuXG4gICAgICAgIC8vIFRoZW4gdmFsaWRhdGUgdGhhdCB0aGUgdHggcGFyYW1zIGFjdHVhbGx5IGVxdWFsIHRoZSByZXF1ZXN0ZWQgcGFyYW1zXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQW1vdW50ID0gbmV3IEJpZ051bWJlcihyZWNpcGllbnRzWzBdLmFtb3VudCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGVzdGluYXRpb246IHN0cmluZyA9IHJlY2lwaWVudHNbMF0uYWRkcmVzcztcblxuICAgICAgICBjb25zdCBob3BBbW91bnQgPSBuZXcgQmlnTnVtYmVyKG9wdGlvbmFsRGVwcy5ldGhVdGlsLmJ1ZmZlclRvSGV4KGJ1aWx0SG9wVHgudmFsdWUgYXMgdW5rbm93biBhcyBCdWZmZXIpKTtcbiAgICAgICAgaWYgKCFidWlsdEhvcFR4LnRvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBkb2VzIG5vdCBoYXZlIGEgZGVzdGluYXRpb24gYWRkcmVzc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvcERlc3RpbmF0aW9uID0gYnVpbHRIb3BUeC50by50b1N0cmluZygpO1xuICAgICAgICBpZiAoIWhvcEFtb3VudC5lcShvcmlnaW5hbEFtb3VudCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhvcCBhbW91bnQ6ICR7aG9wQW1vdW50fSBkb2VzIG5vdCBlcXVhbCBvcmlnaW5hbCBhbW91bnQ6ICR7b3JpZ2luYWxBbW91bnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvcERlc3RpbmF0aW9uLnRvTG93ZXJDYXNlKCkgIT09IG9yaWdpbmFsRGVzdGluYXRpb24udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSG9wIGRlc3RpbmF0aW9uOiAke2hvcERlc3RpbmF0aW9ufSBkb2VzIG5vdCBlcXVhbCBvcmlnaW5hbCByZWNpcGllbnQ6ICR7aG9wRGVzdGluYXRpb259YCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFidWlsdEhvcFR4LnZlcmlmeVNpZ25hdHVyZSgpKSB7XG4gICAgICAgIC8vIFdlIGRvbnQgd2FudCB0byBjb250aW51ZSBhdCBhbGwgaW4gdGhpcyBjYXNlLCBhdCByaXNrIG9mIEFWQVggYmVpbmcgc3R1Y2sgb24gdGhlIGhvcCBhZGRyZXNzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBob3AgdHJhbnNhY3Rpb24gc2lnbmF0dXJlLCB0eGlkOiAke2lkfWApO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbmFsRGVwcy5ldGhVdGlsLmFkZEhleFByZWZpeChidWlsdEhvcFR4Lmhhc2goKS50b1N0cmluZygnaGV4JykpICE9PSBpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpZ25lZCBob3AgdHhpZCBkb2VzIG5vdCBlcXVhbCBhY3R1YWwgdHhpZGApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHNpZ25UcmFuc2FjdGlvbiBmb3IgdGhlIHJhcmUgY2FzZSB0aGF0IFNESyBpcyBkb2luZyB0aGUgc2Vjb25kIHNpZ25hdHVyZVxuICAgKiBOb3RlOiB3ZSBhcmUgZXhwZWN0aW5nIHRoaXMgdG8gYmUgY2FsbGVkIGZyb20gdGhlIG9mZmxpbmUgdmF1bHRcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2XG4gICAqIEByZXR1cm5zIHt7dHhIZXg6IHN0cmluZ319XG4gICAqL1xuICBhc3luYyBzaWduRmluYWwocGFyYW1zOiBTaWduRmluYWxPcHRpb25zKTogUHJvbWlzZTxGdWxseVNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3Qga2V5UGFpciA9IG5ldyBBdmF4Y0tleVBhaXIoeyBwcnY6IHBhcmFtcy5wcnYgfSk7XG4gICAgY29uc3Qgc2lnbmluZ0tleSA9IGtleVBhaXIuZ2V0S2V5cygpLnBydjtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChzaWduaW5nS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRUcmFuc2FjdGlvbkJ1aWxkZXIoKSBhcyBUcmFuc2FjdGlvbkJ1aWxkZXI7XG4gICAgdHJ5IHtcbiAgICAgIHR4QnVpbGRlci5mcm9tKHBhcmFtcy50eFByZWJ1aWxkIS5oYWxmU2lnbmVkIS50eEhleCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGhhbGYtc2lnbmVkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgdHhCdWlsZGVyLnNpZ24oeyBrZXk6IHNpZ25pbmdLZXkgfSk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHhIZXg6IHR4LnRvQnJvYWRjYXN0Rm9ybWF0KCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogQXZheFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgLy8gTm9ybWFsbHkgdGhlIFNESyBwcm92aWRlcyB0aGUgZmlyc3Qgc2lnbmF0dXJlIGZvciBhbiBBVkFYQyB0eCxcbiAgICAvLyBidXQgZm9yIHVuc2lnbmVkIHN3ZWVwIHJlY292ZXJpZXMgaXQgY2FuIHByb3ZpZGUgdGhlIHNlY29uZCBhbmQgZmluYWwgb25lLlxuICAgIGlmIChwYXJhbXMuaXNMYXN0U2lnbmF0dXJlKSB7XG4gICAgICAvLyBJbiB0aGlzIGNhc2Ugd2hlbiB3ZSdyZSBkb2luZyB0aGUgc2Vjb25kIChmaW5hbCkgc2lnbmF0dXJlLCB0aGUgbG9naWMgaXMgZGlmZmVyZW50LlxuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkZpbmFsKHBhcmFtcyBhcyB1bmtub3duIGFzIFNpZ25GaW5hbE9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHR4QnVpbGRlciA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25CdWlsZGVyKCkgYXMgVHJhbnNhY3Rpb25CdWlsZGVyO1xuICAgIHR4QnVpbGRlci5mcm9tKHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4KTtcbiAgICB0eEJ1aWxkZXIudHJhbnNmZXIoKS5rZXkobmV3IEF2YXhjS2V5UGFpcih7IHBydjogcGFyYW1zLnBydiB9KS5nZXRLZXlzKCkucHJ2ISk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcblxuICAgIGNvbnN0IHJlY2lwaWVudHMgPSB0cmFuc2FjdGlvbi5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiAoeyBhZGRyZXNzOiBvdXRwdXQuYWRkcmVzcywgYW1vdW50OiBvdXRwdXQudmFsdWUgfSkpO1xuXG4gICAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgICBlaXAxNTU5OiBwYXJhbXMudHhQcmVidWlsZC5laXAxNTU5LFxuICAgICAgdHhIZXg6IHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCksXG4gICAgICByZWNpcGllbnRzOiByZWNpcGllbnRzLFxuICAgICAgZXhwaXJlVGltZTogcGFyYW1zLnR4UHJlYnVpbGQuZXhwaXJlVGltZSxcbiAgICAgIGhvcFRyYW5zYWN0aW9uOiBwYXJhbXMudHhQcmVidWlsZC5ob3BUcmFuc2FjdGlvbixcbiAgICAgIGN1c3RvZGlhblRyYW5zYWN0aW9uSWQ6IHBhcmFtcy5jdXN0b2RpYW5UcmFuc2FjdGlvbklkLFxuICAgIH07XG5cbiAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB0eFBhcmFtcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZGlmeSBwcmVidWlsZCBiZWZvcmUgc2VuZGluZyBpdCB0byB0aGUgc2VydmVyLiBBZGQgdGhpbmdzIGxpa2UgaG9wIHRyYW5zYWN0aW9uIHBhcmFtc1xuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMgVGhlIHdoaXRlbGlzdGVkIHBhcmFtZXRlcnMgZm9yIHRoaXMgcHJlYnVpbGRcbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zLmhvcCBUcnVlIGlmIHRoaXMgc2hvdWxkIHByZWJ1aWxkIGEgaG9wIHR4LCBlbHNlIGZhbHNlXG4gICAqIEBwYXJhbSBidWlsZFBhcmFtcy5yZWNpcGllbnRzIFRoZSByZWNpcGllbnRzIGFycmF5IG9mIHRoaXMgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGJ1aWxkUGFyYW1zLndhbGxldCBUaGUgd2FsbGV0IHNlbmRpbmcgdGhpcyB0eFxuICAgKiBAcGFyYW0gYnVpbGRQYXJhbXMud2FsbGV0UGFzc3BocmFzZSB0aGUgcGFzc3BocmFzZSBmb3IgdGhpcyB3YWxsZXRcbiAgICovXG4gIGFzeW5jIGdldEV4dHJhUHJlYnVpbGRQYXJhbXMoYnVpbGRQYXJhbXM6IEJ1aWxkT3B0aW9ucyk6IFByb21pc2U8QnVpbGRPcHRpb25zPiB7XG4gICAgaWYgKFxuICAgICAgIV8uaXNVbmRlZmluZWQoYnVpbGRQYXJhbXMuaG9wKSAmJlxuICAgICAgYnVpbGRQYXJhbXMuaG9wICYmXG4gICAgICAhXy5pc1VuZGVmaW5lZChidWlsZFBhcmFtcy53YWxsZXQpICYmXG4gICAgICAhXy5pc1VuZGVmaW5lZChidWlsZFBhcmFtcy5yZWNpcGllbnRzKVxuICAgICkge1xuICAgICAgaWYgKHRoaXMuaXNUb2tlbigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgSG9wIHRyYW5zYWN0aW9ucyBhcmUgbm90IGVuYWJsZWQgZm9yIEFWQVhDIHRva2Vucywgbm9yIGFyZSB0aGV5IG5lY2Vzc2FyeS4gUGxlYXNlIHJlbW92ZSB0aGUgJ2hvcCcgcGFyYW1ldGVyIGFuZCB0cnkgYWdhaW4uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmNyZWF0ZUhvcFRyYW5zYWN0aW9uUGFyYW1zKHtcbiAgICAgICAgcmVjaXBpZW50czogYnVpbGRQYXJhbXMucmVjaXBpZW50cyxcbiAgICAgICAgdHlwZTogYnVpbGRQYXJhbXMudHlwZSxcbiAgICAgIH0pKSBhcyBhbnk7XG4gICAgfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBleHRyYSBwYXJhbWV0ZXJzIG5lZWRlZCB0byBidWlsZCBhIGhvcCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0hvcFRyYW5zYWN0aW9uQnVpbGRPcHRpb25zfSBUaGUgb3JpZ2luYWwgYnVpbGQgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyBleHRyYSBwYXJhbWV0ZXJzIG9iamVjdCB0byBtZXJnZSB3aXRoIHRoZSBvcmlnaW5hbCBidWlsZCBwYXJhbWV0ZXJzIG9iamVjdCBhbmQgc2VuZCB0byB0aGUgcGxhdGZvcm1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZUhvcFRyYW5zYWN0aW9uUGFyYW1zKHsgcmVjaXBpZW50cywgdHlwZSB9OiBIb3BUcmFuc2FjdGlvbkJ1aWxkT3B0aW9ucyk6IFByb21pc2U8SG9wUGFyYW1zPiB7XG4gICAgaWYgKCFyZWNpcGllbnRzIHx8ICFBcnJheS5pc0FycmF5KHJlY2lwaWVudHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGluZyBhcnJheSBvZiByZWNpcGllbnRzJyk7XG4gICAgfVxuXG4gICAgLy8gUmlnaHQgbm93IHdlIG9ubHkgc3VwcG9ydCAxIHJlY2lwaWVudFxuICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHNlbmQgdG8gZXhhY3RseSAxIHJlY2lwaWVudCcpO1xuICAgIH1cbiAgICBjb25zdCByZWNpcGllbnRBZGRyZXNzID0gcmVjaXBpZW50c1swXS5hZGRyZXNzO1xuICAgIGNvbnN0IHJlY2lwaWVudEFtb3VudCA9IHJlY2lwaWVudHNbMF0uYW1vdW50O1xuICAgIGNvbnN0IGZlZUVzdGltYXRlUGFyYW1zID0ge1xuICAgICAgcmVjaXBpZW50OiByZWNpcGllbnRBZGRyZXNzLFxuICAgICAgYW1vdW50OiByZWNpcGllbnRBbW91bnQsXG4gICAgICBob3A6IHRydWUsXG4gICAgICB0eXBlLFxuICAgIH07XG4gICAgY29uc3QgZmVlRXN0aW1hdGU6IEZlZUVzdGltYXRlID0gYXdhaXQgdGhpcy5mZWVFc3RpbWF0ZShmZWVFc3RpbWF0ZVBhcmFtcyk7XG5cbiAgICBjb25zdCBnYXNMaW1pdCA9IGZlZUVzdGltYXRlLmdhc0xpbWl0RXN0aW1hdGU7XG4gICAgY29uc3QgZ2FzUHJpY2UgPSBNYXRoLnJvdW5kKGZlZUVzdGltYXRlLmZlZUVzdGltYXRlIC8gZ2FzTGltaXQpO1xuICAgIGNvbnN0IGdhc1ByaWNlTWF4ID0gZ2FzUHJpY2UgKiA1O1xuICAgIC8vIFBheW1lbnQgaWQgYSByYW5kb20gbnVtYmVyIHNvIGl0cyBkaWZmZXJlbnQgZm9yIGV2ZXJ5IHR4XG4gICAgY29uc3QgcGF5bWVudElkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwMDApLnRvU3RyaW5nKCk7XG5cbiAgICAvLyBUT0RPKEJHLTYyNjcxKTogYWZ0ZXIgY29tcGxldGVkIFtXYWxsZXQtcGxhdGZvcm1dIFJlbW92ZSB1c2Ugb2YgdXNlclJlcVNpZyBmb3IgYXZheGMgaG9wIHRyYW5zYWN0aW9uXG4gICAgY29uc3QgdXNlclJlcVNpZyA9ICcweCc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaG9wUGFyYW1zOiB7XG4gICAgICAgIHVzZXJSZXFTaWcsXG4gICAgICAgIGdhc1ByaWNlTWF4LFxuICAgICAgICBwYXltZW50SWQsXG4gICAgICB9LFxuICAgICAgZ2FzTGltaXQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBmZWUgZXN0aW1hdGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhlIHBhcmFtcyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1zLmhvcF0gVHJ1ZSBpZiB3ZSBzaG91bGQgZXN0aW1hdGUgZmVlIGZvciBhIGhvcCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5yZWNpcGllbnRdIFRoZSByZWNpcGllbnQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGVzdGltYXRlIGEgc2VuZCB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW3BhcmFtcy5kYXRhXSBUaGUgRVRIIHR4IGRhdGEgdG8gZXN0aW1hdGUgYSBzZW5kIGZvclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZmVlIGluZm8gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICBhc3luYyBmZWVFc3RpbWF0ZShwYXJhbXM6IEZlZUVzdGltYXRlT3B0aW9ucyk6IFByb21pc2U8RmVlRXN0aW1hdGU+IHtcbiAgICBjb25zdCBxdWVyeTogRmVlRXN0aW1hdGVPcHRpb25zID0ge307XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuaG9wKSB7XG4gICAgICBxdWVyeS5ob3AgPSBwYXJhbXMuaG9wO1xuICAgIH1cbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5yZWNpcGllbnQpIHtcbiAgICAgIHF1ZXJ5LnJlY2lwaWVudCA9IHBhcmFtcy5yZWNpcGllbnQ7XG4gICAgfVxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLmRhdGEpIHtcbiAgICAgIHF1ZXJ5LmRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMuYW1vdW50KSB7XG4gICAgICBxdWVyeS5hbW91bnQgPSBwYXJhbXMuYW1vdW50O1xuICAgIH1cbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy50eXBlKSB7XG4gICAgICBxdWVyeS50eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYml0Z28uZ2V0KHRoaXMudXJsKCcvdHgvZmVlJykpLnF1ZXJ5KHF1ZXJ5KS5yZXN1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBob3AgZGlnZXN0IGZvciB0aGUgdXNlciB0byBzaWduLiBUaGlzIGlzIHZhbGlkYXRlZCBpbiB0aGUgSFNNIHRvIHByb3ZlIHRoYXQgdGhlIHVzZXIgcmVxdWVzdGVkIHRoaXMgdHhcbiAgICogQHBhcmFtIHBhcmFtc0FyciBUaGUgcGFyYW1ldGVycyB0byBoYXNoIHRvZ2V0aGVyIGZvciB0aGUgZGlnZXN0XG4gICAqL1xuICBzdGF0aWMgZ2V0SG9wRGlnZXN0KHBhcmFtc0Fycjogc3RyaW5nW10pOiBCdWZmZXIge1xuICAgIGNvbnN0IGhhc2ggPSBLZWNjYWsoJ2tlY2NhazI1NicpO1xuICAgIGhhc2gudXBkYXRlKFtBdmF4Qy5ob3BUcmFuc2FjdGlvblNhbHQsIC4uLnBhcmFtc0Fycl0uam9pbignJCcpKTtcbiAgICByZXR1cm4gaGFzaC5kaWdlc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdHggaGFzaCBsaWtlIGV2bSBmcm9tIHR4IGhleC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR4XG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IHR4IGhhc2hcbiAgICovXG4gIHN0YXRpYyBnZXRUeEhhc2godHg6IHN0cmluZyk6IEJ1ZmZlciB7XG4gICAgY29uc3QgaGFzaCA9IEtlY2Nhaygna2VjY2FrMjU2Jyk7XG4gICAgaGFzaC51cGRhdGUob3B0aW9uYWxEZXBzLmV0aFV0aWwuc3RyaXBIZXhQcmVmaXgodHgpLCAnaGV4Jyk7XG4gICAgcmV0dXJuIGhhc2guZGlnZXN0KCk7XG4gIH1cblxuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBWZXJpZnlBZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIGxhdGVyXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlIGVpdGhlciBlbnRlcnByaXNlIG9yIG5ld0ZlZUFkZHJlc3MgaXMgcGFzc2VkLCB0byBrbm93IHdoZXRoZXIgdG8gY3JlYXRlIG5ldyBrZXkgb3IgdXNlIGVudGVycHJpc2Uga2V5XG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy5lbnRlcnByaXNlIHtTdHJpbmd9IHRoZSBlbnRlcnByaXNlIGlkIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMga2V5XG4gICAqIEBwYXJhbSBwYXJhbXMubmV3RmVlQWRkcmVzcyB7Qm9vbGVhbn0gY3JlYXRlIGEgbmV3IGZlZSBhZGRyZXNzIChlbnRlcnByaXNlIG5vdCBuZWVkZWQgaW4gdGhpcyBjYXNlKVxuICAgKi9cbiAgcHJlQ3JlYXRlQml0R28ocGFyYW1zOiBQcmVjcmVhdGVCaXRHb09wdGlvbnMpOiB2b2lkIHtcbiAgICAvLyBXZSBhbHdheXMgbmVlZCBwYXJhbXMgb2JqZWN0LCBzaW5jZSBlaXRoZXIgZW50ZXJwcmlzZSBvciBuZXdGZWVBZGRyZXNzIGlzIHJlcXVpcmVkXG4gICAgaWYgKCFfLmlzT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJlQ3JlYXRlQml0R28gbXVzdCBiZSBwYXNzZWQgYSBwYXJhbXMgb2JqZWN0LiBHb3QgJHtwYXJhbXN9ICh0eXBlICR7dHlwZW9mIHBhcmFtc30pYCk7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpICYmIF8uaXNVbmRlZmluZWQocGFyYW1zLm5ld0ZlZUFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdleHBlY3RpbmcgZW50ZXJwcmlzZSB3aGVuIGFkZGluZyBCaXRHbyBrZXkuIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIG5ldyBBVkFYIGJpdGdvIGtleSwgc2V0IHRoZSBuZXdGZWVBZGRyZXNzIHBhcmFtZXRlciB0byB0cnVlLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgd2hldGhlciBrZXkgc2hvdWxkIGJlIGFuIGVudGVycHJpc2Uga2V5IG9yIGEgQml0R28ga2V5IGZvciBhIG5ldyBmZWUgYWRkcmVzc1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZW50ZXJwcmlzZSkgJiYgIV8uaXNVbmRlZmluZWQocGFyYW1zLm5ld0ZlZUFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGF0aWJsZSBhcmd1bWVudHMgLSBjYW5ub3QgcGFzcyBib3RoIGVudGVycHJpc2UgYW5kIG5ld0ZlZUFkZHJlc3MgcGFyYW1ldGVyLmApO1xuICAgIH1cblxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMuZW50ZXJwcmlzZSkgJiYgIV8uaXNTdHJpbmcocGFyYW1zLmVudGVycHJpc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGVudGVycHJpc2Ugc2hvdWxkIGJlIGEgc3RyaW5nIC0gZ290ICR7cGFyYW1zLmVudGVycHJpc2V9ICh0eXBlICR7dHlwZW9mIHBhcmFtcy5lbnRlcnByaXNlfSlgKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLm5ld0ZlZUFkZHJlc3MpICYmICFfLmlzQm9vbGVhbihwYXJhbXMubmV3RmVlQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYG5ld0ZlZUFkZHJlc3Mgc2hvdWxkIGJlIGEgYm9vbGVhbiAtIGdvdCAke3BhcmFtcy5uZXdGZWVBZGRyZXNzfSAodHlwZSAke3R5cGVvZiBwYXJhbXMubmV3RmVlQWRkcmVzc30pYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBnZXRBdmF4UCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmdldENoYWluKCkudG9TdHJpbmcoKSA9PT0gJ2F2YXhjJyA/ICdhdmF4cCcgOiAndGF2YXhwJztcbiAgfVxufVxuIl19