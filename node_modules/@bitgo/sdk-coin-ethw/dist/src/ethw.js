"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ethw = void 0;
const superagent_1 = __importDefault(require("superagent"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_core_1 = require("@bitgo/sdk-core");
const statics_1 = require("@bitgo/statics");
const sdk_coin_eth_1 = require("@bitgo/sdk-coin-eth");
class Ethw extends sdk_coin_eth_1.Eth {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
    }
    static createInstance(bitgo, staticsCoin) {
        return new Ethw(bitgo, staticsCoin);
    }
    getChain() {
        return 'ethw';
    }
    getFamily() {
        return 'eth';
    }
    getFullName() {
        return 'Ethereum PoW';
    }
    verifyTransaction(params) {
        throw new Error('Method not implemented.');
    }
    async isWalletAddress(params) {
        throw new Error('Method not implemented.');
    }
    parseTransaction(params) {
        throw new Error('Method not implemented.');
    }
    generateKeyPair(seed) {
        throw new Error('Method not implemented.');
    }
    /**
     * Query full node for the balance of an address
     * @param {string} address the ETHw address
     * @returns {Promise<BN>} address balance
     */
    async queryAddressBalance(address) {
        const result = await this.recoveryFullNodeRPCQuery('eth_getBalance', [address, 'latest']);
        // throw if the result does not exist or the result is not a valid number
        if (!result || !result.result) {
            throw new Error(`Could not obtain address balance for ${address} from full node, got: ${result.result}`);
        }
        return new sdk_coin_eth_1.optionalDeps.ethUtil.BN(result.result.slice(2), 16);
    }
    /**
     * Queries the contract (via RPC) for the next sequence ID
     * @param {string} address address of the contract
     * @returns {Promise<number>} sequence ID
     */
    async querySequenceId(address) {
        // Get sequence ID using contract call
        const sequenceIdMethodSignature = sdk_coin_eth_1.optionalDeps.ethAbi.methodID('getNextSequenceId', []);
        const sequenceIdArgs = sdk_coin_eth_1.optionalDeps.ethAbi.rawEncode([], []);
        const sequenceIdData = Buffer.concat([sequenceIdMethodSignature, sequenceIdArgs]).toString('hex');
        const sequenceIdDataHex = sdk_coin_eth_1.optionalDeps.ethUtil.addHexPrefix(sequenceIdData);
        const result = await this.recoveryFullNodeRPCQuery('eth_call', [
            { to: address, data: sequenceIdDataHex },
            'latest',
        ]);
        if (!result || !result.result) {
            throw new Error('Could not obtain sequence ID from full node, got: ' + result.result);
        }
        const sequenceIdHex = result.result;
        return new sdk_coin_eth_1.optionalDeps.ethUtil.BN(sequenceIdHex.slice(2), 16).toNumber();
    }
    /**
     * Queries public full node to get the next ETHw nonce that should be used for the given ETH address
     * @param {string} address
     * @returns {Promise<number>} next ETHw nonce
     */
    async getAddressNonce(address) {
        const result = await this.recoveryFullNodeRPCQuery('eth_getTransactionCount', [address, 'latest']);
        if (!result || !result.result) {
            throw new Error('Unable to find next nonce from full node, got: ' + JSON.stringify(result));
        }
        return new sdk_coin_eth_1.optionalDeps.ethUtil.BN(result.result.slice(2), 16).toNumber();
    }
    /**
     * Make a RPC query to full node for information such as balance, token balance, solidity calls
     * @param {string} method RPC method to execute
     * @param {Array} params params to include in the RPC request
     * @returns {Promise<FullNodeResponseBody>} response from full node
     */
    async recoveryFullNodeRPCQuery(method, params) {
        const response = await superagent_1.default.post(sdk_core_1.common.Environments[this.bitgo.getEnv()].ethwFullNodeRPCBaseUrl).send({
            method,
            params,
            id: 0,
            jsonrpc: '2.0',
        });
        if (!response.ok) {
            throw new Error('could not reach ETHW full node');
        }
        if (response.body.error) {
            throw new Error(`ETHW full node error: ${response.body.error.code} - ${response.body.error.message}`);
        }
        return response.body;
    }
    /**
     * Explain a transaction from txHex
     * @param params The options with which to explain the transaction
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const txBuilder = this.getTransactionBuilder();
        txBuilder.from(txHex);
        const tx = await txBuilder.build();
        const outputs = tx.outputs.map((output) => {
            return {
                address: output.address,
                amount: output.value,
            };
        });
        const displayOrder = ['id', 'outputAmount', 'changeAmount', 'outputs', 'changeOutputs', 'fee'];
        return {
            displayOrder,
            id: tx.id,
            outputs: outputs,
            outputAmount: outputs
                .reduce((accumulator, output) => accumulator.plus(output.amount), new bignumber_js_1.default('0'))
                .toFixed(0),
            changeOutputs: [],
            changeAmount: '0',
            fee: params.feeInfo,
        };
    }
    /**
     * Create a new transaction builder for the current chain
     * @return a new transaction builder
     */
    getTransactionBuilder() {
        return new sdk_coin_eth_1.TransactionBuilder(statics_1.coins.get(this.getChain()));
    }
}
exports.Ethw = Ethw;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXRody5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ldGh3LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDREQUFpQztBQUNqQyxnRUFBcUM7QUFHckMsOENBVXlCO0FBQ3pCLDRDQUFvRTtBQUNwRSxzREFBNEU7QUFhNUUsTUFBYSxJQUFLLFNBQVEsa0JBQUc7SUFDM0IsWUFBc0IsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDZixDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFnQixFQUFFLFdBQXVDO1FBQzdFLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUNELFNBQVM7UUFDUCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFDRCxXQUFXO1FBQ1QsT0FBTyxjQUFjLENBQUM7SUFDeEIsQ0FBQztJQUNELGlCQUFpQixDQUFDLE1BQWdDO1FBQ2hELE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBQ0QsS0FBSyxDQUFDLGVBQWUsQ0FBQyxNQUE0QjtRQUNoRCxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUNELGdCQUFnQixDQUFDLE1BQStCO1FBQzlDLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBQ0QsZUFBZSxDQUFDLElBQXlCO1FBQ3ZDLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxPQUFlO1FBQ3ZDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFD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QVMsRUFBRSxlQUFlLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFL0YsT0FBTztZQUNMLFlBQVk7WUFDWixFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDVCxPQUFPLEVBQUUsT0FBTztZQUNoQixZQUFZLEVBQUUsT0FBTztpQkFDbEIsTUFBTSxDQUFDLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsSUFBSSxzQkFBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUNwRixPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ2IsYUFBYSxFQUFFLEVBQUU7WUFDakIsWUFBWSxFQUFFLEdBQUc7WUFDakIsR0FBRyxFQUFFLE1BQU0sQ0FBQyxPQUFPO1NBQ3BCLENBQUM7SUFDSixDQUFDO0lBRUQ7OztPQUdHO0lBQ08scUJBQXFCO1FBQzdCLE9BQU8sSUFBSSxpQ0FBa0IsQ0FBQyxlQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDNUQsQ0FBQztDQUNGO0FBakpELG9CQWlKQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZXF1ZXN0IGZyb20gJ3N1cGVyYWdlbnQnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgQk4gfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuXG5pbXBvcnQge1xuICBCYXNlQ29pbixcbiAgQml0R29CYXNlLFxuICBjb21tb24sXG4gIEtleVBhaXIsXG4gIFBhcnNlZFRyYW5zYWN0aW9uLFxuICBQYXJzZVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVHJhbnNhY3Rpb25FeHBsYW5hdGlvbixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgY29pbnMgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBFdGgsIG9wdGlvbmFsRGVwcywgVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnQGJpdGdvL3Nkay1jb2luLWV0aCc7XG5pbXBvcnQgeyBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIH0gZnJvbSAnQGJpdGdvL2Fic3RyYWN0LWV0aCc7XG5cbnR5cGUgRnVsbE5vZGVSZXNwb25zZUJvZHkgPSB7XG4gIGpzb25ycGM6IHN0cmluZztcbiAgaWQ6IHN0cmluZztcbiAgcmVzdWx0Pzogc3RyaW5nO1xuICBlcnJvcj86IHtcbiAgICBjb2RlOiBzdHJpbmc7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9O1xufTtcblxuZXhwb3J0IGNsYXNzIEV0aHcgZXh0ZW5kcyBFdGgge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IEV0aHcoYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdldGh3JztcbiAgfVxuICBnZXRGYW1pbHkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2V0aCc7XG4gIH1cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ0V0aGVyZXVtIFBvVyc7XG4gIH1cbiAgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cbiAgYXN5bmMgaXNXYWxsZXRBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cbiAgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlciB8IHVuZGVmaW5lZCk6IEtleVBhaXIge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBmdWxsIG5vZGUgZm9yIHRoZSBiYWxhbmNlIG9mIGFuIGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgdGhlIEVUSHcgYWRkcmVzc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCTj59IGFkZHJlc3MgYmFsYW5jZVxuICAgKi9cbiAgYXN5bmMgcXVlcnlBZGRyZXNzQmFsYW5jZShhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPEJOPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWNvdmVyeUZ1bGxOb2RlUlBDUXVlcnkoJ2V0aF9nZXRCYWxhbmNlJywgW2FkZHJlc3MsICdsYXRlc3QnXSk7XG4gICAgLy8gdGhyb3cgaWYgdGhlIHJlc3VsdCBkb2VzIG5vdCBleGlzdCBvciB0aGUgcmVzdWx0IGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQucmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBvYnRhaW4gYWRkcmVzcyBiYWxhbmNlIGZvciAke2FkZHJlc3N9IGZyb20gZnVsbCBub2RlLCBnb3Q6ICR7cmVzdWx0LnJlc3VsdH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihyZXN1bHQucmVzdWx0LnNsaWNlKDIpLCAxNik7XG4gIH1cblxuICAvKipcbiAgICogUXVlcmllcyB0aGUgY29udHJhY3QgKHZpYSBSUEMpIGZvciB0aGUgbmV4dCBzZXF1ZW5jZSBJRFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyBhZGRyZXNzIG9mIHRoZSBjb250cmFjdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fSBzZXF1ZW5jZSBJRFxuICAgKi9cbiAgYXN5bmMgcXVlcnlTZXF1ZW5jZUlkKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgLy8gR2V0IHNlcXVlbmNlIElEIHVzaW5nIGNvbnRyYWN0IGNhbGxcbiAgICBjb25zdCBzZXF1ZW5jZUlkTWV0aG9kU2lnbmF0dXJlID0gb3B0aW9uYWxEZXBzLmV0aEFiaS5tZXRob2RJRCgnZ2V0TmV4dFNlcXVlbmNlSWQnLCBbXSk7XG4gICAgY29uc3Qgc2VxdWVuY2VJZEFyZ3MgPSBvcHRpb25hbERlcHMuZXRoQWJpLnJhd0VuY29kZShbXSwgW10pO1xuICAgIGNvbnN0IHNlcXVlbmNlSWREYXRhID0gQnVmZmVyLmNvbmNhdChbc2VxdWVuY2VJZE1ldGhvZFNpZ25hdHVyZSwgc2VxdWVuY2VJZEFyZ3NdKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3Qgc2VxdWVuY2VJZERhdGFIZXggPSBvcHRpb25hbERlcHMuZXRoVXRpbC5hZGRIZXhQcmVmaXgoc2VxdWVuY2VJZERhdGEpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucmVjb3ZlcnlGdWxsTm9kZVJQQ1F1ZXJ5KCdldGhfY2FsbCcsIFtcbiAgICAgIHsgdG86IGFkZHJlc3MsIGRhdGE6IHNlcXVlbmNlSWREYXRhSGV4IH0sXG4gICAgICAnbGF0ZXN0JyxcbiAgICBdKTtcbiAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3Qgb2J0YWluIHNlcXVlbmNlIElEIGZyb20gZnVsbCBub2RlLCBnb3Q6ICcgKyByZXN1bHQucmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3Qgc2VxdWVuY2VJZEhleCA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgcmV0dXJuIG5ldyBvcHRpb25hbERlcHMuZXRoVXRpbC5CTihzZXF1ZW5jZUlkSGV4LnNsaWNlKDIpLCAxNikudG9OdW1iZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyaWVzIHB1YmxpYyBmdWxsIG5vZGUgdG8gZ2V0IHRoZSBuZXh0IEVUSHcgbm9uY2UgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGdpdmVuIEVUSCBhZGRyZXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IG5leHQgRVRIdyBub25jZVxuICAgKi9cbiAgYXN5bmMgZ2V0QWRkcmVzc05vbmNlKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWNvdmVyeUZ1bGxOb2RlUlBDUXVlcnkoJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JywgW2FkZHJlc3MsICdsYXRlc3QnXSk7XG4gICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC5yZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbmV4dCBub25jZSBmcm9tIGZ1bGwgbm9kZSwgZ290OiAnICsgSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgb3B0aW9uYWxEZXBzLmV0aFV0aWwuQk4ocmVzdWx0LnJlc3VsdC5zbGljZSgyKSwgMTYpLnRvTnVtYmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIFJQQyBxdWVyeSB0byBmdWxsIG5vZGUgZm9yIGluZm9ybWF0aW9uIHN1Y2ggYXMgYmFsYW5jZSwgdG9rZW4gYmFsYW5jZSwgc29saWRpdHkgY2FsbHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBSUEMgbWV0aG9kIHRvIGV4ZWN1dGVcbiAgICogQHBhcmFtIHtBcnJheX0gcGFyYW1zIHBhcmFtcyB0byBpbmNsdWRlIGluIHRoZSBSUEMgcmVxdWVzdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGdWxsTm9kZVJlc3BvbnNlQm9keT59IHJlc3BvbnNlIGZyb20gZnVsbCBub2RlXG4gICAqL1xuICBhc3luYyByZWNvdmVyeUZ1bGxOb2RlUlBDUXVlcnkobWV0aG9kOiBzdHJpbmcsIHBhcmFtczogQXJyYXk8dW5rbm93bj4pOiBQcm9taXNlPEZ1bGxOb2RlUmVzcG9uc2VCb2R5PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0LnBvc3QoY29tbW9uLkVudmlyb25tZW50c1t0aGlzLmJpdGdvLmdldEVudigpXS5ldGh3RnVsbE5vZGVSUENCYXNlVXJsKS5zZW5kKHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGlkOiAwLFxuICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFjaCBFVEhXIGZ1bGwgbm9kZScpO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS5ib2R5LmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVUSFcgZnVsbCBub2RlIGVycm9yOiAke3Jlc3BvbnNlLmJvZHkuZXJyb3IuY29kZX0gLSAke3Jlc3BvbnNlLmJvZHkuZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG4gIH1cblxuICAvKipcbiAgICogRXhwbGFpbiBhIHRyYW5zYWN0aW9uIGZyb20gdHhIZXhcbiAgICogQHBhcmFtIHBhcmFtcyBUaGUgb3B0aW9ucyB3aXRoIHdoaWNoIHRvIGV4cGxhaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICBpZiAoIXR4SGV4IHx8ICFwYXJhbXMuZmVlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgIH1cbiAgICBjb25zdCB0eEJ1aWxkZXIgPSB0aGlzLmdldFRyYW5zYWN0aW9uQnVpbGRlcigpO1xuICAgIHR4QnVpbGRlci5mcm9tKHR4SGV4KTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGNvbnN0IG91dHB1dHMgPSB0eC5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBvdXRwdXQuYWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBvdXRwdXQudmFsdWUsXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgY29uc3QgZGlzcGxheU9yZGVyID0gWydpZCcsICdvdXRwdXRBbW91bnQnLCAnY2hhbmdlQW1vdW50JywgJ291dHB1dHMnLCAnY2hhbmdlT3V0cHV0cycsICdmZWUnXTtcblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5T3JkZXIsXG4gICAgICBpZDogdHguaWQsXG4gICAgICBvdXRwdXRzOiBvdXRwdXRzLFxuICAgICAgb3V0cHV0QW1vdW50OiBvdXRwdXRzXG4gICAgICAgIC5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBvdXRwdXQpID0+IGFjY3VtdWxhdG9yLnBsdXMob3V0cHV0LmFtb3VudCksIG5ldyBCaWdOdW1iZXIoJzAnKSlcbiAgICAgICAgLnRvRml4ZWQoMCksXG4gICAgICBjaGFuZ2VPdXRwdXRzOiBbXSwgLy8gYWNjb3VudCBiYXNlZCBkb2VzIG5vdCB1c2UgY2hhbmdlIG91dHB1dHNcbiAgICAgIGNoYW5nZUFtb3VudDogJzAnLCAvLyBhY2NvdW50IGJhc2UgZG9lcyBub3QgbWFrZSBjaGFuZ2VcbiAgICAgIGZlZTogcGFyYW1zLmZlZUluZm8sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNhY3Rpb24gYnVpbGRlciBmb3IgdGhlIGN1cnJlbnQgY2hhaW5cbiAgICogQHJldHVybiBhIG5ldyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0VHJhbnNhY3Rpb25CdWlsZGVyKCk6IFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkJ1aWxkZXIoY29pbnMuZ2V0KHRoaXMuZ2V0Q2hhaW4oKSkpO1xuICB9XG59XG4iXX0=