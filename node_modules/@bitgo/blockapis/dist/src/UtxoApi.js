"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchTransactionSpends = exports.fetchInputs = void 0;
const utxolib = require("@bitgo/utxo-lib");
const BaseHttpClient_1 = require("./BaseHttpClient");
/**
 * Helper to efficiently fetch output data.
 * Typical we can query output data for all outputs of a transaction, so we first fetch all
 * the output list via `f` and then pick the output data from the result.
 * @param outpoints
 * @param f - maps txid to a list of outputs with type TOut
 * @return list of TOut corresponding to outputs
 */
async function mapInputs(outpoints, f) {
    const txids = [...new Set(outpoints.map((i) => i.txid))];
    const txMap = new Map(await BaseHttpClient_1.mapSeries(txids, async (txid) => [txid, await f(txid)]));
    return outpoints.map((i) => {
        const arr = txMap.get(i.txid);
        if (arr) {
            if (i.vout in arr) {
                return arr[i.vout];
            }
            throw new Error(`could not find output ${i.vout}`);
        }
        throw new Error(`could not find tx ${i.txid}`);
    });
}
/**
 * Fetch transaction inputs from transaction input list
 * @param ins
 * @param api
 * @param network
 */
async function fetchInputs(ins, api, network) {
    return mapInputs(ins.map((i) => {
        if ('txid' in i) {
            return i;
        }
        return utxolib.bitgo.getOutputIdForInput(i);
    }), async (txid) => utxolib.bitgo.createTransactionFromHex(await api.getTransactionHex(txid), network).outs);
}
exports.fetchInputs = fetchInputs;
/**
 * Fetch transaction spend status outpoints.
 */
async function fetchTransactionSpends(outpoints, api) {
    return mapInputs(outpoints, async (txid) => await api.getTransactionSpends(txid));
}
exports.fetchTransactionSpends = fetchTransactionSpends;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVXR4b0FwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9VdHhvQXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJDQUEyQztBQUMzQyxxREFBNkM7QUEyQzdDOzs7Ozs7O0dBT0c7QUFDSCxLQUFLLFVBQVUsU0FBUyxDQUN0QixTQUFxQyxFQUNyQyxDQUFvQztJQUVwQyxNQUFNLEtBQUssR0FBRyxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN6RCxNQUFNLEtBQUssR0FBRyxJQUFJLEdBQUcsQ0FBQyxNQUFNLDBCQUFTLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JGLE9BQU8sU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO1FBQ3pCLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlCLElBQUksR0FBRyxFQUFFO1lBQ1AsSUFBSSxDQUFDLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRTtnQkFDakIsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3BCO1lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDcEQ7UUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUNqRCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSxXQUFXLENBQy9CLEdBQW1ELEVBQ25ELEdBQVksRUFDWixPQUF3QjtJQUV4QixPQUFPLFNBQVMsQ0FDZCxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBNkMsRUFBRSxFQUFFO1FBQ3hELElBQUksTUFBTSxJQUFJLENBQUMsRUFBRTtZQUNmLE9BQU8sQ0FBQyxDQUFDO1NBQ1Y7UUFDRCxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUMsQ0FBQyxDQUFDLEVBQ0YsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQ3hHLENBQUM7QUFDSixDQUFDO0FBZEQsa0NBY0M7QUFFRDs7R0FFRztBQUNJLEtBQUssVUFBVSxzQkFBc0IsQ0FDMUMsU0FBcUMsRUFDckMsR0FBWTtJQUVaLE9BQU8sU0FBUyxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3BGLENBQUM7QUFMRCx3REFLQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0eG9saWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IG1hcFNlcmllcyB9IGZyb20gJy4vQmFzZUh0dHBDbGllbnQnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25BcGkgfSBmcm9tICcuL1RyYW5zYWN0aW9uQXBpJztcblxuZXhwb3J0IHR5cGUgT3V0cHV0U3BlbmQgPVxuICB8IHtcbiAgICAgIHR4aWQ6IHN0cmluZztcbiAgICAgIHZpbjogbnVtYmVyO1xuICAgIH1cbiAgfCB7IHR4aWQ6IHVuZGVmaW5lZDsgdmluOiB1bmRlZmluZWQgfTtcblxuZXhwb3J0IHR5cGUgVHJhbnNhY3Rpb25JTyA9IHtcbiAgaW5wdXRzOiB7IGFkZHJlc3M6IHN0cmluZyB9W107XG4gIG91dHB1dHM6IHsgYWRkcmVzczogc3RyaW5nIH1bXTtcbn07XG5cbi8qKlxuICogTWV0aG9kcyBzcGVjaWZpYyB0byBVVFhPLWJhc2VkIGJsb2NrY2hhaW5zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXR4b0FwaSBleHRlbmRzIFRyYW5zYWN0aW9uQXBpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB0eGlkXG4gICAqIEByZXR1cm4gdHJhbnNhY3Rpb24gaW5wdXRzXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbklucHV0cyh0eGlkOiBzdHJpbmcpOiBQcm9taXNlPHV0eG9saWIuYml0Z28uVW5zcGVudFtdPjtcblxuICAvKipcbiAgICogQHBhcmFtIHR4aWRcbiAgICogQHJldHVybiB0cmFuc2FjdGlvbiBpbnB1dCBhbmQgb3V0cHV0IGFkZHJlc3Nlc1xuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25JTyh0eGlkOiBzdHJpbmcpOiBQcm9taXNlPFRyYW5zYWN0aW9uSU8+O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gdHhpZFxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25TcGVuZHModHhpZDogc3RyaW5nKTogUHJvbWlzZTxPdXRwdXRTcGVuZFtdPjtcblxuICAvKipcbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICogQHJldHVybiB1bnNwZW50IG91dHB1dHMgZm9yIGFkZHJlc3Nlc1xuICAgKi9cbiAgZ2V0VW5zcGVudHNGb3JBZGRyZXNzZXMoYWRkcmVzczogc3RyaW5nW10pOiBQcm9taXNlPHV0eG9saWIuYml0Z28uVW5zcGVudFtdPjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZWZmaWNpZW50bHkgZmV0Y2ggb3V0cHV0IGRhdGEuXG4gKiBUeXBpY2FsIHdlIGNhbiBxdWVyeSBvdXRwdXQgZGF0YSBmb3IgYWxsIG91dHB1dHMgb2YgYSB0cmFuc2FjdGlvbiwgc28gd2UgZmlyc3QgZmV0Y2ggYWxsXG4gKiB0aGUgb3V0cHV0IGxpc3QgdmlhIGBmYCBhbmQgdGhlbiBwaWNrIHRoZSBvdXRwdXQgZGF0YSBmcm9tIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0gb3V0cG9pbnRzXG4gKiBAcGFyYW0gZiAtIG1hcHMgdHhpZCB0byBhIGxpc3Qgb2Ygb3V0cHV0cyB3aXRoIHR5cGUgVE91dFxuICogQHJldHVybiBsaXN0IG9mIFRPdXQgY29ycmVzcG9uZGluZyB0byBvdXRwdXRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1hcElucHV0czxUT3V0PihcbiAgb3V0cG9pbnRzOiB1dHhvbGliLmJpdGdvLlR4T3V0UG9pbnRbXSxcbiAgZjogKHR4aWQ6IHN0cmluZykgPT4gUHJvbWlzZTxUT3V0W10+XG4pOiBQcm9taXNlPFRPdXRbXT4ge1xuICBjb25zdCB0eGlkcyA9IFsuLi5uZXcgU2V0KG91dHBvaW50cy5tYXAoKGkpID0+IGkudHhpZCkpXTtcbiAgY29uc3QgdHhNYXAgPSBuZXcgTWFwKGF3YWl0IG1hcFNlcmllcyh0eGlkcywgYXN5bmMgKHR4aWQpID0+IFt0eGlkLCBhd2FpdCBmKHR4aWQpXSkpO1xuICByZXR1cm4gb3V0cG9pbnRzLm1hcCgoaSkgPT4ge1xuICAgIGNvbnN0IGFyciA9IHR4TWFwLmdldChpLnR4aWQpO1xuICAgIGlmIChhcnIpIHtcbiAgICAgIGlmIChpLnZvdXQgaW4gYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJbaS52b3V0XTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgY291bGQgbm90IGZpbmQgb3V0cHV0ICR7aS52b3V0fWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNvdWxkIG5vdCBmaW5kIHR4ICR7aS50eGlkfWApO1xuICB9KTtcbn1cblxuLyoqXG4gKiBGZXRjaCB0cmFuc2FjdGlvbiBpbnB1dHMgZnJvbSB0cmFuc2FjdGlvbiBpbnB1dCBsaXN0XG4gKiBAcGFyYW0gaW5zXG4gKiBAcGFyYW0gYXBpXG4gKiBAcGFyYW0gbmV0d29ya1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hJbnB1dHMoXG4gIGluczogdXR4b2xpYi5UeElucHV0W10gfCB1dHhvbGliLmJpdGdvLlR4T3V0UG9pbnRbXSxcbiAgYXBpOiBVdHhvQXBpLFxuICBuZXR3b3JrOiB1dHhvbGliLk5ldHdvcmtcbik6IFByb21pc2U8dXR4b2xpYi5UeE91dHB1dFtdPiB7XG4gIHJldHVybiBtYXBJbnB1dHMoXG4gICAgaW5zLm1hcCgoaTogdXR4b2xpYi5UeElucHV0IHwgdXR4b2xpYi5iaXRnby5UeE91dFBvaW50KSA9PiB7XG4gICAgICBpZiAoJ3R4aWQnIGluIGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXR4b2xpYi5iaXRnby5nZXRPdXRwdXRJZEZvcklucHV0KGkpO1xuICAgIH0pLFxuICAgIGFzeW5jICh0eGlkKSA9PiB1dHhvbGliLmJpdGdvLmNyZWF0ZVRyYW5zYWN0aW9uRnJvbUhleChhd2FpdCBhcGkuZ2V0VHJhbnNhY3Rpb25IZXgodHhpZCksIG5ldHdvcmspLm91dHNcbiAgKTtcbn1cblxuLyoqXG4gKiBGZXRjaCB0cmFuc2FjdGlvbiBzcGVuZCBzdGF0dXMgb3V0cG9pbnRzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUcmFuc2FjdGlvblNwZW5kcyhcbiAgb3V0cG9pbnRzOiB1dHhvbGliLmJpdGdvLlR4T3V0UG9pbnRbXSxcbiAgYXBpOiBVdHhvQXBpXG4pOiBQcm9taXNlPE91dHB1dFNwZW5kW10+IHtcbiAgcmV0dXJuIG1hcElucHV0cyhvdXRwb2ludHMsIGFzeW5jICh0eGlkKSA9PiBhd2FpdCBhcGkuZ2V0VHJhbnNhY3Rpb25TcGVuZHModHhpZCkpO1xufVxuIl19