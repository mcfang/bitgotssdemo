"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyPair = void 0;
const crypto_1 = require("crypto");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const sdk_core_1 = require("@bitgo/sdk-core");
const constants_1 = require("./constants");
const DEFAULT_SEED_SIZE_BYTES = 16;
class KeyPair extends sdk_core_1.Secp256k1ExtendedKeyPair {
    /**
     * Public constructor. By default, creates a key pair with a random master seed.
     *
     * @param { KeyPairOptions } source Either a master seed, a private key, or a public key
     */
    constructor(source) {
        super(source);
        if (!source) {
            const seed = crypto_1.randomBytes(DEFAULT_SEED_SIZE_BYTES);
            this.hdNode = utxo_lib_1.bip32.fromSeed(seed);
        }
        else if (sdk_core_1.isSeed(source)) {
            this.hdNode = utxo_lib_1.bip32.fromSeed(source.seed);
        }
        else if (sdk_core_1.isPrivateKey(source)) {
            this.recordKeysFromPrivateKey(source.prv);
        }
        else if (sdk_core_1.isPublicKey(source)) {
            this.recordKeysFromPublicKey(source.pub);
        }
        else {
            throw new Error('Invalid key pair options');
        }
        if (this.hdNode) {
            this.keyPair = sdk_core_1.Secp256k1ExtendedKeyPair.toKeyPair(this.hdNode);
        }
    }
    /**
     * Default keys format is a pair of Uint8Array keys
     *
     * @returns { DefaultKeys } The keys in the defined format
     */
    getKeys() {
        var _a;
        return {
            pub: this.getPublicKey({ compressed: true }).toString('hex'),
            prv: (_a = this.getPrivateKey()) === null || _a === void 0 ? void 0 : _a.toString('hex'),
        };
    }
    /** @inheritdoc */
    getAddress() {
        const keys = this.getKeys();
        return constants_1.SECP256K1_PREFIX + keys.pub;
    }
}
exports.KeyPair = KeyPair;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2V5UGFpci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIva2V5UGFpci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBcUM7QUFDckMsOENBQXdDO0FBQ3hDLDhDQU95QjtBQUN6QiwyQ0FBK0M7QUFDL0MsTUFBTSx1QkFBdUIsR0FBRyxFQUFFLENBQUM7QUFFbkMsTUFBYSxPQUFRLFNBQVEsbUNBQXdCO0lBQ25EOzs7O09BSUc7SUFDSCxZQUFZLE1BQXVCO1FBQ2pDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNkLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxNQUFNLElBQUksR0FBRyxvQkFBVyxDQUFDLHVCQUF1QixDQUFDLENBQUM7WUFDbEQsSUFBSSxDQUFDLE1BQU0sR0FBRyxnQkFBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNwQzthQUFNLElBQUksaUJBQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUN6QixJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUMzQzthQUFNLElBQUksdUJBQVksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUMvQixJQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzNDO2FBQU0sSUFBSSxzQkFBVyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzlCLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDMUM7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLENBQUMsQ0FBQztTQUM3QztRQUVELElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsbUNBQXdCLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNoRTtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsT0FBTzs7UUFDTCxPQUFPO1lBQ0wsR0FBRyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO1lBQzVELEdBQUcsRUFBRSxNQUFBLElBQUksQ0FBQyxhQUFhLEVBQUUsMENBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQztTQUMzQyxDQUFDO0lBQ0osQ0FBQztJQUVELGtCQUFrQjtJQUNsQixVQUFVO1FBQ1IsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzVCLE9BQU8sNEJBQWdCLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztJQUNyQyxDQUFDO0NBQ0Y7QUEzQ0QsMEJBMkNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0IHsgYmlwMzIgfSBmcm9tICdAYml0Z28vdXR4by1saWInO1xuaW1wb3J0IHtcbiAgS2V5UGFpck9wdGlvbnMsXG4gIGlzUHJpdmF0ZUtleSxcbiAgaXNQdWJsaWNLZXksXG4gIGlzU2VlZCxcbiAgRGVmYXVsdEtleXMsXG4gIFNlY3AyNTZrMUV4dGVuZGVkS2V5UGFpcixcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IFNFQ1AyNTZLMV9QUkVGSVggfSBmcm9tICcuL2NvbnN0YW50cyc7XG5jb25zdCBERUZBVUxUX1NFRURfU0laRV9CWVRFUyA9IDE2O1xuXG5leHBvcnQgY2xhc3MgS2V5UGFpciBleHRlbmRzIFNlY3AyNTZrMUV4dGVuZGVkS2V5UGFpciB7XG4gIC8qKlxuICAgKiBQdWJsaWMgY29uc3RydWN0b3IuIEJ5IGRlZmF1bHQsIGNyZWF0ZXMgYSBrZXkgcGFpciB3aXRoIGEgcmFuZG9tIG1hc3RlciBzZWVkLlxuICAgKlxuICAgKiBAcGFyYW0geyBLZXlQYWlyT3B0aW9ucyB9IHNvdXJjZSBFaXRoZXIgYSBtYXN0ZXIgc2VlZCwgYSBwcml2YXRlIGtleSwgb3IgYSBwdWJsaWMga2V5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2U/OiBLZXlQYWlyT3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgIGNvbnN0IHNlZWQgPSByYW5kb21CeXRlcyhERUZBVUxUX1NFRURfU0laRV9CWVRFUyk7XG4gICAgICB0aGlzLmhkTm9kZSA9IGJpcDMyLmZyb21TZWVkKHNlZWQpO1xuICAgIH0gZWxzZSBpZiAoaXNTZWVkKHNvdXJjZSkpIHtcbiAgICAgIHRoaXMuaGROb2RlID0gYmlwMzIuZnJvbVNlZWQoc291cmNlLnNlZWQpO1xuICAgIH0gZWxzZSBpZiAoaXNQcml2YXRlS2V5KHNvdXJjZSkpIHtcbiAgICAgIHRoaXMucmVjb3JkS2V5c0Zyb21Qcml2YXRlS2V5KHNvdXJjZS5wcnYpO1xuICAgIH0gZWxzZSBpZiAoaXNQdWJsaWNLZXkoc291cmNlKSkge1xuICAgICAgdGhpcy5yZWNvcmRLZXlzRnJvbVB1YmxpY0tleShzb3VyY2UucHViKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSBwYWlyIG9wdGlvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oZE5vZGUpIHtcbiAgICAgIHRoaXMua2V5UGFpciA9IFNlY3AyNTZrMUV4dGVuZGVkS2V5UGFpci50b0tleVBhaXIodGhpcy5oZE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGtleXMgZm9ybWF0IGlzIGEgcGFpciBvZiBVaW50OEFycmF5IGtleXNcbiAgICpcbiAgICogQHJldHVybnMgeyBEZWZhdWx0S2V5cyB9IFRoZSBrZXlzIGluIHRoZSBkZWZpbmVkIGZvcm1hdFxuICAgKi9cbiAgZ2V0S2V5cygpOiBEZWZhdWx0S2V5cyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogdGhpcy5nZXRQdWJsaWNLZXkoeyBjb21wcmVzc2VkOiB0cnVlIH0pLnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgIHBydjogdGhpcy5nZXRQcml2YXRlS2V5KCk/LnRvU3RyaW5nKCdoZXgnKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGdldEFkZHJlc3MoKTogc3RyaW5nIHtcbiAgICBjb25zdCBrZXlzID0gdGhpcy5nZXRLZXlzKCk7XG4gICAgcmV0dXJuIFNFQ1AyNTZLMV9QUkVGSVggKyBrZXlzLnB1YjtcbiAgfVxufVxuIl19