"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cspr = void 0;
/**
 * @prettier
 */
const CsprLib = __importStar(require("./lib"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const statics_1 = require("@bitgo/statics");
const sdk_core_1 = require("@bitgo/sdk-core");
class Cspr extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Cspr(bitgo, staticsCoin);
    }
    getChain() {
        return this._staticsCoin.name;
    }
    getFamily() {
        return this._staticsCoin.family;
    }
    getFullName() {
        return this._staticsCoin.fullName;
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    async verifyTransaction(params) {
        // TODO: Implement when available on the SDK.
        return true;
    }
    /**
     * Check if address is valid, then make sure it matches the root address.
     *
     * @param {VerifyAddressOptions} params address and rootAddress to verify
     */
    async isWalletAddress(params) {
        const { address, rootAddress } = params;
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (!this.isValidAddress(rootAddress)) {
            throw new sdk_core_1.InvalidAddressError('wallet root address is not valid');
        }
        const newAddressDetails = CsprLib.Utils.getAddressDetails(address);
        const rootAddressDetails = CsprLib.Utils.getAddressDetails(rootAddress);
        if (newAddressDetails.address.toLowerCase() !== rootAddressDetails.address.toLowerCase()) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${newAddressDetails.address} vs ${rootAddress}`);
        }
        return true;
    }
    /**
     * Generate Casper key pair - BitGo xpub format
     *
     * @param {Buffer} seed - Seed from which the new keypair should be generated, otherwise a random seed is used
     * @returns {Object} object with generated xpub and xprv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? new CsprLib.KeyPair({ seed }) : new CsprLib.KeyPair();
        const keys = keyPair.getExtendedKeys();
        if (!keys.xprv) {
            throw new Error('Missing xprv in key generation.');
        }
        return {
            pub: keys.xpub,
            prv: keys.xprv,
        };
    }
    isValidPub(pub) {
        // TODO(STLX-1344): Validate using account-lib when available
        //  return accountLib.Cspr.Utils.isValidPublicKey(pub);
        try {
            new CsprLib.KeyPair({ pub });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid private key for the coin
     *
     * @param prv the prv to be checked
     * @returns is it valid?
     */
    isValidPrv(prv) {
        // TODO(STLX-1345): Validate using account-lib when available
        //  return accountLib.Cspr.Utils.isValidPrivateKey(prv);
        try {
            new CsprLib.KeyPair({ prv });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return boolean indicating whether input is valid CSPR address
     *
     * @param address the pub to be checked
     * @returns true if the address is valid
     */
    isValidAddress(address) {
        try {
            const addressDetails = CsprLib.Utils.getAddressDetails(address);
            return address === CsprLib.Utils.normalizeAddress(addressDetails);
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param {SignTransactionOptions} params data required to rebuild and sign the transaction
     * @param {TransactionPrebuild} params.txPrebuild prebuild object returned by platform
     * @param {String} params.prv user prv used to sign the transaction
     * @returns Bluebird<SignedTransaction>
     */
    async signTransaction(params) {
        const txBuilder = this.getBuilder().from(params.txPrebuild.txHex);
        const key = params.prv;
        txBuilder.sign({ key });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new sdk_core_1.InvalidTransactionError('Error while trying to build transaction');
        }
        const response = {
            txHex: transaction.toBroadcastFormat(),
        };
        return transaction.signature.length >= 2 ? response : { halfSigned: response };
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Extend walletParams with extra params required for generating a Casper wallet
     *
     * Casper wallets have three three keys, user, backup and bitgo.
     * Initially, we need a root prv to generate the account, which must be distinct from all three keychains on the wallet.
     * If a root private key is not provided, a random one is generated.
     * The root public key is the basis for the wallet root address.
     */
    async supplementGenerateWallet(walletParams) {
        if (walletParams.rootPrivateKey) {
            if (!this.isValidPrv(walletParams.rootPrivateKey) || walletParams.rootPrivateKey.length !== 64) {
                throw new Error('rootPrivateKey needs to be a hexadecimal private key string');
            }
        }
        else {
            const keyPair = utxo_lib_1.ECPair.makeRandom();
            if (!keyPair.privateKey) {
                throw new Error('no privateKey');
            }
            walletParams.rootPrivateKey = keyPair.privateKey.toString('hex');
        }
        return walletParams;
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        const keyPair = new CsprLib.KeyPair({ prv: key.prv });
        const messageHex = message instanceof Buffer ? message.toString('hex') : message;
        const signatureData = CsprLib.Utils.signMessage(keyPair, messageHex);
        return Buffer.from(signatureData.signature);
    }
    /**
     * Explain a Casper transaction from Raw Tx
     *
     * @param {ExplainTransactionOptions} params given explain transaction params
     * @param {String} params.txHex raw transaction
     * @param {String} params.halfSigned.txHex raw half signed transaction
     * @param {TransactionFee} fee fee information
     * @returns Bluebird<TransactionExplanation>
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const txBuilder = this.getBuilder().from(txHex);
        const tx = await txBuilder.build();
        if (!tx) {
            throw new sdk_core_1.InvalidTransactionError('Error while trying to build transaction');
        }
        const id = Buffer.from(tx.casperTx.hash).toString('hex');
        const amount = CsprLib.Utils.getTransferAmount(tx.casperTx.session);
        let transferId;
        const outputs = [];
        const operations = [];
        switch (tx.type) {
            case sdk_core_1.TransactionType.Send: {
                transferId = CsprLib.Utils.getTransferId(tx.casperTx.session);
                const toAddress = CsprLib.Utils.getTransferDestinationAddress(tx._deploy.session);
                outputs.push({
                    address: toAddress,
                    amount,
                    coin: this.getChain(),
                });
                break;
            }
            case sdk_core_1.TransactionType.StakingLock: {
                const validator = CsprLib.Utils.getValidatorAddress(tx._deploy.session);
                operations.push({
                    type: sdk_core_1.TransactionType.StakingLock,
                    amount,
                    coin: this.getChain(),
                    validator: validator,
                });
                break;
            }
            case sdk_core_1.TransactionType.StakingUnlock: {
                const validator = CsprLib.Utils.getValidatorAddress(tx._deploy.session);
                operations.push({
                    type: sdk_core_1.TransactionType.StakingUnlock,
                    amount,
                    coin: this.getChain(),
                    validator: validator,
                });
                break;
            }
            default: {
                throw new sdk_core_1.InvalidTransactionError('Error while trying to get transaction type');
            }
        }
        const outputAmount = outputs
            .reduce((acumulator, output) => {
            const currentValue = new bignumber_js_1.default(output.amount);
            return acumulator.plus(currentValue);
        }, new bignumber_js_1.default(0))
            .toFixed(0);
        const displayOrder = [
            'id',
            'outputAmount',
            'changeAmount',
            'outputs',
            'changeOutputs',
            'transferId',
            'fee',
            'operations',
        ];
        return {
            displayOrder,
            id,
            outputs,
            outputAmount,
            changeOutputs: [],
            changeAmount: '0',
            transferId,
            fee: params.feeInfo,
            operations,
        };
    }
    getBuilder() {
        return new CsprLib.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
}
exports.Cspr = Cspr;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3Nwci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jc3ByLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILCtDQUFpQztBQUNqQyw4Q0FBeUM7QUFDekMsZ0VBQXFDO0FBRXJDLDRDQUFnRjtBQUNoRiw4Q0FnQnlCO0FBNkN6QixNQUFhLElBQUssU0FBUSxtQkFBUTtJQUdoQyxZQUFZLEtBQWdCLEVBQUUsV0FBdUM7UUFDbkUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWIsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDdkU7UUFFRCxJQUFJLENBQUMsWUFBWSxHQUFHLFdBQVcsQ0FBQztJQUNsQyxDQUFDO0lBRUQsTUFBTSxDQUFDLGNBQWMsQ0FBQyxLQUFnQixFQUFFLFdBQXVDO1FBQzdFLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBQ0QsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDbEMsQ0FBQztJQUNELFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxDQUFDO0lBQ3BDLENBQUM7SUFDRCxhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxLQUFLLENBQUMsaUJBQWlCLENBQUMsTUFBZ0M7UUFDdEQsNkNBQTZDO1FBQzdDLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsZUFB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QVU7UUFDaEIsT0FBTyxJQUFJLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxlQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDM0UsQ0FBQztDQUNGO0FBelJELG9CQXlSQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIENzcHJMaWIgZnJvbSAnLi9saWInO1xuaW1wb3J0IHsgRUNQYWlyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcblxuaW1wb3J0IHsgQmFzZUNvaW4gYXMgU3RhdGljc0Jhc2VDb2luLCBDb2luRmFtaWx5LCBjb2lucyB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBCaXRHb0Jhc2UsXG4gIEludmFsaWRBZGRyZXNzRXJyb3IsXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxuICBLZXlQYWlyLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBUcmFuc2FjdGlvblByZWJ1aWxkIGFzIEJhc2VUcmFuc2FjdGlvblByZWJ1aWxkLFxuICBUcmFuc2FjdGlvblR5cGUsXG4gIFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IsXG4gIFZlcmlmeUFkZHJlc3NPcHRpb25zLFxuICBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5cbmludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblByZWJ1aWxkIGV4dGVuZHMgQmFzZVRyYW5zYWN0aW9uUHJlYnVpbGQge1xuICB0eEhleDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uRmVlIHtcbiAgZ2FzTGltaXQ6IHN0cmluZztcbiAgZ2FzUHJpY2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhIZXg/OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbiAgZmVlSW5mbzogVHJhbnNhY3Rpb25GZWU7XG59XG5cbmludGVyZmFjZSBTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zIHtcbiAgcm9vdFByaXZhdGVLZXk/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBUcmFuc2FjdGlvbk91dHB1dCB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIGNvaW46IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3BlcmF0aW9uIHtcbiAgdHlwZTogbnVtYmVyO1xuICBhbW91bnQ6IHN0cmluZztcbiAgY29pbjogc3RyaW5nO1xuICB2YWxpZGF0b3I6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENzcHJWZXJpZnlBZGRyZXNzT3B0aW9ucyBleHRlbmRzIFZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIENzcHIgZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfc3RhdGljc0NvaW46IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj47XG5cbiAgY29uc3RydWN0b3IoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KSB7XG4gICAgc3VwZXIoYml0Z28pO1xuXG4gICAgaWYgKCFzdGF0aWNzQ29pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBzdGF0aWNzQ29pbicpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXRpY3NDb2luID0gc3RhdGljc0NvaW47XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgQ3NwcihiaXRnbywgc3RhdGljc0NvaW4pO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4ubmFtZTtcbiAgfVxuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5mdWxsTmFtZTtcbiAgfVxuICBnZXRCYXNlRmFjdG9yKCk6IHN0cmluZyB8IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGF0aWNzQ29pbi5kZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50IHdoZW4gYXZhaWxhYmxlIG9uIHRoZSBTREsuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYWRkcmVzcyBpcyB2YWxpZCwgdGhlbiBtYWtlIHN1cmUgaXQgbWF0Y2hlcyB0aGUgcm9vdCBhZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0ge1ZlcmlmeUFkZHJlc3NPcHRpb25zfSBwYXJhbXMgYWRkcmVzcyBhbmQgcm9vdEFkZHJlc3MgdG8gdmVyaWZ5XG4gICAqL1xuICBhc3luYyBpc1dhbGxldEFkZHJlc3MocGFyYW1zOiBDc3ByVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIHJvb3RBZGRyZXNzIH0gPSBwYXJhbXM7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhyb290QWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKCd3YWxsZXQgcm9vdCBhZGRyZXNzIGlzIG5vdCB2YWxpZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0FkZHJlc3NEZXRhaWxzID0gQ3NwckxpYi5VdGlscy5nZXRBZGRyZXNzRGV0YWlscyhhZGRyZXNzKTtcbiAgICBjb25zdCByb290QWRkcmVzc0RldGFpbHMgPSBDc3ByTGliLlV0aWxzLmdldEFkZHJlc3NEZXRhaWxzKHJvb3RBZGRyZXNzKTtcbiAgICBpZiAobmV3QWRkcmVzc0RldGFpbHMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpICE9PSByb290QWRkcmVzc0RldGFpbHMuYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZEFkZHJlc3NFcnJvcihgYWRkcmVzcyB2YWxpZGF0aW9uIGZhaWx1cmU6ICR7bmV3QWRkcmVzc0RldGFpbHMuYWRkcmVzc30gdnMgJHtyb290QWRkcmVzc31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgQ2FzcGVyIGtleSBwYWlyIC0gQml0R28geHB1YiBmb3JtYXRcbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNlZWQgLSBTZWVkIGZyb20gd2hpY2ggdGhlIG5ldyBrZXlwYWlyIHNob3VsZCBiZSBnZW5lcmF0ZWQsIG90aGVyd2lzZSBhIHJhbmRvbSBzZWVkIGlzIHVzZWRcbiAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IHdpdGggZ2VuZXJhdGVkIHhwdWIgYW5kIHhwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlZWQgPyBuZXcgQ3NwckxpYi5LZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBDc3ByTGliLktleVBhaXIoKTtcbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRFeHRlbmRlZEtleXMoKTtcblxuICAgIGlmICgha2V5cy54cHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgeHBydiBpbiBrZXkgZ2VuZXJhdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBrZXlzLnhwdWIsXG4gICAgICBwcnY6IGtleXMueHBydixcbiAgICB9O1xuICB9XG5cbiAgaXNWYWxpZFB1YihwdWI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIFRPRE8oU1RMWC0xMzQ0KTogVmFsaWRhdGUgdXNpbmcgYWNjb3VudC1saWIgd2hlbiBhdmFpbGFibGVcbiAgICAvLyAgcmV0dXJuIGFjY291bnRMaWIuQ3Nwci5VdGlscy5pc1ZhbGlkUHVibGljS2V5KHB1Yik7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBDc3ByTGliLktleVBhaXIoeyBwdWIgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBwcml2YXRlIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHBydiB0aGUgcHJ2IHRvIGJlIGNoZWNrZWRcbiAgICogQHJldHVybnMgaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETyhTVExYLTEzNDUpOiBWYWxpZGF0ZSB1c2luZyBhY2NvdW50LWxpYiB3aGVuIGF2YWlsYWJsZVxuICAgIC8vICByZXR1cm4gYWNjb3VudExpYi5Dc3ByLlV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KHBydik7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBDc3ByTGliLktleVBhaXIoeyBwcnYgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBpbnB1dCBpcyB2YWxpZCBDU1BSIGFkZHJlc3NcbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGFkZHJlc3MgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IENzcHJMaWIuVXRpbHMuZ2V0QWRkcmVzc0RldGFpbHMoYWRkcmVzcyk7XG4gICAgICByZXR1cm4gYWRkcmVzcyA9PT0gQ3NwckxpYi5VdGlscy5ub3JtYWxpemVBZGRyZXNzKGFkZHJlc3NEZXRhaWxzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGtleWNoYWluIGFuZCBoYWxmLXNpZ24gcHJlYnVpbHQgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtTaWduVHJhbnNhY3Rpb25PcHRpb25zfSBwYXJhbXMgZGF0YSByZXF1aXJlZCB0byByZWJ1aWxkIGFuZCBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uUHJlYnVpbGR9IHBhcmFtcy50eFByZWJ1aWxkIHByZWJ1aWxkIG9iamVjdCByZXR1cm5lZCBieSBwbGF0Zm9ybVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnBydiB1c2VyIHBydiB1c2VkIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIEJsdWViaXJkPFNpZ25lZFRyYW5zYWN0aW9uPlxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCB0eEJ1aWxkZXIgPSB0aGlzLmdldEJ1aWxkZXIoKS5mcm9tKHBhcmFtcy50eFByZWJ1aWxkLnR4SGV4KTtcbiAgICBjb25zdCBrZXkgPSBwYXJhbXMucHJ2O1xuICAgIHR4QnVpbGRlci5zaWduKHsga2V5IH0pO1xuXG4gICAgY29uc3QgdHJhbnNhY3Rpb246IGFueSA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGJ1aWxkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgdHhIZXg6IHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCksXG4gICAgfTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uc2lnbmF0dXJlLmxlbmd0aCA+PSAyID8gcmVzcG9uc2UgOiB7IGhhbGZTaWduZWQ6IHJlc3BvbnNlIH07XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCB3YWxsZXRQYXJhbXMgd2l0aCBleHRyYSBwYXJhbXMgcmVxdWlyZWQgZm9yIGdlbmVyYXRpbmcgYSBDYXNwZXIgd2FsbGV0XG4gICAqXG4gICAqIENhc3BlciB3YWxsZXRzIGhhdmUgdGhyZWUgdGhyZWUga2V5cywgdXNlciwgYmFja3VwIGFuZCBiaXRnby5cbiAgICogSW5pdGlhbGx5LCB3ZSBuZWVkIGEgcm9vdCBwcnYgdG8gZ2VuZXJhdGUgdGhlIGFjY291bnQsIHdoaWNoIG11c3QgYmUgZGlzdGluY3QgZnJvbSBhbGwgdGhyZWUga2V5Y2hhaW5zIG9uIHRoZSB3YWxsZXQuXG4gICAqIElmIGEgcm9vdCBwcml2YXRlIGtleSBpcyBub3QgcHJvdmlkZWQsIGEgcmFuZG9tIG9uZSBpcyBnZW5lcmF0ZWQuXG4gICAqIFRoZSByb290IHB1YmxpYyBrZXkgaXMgdGhlIGJhc2lzIGZvciB0aGUgd2FsbGV0IHJvb3QgYWRkcmVzcy5cbiAgICovXG4gIGFzeW5jIHN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldChcbiAgICB3YWxsZXRQYXJhbXM6IFN1cHBsZW1lbnRHZW5lcmF0ZVdhbGxldE9wdGlvbnNcbiAgKTogUHJvbWlzZTxTdXBwbGVtZW50R2VuZXJhdGVXYWxsZXRPcHRpb25zPiB7XG4gICAgaWYgKHdhbGxldFBhcmFtcy5yb290UHJpdmF0ZUtleSkge1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRQcnYod2FsbGV0UGFyYW1zLnJvb3RQcml2YXRlS2V5KSB8fCB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RQcml2YXRlS2V5IG5lZWRzIHRvIGJlIGEgaGV4YWRlY2ltYWwgcHJpdmF0ZSBrZXkgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleVBhaXIgPSBFQ1BhaXIubWFrZVJhbmRvbSgpO1xuICAgICAgaWYgKCFrZXlQYWlyLnByaXZhdGVLZXkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBwcml2YXRlS2V5Jyk7XG4gICAgICB9XG4gICAgICB3YWxsZXRQYXJhbXMucm9vdFByaXZhdGVLZXkgPSBrZXlQYWlyLnByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0UGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gbWVzc2FnZSB3aXRoIHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSBrZXlcbiAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKGtleTogS2V5UGFpciwgbWVzc2FnZTogc3RyaW5nIHwgQnVmZmVyKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgICBjb25zdCBrZXlQYWlyID0gbmV3IENzcHJMaWIuS2V5UGFpcih7IHBydjoga2V5LnBydiB9KTtcbiAgICBjb25zdCBtZXNzYWdlSGV4ID0gbWVzc2FnZSBpbnN0YW5jZW9mIEJ1ZmZlciA/IG1lc3NhZ2UudG9TdHJpbmcoJ2hleCcpIDogbWVzc2FnZTtcbiAgICBjb25zdCBzaWduYXR1cmVEYXRhID0gQ3NwckxpYi5VdGlscy5zaWduTWVzc2FnZShrZXlQYWlyLCBtZXNzYWdlSGV4KTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc2lnbmF0dXJlRGF0YS5zaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gYSBDYXNwZXIgdHJhbnNhY3Rpb24gZnJvbSBSYXcgVHhcbiAgICpcbiAgICogQHBhcmFtIHtFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zfSBwYXJhbXMgZ2l2ZW4gZXhwbGFpbiB0cmFuc2FjdGlvbiBwYXJhbXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy50eEhleCByYXcgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4IHJhdyBoYWxmIHNpZ25lZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uRmVlfSBmZWUgZmVlIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIEJsdWViaXJkPFRyYW5zYWN0aW9uRXhwbGFuYXRpb24+XG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24ocGFyYW1zOiBFeHBsYWluVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxUcmFuc2FjdGlvbkV4cGxhbmF0aW9uPiB7XG4gICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICBpZiAoIXR4SGV4IHx8ICFwYXJhbXMuZmVlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgIH1cbiAgICBjb25zdCB0eEJ1aWxkZXIgPSB0aGlzLmdldEJ1aWxkZXIoKS5mcm9tKHR4SGV4KTtcblxuICAgIGNvbnN0IHR4OiBhbnkgPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBpZiAoIXR4KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0Vycm9yIHdoaWxlIHRyeWluZyB0byBidWlsZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IEJ1ZmZlci5mcm9tKHR4LmNhc3BlclR4Lmhhc2gpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBhbW91bnQgPSBDc3ByTGliLlV0aWxzLmdldFRyYW5zZmVyQW1vdW50KHR4LmNhc3BlclR4LnNlc3Npb24pO1xuICAgIGxldCB0cmFuc2ZlcklkO1xuICAgIGNvbnN0IG91dHB1dHM6IFRyYW5zYWN0aW9uT3V0cHV0W10gPSBbXTtcbiAgICBjb25zdCBvcGVyYXRpb25zOiBUcmFuc2FjdGlvbk9wZXJhdGlvbltdID0gW107XG5cbiAgICBzd2l0Y2ggKHR4LnR5cGUpIHtcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlNlbmQ6IHtcbiAgICAgICAgdHJhbnNmZXJJZCA9IENzcHJMaWIuVXRpbHMuZ2V0VHJhbnNmZXJJZCh0eC5jYXNwZXJUeC5zZXNzaW9uKTtcbiAgICAgICAgY29uc3QgdG9BZGRyZXNzID0gQ3NwckxpYi5VdGlscy5nZXRUcmFuc2ZlckRlc3RpbmF0aW9uQWRkcmVzcyh0eC5fZGVwbG95LnNlc3Npb24pO1xuICAgICAgICBvdXRwdXRzLnB1c2goe1xuICAgICAgICAgIGFkZHJlc3M6IHRvQWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nTG9jazoge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBDc3ByTGliLlV0aWxzLmdldFZhbGlkYXRvckFkZHJlc3ModHguX2RlcGxveS5zZXNzaW9uKTtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0xvY2ssXG4gICAgICAgICAgYW1vdW50LFxuICAgICAgICAgIGNvaW46IHRoaXMuZ2V0Q2hhaW4oKSxcbiAgICAgICAgICB2YWxpZGF0b3I6IHZhbGlkYXRvcixcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1VubG9jazoge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBDc3ByTGliLlV0aWxzLmdldFZhbGlkYXRvckFkZHJlc3ModHguX2RlcGxveS5zZXNzaW9uKTtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ1VubG9jayxcbiAgICAgICAgICBhbW91bnQsXG4gICAgICAgICAgY29pbjogdGhpcy5nZXRDaGFpbigpLFxuICAgICAgICAgIHZhbGlkYXRvcjogdmFsaWRhdG9yLFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignRXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGdldCB0cmFuc2FjdGlvbiB0eXBlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0QW1vdW50ID0gb3V0cHV0c1xuICAgICAgLnJlZHVjZSgoYWN1bXVsYXRvciwgb3V0cHV0KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IG5ldyBCaWdOdW1iZXIob3V0cHV0LmFtb3VudCk7XG4gICAgICAgIHJldHVybiBhY3VtdWxhdG9yLnBsdXMoY3VycmVudFZhbHVlKTtcbiAgICAgIH0sIG5ldyBCaWdOdW1iZXIoMCkpXG4gICAgICAudG9GaXhlZCgwKTtcblxuICAgIGNvbnN0IGRpc3BsYXlPcmRlciA9IFtcbiAgICAgICdpZCcsXG4gICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICdjaGFuZ2VBbW91bnQnLFxuICAgICAgJ291dHB1dHMnLFxuICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgJ3RyYW5zZmVySWQnLFxuICAgICAgJ2ZlZScsXG4gICAgICAnb3BlcmF0aW9ucycsXG4gICAgXTtcblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5T3JkZXIsXG4gICAgICBpZCxcbiAgICAgIG91dHB1dHMsXG4gICAgICBvdXRwdXRBbW91bnQsXG4gICAgICBjaGFuZ2VPdXRwdXRzOiBbXSwgLy8gYWNjb3VudCBiYXNlZCBkb2VzIG5vdCB1c2UgY2hhbmdlIG91dHB1dHNcbiAgICAgIGNoYW5nZUFtb3VudDogJzAnLCAvLyBhY2NvdW50IGJhc2UgZG9lcyBub3QgbWFrZSBjaGFuZ2VcbiAgICAgIHRyYW5zZmVySWQsXG4gICAgICBmZWU6IHBhcmFtcy5mZWVJbmZvLFxuICAgICAgb3BlcmF0aW9ucyxcbiAgICB9IGFzIGFueTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QnVpbGRlcigpOiBDc3ByTGliLlRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICAgIHJldHVybiBuZXcgQ3NwckxpYi5UcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5KGNvaW5zLmdldCh0aGlzLmdldENoYWluKCkpKTtcbiAgfVxufVxuIl19