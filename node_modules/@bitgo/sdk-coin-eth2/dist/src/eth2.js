"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Eth2 = void 0;
/**
 * @prettier
 */
const _ = __importStar(require("lodash"));
const ethUtil = __importStar(require("ethereumjs-util"));
const request = __importStar(require("superagent"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_core_1 = require("@bitgo/sdk-core");
const lib_1 = require("./lib");
class Eth2 extends sdk_core_1.BaseCoin {
    static createInstance(bitgo) {
        return new Eth2(bitgo);
    }
    /** @inheritDoc */
    supportsBlsDkg() {
        return true;
    }
    /**
     * Returns the factor between the base unit and its smallest subdivison
     * @return {number}
     */
    getBaseFactor() {
        // 10^18
        return '1000000000000000000';
    }
    getChain() {
        return 'eth2';
    }
    getFamily() {
        return 'eth2';
    }
    getFullName() {
        return 'Ethereum 2.0';
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        // false until phase 2 of eth2.0 rolled out
        return false;
    }
    /**
     * Flag for sending data along with transactions
     * @returns {boolean} True if okay to send tx data (ETH), false otherwise
     */
    transactionDataAllowed() {
        // false until phase 2 of eth2.0 rolled out
        return false;
    }
    /**
     * Evaluates whether a address string is valid for this coin
     * @param address
     */
    isValidAddress(address) {
        return this.isValidPub(address);
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        return lib_1.KeyPair.isValidPub(pub);
    }
    /**
     * Default gas price from platform
     * @returns {BigNumber}
     */
    getRecoveryGasPrice() {
        throw new Error('Method not yet implemented');
    }
    /**
     * Default gas limit from platform
     * @returns {BigNumber}
     */
    getRecoveryGasLimit() {
        throw new Error('Method not yet implemented');
    }
    /**
     * Specifies what key we will need for signing - ETH2 needs the backup, bitgo pubs.
     */
    keyIdsForSigning() {
        return [sdk_core_1.KeyIndices.USER, sdk_core_1.KeyIndices.BACKUP, sdk_core_1.KeyIndices.BITGO];
    }
    /**
     * Query Beaconscan for the balance of an address
     * @param address {String} the ETH address
     * @returns {BigNumber} address balance
     */
    async queryAddressBalance(address) {
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'account',
            action: 'balance',
            address: address,
        });
        return new bignumber_js_1.default(result.result, 10);
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     * @param params
     * - txPrebuild
     * - prv
     * @returns {Promise<SignedTransaction>}
     */
    async signTransaction(params) {
        throw new Error('Method not yet implemented');
    }
    /**
     * Ensure either enterprise or newFeeAddress is passed, to know whether to create new key or use enterprise key
     * @param params
     * @param params.enterprise {String} the enterprise id to associate with this key
     * @param params.newFeeAddress {Boolean} create a new fee address (enterprise not needed in this case)
     */
    preCreateBitGo(params) {
        // We always need params object, since either enterprise or newFeeAddress is required
        if (!_.isObject(params)) {
            throw new Error(`preCreateBitGo must be passed a params object. Got ${params} (type ${typeof params})`);
        }
        if (_.isUndefined(params.enterprise)) {
            throw new Error('expecting enterprise when adding BitGo key');
        }
        if (!_.isUndefined(params.enterprise) && !_.isString(params.enterprise)) {
            throw new Error(`enterprise should be a string - got ${params.enterprise} (type ${typeof params.enterprise})`);
        }
    }
    /**
     * Queries public block explorer to get the next ETH nonce that should be used for the given ETH address
     * @param address
     * @returns Promise<number>
     */
    async getAddressNonce(address) {
        // Get nonce for backup key (should be 0)
        let nonce = 0;
        const result = await this.recoveryBlockchainExplorerQuery({
            module: 'account',
            action: 'txlist',
            address,
        });
        const backupKeyTxList = result.result;
        if (backupKeyTxList.length > 0) {
            // Calculate last nonce used
            const outgoingTxs = backupKeyTxList.filter((tx) => tx.from === address);
            nonce = outgoingTxs.length;
        }
        return nonce;
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param params
     * @param params.userKey {String} [encrypted] xprv
     * @param params.backupKey {String} [encrypted] xprv or xpub if the xprv is held by a KRS provider
     * @param params.walletPassphrase {String} used to decrypt userKey and backupKey
     * @param params.walletContractAddress {String} the ETH address of the wallet contract
     * @param params.recoveryDestination {String} target address to send recovered funds to
     */
    recover(params) {
        throw new Error('recover not implemented');
    }
    /**
     * Make a query to Etherscan for information such as balance, token balance, solidity calls
     * @param query {Object} key-value pairs of parameters to append after /api
     * @returns {Object} response from Etherscan
     */
    async recoveryBlockchainExplorerQuery(query) {
        const response = await request.get(sdk_core_1.common.Environments[this.bitgo.getEnv()].eth2ExplorerBaseUrl).query(query);
        if (!response.ok) {
            throw new Error('could not reach BeaconScan');
        }
        return response.body;
    }
    /**
     * Generate BLS key pair
     *
     * @param seed - byte array to generate BLS key pair from
     * @returns {Object} object with generated pub and prv
     */
    generateKeyPair(seed) {
        let keyPair = new lib_1.KeyPair();
        if (seed && lib_1.KeyPair.isValidPrv(seed)) {
            const seedStr = Buffer.from(seed).toString('hex');
            keyPair = new lib_1.KeyPair({ prv: seedStr });
        }
        else if (seed) {
            throw new Error('trying to generate keypair from invalid seed');
        }
        const keys = keyPair.getKeys();
        return {
            pub: keys.publicShare,
            prv: keys.prv || '',
            secretShares: keys.secretShares || [],
            seed: keys.seed,
            chaincode: keys.chaincode || '',
        };
    }
    async parseTransaction(params) {
        return {};
    }
    async isWalletAddress(params) {
        throw new sdk_core_1.MethodNotImplementedError();
    }
    async verifyTransaction(params) {
        return true;
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        const keyPair = new lib_1.KeyPair({ prv: key.prv });
        let messageToSign = Buffer.from(message);
        if (lib_1.KeyPair.isValidPub(message)) {
            // if we are doing a key signature, we should decode the message as a hex string
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore BG-34579: known compatibility issue with @types/ethereumjs-util
            messageToSign = Buffer.from(ethUtil.stripHexPrefix(message), 'hex');
        }
        const signedMessage = await keyPair.sign(messageToSign);
        return ethUtil.toBuffer(signedMessage);
    }
    aggregateShares(shares) {
        const commonPub = lib_1.KeyPair.aggregatePubkeys(shares.pubShares);
        const prv = lib_1.KeyPair.aggregatePrvkeys(shares.prvShares);
        const commonChaincode = lib_1.KeyPair.aggregateChaincodes(shares.chaincodes);
        return {
            pub: commonPub,
            prv,
            secretShares: shares.prvShares,
            chaincode: commonChaincode,
        };
    }
}
exports.Eth2 = Eth2;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXRoMi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ldGgyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILDBDQUE0QjtBQUM1Qix5REFBMkM7QUFDM0Msb0RBQXNDO0FBQ3RDLGdFQUFxQztBQUVyQyw4Q0FheUI7QUFFekIsK0JBQStDO0FBc0YvQyxNQUFhLElBQUssU0FBUSxtQkFBUTtJQUNoQyxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCO1FBQ3BDLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsYUFBYTtRQUNYLFFBQVE7UUFDUixPQUFPLHFCQUFxQixDQUFDO0lBQy9CLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELFNBQVM7UUFDUCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsV0FBVztRQUNULE9BQU8sY0FBYyxDQUFDO0lBQ3hCLENBQUM7SUFFRDs7O09BR0c7SUFDSCx3QkFBd0I7UUFDdEIsMkNBQTJDO1FBQzNDLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7T0FHRztJQUNILHNCQUFzQjtRQUNwQiwyQ0FBMkM7UUFDM0MsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsY0FBYyxDQUFDLE9BQWU7UUFDNUIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFVBQVUsQ0FBQyxHQUFXO1FBQ3BCLE9BQU8sYUFBVyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsbUJBQW1CO1FBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsbUJBQW1CO1FBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxnQkFBZ0I7UUFDZCxPQUFPLENBQUMscUJBQVUsQ0FBQyxJQUFJLEVBQUUscUJBQVUsQ0FBQyxNQUFNLEVBQUUscUJBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxPQUFlO1FBQ3ZDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLCtCQUErQixDQUFDO1lBQ3hELE1BQU0sRUFBRSxTQUFTO1lBQ2pCLE1BQU0sRUFBRSxTQUFTO1lBQ2pCLE9BQU8sRUFBRSxPQUFPO1NBQ2pCLENBQUMsQ0FBQztRQUNILE9BQU8sSUFBSSxzQkFBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDMUMsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxlQUFlLENBQUMsTUFBOEI7UUFDbEQsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGNBQWMsQ0FBQyxNQUE2QjtRQUMxQyxxRkFBcUY7UUFDckYsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzREFBc0QsTUFBTSxVQUFVLE9BQU8sTUFBTSxHQUFHLENBQUMsQ0FBQztTQUN6RztRQUVELElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDcEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO1NBQy9EO1FBRUQsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDdkUsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsTUFBTSxDQUFDLFVBQVUsVUFBVSxPQUFPLE1BQU0sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO1NBQ2hIO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUFDLE9BQWU7UUFDbkMseUNBQXlDO1FBQ3pDLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztRQUVkLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLCtCQUErQixDQUFDO1lBQ3hELE1BQU0sRUFBRSxTQUFTO1lBQ2pCLE1BQU0sRUFBRSxRQUFRO1lBQ2hCLE9BQU87U0FDUixDQUFDLENBQUM7UUFDSCxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDO1FBQ3RDLElBQUksZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDOUIsNEJBQTRCO1lBQzVCLE1BQU0sV0FBVyxHQUFHLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLEtBQUssT0FBTyxDQUFDLENBQUM7WUFDeEUsS0FBSyxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7U0FDNUI7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILE9BQU8sQ0FBQyxNQUFzQjtRQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsK0JBQStCLENBQUMsS0FBVTtRQUM5QyxNQUFNLFFBQVEsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQU0sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRTlHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztTQUMvQztRQUNELE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxlQUFlLENBQUMsSUFBYTtRQUMzQixJQUFJLE9BQU8sR0FBRyxJQUFJLGFBQVcsRUFBRSxDQUFDO1FBQ2hDLElBQUksSUFBSSxJQUFJLGFBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDeEMsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDbEQsT0FBTyxHQUFHLElBQUksYUFBVyxDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDN0M7YUFBTSxJQUFJLElBQUksRUFBRTtZQUNmLE1BQU0sSUFBSSxLQUFLLENBQUMsOENBQThDLENBQUMsQ0FBQztTQUNqRTtRQUVELE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMvQixPQUFPO1lBQ0wsR0FBRyxFQUFFLElBQUksQ0FBQyxXQUFXO1lBQ3JCLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxJQUFJLEVBQUU7WUFDbkIsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZLElBQUksRUFBRTtZQUNyQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVMsSUFBSSxFQUFFO1NBQ2hDLENBQUM7SUFDSixDQUFDO0lBRUQsS0FBSyxDQUFDLGdCQUFnQixDQUFDLE1BQStCO1FBQ3BELE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztJQUVELEtBQUssQ0FBQyxlQUFlLENBQUMsTUFBNEI7UUFDaEQsTUFBTSxJQUFJLG9DQUF5QixFQUFFLENBQUM7SUFDeEMsQ0FBQztJQUVELEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxNQUFnQztRQUN0RCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FBQyxXQUFXLENBQUMsR0FBb0IsRUFBRSxPQUFlO1FBQ3JELE1BQU0sT0FBTyxHQUFHLElBQUksYUFBVyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBRWxELElBQUksYUFBYSxHQUFXLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDakQsSUFBSSxhQUFXLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ25DLGdGQUFnRjtZQUNoRiw2REFBNkQ7WUFDN0QsNkVBQTZFO1lBQzdFLGFBQWEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDckU7UUFFRCxNQUFNLGFBQWEsR0FBRyxNQUFNLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDeEQsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRCxlQUFlLENBQUMsTUFBMEU7UUFDeEYsTUFBTSxTQUFTLEdBQUcsYUFBVyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNqRSxNQUFNLEdBQUcsR0FBRyxhQUFXLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzNELE1BQU0sZUFBZSxHQUFHLGFBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFM0UsT0FBTztZQUNMLEdBQUcsRUFBRSxTQUFTO1lBQ2QsR0FBRztZQUNILFlBQVksRUFBRSxNQUFNLENBQUMsU0FBUztZQUM5QixTQUFTLEVBQUUsZUFBZTtTQUMzQixDQUFDO0lBQ0osQ0FBQztDQUNGO0FBaFFELG9CQWdRQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCAqIGFzIGV0aFV0aWwgZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCAqIGFzIHJlcXVlc3QgZnJvbSAnc3VwZXJhZ2VudCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5cbmltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBCaXRHb0Jhc2UsXG4gIGNvbW1vbixcbiAgSGFsZlNpZ25lZEFjY291bnRUcmFuc2FjdGlvbiBhcyBCYXNlSGFsZlNpZ25lZFRyYW5zYWN0aW9uLFxuICBJQmxzS2V5UGFpcixcbiAgS2V5SW5kaWNlcyxcbiAgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcixcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuXG5pbXBvcnQgeyBLZXlQYWlyIGFzIEV0aDJLZXlQYWlyIH0gZnJvbSAnLi9saWInO1xuXG5pbnRlcmZhY2UgUmVjaXBpZW50IHtcbiAgYWRkcmVzczogc3RyaW5nO1xuICBhbW91bnQ6IHN0cmluZztcbiAgZGF0YT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFNpZ25GaW5hbE9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiB7XG4gICAgZ2FzUHJpY2U6IHN0cmluZztcbiAgICBnYXNMaW1pdDogc3RyaW5nO1xuICAgIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICAgIGhhbGZTaWduZWQ6IHtcbiAgICAgIGV4cGlyZVRpbWU6IG51bWJlcjtcbiAgICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogbnVtYmVyO1xuICAgICAgYmFja3VwS2V5Tm9uY2U/OiBudW1iZXI7XG4gICAgICBzaWduYXR1cmU6IHN0cmluZztcbiAgICB9O1xuICAgIG5leHRDb250cmFjdFNlcXVlbmNlSWQ/OiBudW1iZXI7XG4gICAgYmFja3VwS2V5Tm9uY2U/OiBudW1iZXI7XG4gIH07XG4gIHNpZ25pbmdLZXlOb25jZTogbnVtYmVyO1xuICB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHN0cmluZztcbiAgcHJ2OiBzdHJpbmc7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMgZXh0ZW5kcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucywgU2lnbkZpbmFsT3B0aW9ucyB7XG4gIGlzTGFzdFNpZ25hdHVyZT86IGJvb2xlYW47XG4gIGV4cGlyZVRpbWU6IG51bWJlcjtcbiAgc2VxdWVuY2VJZDogbnVtYmVyO1xuICBnYXNMaW1pdDogbnVtYmVyO1xuICBnYXNQcmljZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhbGZTaWduZWRUcmFuc2FjdGlvbiBleHRlbmRzIEJhc2VIYWxmU2lnbmVkVHJhbnNhY3Rpb24ge1xuICBoYWxmU2lnbmVkOiB7XG4gICAgcmVjaXBpZW50czogUmVjaXBpZW50W107XG4gICAgZXhwaXJlVGltZTogbnVtYmVyO1xuICAgIGNvbnRyYWN0U2VxdWVuY2VJZDogbnVtYmVyO1xuICAgIHNlcXVlbmNlSWQ6IG51bWJlcjtcbiAgICB0eEhleD86IG5ldmVyO1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb24ge1xuICB0eEhleDogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBTaWduZWRUcmFuc2FjdGlvbiA9IEhhbGZTaWduZWRUcmFuc2FjdGlvbiB8IEZ1bGx5U2lnbmVkVHJhbnNhY3Rpb247XG5cbmludGVyZmFjZSBQcmVjcmVhdGVCaXRHb09wdGlvbnMge1xuICBlbnRlcnByaXNlPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgT2ZmbGluZVZhdWx0VHhJbmZvIHtcbiAgbmV4dENvbnRyYWN0U2VxdWVuY2VJZD86IHN0cmluZztcbiAgY29udHJhY3RTZXF1ZW5jZUlkPzogc3RyaW5nO1xuICB0eDogc3RyaW5nO1xuICB1c2VyS2V5OiBzdHJpbmc7XG4gIGJhY2t1cEtleTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG4gIGdhc1ByaWNlOiBudW1iZXI7XG4gIGdhc0xpbWl0OiBudW1iZXI7XG4gIHJlY2lwaWVudHM6IFJlY2lwaWVudFtdO1xuICB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIGJhY2t1cEtleU5vbmNlOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVjb3Zlck9wdGlvbnMge1xuICB1c2VyS2V5OiBzdHJpbmc7XG4gIGJhY2t1cEtleTogc3RyaW5nO1xuICB3YWxsZXRQYXNzcGhyYXNlPzogc3RyaW5nO1xuICB3YWxsZXRDb250cmFjdEFkZHJlc3M6IHN0cmluZztcbiAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlY292ZXJ5SW5mbyB7XG4gIGlkOiBzdHJpbmc7XG4gIHR4OiBzdHJpbmc7XG4gIGJhY2t1cEtleT86IHN0cmluZztcbiAgY29pbj86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEV0aDIgZXh0ZW5kcyBCYXNlQ29pbiB7XG4gIHN0YXRpYyBjcmVhdGVJbnN0YW5jZShiaXRnbzogQml0R29CYXNlKTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgRXRoMihiaXRnbyk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgc3VwcG9ydHNCbHNEa2coKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmFjdG9yIGJldHdlZW4gdGhlIGJhc2UgdW5pdCBhbmQgaXRzIHNtYWxsZXN0IHN1YmRpdmlzb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QmFzZUZhY3RvcigpOiBzdHJpbmcge1xuICAgIC8vIDEwXjE4XG4gICAgcmV0dXJuICcxMDAwMDAwMDAwMDAwMDAwMDAwJztcbiAgfVxuXG4gIGdldENoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdldGgyJztcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZXRoMic7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnRXRoZXJldW0gMi4wJztcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCkge1xuICAgIC8vIGZhbHNlIHVudGlsIHBoYXNlIDIgb2YgZXRoMi4wIHJvbGxlZCBvdXRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyBkYXRhIGFsb25nIHdpdGggdHJhbnNhY3Rpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCB0eCBkYXRhIChFVEgpLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHRyYW5zYWN0aW9uRGF0YUFsbG93ZWQoKSB7XG4gICAgLy8gZmFsc2UgdW50aWwgcGhhc2UgMiBvZiBldGgyLjAgcm9sbGVkIG91dFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgd2hldGhlciBhIGFkZHJlc3Mgc3RyaW5nIGlzIHZhbGlkIGZvciB0aGlzIGNvaW5cbiAgICogQHBhcmFtIGFkZHJlc3NcbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRQdWIoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEV0aDJLZXlQYWlyLmlzVmFsaWRQdWIocHViKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGdhcyBwcmljZSBmcm9tIHBsYXRmb3JtXG4gICAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9XG4gICAqL1xuICBnZXRSZWNvdmVyeUdhc1ByaWNlKCk6IGFueSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZ2FzIGxpbWl0IGZyb20gcGxhdGZvcm1cbiAgICogQHJldHVybnMge0JpZ051bWJlcn1cbiAgICovXG4gIGdldFJlY292ZXJ5R2FzTGltaXQoKTogYW55IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgeWV0IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHdoYXQga2V5IHdlIHdpbGwgbmVlZCBmb3Igc2lnbmluZyAtIEVUSDIgbmVlZHMgdGhlIGJhY2t1cCwgYml0Z28gcHVicy5cbiAgICovXG4gIGtleUlkc0ZvclNpZ25pbmcoKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBbS2V5SW5kaWNlcy5VU0VSLCBLZXlJbmRpY2VzLkJBQ0tVUCwgS2V5SW5kaWNlcy5CSVRHT107XG4gIH1cblxuICAvKipcbiAgICogUXVlcnkgQmVhY29uc2NhbiBmb3IgdGhlIGJhbGFuY2Ugb2YgYW4gYWRkcmVzc1xuICAgKiBAcGFyYW0gYWRkcmVzcyB7U3RyaW5nfSB0aGUgRVRIIGFkZHJlc3NcbiAgICogQHJldHVybnMge0JpZ051bWJlcn0gYWRkcmVzcyBiYWxhbmNlXG4gICAqL1xuICBhc3luYyBxdWVyeUFkZHJlc3NCYWxhbmNlKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QmlnTnVtYmVyPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWNvdmVyeUJsb2NrY2hhaW5FeHBsb3JlclF1ZXJ5KHtcbiAgICAgIG1vZHVsZTogJ2FjY291bnQnLFxuICAgICAgYWN0aW9uOiAnYmFsYW5jZScsXG4gICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHJlc3VsdC5yZXN1bHQsIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogLSB0eFByZWJ1aWxkXG4gICAqIC0gcHJ2XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPn1cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IHlldCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBlaXRoZXIgZW50ZXJwcmlzZSBvciBuZXdGZWVBZGRyZXNzIGlzIHBhc3NlZCwgdG8ga25vdyB3aGV0aGVyIHRvIGNyZWF0ZSBuZXcga2V5IG9yIHVzZSBlbnRlcnByaXNlIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMuZW50ZXJwcmlzZSB7U3RyaW5nfSB0aGUgZW50ZXJwcmlzZSBpZCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGtleVxuICAgKiBAcGFyYW0gcGFyYW1zLm5ld0ZlZUFkZHJlc3Mge0Jvb2xlYW59IGNyZWF0ZSBhIG5ldyBmZWUgYWRkcmVzcyAoZW50ZXJwcmlzZSBub3QgbmVlZGVkIGluIHRoaXMgY2FzZSlcbiAgICovXG4gIHByZUNyZWF0ZUJpdEdvKHBhcmFtczogUHJlY3JlYXRlQml0R29PcHRpb25zKTogdm9pZCB7XG4gICAgLy8gV2UgYWx3YXlzIG5lZWQgcGFyYW1zIG9iamVjdCwgc2luY2UgZWl0aGVyIGVudGVycHJpc2Ugb3IgbmV3RmVlQWRkcmVzcyBpcyByZXF1aXJlZFxuICAgIGlmICghXy5pc09iamVjdChwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByZUNyZWF0ZUJpdEdvIG11c3QgYmUgcGFzc2VkIGEgcGFyYW1zIG9iamVjdC4gR290ICR7cGFyYW1zfSAodHlwZSAke3R5cGVvZiBwYXJhbXN9KWApO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBhcmFtcy5lbnRlcnByaXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RpbmcgZW50ZXJwcmlzZSB3aGVuIGFkZGluZyBCaXRHbyBrZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyYW1zLmVudGVycHJpc2UpICYmICFfLmlzU3RyaW5nKHBhcmFtcy5lbnRlcnByaXNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbnRlcnByaXNlIHNob3VsZCBiZSBhIHN0cmluZyAtIGdvdCAke3BhcmFtcy5lbnRlcnByaXNlfSAodHlwZSAke3R5cGVvZiBwYXJhbXMuZW50ZXJwcmlzZX0pYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgcHVibGljIGJsb2NrIGV4cGxvcmVyIHRvIGdldCB0aGUgbmV4dCBFVEggbm9uY2UgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlIGdpdmVuIEVUSCBhZGRyZXNzXG4gICAqIEBwYXJhbSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIFByb21pc2U8bnVtYmVyPlxuICAgKi9cbiAgYXN5bmMgZ2V0QWRkcmVzc05vbmNlKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgLy8gR2V0IG5vbmNlIGZvciBiYWNrdXAga2V5IChzaG91bGQgYmUgMClcbiAgICBsZXQgbm9uY2UgPSAwO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZWNvdmVyeUJsb2NrY2hhaW5FeHBsb3JlclF1ZXJ5KHtcbiAgICAgIG1vZHVsZTogJ2FjY291bnQnLFxuICAgICAgYWN0aW9uOiAndHhsaXN0JyxcbiAgICAgIGFkZHJlc3MsXG4gICAgfSk7XG4gICAgY29uc3QgYmFja3VwS2V5VHhMaXN0ID0gcmVzdWx0LnJlc3VsdDtcbiAgICBpZiAoYmFja3VwS2V5VHhMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIENhbGN1bGF0ZSBsYXN0IG5vbmNlIHVzZWRcbiAgICAgIGNvbnN0IG91dGdvaW5nVHhzID0gYmFja3VwS2V5VHhMaXN0LmZpbHRlcigodHgpID0+IHR4LmZyb20gPT09IGFkZHJlc3MpO1xuICAgICAgbm9uY2UgPSBvdXRnb2luZ1R4cy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBub25jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBmdW5kcyByZWNvdmVyeSB0cmFuc2FjdGlvbiB3aXRob3V0IEJpdEdvXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy51c2VyS2V5IHtTdHJpbmd9IFtlbmNyeXB0ZWRdIHhwcnZcbiAgICogQHBhcmFtIHBhcmFtcy5iYWNrdXBLZXkge1N0cmluZ30gW2VuY3J5cHRlZF0geHBydiBvciB4cHViIGlmIHRoZSB4cHJ2IGlzIGhlbGQgYnkgYSBLUlMgcHJvdmlkZXJcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlIHtTdHJpbmd9IHVzZWQgdG8gZGVjcnlwdCB1c2VyS2V5IGFuZCBiYWNrdXBLZXlcbiAgICogQHBhcmFtIHBhcmFtcy53YWxsZXRDb250cmFjdEFkZHJlc3Mge1N0cmluZ30gdGhlIEVUSCBhZGRyZXNzIG9mIHRoZSB3YWxsZXQgY29udHJhY3RcbiAgICogQHBhcmFtIHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIHtTdHJpbmd9IHRhcmdldCBhZGRyZXNzIHRvIHNlbmQgcmVjb3ZlcmVkIGZ1bmRzIHRvXG4gICAqL1xuICByZWNvdmVyKHBhcmFtczogUmVjb3Zlck9wdGlvbnMpOiBQcm9taXNlPFJlY292ZXJ5SW5mbyB8IE9mZmxpbmVWYXVsdFR4SW5mbz4ge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlciBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgcXVlcnkgdG8gRXRoZXJzY2FuIGZvciBpbmZvcm1hdGlvbiBzdWNoIGFzIGJhbGFuY2UsIHRva2VuIGJhbGFuY2UsIHNvbGlkaXR5IGNhbGxzXG4gICAqIEBwYXJhbSBxdWVyeSB7T2JqZWN0fSBrZXktdmFsdWUgcGFpcnMgb2YgcGFyYW1ldGVycyB0byBhcHBlbmQgYWZ0ZXIgL2FwaVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSByZXNwb25zZSBmcm9tIEV0aGVyc2NhblxuICAgKi9cbiAgYXN5bmMgcmVjb3ZlcnlCbG9ja2NoYWluRXhwbG9yZXJRdWVyeShxdWVyeTogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3QuZ2V0KGNvbW1vbi5FbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0uZXRoMkV4cGxvcmVyQmFzZVVybCkucXVlcnkocXVlcnkpO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhY2ggQmVhY29uU2NhbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBCTFMga2V5IHBhaXJcbiAgICpcbiAgICogQHBhcmFtIHNlZWQgLSBieXRlIGFycmF5IHRvIGdlbmVyYXRlIEJMUyBrZXkgcGFpciBmcm9tXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCB3aXRoIGdlbmVyYXRlZCBwdWIgYW5kIHBydlxuICAgKi9cbiAgZ2VuZXJhdGVLZXlQYWlyKHNlZWQ/OiBCdWZmZXIpOiBJQmxzS2V5UGFpciB7XG4gICAgbGV0IGtleVBhaXIgPSBuZXcgRXRoMktleVBhaXIoKTtcbiAgICBpZiAoc2VlZCAmJiBFdGgyS2V5UGFpci5pc1ZhbGlkUHJ2KHNlZWQpKSB7XG4gICAgICBjb25zdCBzZWVkU3RyID0gQnVmZmVyLmZyb20oc2VlZCkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAga2V5UGFpciA9IG5ldyBFdGgyS2V5UGFpcih7IHBydjogc2VlZFN0ciB9KTtcbiAgICB9IGVsc2UgaWYgKHNlZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIGdlbmVyYXRlIGtleXBhaXIgZnJvbSBpbnZhbGlkIHNlZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRLZXlzKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yjoga2V5cy5wdWJsaWNTaGFyZSxcbiAgICAgIHBydjoga2V5cy5wcnYgfHwgJycsXG4gICAgICBzZWNyZXRTaGFyZXM6IGtleXMuc2VjcmV0U2hhcmVzIHx8IFtdLFxuICAgICAgc2VlZDoga2V5cy5zZWVkLFxuICAgICAgY2hhaW5jb2RlOiBrZXlzLmNoYWluY29kZSB8fCAnJyxcbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFkZHJlc3NPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdGhyb3cgbmV3IE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxuXG4gIGFzeW5jIHZlcmlmeVRyYW5zYWN0aW9uKHBhcmFtczogVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiB7IHBydjogc3RyaW5nIH0sIG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgY29uc3Qga2V5UGFpciA9IG5ldyBFdGgyS2V5UGFpcih7IHBydjoga2V5LnBydiB9KTtcblxuICAgIGxldCBtZXNzYWdlVG9TaWduOiBCdWZmZXIgPSBCdWZmZXIuZnJvbShtZXNzYWdlKTtcbiAgICBpZiAoRXRoMktleVBhaXIuaXNWYWxpZFB1YihtZXNzYWdlKSkge1xuICAgICAgLy8gaWYgd2UgYXJlIGRvaW5nIGEga2V5IHNpZ25hdHVyZSwgd2Ugc2hvdWxkIGRlY29kZSB0aGUgbWVzc2FnZSBhcyBhIGhleCBzdHJpbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmUgQkctMzQ1Nzk6IGtub3duIGNvbXBhdGliaWxpdHkgaXNzdWUgd2l0aCBAdHlwZXMvZXRoZXJldW1qcy11dGlsXG4gICAgICBtZXNzYWdlVG9TaWduID0gQnVmZmVyLmZyb20oZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlKSwgJ2hleCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25lZE1lc3NhZ2UgPSBhd2FpdCBrZXlQYWlyLnNpZ24obWVzc2FnZVRvU2lnbik7XG4gICAgcmV0dXJuIGV0aFV0aWwudG9CdWZmZXIoc2lnbmVkTWVzc2FnZSk7XG4gIH1cblxuICBhZ2dyZWdhdGVTaGFyZXMoc2hhcmVzOiB7IHB1YlNoYXJlczogc3RyaW5nW107IHBydlNoYXJlczogc3RyaW5nW107IGNoYWluY29kZXM6IHN0cmluZ1tdIH0pOiBJQmxzS2V5UGFpciB7XG4gICAgY29uc3QgY29tbW9uUHViID0gRXRoMktleVBhaXIuYWdncmVnYXRlUHVia2V5cyhzaGFyZXMucHViU2hhcmVzKTtcbiAgICBjb25zdCBwcnYgPSBFdGgyS2V5UGFpci5hZ2dyZWdhdGVQcnZrZXlzKHNoYXJlcy5wcnZTaGFyZXMpO1xuICAgIGNvbnN0IGNvbW1vbkNoYWluY29kZSA9IEV0aDJLZXlQYWlyLmFnZ3JlZ2F0ZUNoYWluY29kZXMoc2hhcmVzLmNoYWluY29kZXMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YjogY29tbW9uUHViLFxuICAgICAgcHJ2LFxuICAgICAgc2VjcmV0U2hhcmVzOiBzaGFyZXMucHJ2U2hhcmVzLFxuICAgICAgY2hhaW5jb2RlOiBjb21tb25DaGFpbmNvZGUsXG4gICAgfTtcbiAgfVxufVxuIl19