"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dimensions = exports.OutputDimensions = exports.VirtualSizes = void 0;
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const utxo_lib_1 = require("@bitgo/utxo-lib");
const { isChainCode, scriptTypeForChain } = utxo_lib_1.bitgo;
const scriptSizes_1 = require("./scriptSizes");
const types_1 = require("./types");
const virtualSizes_1 = require("./virtualSizes");
Object.defineProperty(exports, "VirtualSizes", { enumerable: true, get: function () { return virtualSizes_1.VirtualSizes; } });
/**
 * Apply `f` to all properties of `d`
 */
function mapDimensions(d, f) {
    return new Dimensions(Object.fromEntries(Object.entries(d).map(([key, value]) => [key, f(key, value)])));
}
/**
 * Aggregate count and size of transaction outputs
 */
class OutputDimensions {
    constructor({ count = 0, size = 0 } = { count: 0, size: 0 }) {
        if (count === 0 || size === 0) {
            if (count !== 0 || size !== 0) {
                throw new Error(`count and size must both be zero if one is zero`);
            }
        }
        this.count = count;
        this.size = size;
        Object.freeze(this);
    }
}
exports.OutputDimensions = OutputDimensions;
const defaultUnspentParams = {
    p2tr: {
        scriptPathLevel: 1,
    },
    p2trMusig2: {
        // Default to script path spend, to make it easier for recovery case callers (WRW etc).
        // WP can explicitly pass undefined to use key path.
        scriptPathLevel: 1,
    },
};
/**
 * Dimensions of a BitGo wallet transactions.
 */
class Dimensions {
    constructor(d = {}) {
        /** Input counts for BitGo wallet multi-signature inputs */
        this.nP2shInputs = 0;
        this.nP2shP2wshInputs = 0;
        this.nP2wshInputs = 0;
        this.nP2trKeypathInputs = 0;
        this.nP2trScriptPathLevel1Inputs = 0;
        this.nP2trScriptPathLevel2Inputs = 0;
        /* Input count for single-signature inputs (Replay Protection inputs) */
        this.nP2shP2pkInputs = 0;
        this.outputs = new OutputDimensions();
        Object.entries(d).forEach(([key, value]) => this.setProperty(key, value));
        Object.freeze(this);
    }
    setProperty(k, v) {
        switch (k) {
            case 'nP2shInputs':
            case 'nP2shP2wshInputs':
            case 'nP2wshInputs':
            case 'nP2trKeypathInputs':
            case 'nP2trScriptPathLevel1Inputs':
            case 'nP2trScriptPathLevel2Inputs':
            case 'nP2shP2pkInputs':
                if (typeof v !== 'number') {
                    throw new Error(`property ${k} must be number`);
                }
                if (!Number.isSafeInteger(v) || v < 0) {
                    throw new Error(`property ${k} must be zero or positive integer`);
                }
                break;
            case 'outputs':
                if (!(v instanceof OutputDimensions)) {
                    v = new OutputDimensions(v);
                }
                break;
            default:
                throw new Error(`unknown property ${k}`);
        }
        this[k] = v;
    }
    /**
     * @deprecated use ZERO
     * @return Dimensions for an empty transaction
     */
    static zero() {
        return this.ZERO;
    }
    /**
     * @param size
     * @return Dimensions for a single output with given size
     */
    static singleOutput(size) {
        return Dimensions.sum({ outputs: { count: 1, size } });
    }
    /**
     * @return Number of total inputs (p2sh + p2shP2wsh + p2wsh + p2tr)
     */
    get nInputs() {
        return (this.nP2shInputs +
            this.nP2shP2wshInputs +
            this.nP2wshInputs +
            this.nP2trKeypathInputs +
            this.nP2trScriptPathLevel1Inputs +
            this.nP2trScriptPathLevel2Inputs +
            this.nP2shP2pkInputs);
    }
    set nInputs(_) {
        throw new Error('read-only property nInputs');
    }
    /**
     * @return Number of total outputs
     */
    get nOutputs() {
        return this.outputs.count;
    }
    set nOutputs(_) {
        throw new Error(`read-only property nOutputs`);
    }
    /**
     * @param args - Dimensions (can be partially defined)
     * @return {Dimensions} sum of arguments
     */
    static sum(...args) {
        return args.reduce((a, b) => a.plus(b), new Dimensions());
    }
    /**
     * @param chain
     * @return {Number}
     */
    static getOutputScriptLengthForChain(chain) {
        switch (scriptTypeForChain(chain)) {
            case 'p2wsh':
            case 'p2tr':
            case 'p2trMusig2':
                return 34;
            default:
                return 23;
        }
    }
    /**
     * @param scriptLength
     * @return {Number} vSize of an output with script length
     */
    static getVSizeForOutputWithScriptLength(scriptLength) {
        if (!types_1.PositiveInteger.is(scriptLength)) {
            throw new TypeError(`expected positive integer for scriptLength, got ${scriptLength}`);
        }
        return scriptLength + scriptSizes_1.compactSize(scriptLength) + virtualSizes_1.VirtualSizes.txOutputAmountSize;
    }
    /**
     * @return
     */
    static fromScriptType(scriptType, params = {}) {
        switch (scriptType) {
            case 'p2sh':
            case 'p2shP2wsh':
            case 'p2wsh':
            case 'p2shP2pk':
                return Dimensions.SingleInput[scriptType];
            case 'p2tr':
            case 'taprootScriptPathSpend':
                switch (params.scriptPathLevel) {
                    case 1:
                        return Dimensions.SingleInput.p2trScriptPathLevel1;
                    case 2:
                        return Dimensions.SingleInput.p2trScriptPathLevel2;
                    default:
                        throw new Error(`unexpected script path level`);
                }
            case 'p2trMusig2':
                switch (params.scriptPathLevel) {
                    case undefined:
                        return Dimensions.SingleInput.p2trKeypath;
                    case 1:
                        return Dimensions.SingleInput.p2trScriptPathLevel1;
                    default:
                        throw new Error(`unexpected script path level`);
                }
            case 'taprootKeyPathSpend':
                return Dimensions.SingleInput.p2trKeypath;
            default:
                throw new Error(`unexpected scriptType ${scriptType}`);
        }
    }
    static getAssumedDimension(params = {}, index) {
        const { assumeUnsigned } = params;
        if (!assumeUnsigned) {
            throw new Error(`illegal input ${index}: empty script and assumeUnsigned not set`);
        }
        return assumeUnsigned;
    }
    /**
     * @param input - the transaction input to count
     * @param params
     *        [param.assumeUnsigned] - default type for unsigned input
     */
    static fromInput(input, params = {}) {
        var _a, _b;
        if (((_a = input.script) === null || _a === void 0 ? void 0 : _a.length) || ((_b = input.witness) === null || _b === void 0 ? void 0 : _b.length)) {
            const parsed = utxolib.bitgo.parseSignatureScript(input);
            return Dimensions.fromScriptType(parsed.scriptType, parsed);
        }
        return Dimensions.getAssumedDimension(params, input.index);
    }
    /**
     * Create Dimensions from psbt input
     * @param input - psbt input
     */
    static fromPsbtInput(input) {
        const parsed = utxo_lib_1.bitgo.parsePsbtInput(input);
        return Dimensions.fromScriptType(parsed.scriptType, parsed);
    }
    /**
     * @param inputs - Array of inputs
     * @param params - @see Dimensions.fromInput()
     * @return {Dimensions} sum of the dimensions for each input (@see Dimensions.fromInput())
     */
    static fromInputs(inputs, params) {
        if (!Array.isArray(inputs)) {
            throw new TypeError(`inputs must be array`);
        }
        return Dimensions.sum(...inputs.map((i) => Dimensions.fromInput(i, params)));
    }
    /**
     * Create Dimensions from multiple psbt inputs
     * @param inputs psbt input array
     * @return {Dimensions} sum of the dimensions for each input (@see Dimensions.fromPsbtInput())
     */
    static fromPsbtInputs(inputs) {
        if (!Array.isArray(inputs)) {
            throw new TypeError(`inputs must be array`);
        }
        return Dimensions.sum(...inputs.map((input, _) => Dimensions.fromPsbtInput(input)));
    }
    /**
     * @param scriptLength {number} - size of the output script in bytes
     * @return {Dimensions} - Dimensions of the output
     */
    static fromOutputScriptLength(scriptLength) {
        return Dimensions.sum({
            outputs: {
                count: 1,
                size: Dimensions.getVSizeForOutputWithScriptLength(scriptLength),
            },
        });
    }
    /**
     * @param output - a tx output
     * @return Dimensions - the dimensions of the given output
     */
    static fromOutput({ script }) {
        if (!script) {
            throw new Error('expected output script to be defined');
        }
        if (!Buffer.isBuffer(script)) {
            throw new TypeError('expected script to be buffer, got ' + typeof script);
        }
        return Dimensions.fromOutputScriptLength(script.length);
    }
    /**
     * @param outputs - Array of outputs
     * @return {Dimensions} sum of the dimensions for each output (@see Dimensions.fromOutput())
     */
    static fromOutputs(outputs) {
        if (!Array.isArray(outputs)) {
            throw new TypeError(`outputs must be array`);
        }
        return Dimensions.sum(...outputs.map(Dimensions.fromOutput));
    }
    /**
     * Returns the dimensions of an output that will be created on a specific chain.
     * Currently, this simply adds a default output.
     *
     * @param chain - Chain code as defined by utxolib.bitgo
     * @return {Dimensions} - Dimensions for a single output on the given chain.
     */
    static fromOutputOnChain(chain) {
        return Dimensions.fromOutputScriptLength(Dimensions.getOutputScriptLengthForChain(chain));
    }
    /**
     * Return dimensions of an unspent according to `chain` parameter
     * @param chain - Chain code as defined by utxo.chain
     * @param params - Hint for unspents with variable input sizes (p2tr).
     * @return {Dimensions} of the unspent
     * @throws if the chain code is invalid or unsupported
     */
    static fromUnspent({ chain }, params = defaultUnspentParams) {
        if (!isChainCode(chain)) {
            throw new TypeError('invalid chain code');
        }
        const scriptType = scriptTypeForChain(chain);
        return Dimensions.fromScriptType(scriptType, scriptType === 'p2tr' ? params.p2tr : scriptType === 'p2trMusig2' ? params.p2trMusig2 : {});
    }
    /**
     * @param unspents
     * @return {Dimensions} sum of the dimensions for each unspent (@see Dimensions.fromUnspent())
     */
    static fromUnspents(unspents) {
        if (!Array.isArray(unspents)) {
            throw new TypeError(`unspents must be array`);
        }
        // Convert the individual unspents into dimensions and sum them up
        return Dimensions.sum(...unspents.map((u) => Dimensions.fromUnspent(u)));
    }
    /**
     * @param transaction - bitcoin-like transaction
     * @param [param.assumeUnsigned] - default type for unsigned inputs
     * @return {Dimensions}
     */
    static fromTransaction({ ins, outs, }, params) {
        return Dimensions.fromInputs(ins, params).plus(Dimensions.fromOutputs(outs));
    }
    /**
     * Create Dimensions from psbt inputs and outputs
     * @param psbt
     * @return {Dimensions}
     */
    static fromPsbt(psbt) {
        return Dimensions.fromPsbtInputs(psbt.data.inputs).plus(Dimensions.fromOutputs(psbt.getUnsignedTx().outs));
    }
    /**
     * @param dimensions (can be partially defined)
     * @return new dimensions with argument added
     */
    plus(dimensions) {
        if (typeof dimensions !== 'object') {
            throw new TypeError(`expected argument to be object`);
        }
        if (!(dimensions instanceof Dimensions)) {
            dimensions = new Dimensions(dimensions);
        }
        // Catch instances where we try to initialize Dimensions from partial data using deprecated parameters
        // using only "nOutputs".
        if ('nOutputs' in dimensions) {
            if (!('outputs' in dimensions)) {
                throw new Error('deprecated partial addition: argument has key "nOutputs" but no "outputs"');
            }
            const { outputs, nOutputs } = dimensions;
            if (outputs.count !== nOutputs) {
                throw new Error('deprecated partial addition: inconsistent values for "nOutputs" and "outputs.count"');
            }
        }
        return mapDimensions(this, (key, v) => {
            var _a;
            const w = (_a = dimensions[key]) !== null && _a !== void 0 ? _a : Dimensions.ZERO[key];
            if (key === 'outputs') {
                const vOutputs = v;
                const wOutputs = w;
                return new OutputDimensions({
                    count: vOutputs.count + wOutputs.count,
                    size: vOutputs.size + wOutputs.size,
                });
            }
            return v + w;
        });
    }
    /**
     * Multiply dimensions by a given factor
     * @param factor - Positive integer
     * @return {Dimensions}
     */
    times(factor) {
        if (!types_1.PositiveInteger.is(factor)) {
            throw new TypeError(`expected factor to be positive integer`);
        }
        return mapDimensions(this, (key, value) => {
            if (key === 'outputs') {
                const vOutputs = value;
                return {
                    count: vOutputs.count * factor,
                    size: vOutputs.size * factor,
                };
            }
            return value * factor;
        });
    }
    /**
     * @return Number of total inputs (p2sh, p2shP2wsh and p2wsh)
     * @deprecated use `dimension.nInputs` instead
     */
    getNInputs() {
        return this.nInputs;
    }
    /**
     * @returns {boolean} true iff dimensions have one or more (p2sh)p2wsh inputs
     */
    isSegwit() {
        return (this.nP2wshInputs +
            this.nP2shP2wshInputs +
            this.nP2trKeypathInputs +
            this.nP2trScriptPathLevel1Inputs +
            this.nP2trScriptPathLevel2Inputs >
            0);
    }
    /**
     * @return {Number} overhead vsize, based on result isSegwit().
     */
    getOverheadVSize() {
        return this.isSegwit() ? virtualSizes_1.VirtualSizes.txSegOverheadVSize : virtualSizes_1.VirtualSizes.txOverheadSize;
    }
    /**
     * @returns {number} vsize of inputs, without transaction overhead
     */
    getInputsVSize() {
        const { txP2shInputSize, txP2shP2wshInputSize, txP2wshInputSize, txP2trKeypathInputSize, txP2trScriptPathLevel1InputSize, txP2trScriptPathLevel2InputSize, txP2shP2pkInputSize, } = virtualSizes_1.VirtualSizes;
        const { nP2shInputs, nP2shP2wshInputs, nP2wshInputs, nP2trKeypathInputs, nP2trScriptPathLevel1Inputs, nP2trScriptPathLevel2Inputs, nP2shP2pkInputs, } = this;
        const size = nP2shInputs * txP2shInputSize +
            nP2shP2wshInputs * txP2shP2wshInputSize +
            nP2wshInputs * txP2wshInputSize +
            nP2trKeypathInputs * txP2trKeypathInputSize +
            nP2shP2pkInputs * txP2shP2pkInputSize +
            nP2trScriptPathLevel1Inputs * txP2trScriptPathLevel1InputSize +
            nP2trScriptPathLevel2Inputs * txP2trScriptPathLevel2InputSize;
        if (Number.isNaN(size)) {
            throw new Error(`invalid size`);
        }
        return size;
    }
    /**
     * @returns {number} return vsize of outputs, without overhead
     */
    getOutputsVSize() {
        return this.outputs.size;
    }
    /**
     * Estimates the virtual size (1/4 weight) of a signed transaction as sum of
     * overhead vsize, input vsize and output vsize.
     * @returns {Number} The estimated vsize of the transaction dimensions.
     */
    getVSize() {
        return this.getOverheadVSize() + this.getInputsVSize() + this.getOutputsVSize();
    }
}
exports.Dimensions = Dimensions;
Dimensions.ZERO = Object.freeze(new Dimensions());
Dimensions.SingleOutput = Object.freeze({
    p2sh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2shOutputSize),
    p2shP2wsh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2shP2wshOutputSize),
    p2wsh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2wshOutputSize),
    p2tr: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2trOutputSize),
    p2pkh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2pkhOutputSize),
    p2wpkh: Dimensions.singleOutput(virtualSizes_1.VirtualSizes.txP2wpkhOutputSize),
});
Dimensions.SingleInput = Object.freeze({
    p2sh: Dimensions.sum({ nP2shInputs: 1 }),
    p2shP2wsh: Dimensions.sum({ nP2shP2wshInputs: 1 }),
    p2wsh: Dimensions.sum({ nP2wshInputs: 1 }),
    p2trKeypath: Dimensions.sum({ nP2trKeypathInputs: 1 }),
    p2trScriptPathLevel1: Dimensions.sum({ nP2trScriptPathLevel1Inputs: 1 }),
    p2trScriptPathLevel2: Dimensions.sum({ nP2trScriptPathLevel2Inputs: 1 }),
    p2shP2pk: Dimensions.sum({ nP2shP2pkInputs: 1 }),
});
Dimensions.ASSUME_P2SH = Dimensions.SingleInput.p2sh;
Dimensions.ASSUME_P2SH_P2WSH = Dimensions.SingleInput.p2shP2wsh;
Dimensions.ASSUME_P2WSH = Dimensions.SingleInput.p2wsh;
Dimensions.ASSUME_P2TR_KEYPATH = Dimensions.SingleInput.p2trKeypath;
Dimensions.ASSUME_P2TR_SCRIPTPATH_LEVEL1 = Dimensions.SingleInput.p2trScriptPathLevel1;
Dimensions.ASSUME_P2TR_SCRIPTPATH_LEVEL2 = Dimensions.SingleInput.p2trScriptPathLevel2;
Dimensions.ASSUME_P2SH_P2PK_INPUT = Dimensions.SingleInput.p2shP2pk;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGltZW5zaW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kaW1lbnNpb25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSx5REFBMkM7QUFDM0MsOENBQXdDO0FBQ3hDLE1BQU0sRUFBRSxXQUFXLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxnQkFBSyxDQUFDO0FBR2xELCtDQUE0QztBQUM1QyxtQ0FBMEM7QUFFMUMsaURBQThDO0FBQ3JDLDZGQURBLDJCQUFZLE9BQ0E7QUFFckI7O0dBRUc7QUFDSCxTQUFTLGFBQWEsQ0FDcEIsQ0FBc0IsRUFDdEIsQ0FBZ0Y7SUFFaEYsT0FBTyxJQUFJLFVBQVUsQ0FDbkIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBdUIsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDdEcsQ0FBQztBQUNKLENBQUM7QUFFRDs7R0FFRztBQUNILE1BQWEsZ0JBQWdCO0lBVTNCLFlBQVksRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxDQUFDLEtBQXVCLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFO1FBQzNFLElBQUksS0FBSyxLQUFLLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO1lBQzdCLElBQUksS0FBSyxLQUFLLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxFQUFFO2dCQUM3QixNQUFNLElBQUksS0FBSyxDQUFDLGlEQUFpRCxDQUFDLENBQUM7YUFDcEU7U0FDRjtRQUVELElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxD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LFdBQVcsRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUN4QyxTQUFTLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLGdCQUFnQixFQUFFLENBQUMsRUFBRSxDQUFDO0lBQ2xELEtBQUssRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxDQUFDO0lBQzFDLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDdEQsb0JBQW9CLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLDJCQUEyQixFQUFFLENBQUMsRUFBRSxDQUFDO0lBQ3hFLG9CQUFvQixFQUFFLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSwyQkFBMkIsRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUN4RSxRQUFRLEVBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLGVBQWUsRUFBRSxDQUFDLEVBQUUsQ0FBQztDQUNqRCxDQUFDLENBQUM7QUEyQ2Esc0JBQVcsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztBQUMxQyw0QkFBaUIsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQztBQUNyRCx1QkFBWSxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO0FBQzVDLDhCQUFtQixHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDO0FBQ3pELHdDQUE2QixHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsb0JBQW9CLENBQUM7QUFDNUUsd0NBQTZCLEdBQUcsVUFBVSxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQztBQUM1RSxpQ0FBc0IsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHV0eG9saWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IGJpdGdvIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmNvbnN0IHsgaXNDaGFpbkNvZGUsIHNjcmlwdFR5cGVGb3JDaGFpbiB9ID0gYml0Z287XG50eXBlIENoYWluQ29kZSA9IGJpdGdvLkNoYWluQ29kZTtcblxuaW1wb3J0IHsgY29tcGFjdFNpemUgfSBmcm9tICcuL3NjcmlwdFNpemVzJztcbmltcG9ydCB7IFBvc2l0aXZlSW50ZWdlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5pbXBvcnQgeyBWaXJ0dWFsU2l6ZXMgfSBmcm9tICcuL3ZpcnR1YWxTaXplcyc7XG5leHBvcnQgeyBWaXJ0dWFsU2l6ZXMgfTtcblxuLyoqXG4gKiBBcHBseSBgZmAgdG8gYWxsIHByb3BlcnRpZXMgb2YgYGRgXG4gKi9cbmZ1bmN0aW9uIG1hcERpbWVuc2lvbnMoXG4gIGQ6IFBhcnRpYWw8RGltZW5zaW9ucz4sXG4gIGY6IDxUIGV4dGVuZHMga2V5b2YgRGltZW5zaW9ucz4oa2V5OiBULCB2OiBEaW1lbnNpb25zW1RdIHwgdW5kZWZpbmVkKSA9PiB1bmtub3duXG4pOiBEaW1lbnNpb25zIHtcbiAgcmV0dXJuIG5ldyBEaW1lbnNpb25zKFxuICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhkKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgZihrZXkgYXMga2V5b2YgRGltZW5zaW9ucywgdmFsdWUpXSkpXG4gICk7XG59XG5cbi8qKlxuICogQWdncmVnYXRlIGNvdW50IGFuZCBzaXplIG9mIHRyYW5zYWN0aW9uIG91dHB1dHNcbiAqL1xuZXhwb3J0IGNsYXNzIE91dHB1dERpbWVuc2lvbnMge1xuICAvKipcbiAgICogTnVtYmVyIG9mIG91dHB1dHNcbiAgICovXG4gIGNvdW50OiBudW1iZXI7XG4gIC8qKlxuICAgKiBBZ2dyZWdhdGUgdlNpemVcbiAgICovXG4gIHNpemU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcih7IGNvdW50ID0gMCwgc2l6ZSA9IDAgfTogT3V0cHV0RGltZW5zaW9ucyA9IHsgY291bnQ6IDAsIHNpemU6IDAgfSkge1xuICAgIGlmIChjb3VudCA9PT0gMCB8fCBzaXplID09PSAwKSB7XG4gICAgICBpZiAoY291bnQgIT09IDAgfHwgc2l6ZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvdW50IGFuZCBzaXplIG11c3QgYm90aCBiZSB6ZXJvIGlmIG9uZSBpcyB6ZXJvYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG5cbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG59XG5cbmludGVyZmFjZSBGcm9tSW5wdXRQYXJhbXMge1xuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgaW5wdXQgdHlwZSBpcyBhbWJpZ3VvdXMsIHdlIG11c3QgcHJvdmlkZSBhIGhpbnQgYWJvdXQgc3BlbmQgc2NyaXB0IHR5cGUuXG4gIGFzc3VtZVVuc2lnbmVkPzogRGltZW5zaW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGcm9tVW5zcGVudFBhcmFtcyB7XG4gIHAydHI6IHtcbiAgICBzY3JpcHRQYXRoTGV2ZWw/OiBudW1iZXI7XG4gIH07XG4gIHAydHJNdXNpZzI6IHtcbiAgICBzY3JpcHRQYXRoTGV2ZWw/OiBudW1iZXI7XG4gIH07XG59XG5cbmNvbnN0IGRlZmF1bHRVbnNwZW50UGFyYW1zOiBGcm9tVW5zcGVudFBhcmFtcyA9IHtcbiAgcDJ0cjoge1xuICAgIHNjcmlwdFBhdGhMZXZlbDogMSxcbiAgfSxcbiAgcDJ0ck11c2lnMjoge1xuICAgIC8vIERlZmF1bHQgdG8gc2NyaXB0IHBhdGggc3BlbmQsIHRvIG1ha2UgaXQgZWFzaWVyIGZvciByZWNvdmVyeSBjYXNlIGNhbGxlcnMgKFdSVyBldGMpLlxuICAgIC8vIFdQIGNhbiBleHBsaWNpdGx5IHBhc3MgdW5kZWZpbmVkIHRvIHVzZSBrZXkgcGF0aC5cbiAgICBzY3JpcHRQYXRoTGV2ZWw6IDEsXG4gIH0sXG59O1xuXG4vKipcbiAqIERpbWVuc2lvbnMgb2YgYSBCaXRHbyB3YWxsZXQgdHJhbnNhY3Rpb25zLlxuICovXG5leHBvcnQgY2xhc3MgRGltZW5zaW9ucyB7XG4gIC8qKiBJbnB1dCBjb3VudHMgZm9yIEJpdEdvIHdhbGxldCBtdWx0aS1zaWduYXR1cmUgaW5wdXRzICovXG4gIHB1YmxpYyByZWFkb25seSBuUDJzaElucHV0czogbnVtYmVyID0gMDtcbiAgcHVibGljIHJlYWRvbmx5IG5QMnNoUDJ3c2hJbnB1dHM6IG51bWJlciA9IDA7XG4gIHB1YmxpYyByZWFkb25seSBuUDJ3c2hJbnB1dHM6IG51bWJlciA9IDA7XG4gIHB1YmxpYyByZWFkb25seSBuUDJ0cktleXBhdGhJbnB1dHM6IG51bWJlciA9IDA7XG4gIHB1YmxpYyByZWFkb25seSBuUDJ0clNjcmlwdFBhdGhMZXZlbDFJbnB1dHM6IG51bWJlciA9IDA7XG4gIHB1YmxpYyByZWFkb25seSBuUDJ0clNjcmlwdFBhdGhMZXZlbDJJbnB1dHM6IG51bWJlciA9IDA7XG5cbiAgLyogSW5wdXQgY291bnQgZm9yIHNpbmdsZS1zaWduYXR1cmUgaW5wdXRzIChSZXBsYXkgUHJvdGVjdGlvbiBpbnB1dHMpICovXG4gIHB1YmxpYyByZWFkb25seSBuUDJzaFAycGtJbnB1dHM6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIHJlYWRvbmx5IG91dHB1dHM6IE91dHB1dERpbWVuc2lvbnMgPSBuZXcgT3V0cHV0RGltZW5zaW9ucygpO1xuXG4gIGNvbnN0cnVjdG9yKGQ6IFBhcnRpYWw8RGltZW5zaW9ucz4gPSB7fSkge1xuICAgIE9iamVjdC5lbnRyaWVzKGQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4gdGhpcy5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKSk7XG5cbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRQcm9wZXJ0eShrOiBzdHJpbmcsIHY6IHVua25vd24pOiB2b2lkIHtcbiAgICBzd2l0Y2ggKGspIHtcbiAgICAgIGNhc2UgJ25QMnNoSW5wdXRzJzpcbiAgICAgIGNhc2UgJ25QMnNoUDJ3c2hJbnB1dHMnOlxuICAgICAgY2FzZSAnblAyd3NoSW5wdXRzJzpcbiAgICAgIGNhc2UgJ25QMnRyS2V5cGF0aElucHV0cyc6XG4gICAgICBjYXNlICduUDJ0clNjcmlwdFBhdGhMZXZlbDFJbnB1dHMnOlxuICAgICAgY2FzZSAnblAydHJTY3JpcHRQYXRoTGV2ZWwySW5wdXRzJzpcbiAgICAgIGNhc2UgJ25QMnNoUDJwa0lucHV0cyc6XG4gICAgICAgIGlmICh0eXBlb2YgdiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByb3BlcnR5ICR7a30gbXVzdCBiZSBudW1iZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHYpIHx8IHYgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcm9wZXJ0eSAke2t9IG11c3QgYmUgemVybyBvciBwb3NpdGl2ZSBpbnRlZ2VyYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvdXRwdXRzJzpcbiAgICAgICAgaWYgKCEodiBpbnN0YW5jZW9mIE91dHB1dERpbWVuc2lvbnMpKSB7XG4gICAgICAgICAgdiA9IG5ldyBPdXRwdXREaW1lbnNpb25zKHYgYXMgT3V0cHV0RGltZW5zaW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gcHJvcGVydHkgJHtrfWApO1xuICAgIH1cblxuICAgICh0aGlzIGFzIGFueSlba10gPSB2O1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IFpFUk8gPSBPYmplY3QuZnJlZXplKG5ldyBEaW1lbnNpb25zKCkpO1xuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgWkVST1xuICAgKiBAcmV0dXJuIERpbWVuc2lvbnMgZm9yIGFuIGVtcHR5IHRyYW5zYWN0aW9uXG4gICAqL1xuICBzdGF0aWMgemVybygpOiBSZWFkb25seTxEaW1lbnNpb25zPiB7XG4gICAgcmV0dXJuIHRoaXMuWkVSTztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gc2l6ZVxuICAgKiBAcmV0dXJuIERpbWVuc2lvbnMgZm9yIGEgc2luZ2xlIG91dHB1dCB3aXRoIGdpdmVuIHNpemVcbiAgICovXG4gIHN0YXRpYyBzaW5nbGVPdXRwdXQoc2l6ZTogbnVtYmVyKTogRGltZW5zaW9ucyB7XG4gICAgcmV0dXJuIERpbWVuc2lvbnMuc3VtKHsgb3V0cHV0czogeyBjb3VudDogMSwgc2l6ZSB9IH0pO1xuICB9XG5cbiAgc3RhdGljIHJlYWRvbmx5IFNpbmdsZU91dHB1dCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHAyc2g6IERpbWVuc2lvbnMuc2luZ2xlT3V0cHV0KFZpcnR1YWxTaXplcy50eFAyc2hPdXRwdXRTaXplKSxcbiAgICBwMnNoUDJ3c2g6IERpbWVuc2lvbnMuc2luZ2xlT3V0cHV0KFZpcnR1YWxTaXplcy50eFAyc2hQMndzaE91dHB1dFNpemUpLFxuICAgIHAyd3NoOiBEaW1lbnNpb25zLnNpbmdsZU91dHB1dChWaXJ0dWFsU2l6ZXMudHhQMndzaE91dHB1dFNpemUpLFxuICAgIHAydHI6IERpbWVuc2lvbnMuc2luZ2xlT3V0cHV0KFZpcnR1YWxTaXplcy50eFAydHJPdXRwdXRTaXplKSxcblxuICAgIHAycGtoOiBEaW1lbnNpb25zLnNpbmdsZU91dHB1dChWaXJ0dWFsU2l6ZXMudHhQMnBraE91dHB1dFNpemUpLFxuICAgIHAyd3BraDogRGltZW5zaW9ucy5zaW5nbGVPdXRwdXQoVmlydHVhbFNpemVzLnR4UDJ3cGtoT3V0cHV0U2l6ZSksXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIE51bWJlciBvZiB0b3RhbCBpbnB1dHMgKHAyc2ggKyBwMnNoUDJ3c2ggKyBwMndzaCArIHAydHIpXG4gICAqL1xuICBnZXQgbklucHV0cygpOiBudW1iZXIge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm5QMnNoSW5wdXRzICtcbiAgICAgIHRoaXMublAyc2hQMndzaElucHV0cyArXG4gICAgICB0aGlzLm5QMndzaElucHV0cyArXG4gICAgICB0aGlzLm5QMnRyS2V5cGF0aElucHV0cyArXG4gICAgICB0aGlzLm5QMnRyU2NyaXB0UGF0aExldmVsMUlucHV0cyArXG4gICAgICB0aGlzLm5QMnRyU2NyaXB0UGF0aExldmVsMklucHV0cyArXG4gICAgICB0aGlzLm5QMnNoUDJwa0lucHV0c1xuICAgICk7XG4gIH1cblxuICBzZXQgbklucHV0cyhfOiBudW1iZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlYWQtb25seSBwcm9wZXJ0eSBuSW5wdXRzJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiBOdW1iZXIgb2YgdG90YWwgb3V0cHV0c1xuICAgKi9cbiAgZ2V0IG5PdXRwdXRzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0cy5jb3VudDtcbiAgfVxuXG4gIHNldCBuT3V0cHV0cyhfOiBudW1iZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHJlYWQtb25seSBwcm9wZXJ0eSBuT3V0cHV0c2ApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhcmdzIC0gRGltZW5zaW9ucyAoY2FuIGJlIHBhcnRpYWxseSBkZWZpbmVkKVxuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfSBzdW0gb2YgYXJndW1lbnRzXG4gICAqL1xuICBzdGF0aWMgc3VtKC4uLmFyZ3M6IFBhcnRpYWw8RGltZW5zaW9ucz5bXSk6IERpbWVuc2lvbnMge1xuICAgIHJldHVybiBhcmdzLnJlZHVjZSgoYTogRGltZW5zaW9ucywgYjogUGFydGlhbDxEaW1lbnNpb25zPikgPT4gYS5wbHVzKGIpLCBuZXcgRGltZW5zaW9ucygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gY2hhaW5cbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIGdldE91dHB1dFNjcmlwdExlbmd0aEZvckNoYWluKGNoYWluOiBDaGFpbkNvZGUpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoc2NyaXB0VHlwZUZvckNoYWluKGNoYWluKSkge1xuICAgICAgY2FzZSAncDJ3c2gnOlxuICAgICAgY2FzZSAncDJ0cic6XG4gICAgICBjYXNlICdwMnRyTXVzaWcyJzpcbiAgICAgICAgcmV0dXJuIDM0O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIDIzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gc2NyaXB0TGVuZ3RoXG4gICAqIEByZXR1cm4ge051bWJlcn0gdlNpemUgb2YgYW4gb3V0cHV0IHdpdGggc2NyaXB0IGxlbmd0aFxuICAgKi9cbiAgc3RhdGljIGdldFZTaXplRm9yT3V0cHV0V2l0aFNjcmlwdExlbmd0aChzY3JpcHRMZW5ndGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKCFQb3NpdGl2ZUludGVnZXIuaXMoc2NyaXB0TGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlciBmb3Igc2NyaXB0TGVuZ3RoLCBnb3QgJHtzY3JpcHRMZW5ndGh9YCk7XG4gICAgfVxuICAgIHJldHVybiBzY3JpcHRMZW5ndGggKyBjb21wYWN0U2l6ZShzY3JpcHRMZW5ndGgpICsgVmlydHVhbFNpemVzLnR4T3V0cHV0QW1vdW50U2l6ZTtcbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBTaW5nbGVJbnB1dCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHAyc2g6IERpbWVuc2lvbnMuc3VtKHsgblAyc2hJbnB1dHM6IDEgfSksXG4gICAgcDJzaFAyd3NoOiBEaW1lbnNpb25zLnN1bSh7IG5QMnNoUDJ3c2hJbnB1dHM6IDEgfSksXG4gICAgcDJ3c2g6IERpbWVuc2lvbnMuc3VtKHsgblAyd3NoSW5wdXRzOiAxIH0pLFxuICAgIHAydHJLZXlwYXRoOiBEaW1lbnNpb25zLnN1bSh7IG5QMnRyS2V5cGF0aElucHV0czogMSB9KSxcbiAgICBwMnRyU2NyaXB0UGF0aExldmVsMTogRGltZW5zaW9ucy5zdW0oeyBuUDJ0clNjcmlwdFBhdGhMZXZlbDFJbnB1dHM6IDEgfSksXG4gICAgcDJ0clNjcmlwdFBhdGhMZXZlbDI6IERpbWVuc2lvbnMuc3VtKHsgblAydHJTY3JpcHRQYXRoTGV2ZWwySW5wdXRzOiAxIH0pLFxuICAgIHAyc2hQMnBrOiBEaW1lbnNpb25zLnN1bSh7IG5QMnNoUDJwa0lucHV0czogMSB9KSxcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm5cbiAgICovXG4gIHN0YXRpYyBmcm9tU2NyaXB0VHlwZShcbiAgICBzY3JpcHRUeXBlOiB1dHhvbGliLmJpdGdvLm91dHB1dFNjcmlwdHMuU2NyaXB0VHlwZSB8IHV0eG9saWIuYml0Z28uUGFyc2VkU2NyaXB0VHlwZTJPZjMgfCAncDJwa2gnLFxuICAgIHBhcmFtczoge1xuICAgICAgc2NyaXB0UGF0aExldmVsPzogbnVtYmVyO1xuICAgIH0gPSB7fVxuICApOiBEaW1lbnNpb25zIHtcbiAgICBzd2l0Y2ggKHNjcmlwdFR5cGUpIHtcbiAgICAgIGNhc2UgJ3Ayc2gnOlxuICAgICAgY2FzZSAncDJzaFAyd3NoJzpcbiAgICAgIGNhc2UgJ3Ayd3NoJzpcbiAgICAgIGNhc2UgJ3Ayc2hQMnBrJzpcbiAgICAgICAgcmV0dXJuIERpbWVuc2lvbnMuU2luZ2xlSW5wdXRbc2NyaXB0VHlwZV07XG4gICAgICBjYXNlICdwMnRyJzpcbiAgICAgIGNhc2UgJ3RhcHJvb3RTY3JpcHRQYXRoU3BlbmQnOlxuICAgICAgICBzd2l0Y2ggKHBhcmFtcy5zY3JpcHRQYXRoTGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gRGltZW5zaW9ucy5TaW5nbGVJbnB1dC5wMnRyU2NyaXB0UGF0aExldmVsMTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gRGltZW5zaW9ucy5TaW5nbGVJbnB1dC5wMnRyU2NyaXB0UGF0aExldmVsMjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHNjcmlwdCBwYXRoIGxldmVsYCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3AydHJNdXNpZzInOlxuICAgICAgICBzd2l0Y2ggKHBhcmFtcy5zY3JpcHRQYXRoTGV2ZWwpIHtcbiAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBEaW1lbnNpb25zLlNpbmdsZUlucHV0LnAydHJLZXlwYXRoO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBEaW1lbnNpb25zLlNpbmdsZUlucHV0LnAydHJTY3JpcHRQYXRoTGV2ZWwxO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgc2NyaXB0IHBhdGggbGV2ZWxgKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAndGFwcm9vdEtleVBhdGhTcGVuZCc6XG4gICAgICAgIHJldHVybiBEaW1lbnNpb25zLlNpbmdsZUlucHV0LnAydHJLZXlwYXRoO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIHNjcmlwdFR5cGUgJHtzY3JpcHRUeXBlfWApO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyByZWFkb25seSBBU1NVTUVfUDJTSCA9IERpbWVuc2lvbnMuU2luZ2xlSW5wdXQucDJzaDtcbiAgc3RhdGljIHJlYWRvbmx5IEFTU1VNRV9QMlNIX1AyV1NIID0gRGltZW5zaW9ucy5TaW5nbGVJbnB1dC5wMnNoUDJ3c2g7XG4gIHN0YXRpYyByZWFkb25seSBBU1NVTUVfUDJXU0ggPSBEaW1lbnNpb25zLlNpbmdsZUlucHV0LnAyd3NoO1xuICBzdGF0aWMgcmVhZG9ubHkgQVNTVU1FX1AyVFJfS0VZUEFUSCA9IERpbWVuc2lvbnMuU2luZ2xlSW5wdXQucDJ0cktleXBhdGg7XG4gIHN0YXRpYyByZWFkb25seSBBU1NVTUVfUDJUUl9TQ1JJUFRQQVRIX0xFVkVMMSA9IERpbWVuc2lvbnMuU2luZ2xlSW5wdXQucDJ0clNjcmlwdFBhdGhMZXZlbDE7XG4gIHN0YXRpYyByZWFkb25seSBBU1NVTUVfUDJUUl9TQ1JJUFRQQVRIX0xFVkVMMiA9IERpbWVuc2lvbnMuU2luZ2xlSW5wdXQucDJ0clNjcmlwdFBhdGhMZXZlbDI7XG4gIHN0YXRpYyByZWFkb25seSBBU1NVTUVfUDJTSF9QMlBLX0lOUFVUID0gRGltZW5zaW9ucy5TaW5nbGVJbnB1dC5wMnNoUDJwaztcblxuICBwcml2YXRlIHN0YXRpYyBnZXRBc3N1bWVkRGltZW5zaW9uKHBhcmFtczogRnJvbUlucHV0UGFyYW1zID0ge30sIGluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCB7IGFzc3VtZVVuc2lnbmVkIH0gPSBwYXJhbXM7XG4gICAgaWYgKCFhc3N1bWVVbnNpZ25lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbGxlZ2FsIGlucHV0ICR7aW5kZXh9OiBlbXB0eSBzY3JpcHQgYW5kIGFzc3VtZVVuc2lnbmVkIG5vdCBzZXRgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFzc3VtZVVuc2lnbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBpbnB1dCAtIHRoZSB0cmFuc2FjdGlvbiBpbnB1dCB0byBjb3VudFxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqICAgICAgICBbcGFyYW0uYXNzdW1lVW5zaWduZWRdIC0gZGVmYXVsdCB0eXBlIGZvciB1bnNpZ25lZCBpbnB1dFxuICAgKi9cbiAgc3RhdGljIGZyb21JbnB1dChpbnB1dDogdXR4b2xpYi5UeElucHV0LCBwYXJhbXM6IEZyb21JbnB1dFBhcmFtcyA9IHt9KTogRGltZW5zaW9ucyB7XG4gICAgaWYgKGlucHV0LnNjcmlwdD8ubGVuZ3RoIHx8IGlucHV0LndpdG5lc3M/Lmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyc2VkID0gdXR4b2xpYi5iaXRnby5wYXJzZVNpZ25hdHVyZVNjcmlwdChpbnB1dCk7XG4gICAgICByZXR1cm4gRGltZW5zaW9ucy5mcm9tU2NyaXB0VHlwZShwYXJzZWQuc2NyaXB0VHlwZSwgcGFyc2VkIGFzIHsgc2NyaXB0UGF0aExldmVsPzogbnVtYmVyIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBEaW1lbnNpb25zLmdldEFzc3VtZWREaW1lbnNpb24ocGFyYW1zLCBpbnB1dC5pbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIERpbWVuc2lvbnMgZnJvbSBwc2J0IGlucHV0XG4gICAqIEBwYXJhbSBpbnB1dCAtIHBzYnQgaW5wdXRcbiAgICovXG4gIHN0YXRpYyBmcm9tUHNidElucHV0KGlucHV0OiBiaXRnby5Qc2J0SW5wdXRUeXBlKTogRGltZW5zaW9ucyB7XG4gICAgY29uc3QgcGFyc2VkID0gYml0Z28ucGFyc2VQc2J0SW5wdXQoaW5wdXQpO1xuICAgIHJldHVybiBEaW1lbnNpb25zLmZyb21TY3JpcHRUeXBlKHBhcnNlZC5zY3JpcHRUeXBlLCBwYXJzZWQgYXMgeyBzY3JpcHRQYXRoTGV2ZWw/OiBudW1iZXIgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGlucHV0cyAtIEFycmF5IG9mIGlucHV0c1xuICAgKiBAcGFyYW0gcGFyYW1zIC0gQHNlZSBEaW1lbnNpb25zLmZyb21JbnB1dCgpXG4gICAqIEByZXR1cm4ge0RpbWVuc2lvbnN9IHN1bSBvZiB0aGUgZGltZW5zaW9ucyBmb3IgZWFjaCBpbnB1dCAoQHNlZSBEaW1lbnNpb25zLmZyb21JbnB1dCgpKVxuICAgKi9cbiAgc3RhdGljIGZyb21JbnB1dHMoaW5wdXRzOiB1dHhvbGliLlR4SW5wdXRbXSwgcGFyYW1zPzogRnJvbUlucHV0UGFyYW1zKTogRGltZW5zaW9ucyB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGlucHV0cyBtdXN0IGJlIGFycmF5YCk7XG4gICAgfVxuICAgIHJldHVybiBEaW1lbnNpb25zLnN1bSguLi5pbnB1dHMubWFwKChpKSA9PiBEaW1lbnNpb25zLmZyb21JbnB1dChpLCBwYXJhbXMpKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIERpbWVuc2lvbnMgZnJvbSBtdWx0aXBsZSBwc2J0IGlucHV0c1xuICAgKiBAcGFyYW0gaW5wdXRzIHBzYnQgaW5wdXQgYXJyYXlcbiAgICogQHJldHVybiB7RGltZW5zaW9uc30gc3VtIG9mIHRoZSBkaW1lbnNpb25zIGZvciBlYWNoIGlucHV0IChAc2VlIERpbWVuc2lvbnMuZnJvbVBzYnRJbnB1dCgpKVxuICAgKi9cbiAgc3RhdGljIGZyb21Qc2J0SW5wdXRzKGlucHV0czogYml0Z28uUHNidElucHV0VHlwZVtdKTogRGltZW5zaW9ucyB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGlucHV0cyBtdXN0IGJlIGFycmF5YCk7XG4gICAgfVxuICAgIHJldHVybiBEaW1lbnNpb25zLnN1bSguLi5pbnB1dHMubWFwKChpbnB1dCwgXykgPT4gRGltZW5zaW9ucy5mcm9tUHNidElucHV0KGlucHV0KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBzY3JpcHRMZW5ndGgge251bWJlcn0gLSBzaXplIG9mIHRoZSBvdXRwdXQgc2NyaXB0IGluIGJ5dGVzXG4gICAqIEByZXR1cm4ge0RpbWVuc2lvbnN9IC0gRGltZW5zaW9ucyBvZiB0aGUgb3V0cHV0XG4gICAqL1xuICBzdGF0aWMgZnJvbU91dHB1dFNjcmlwdExlbmd0aChzY3JpcHRMZW5ndGg6IG51bWJlcik6IERpbWVuc2lvbnMge1xuICAgIHJldHVybiBEaW1lbnNpb25zLnN1bSh7XG4gICAgICBvdXRwdXRzOiB7XG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICBzaXplOiBEaW1lbnNpb25zLmdldFZTaXplRm9yT3V0cHV0V2l0aFNjcmlwdExlbmd0aChzY3JpcHRMZW5ndGgpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gb3V0cHV0IC0gYSB0eCBvdXRwdXRcbiAgICogQHJldHVybiBEaW1lbnNpb25zIC0gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGdpdmVuIG91dHB1dFxuICAgKi9cbiAgc3RhdGljIGZyb21PdXRwdXQoeyBzY3JpcHQgfTogeyBzY3JpcHQ6IEJ1ZmZlciB9KTogRGltZW5zaW9ucyB7XG4gICAgaWYgKCFzY3JpcHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgb3V0cHV0IHNjcmlwdCB0byBiZSBkZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHNjcmlwdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIHNjcmlwdCB0byBiZSBidWZmZXIsIGdvdCAnICsgdHlwZW9mIHNjcmlwdCk7XG4gICAgfVxuICAgIHJldHVybiBEaW1lbnNpb25zLmZyb21PdXRwdXRTY3JpcHRMZW5ndGgoc2NyaXB0Lmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIG91dHB1dHMgLSBBcnJheSBvZiBvdXRwdXRzXG4gICAqIEByZXR1cm4ge0RpbWVuc2lvbnN9IHN1bSBvZiB0aGUgZGltZW5zaW9ucyBmb3IgZWFjaCBvdXRwdXQgKEBzZWUgRGltZW5zaW9ucy5mcm9tT3V0cHV0KCkpXG4gICAqL1xuICBzdGF0aWMgZnJvbU91dHB1dHMob3V0cHV0czogeyBzY3JpcHQ6IEJ1ZmZlciB9W10pOiBEaW1lbnNpb25zIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob3V0cHV0cykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG91dHB1dHMgbXVzdCBiZSBhcnJheWApO1xuICAgIH1cbiAgICByZXR1cm4gRGltZW5zaW9ucy5zdW0oLi4ub3V0cHV0cy5tYXAoRGltZW5zaW9ucy5mcm9tT3V0cHV0KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiBhbiBvdXRwdXQgdGhhdCB3aWxsIGJlIGNyZWF0ZWQgb24gYSBzcGVjaWZpYyBjaGFpbi5cbiAgICogQ3VycmVudGx5LCB0aGlzIHNpbXBseSBhZGRzIGEgZGVmYXVsdCBvdXRwdXQuXG4gICAqXG4gICAqIEBwYXJhbSBjaGFpbiAtIENoYWluIGNvZGUgYXMgZGVmaW5lZCBieSB1dHhvbGliLmJpdGdvXG4gICAqIEByZXR1cm4ge0RpbWVuc2lvbnN9IC0gRGltZW5zaW9ucyBmb3IgYSBzaW5nbGUgb3V0cHV0IG9uIHRoZSBnaXZlbiBjaGFpbi5cbiAgICovXG4gIHN0YXRpYyBmcm9tT3V0cHV0T25DaGFpbihjaGFpbjogQ2hhaW5Db2RlKTogRGltZW5zaW9ucyB7XG4gICAgcmV0dXJuIERpbWVuc2lvbnMuZnJvbU91dHB1dFNjcmlwdExlbmd0aChEaW1lbnNpb25zLmdldE91dHB1dFNjcmlwdExlbmd0aEZvckNoYWluKGNoYWluKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGRpbWVuc2lvbnMgb2YgYW4gdW5zcGVudCBhY2NvcmRpbmcgdG8gYGNoYWluYCBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIGNoYWluIC0gQ2hhaW4gY29kZSBhcyBkZWZpbmVkIGJ5IHV0eG8uY2hhaW5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEhpbnQgZm9yIHVuc3BlbnRzIHdpdGggdmFyaWFibGUgaW5wdXQgc2l6ZXMgKHAydHIpLlxuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfSBvZiB0aGUgdW5zcGVudFxuICAgKiBAdGhyb3dzIGlmIHRoZSBjaGFpbiBjb2RlIGlzIGludmFsaWQgb3IgdW5zdXBwb3J0ZWRcbiAgICovXG4gIHN0YXRpYyBmcm9tVW5zcGVudCh7IGNoYWluIH06IHsgY2hhaW46IG51bWJlciB9LCBwYXJhbXM6IEZyb21VbnNwZW50UGFyYW1zID0gZGVmYXVsdFVuc3BlbnRQYXJhbXMpOiBEaW1lbnNpb25zIHtcbiAgICBpZiAoIWlzQ2hhaW5Db2RlKGNoYWluKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjaGFpbiBjb2RlJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NyaXB0VHlwZSA9IHNjcmlwdFR5cGVGb3JDaGFpbihjaGFpbik7XG5cbiAgICByZXR1cm4gRGltZW5zaW9ucy5mcm9tU2NyaXB0VHlwZShcbiAgICAgIHNjcmlwdFR5cGUsXG4gICAgICBzY3JpcHRUeXBlID09PSAncDJ0cicgPyBwYXJhbXMucDJ0ciA6IHNjcmlwdFR5cGUgPT09ICdwMnRyTXVzaWcyJyA/IHBhcmFtcy5wMnRyTXVzaWcyIDoge31cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB1bnNwZW50c1xuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfSBzdW0gb2YgdGhlIGRpbWVuc2lvbnMgZm9yIGVhY2ggdW5zcGVudCAoQHNlZSBEaW1lbnNpb25zLmZyb21VbnNwZW50KCkpXG4gICAqL1xuICBzdGF0aWMgZnJvbVVuc3BlbnRzKHVuc3BlbnRzOiB7IGNoYWluOiBDaGFpbkNvZGUgfVtdKTogRGltZW5zaW9ucyB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVuc3BlbnRzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zcGVudHMgbXVzdCBiZSBhcnJheWApO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBpbmRpdmlkdWFsIHVuc3BlbnRzIGludG8gZGltZW5zaW9ucyBhbmQgc3VtIHRoZW0gdXBcbiAgICByZXR1cm4gRGltZW5zaW9ucy5zdW0oLi4udW5zcGVudHMubWFwKCh1KSA9PiBEaW1lbnNpb25zLmZyb21VbnNwZW50KHUpKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gYml0Y29pbi1saWtlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBbcGFyYW0uYXNzdW1lVW5zaWduZWRdIC0gZGVmYXVsdCB0eXBlIGZvciB1bnNpZ25lZCBpbnB1dHNcbiAgICogQHJldHVybiB7RGltZW5zaW9uc31cbiAgICovXG4gIHN0YXRpYyBmcm9tVHJhbnNhY3Rpb24oXG4gICAge1xuICAgICAgaW5zLFxuICAgICAgb3V0cyxcbiAgICB9OiB7XG4gICAgICBpbnM6IHV0eG9saWIuVHhJbnB1dFtdO1xuICAgICAgb3V0czogdXR4b2xpYi5UeE91dHB1dFtdO1xuICAgIH0sXG4gICAgcGFyYW1zPzogRnJvbUlucHV0UGFyYW1zXG4gICk6IERpbWVuc2lvbnMge1xuICAgIHJldHVybiBEaW1lbnNpb25zLmZyb21JbnB1dHMoaW5zLCBwYXJhbXMpLnBsdXMoRGltZW5zaW9ucy5mcm9tT3V0cHV0cyhvdXRzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIERpbWVuc2lvbnMgZnJvbSBwc2J0IGlucHV0cyBhbmQgb3V0cHV0c1xuICAgKiBAcGFyYW0gcHNidFxuICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICAgKi9cbiAgc3RhdGljIGZyb21Qc2J0KHBzYnQ6IGJpdGdvLlV0eG9Qc2J0KTogRGltZW5zaW9ucyB7XG4gICAgcmV0dXJuIERpbWVuc2lvbnMuZnJvbVBzYnRJbnB1dHMocHNidC5kYXRhLmlucHV0cykucGx1cyhEaW1lbnNpb25zLmZyb21PdXRwdXRzKHBzYnQuZ2V0VW5zaWduZWRUeCgpLm91dHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gZGltZW5zaW9ucyAoY2FuIGJlIHBhcnRpYWxseSBkZWZpbmVkKVxuICAgKiBAcmV0dXJuIG5ldyBkaW1lbnNpb25zIHdpdGggYXJndW1lbnQgYWRkZWRcbiAgICovXG4gIHBsdXMoZGltZW5zaW9uczogUGFydGlhbDxEaW1lbnNpb25zPik6IERpbWVuc2lvbnMge1xuICAgIGlmICh0eXBlb2YgZGltZW5zaW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIG9iamVjdGApO1xuICAgIH1cblxuICAgIGlmICghKGRpbWVuc2lvbnMgaW5zdGFuY2VvZiBEaW1lbnNpb25zKSkge1xuICAgICAgZGltZW5zaW9ucyA9IG5ldyBEaW1lbnNpb25zKGRpbWVuc2lvbnMpO1xuICAgIH1cblxuICAgIC8vIENhdGNoIGluc3RhbmNlcyB3aGVyZSB3ZSB0cnkgdG8gaW5pdGlhbGl6ZSBEaW1lbnNpb25zIGZyb20gcGFydGlhbCBkYXRhIHVzaW5nIGRlcHJlY2F0ZWQgcGFyYW1ldGVyc1xuICAgIC8vIHVzaW5nIG9ubHkgXCJuT3V0cHV0c1wiLlxuICAgIGlmICgnbk91dHB1dHMnIGluIGRpbWVuc2lvbnMpIHtcbiAgICAgIGlmICghKCdvdXRwdXRzJyBpbiBkaW1lbnNpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlcHJlY2F0ZWQgcGFydGlhbCBhZGRpdGlvbjogYXJndW1lbnQgaGFzIGtleSBcIm5PdXRwdXRzXCIgYnV0IG5vIFwib3V0cHV0c1wiJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgb3V0cHV0cywgbk91dHB1dHMgfSA9IGRpbWVuc2lvbnMgYXMgRGltZW5zaW9ucztcblxuICAgICAgaWYgKG91dHB1dHMuY291bnQgIT09IG5PdXRwdXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVwcmVjYXRlZCBwYXJ0aWFsIGFkZGl0aW9uOiBpbmNvbnNpc3RlbnQgdmFsdWVzIGZvciBcIm5PdXRwdXRzXCIgYW5kIFwib3V0cHV0cy5jb3VudFwiJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcERpbWVuc2lvbnModGhpcywgKGtleSwgdikgPT4ge1xuICAgICAgY29uc3QgdyA9IGRpbWVuc2lvbnNba2V5XSA/PyBEaW1lbnNpb25zLlpFUk9ba2V5XTtcbiAgICAgIGlmIChrZXkgPT09ICdvdXRwdXRzJykge1xuICAgICAgICBjb25zdCB2T3V0cHV0cyA9IHYgYXMgT3V0cHV0RGltZW5zaW9ucztcbiAgICAgICAgY29uc3Qgd091dHB1dHMgPSB3IGFzIE91dHB1dERpbWVuc2lvbnM7XG4gICAgICAgIHJldHVybiBuZXcgT3V0cHV0RGltZW5zaW9ucyh7XG4gICAgICAgICAgY291bnQ6IHZPdXRwdXRzLmNvdW50ICsgd091dHB1dHMuY291bnQsXG4gICAgICAgICAgc2l6ZTogdk91dHB1dHMuc2l6ZSArIHdPdXRwdXRzLnNpemUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuICh2IGFzIG51bWJlcikgKyAodyBhcyBudW1iZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE11bHRpcGx5IGRpbWVuc2lvbnMgYnkgYSBnaXZlbiBmYWN0b3JcbiAgICogQHBhcmFtIGZhY3RvciAtIFBvc2l0aXZlIGludGVnZXJcbiAgICogQHJldHVybiB7RGltZW5zaW9uc31cbiAgICovXG4gIHRpbWVzKGZhY3RvcjogbnVtYmVyKTogRGltZW5zaW9ucyB7XG4gICAgaWYgKCFQb3NpdGl2ZUludGVnZXIuaXMoZmFjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgZmFjdG9yIHRvIGJlIHBvc2l0aXZlIGludGVnZXJgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwRGltZW5zaW9ucyh0aGlzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gJ291dHB1dHMnKSB7XG4gICAgICAgIGNvbnN0IHZPdXRwdXRzID0gdmFsdWUgYXMgT3V0cHV0RGltZW5zaW9ucztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb3VudDogdk91dHB1dHMuY291bnQgKiBmYWN0b3IsXG4gICAgICAgICAgc2l6ZTogdk91dHB1dHMuc2l6ZSAqIGZhY3RvcixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAodmFsdWUgYXMgbnVtYmVyKSAqIGZhY3RvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIE51bWJlciBvZiB0b3RhbCBpbnB1dHMgKHAyc2gsIHAyc2hQMndzaCBhbmQgcDJ3c2gpXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgZGltZW5zaW9uLm5JbnB1dHNgIGluc3RlYWRcbiAgICovXG4gIGdldE5JbnB1dHMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5uSW5wdXRzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmZiBkaW1lbnNpb25zIGhhdmUgb25lIG9yIG1vcmUgKHAyc2gpcDJ3c2ggaW5wdXRzXG4gICAqL1xuICBpc1NlZ3dpdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5uUDJ3c2hJbnB1dHMgK1xuICAgICAgICB0aGlzLm5QMnNoUDJ3c2hJbnB1dHMgK1xuICAgICAgICB0aGlzLm5QMnRyS2V5cGF0aElucHV0cyArXG4gICAgICAgIHRoaXMublAydHJTY3JpcHRQYXRoTGV2ZWwxSW5wdXRzICtcbiAgICAgICAgdGhpcy5uUDJ0clNjcmlwdFBhdGhMZXZlbDJJbnB1dHMgPlxuICAgICAgMFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfSBvdmVyaGVhZCB2c2l6ZSwgYmFzZWQgb24gcmVzdWx0IGlzU2Vnd2l0KCkuXG4gICAqL1xuICBnZXRPdmVyaGVhZFZTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaXNTZWd3aXQoKSA/IFZpcnR1YWxTaXplcy50eFNlZ092ZXJoZWFkVlNpemUgOiBWaXJ0dWFsU2l6ZXMudHhPdmVyaGVhZFNpemU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn0gdnNpemUgb2YgaW5wdXRzLCB3aXRob3V0IHRyYW5zYWN0aW9uIG92ZXJoZWFkXG4gICAqL1xuICBnZXRJbnB1dHNWU2l6ZSgpOiBudW1iZXIge1xuICAgIGNvbnN0IHtcbiAgICAgIHR4UDJzaElucHV0U2l6ZSxcbiAgICAgIHR4UDJzaFAyd3NoSW5wdXRTaXplLFxuICAgICAgdHhQMndzaElucHV0U2l6ZSxcbiAgICAgIHR4UDJ0cktleXBhdGhJbnB1dFNpemUsXG4gICAgICB0eFAydHJTY3JpcHRQYXRoTGV2ZWwxSW5wdXRTaXplLFxuICAgICAgdHhQMnRyU2NyaXB0UGF0aExldmVsMklucHV0U2l6ZSxcbiAgICAgIHR4UDJzaFAycGtJbnB1dFNpemUsXG4gICAgfSA9IFZpcnR1YWxTaXplcztcblxuICAgIGNvbnN0IHtcbiAgICAgIG5QMnNoSW5wdXRzLFxuICAgICAgblAyc2hQMndzaElucHV0cyxcbiAgICAgIG5QMndzaElucHV0cyxcbiAgICAgIG5QMnRyS2V5cGF0aElucHV0cyxcbiAgICAgIG5QMnRyU2NyaXB0UGF0aExldmVsMUlucHV0cyxcbiAgICAgIG5QMnRyU2NyaXB0UGF0aExldmVsMklucHV0cyxcbiAgICAgIG5QMnNoUDJwa0lucHV0cyxcbiAgICB9ID0gdGhpcztcblxuICAgIGNvbnN0IHNpemUgPVxuICAgICAgblAyc2hJbnB1dHMgKiB0eFAyc2hJbnB1dFNpemUgK1xuICAgICAgblAyc2hQMndzaElucHV0cyAqIHR4UDJzaFAyd3NoSW5wdXRTaXplICtcbiAgICAgIG5QMndzaElucHV0cyAqIHR4UDJ3c2hJbnB1dFNpemUgK1xuICAgICAgblAydHJLZXlwYXRoSW5wdXRzICogdHhQMnRyS2V5cGF0aElucHV0U2l6ZSArXG4gICAgICBuUDJzaFAycGtJbnB1dHMgKiB0eFAyc2hQMnBrSW5wdXRTaXplICtcbiAgICAgIG5QMnRyU2NyaXB0UGF0aExldmVsMUlucHV0cyAqIHR4UDJ0clNjcmlwdFBhdGhMZXZlbDFJbnB1dFNpemUgK1xuICAgICAgblAydHJTY3JpcHRQYXRoTGV2ZWwySW5wdXRzICogdHhQMnRyU2NyaXB0UGF0aExldmVsMklucHV0U2l6ZTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHNpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2l6ZWApO1xuICAgIH1cblxuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHJldHVybiB2c2l6ZSBvZiBvdXRwdXRzLCB3aXRob3V0IG92ZXJoZWFkXG4gICAqL1xuICBnZXRPdXRwdXRzVlNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRzLnNpemU7XG4gIH1cblxuICAvKipcbiAgICogRXN0aW1hdGVzIHRoZSB2aXJ0dWFsIHNpemUgKDEvNCB3ZWlnaHQpIG9mIGEgc2lnbmVkIHRyYW5zYWN0aW9uIGFzIHN1bSBvZlxuICAgKiBvdmVyaGVhZCB2c2l6ZSwgaW5wdXQgdnNpemUgYW5kIG91dHB1dCB2c2l6ZS5cbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIGVzdGltYXRlZCB2c2l6ZSBvZiB0aGUgdHJhbnNhY3Rpb24gZGltZW5zaW9ucy5cbiAgICovXG4gIGdldFZTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T3ZlcmhlYWRWU2l6ZSgpICsgdGhpcy5nZXRJbnB1dHNWU2l6ZSgpICsgdGhpcy5nZXRPdXRwdXRzVlNpemUoKTtcbiAgfVxufVxuIl19