"use strict";
/*
This is a reference implementation for calculating weights and vSizes from bitcoinjs-lib 3.3.2.
https://github.com/bitcoinjs/bitcoinjs-lib/blob/v3.3.2/src/transaction.js#L194-L219

```
  function encodingLength (number) {
    checkUInt53(number)

    return (
      number < 0xfd ? 1
    : number <= 0xffff ? 3
    : number <= 0xffffffff ? 5
    : 9
    )
  }

  function varSliceSize (someScript) {
    var length = someScript.length

    return encodingLength(length) + length
  }

  function vectorSize (someVector) {
    var length = someVector.length

    return varuint.encodingLength(length) + someVector.reduce(function (sum, witness) {
      return sum + varSliceSize(witness)
    }, 0)
  }

  Transaction.prototype.__byteLength = function (__allowWitness) {
    var hasWitnesses = __allowWitness && this.hasWitnesses()

    return (
      (hasWitnesses ? 10 : 8) +
      varuint.encodingLength(this.ins.length) +
      varuint.encodingLength(this.outs.length) +
      this.ins.reduce(function (sum, input) { return sum + 40 + varSliceSize(input.script) }, 0) +
      this.outs.reduce(function (sum, output) { return sum + 8 + varSliceSize(output.script) }, 0) +
      (hasWitnesses ? this.ins.reduce(function (sum, input) { return sum + vectorSize(input.witness) }, 0) : 0)
    )
  }

  Transaction.prototype.weight = function () {
    var base = this.__byteLength(false)
    var total = this.__byteLength(true)
    return base * 3 + total
  }

  Transaction.prototype.virtualSize = function () {
    return Math.ceil(this.weight() / 4)
  }
```
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualSizes = void 0;
const inputWeights_1 = require("./inputWeights");
function getVirtualInputSizeFromComponents(components) {
    return Math.ceil(inputWeights_1.getInputComponentsWeight(components) / 4);
}
// Constants for signed TX input and output vsizes.
// See https://bitcoincore.org/en/segwit_wallet_dev/#transaction-serialization for full description
// FIXME(BG-9233): use weight units instead
exports.VirtualSizes = Object.freeze({
    // FIXME(BG-7873): add support for signature grinding
    // Size of a P2PKH input with (un)compressed key
    /** @deprecated */
    txP2pkhInputSizeCompressedKey: 148,
    /** @deprecated */
    txP2pkhInputSizeUncompressedKey: 180,
    // Input sizes
    txP2shInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2sh),
    txP2shP2wshInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2shP2wsh),
    txP2wshInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2wsh),
    txP2trKeypathInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2trKeySpend),
    txP2shP2pkInputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2shP2pk),
    txP2trScriptPathLevel1InputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2trScriptSpendLevel1),
    txP2trScriptPathLevel2InputSize: getVirtualInputSizeFromComponents(inputWeights_1.inputComponentsP2trScriptSpendLevel2),
    //
    // Output sizes
    //
    // The size is calculated as
    //
    //    scriptLength + compactSize(scriptLength) + txOutputAmountSize
    //
    // Since compactSize(scriptLength) is 1 for all scripts considered here, we can simplify this to
    //
    //    scriptLength + 9
    //
    // Size of single output amount
    txOutputAmountSize: 8,
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/v4.0.2/src/templates/scripthash/output.js#L9
    txP2shOutputSize: 32,
    txP2shP2wshOutputSize: 32,
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/v4.0.2/src/templates/witnessscripthash/output.js#L9
    txP2wshOutputSize: 43,
    // OP_1 OP_PUSH32 <schnorr_public_key>
    txP2trOutputSize: 43,
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/v4.0.2/src/templates/pubkeyhash/output.js#L9
    txP2pkhOutputSize: 34,
    // https://github.com/bitcoinjs/bitcoinjs-lib/blob/v4.0.2/src/templates/witnesspubkeyhash/output.js#L9
    txP2wpkhOutputSize: 31,
    /** @deprecated - use txP2pkhOutputSize instead */
    txOutputSize: 34,
    //
    // General tx size constants
    //
    txOverheadSize: 10,
    // Segwit adds one byte each for marker and flag to the witness section.
    // Thus, the vsize is only increased by one.
    txSegOverheadVSize: 11,
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlydHVhbFNpemVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3ZpcnR1YWxTaXplcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBcURFOzs7QUFFRixpREFVd0I7QUFFeEIsU0FBUyxpQ0FBaUMsQ0FBQyxVQUEyQjtJQUNwRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsdUNBQXdCLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDN0QsQ0FBQztBQUVELG1EQUFtRDtBQUNuRCxtR0FBbUc7QUFDbkcsMkNBQTJDO0FBQzlCLFFBQUEsWUFBWSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDeEMscURBQXFEO0lBRXJELGdEQUFnRDtJQUNoRCxrQkFBa0I7SUFDbEIsNkJBQTZCLEVBQUUsR0FBRztJQUNsQyxrQkFBa0I7SUFDbEIsK0JBQStCLEVBQUUsR0FBRztJQUVwQyxjQUFjO0lBQ2QsZUFBZSxFQUFFLGlDQUFpQyxDQUFDLGtDQUFtQixDQUFDO0lBQ3ZFLG9CQUFvQixFQUFFLGlDQUFpQyxDQUFDLHVDQUF3QixDQUFDO0lBQ2pGLGdCQUFnQixFQUFFLGlDQUFpQyxDQUFDLG1DQUFvQixDQUFDO0lBQ3pFLHNCQUFzQixFQUFFLGlDQUFpQyxDQUFDLDBDQUEyQixDQUFDO0lBQ3RGLG1CQUFtQixFQUFFLGlDQUFpQyxDQUFDLHNDQUF1QixDQUFDO0lBQy9FLCtCQUErQixFQUFFLGlDQUFpQyxDQUFDLG1EQUFvQyxDQUFDO0lBQ3hHLCtCQUErQixFQUFFLGlDQUFpQyxDQUFDLG1EQUFvQyxDQUFDO0lBRXhHLEVBQUU7SUFDRixlQUFlO0lBQ2YsRUFBRTtJQUVGLDRCQUE0QjtJQUM1QixFQUFFO0lBQ0YsbUVBQW1FO0lBQ25FLEVBQUU7SUFDRixnR0FBZ0c7SUFDaEcsRUFBRTtJQUNGLHNCQUFzQjtJQUN0QixFQUFFO0lBRUYsK0JBQStCO0lBQy9CLGtCQUFrQixFQUFFLENBQUM7SUFFckIsK0ZBQStGO0lBQy9GLGdCQUFnQixFQUFFLEVBQUU7SUFDcEIscUJBQXFCLEVBQUUsRUFBRTtJQUN6QixzR0FBc0c7SUFDdEcsaUJBQWlCLEVBQUUsRUFBRTtJQUNyQixzQ0FBc0M7SUFDdEMsZ0JBQWdCLEVBQUUsRUFBRTtJQUNwQiwrRkFBK0Y7SUFDL0YsaUJBQWlCLEVBQUUsRUFBRTtJQUNyQixzR0FBc0c7SUFDdEcsa0JBQWtCLEVBQUUsRUFBRTtJQUV0QixrREFBa0Q7SUFDbEQsWUFBWSxFQUFFLEVBQUU7SUFFaEIsRUFBRTtJQUNGLDRCQUE0QjtJQUM1QixFQUFFO0lBRUYsY0FBYyxFQUFFLEVBQUU7SUFDbEIsd0VBQXdFO0lBQ3hFLDRDQUE0QztJQUM1QyxrQkFBa0IsRUFBRSxFQUFFO0NBQ3ZCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5UaGlzIGlzIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIGZvciBjYWxjdWxhdGluZyB3ZWlnaHRzIGFuZCB2U2l6ZXMgZnJvbSBiaXRjb2luanMtbGliIDMuMy4yLlxuaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliL2Jsb2IvdjMuMy4yL3NyYy90cmFuc2FjdGlvbi5qcyNMMTk0LUwyMTlcblxuYGBgXG4gIGZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChudW1iZXIpIHtcbiAgICBjaGVja1VJbnQ1MyhudW1iZXIpXG5cbiAgICByZXR1cm4gKFxuICAgICAgbnVtYmVyIDwgMHhmZCA/IDFcbiAgICA6IG51bWJlciA8PSAweGZmZmYgPyAzXG4gICAgOiBudW1iZXIgPD0gMHhmZmZmZmZmZiA/IDVcbiAgICA6IDlcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiB2YXJTbGljZVNpemUgKHNvbWVTY3JpcHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gc29tZVNjcmlwdC5sZW5ndGhcblxuICAgIHJldHVybiBlbmNvZGluZ0xlbmd0aChsZW5ndGgpICsgbGVuZ3RoXG4gIH1cblxuICBmdW5jdGlvbiB2ZWN0b3JTaXplIChzb21lVmVjdG9yKSB7XG4gICAgdmFyIGxlbmd0aCA9IHNvbWVWZWN0b3IubGVuZ3RoXG5cbiAgICByZXR1cm4gdmFydWludC5lbmNvZGluZ0xlbmd0aChsZW5ndGgpICsgc29tZVZlY3Rvci5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgd2l0bmVzcykge1xuICAgICAgcmV0dXJuIHN1bSArIHZhclNsaWNlU2l6ZSh3aXRuZXNzKVxuICAgIH0sIDApXG4gIH1cblxuICBUcmFuc2FjdGlvbi5wcm90b3R5cGUuX19ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKF9fYWxsb3dXaXRuZXNzKSB7XG4gICAgdmFyIGhhc1dpdG5lc3NlcyA9IF9fYWxsb3dXaXRuZXNzICYmIHRoaXMuaGFzV2l0bmVzc2VzKClcblxuICAgIHJldHVybiAoXG4gICAgICAoaGFzV2l0bmVzc2VzID8gMTAgOiA4KSArXG4gICAgICB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHRoaXMuaW5zLmxlbmd0aCkgK1xuICAgICAgdmFydWludC5lbmNvZGluZ0xlbmd0aCh0aGlzLm91dHMubGVuZ3RoKSArXG4gICAgICB0aGlzLmlucy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgaW5wdXQpIHsgcmV0dXJuIHN1bSArIDQwICsgdmFyU2xpY2VTaXplKGlucHV0LnNjcmlwdCkgfSwgMCkgK1xuICAgICAgdGhpcy5vdXRzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBvdXRwdXQpIHsgcmV0dXJuIHN1bSArIDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCkgfSwgMCkgK1xuICAgICAgKGhhc1dpdG5lc3NlcyA/IHRoaXMuaW5zLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBpbnB1dCkgeyByZXR1cm4gc3VtICsgdmVjdG9yU2l6ZShpbnB1dC53aXRuZXNzKSB9LCAwKSA6IDApXG4gICAgKVxuICB9XG5cbiAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLndlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmFzZSA9IHRoaXMuX19ieXRlTGVuZ3RoKGZhbHNlKVxuICAgIHZhciB0b3RhbCA9IHRoaXMuX19ieXRlTGVuZ3RoKHRydWUpXG4gICAgcmV0dXJuIGJhc2UgKiAzICsgdG90YWxcbiAgfVxuXG4gIFRyYW5zYWN0aW9uLnByb3RvdHlwZS52aXJ0dWFsU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMud2VpZ2h0KCkgLyA0KVxuICB9XG5gYGBcbiovXG5cbmltcG9ydCB7XG4gIGdldElucHV0Q29tcG9uZW50c1dlaWdodCxcbiAgSW5wdXRDb21wb25lbnRzLFxuICBpbnB1dENvbXBvbmVudHNQMnNoLFxuICBpbnB1dENvbXBvbmVudHNQMnNoUDJwayxcbiAgaW5wdXRDb21wb25lbnRzUDJzaFAyd3NoLFxuICBpbnB1dENvbXBvbmVudHNQMnRyS2V5U3BlbmQsXG4gIGlucHV0Q29tcG9uZW50c1AydHJTY3JpcHRTcGVuZExldmVsMSxcbiAgaW5wdXRDb21wb25lbnRzUDJ0clNjcmlwdFNwZW5kTGV2ZWwyLFxuICBpbnB1dENvbXBvbmVudHNQMndzaCxcbn0gZnJvbSAnLi9pbnB1dFdlaWdodHMnO1xuXG5mdW5jdGlvbiBnZXRWaXJ0dWFsSW5wdXRTaXplRnJvbUNvbXBvbmVudHMoY29tcG9uZW50czogSW5wdXRDb21wb25lbnRzKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguY2VpbChnZXRJbnB1dENvbXBvbmVudHNXZWlnaHQoY29tcG9uZW50cykgLyA0KTtcbn1cblxuLy8gQ29uc3RhbnRzIGZvciBzaWduZWQgVFggaW5wdXQgYW5kIG91dHB1dCB2c2l6ZXMuXG4vLyBTZWUgaHR0cHM6Ly9iaXRjb2luY29yZS5vcmcvZW4vc2Vnd2l0X3dhbGxldF9kZXYvI3RyYW5zYWN0aW9uLXNlcmlhbGl6YXRpb24gZm9yIGZ1bGwgZGVzY3JpcHRpb25cbi8vIEZJWE1FKEJHLTkyMzMpOiB1c2Ugd2VpZ2h0IHVuaXRzIGluc3RlYWRcbmV4cG9ydCBjb25zdCBWaXJ0dWFsU2l6ZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgLy8gRklYTUUoQkctNzg3Myk6IGFkZCBzdXBwb3J0IGZvciBzaWduYXR1cmUgZ3JpbmRpbmdcblxuICAvLyBTaXplIG9mIGEgUDJQS0ggaW5wdXQgd2l0aCAodW4pY29tcHJlc3NlZCBrZXlcbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIHR4UDJwa2hJbnB1dFNpemVDb21wcmVzc2VkS2V5OiAxNDgsXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICB0eFAycGtoSW5wdXRTaXplVW5jb21wcmVzc2VkS2V5OiAxODAsXG5cbiAgLy8gSW5wdXQgc2l6ZXNcbiAgdHhQMnNoSW5wdXRTaXplOiBnZXRWaXJ0dWFsSW5wdXRTaXplRnJvbUNvbXBvbmVudHMoaW5wdXRDb21wb25lbnRzUDJzaCksXG4gIHR4UDJzaFAyd3NoSW5wdXRTaXplOiBnZXRWaXJ0dWFsSW5wdXRTaXplRnJvbUNvbXBvbmVudHMoaW5wdXRDb21wb25lbnRzUDJzaFAyd3NoKSxcbiAgdHhQMndzaElucHV0U2l6ZTogZ2V0VmlydHVhbElucHV0U2l6ZUZyb21Db21wb25lbnRzKGlucHV0Q29tcG9uZW50c1Ayd3NoKSxcbiAgdHhQMnRyS2V5cGF0aElucHV0U2l6ZTogZ2V0VmlydHVhbElucHV0U2l6ZUZyb21Db21wb25lbnRzKGlucHV0Q29tcG9uZW50c1AydHJLZXlTcGVuZCksXG4gIHR4UDJzaFAycGtJbnB1dFNpemU6IGdldFZpcnR1YWxJbnB1dFNpemVGcm9tQ29tcG9uZW50cyhpbnB1dENvbXBvbmVudHNQMnNoUDJwayksXG4gIHR4UDJ0clNjcmlwdFBhdGhMZXZlbDFJbnB1dFNpemU6IGdldFZpcnR1YWxJbnB1dFNpemVGcm9tQ29tcG9uZW50cyhpbnB1dENvbXBvbmVudHNQMnRyU2NyaXB0U3BlbmRMZXZlbDEpLFxuICB0eFAydHJTY3JpcHRQYXRoTGV2ZWwySW5wdXRTaXplOiBnZXRWaXJ0dWFsSW5wdXRTaXplRnJvbUNvbXBvbmVudHMoaW5wdXRDb21wb25lbnRzUDJ0clNjcmlwdFNwZW5kTGV2ZWwyKSxcblxuICAvL1xuICAvLyBPdXRwdXQgc2l6ZXNcbiAgLy9cblxuICAvLyBUaGUgc2l6ZSBpcyBjYWxjdWxhdGVkIGFzXG4gIC8vXG4gIC8vICAgIHNjcmlwdExlbmd0aCArIGNvbXBhY3RTaXplKHNjcmlwdExlbmd0aCkgKyB0eE91dHB1dEFtb3VudFNpemVcbiAgLy9cbiAgLy8gU2luY2UgY29tcGFjdFNpemUoc2NyaXB0TGVuZ3RoKSBpcyAxIGZvciBhbGwgc2NyaXB0cyBjb25zaWRlcmVkIGhlcmUsIHdlIGNhbiBzaW1wbGlmeSB0aGlzIHRvXG4gIC8vXG4gIC8vICAgIHNjcmlwdExlbmd0aCArIDlcbiAgLy9cblxuICAvLyBTaXplIG9mIHNpbmdsZSBvdXRwdXQgYW1vdW50XG4gIHR4T3V0cHV0QW1vdW50U2l6ZTogOCxcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbmpzL2JpdGNvaW5qcy1saWIvYmxvYi92NC4wLjIvc3JjL3RlbXBsYXRlcy9zY3JpcHRoYXNoL291dHB1dC5qcyNMOVxuICB0eFAyc2hPdXRwdXRTaXplOiAzMixcbiAgdHhQMnNoUDJ3c2hPdXRwdXRTaXplOiAzMixcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliL2Jsb2IvdjQuMC4yL3NyYy90ZW1wbGF0ZXMvd2l0bmVzc3NjcmlwdGhhc2gvb3V0cHV0LmpzI0w5XG4gIHR4UDJ3c2hPdXRwdXRTaXplOiA0MyxcbiAgLy8gT1BfMSBPUF9QVVNIMzIgPHNjaG5vcnJfcHVibGljX2tleT5cbiAgdHhQMnRyT3V0cHV0U2l6ZTogNDMsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYml0Y29pbmpzLWxpYi9ibG9iL3Y0LjAuMi9zcmMvdGVtcGxhdGVzL3B1YmtleWhhc2gvb3V0cHV0LmpzI0w5XG4gIHR4UDJwa2hPdXRwdXRTaXplOiAzNCxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXRjb2luanMtbGliL2Jsb2IvdjQuMC4yL3NyYy90ZW1wbGF0ZXMvd2l0bmVzc3B1YmtleWhhc2gvb3V0cHV0LmpzI0w5XG4gIHR4UDJ3cGtoT3V0cHV0U2l6ZTogMzEsXG5cbiAgLyoqIEBkZXByZWNhdGVkIC0gdXNlIHR4UDJwa2hPdXRwdXRTaXplIGluc3RlYWQgKi9cbiAgdHhPdXRwdXRTaXplOiAzNCxcblxuICAvL1xuICAvLyBHZW5lcmFsIHR4IHNpemUgY29uc3RhbnRzXG4gIC8vXG5cbiAgdHhPdmVyaGVhZFNpemU6IDEwLFxuICAvLyBTZWd3aXQgYWRkcyBvbmUgYnl0ZSBlYWNoIGZvciBtYXJrZXIgYW5kIGZsYWcgdG8gdGhlIHdpdG5lc3Mgc2VjdGlvbi5cbiAgLy8gVGh1cywgdGhlIHZzaXplIGlzIG9ubHkgaW5jcmVhc2VkIGJ5IG9uZS5cbiAgdHhTZWdPdmVyaGVhZFZTaXplOiAxMSxcbn0pO1xuIl19