"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakingActivateBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const transactionBuilder_1 = require("./transactionBuilder");
const constants_1 = require("./constants");
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("./utils");
class StakingActivateBuilder extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    get transactionType() {
        return sdk_core_1.TransactionType.StakingActivate;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        for (const instruction of this._instructionsData) {
            if (instruction.type === constants_1.InstructionBuilderTypes.StakingActivate) {
                const activateInstruction = instruction;
                this.sender(activateInstruction.params.fromAddress);
                this.stakingAddress(activateInstruction.params.stakingAddress);
                this.amount(activateInstruction.params.amount);
                this.validator(activateInstruction.params.validator);
            }
        }
    }
    /**
     * The amount to stake expressed in Lamports, 1 SOL = 1_000_000_000 lamports.
     *
     * @param {string} amount expressed in Lamports.
     * @returns {StakeBuilder} This staking builder.
     *
     */
    amount(amount) {
        if (!utils_1.isValidStakingAmount(amount)) {
            throw new sdk_core_1.BuildTransactionError('Value cannot be zero or less');
        }
        this._amount = amount;
        return this;
    }
    /**
     * The address of the staking account.
     *
     * @param {string} stakingAddress public address of the staking account.
     * @returns {StakingActivateBuilder} This staking builder.
     *
     * @see https://docs.solana.com/staking/stake-accounts#account-address
     */
    stakingAddress(stakingAddress) {
        utils_1.validateAddress(stakingAddress, 'stakingAddress');
        this._stakingAddress = stakingAddress;
        return this;
    }
    /**
     * Set validator address to delegate funds to.
     *
     * @param {string} validator Validator address to delegate funds to.
     * @returns {StakingActivateBuilder} This staking builder.
     *
     */
    validator(validator) {
        utils_1.validateAddress(validator, 'validator');
        this._validator = validator;
        return this;
    }
    /** @inheritdoc */
    async buildImplementation() {
        assert_1.default(this._sender, 'Sender must be set before building the transaction');
        assert_1.default(this._stakingAddress, 'Staking Address must be set before building the transaction');
        assert_1.default(this._validator, 'Validator must be set before building the transaction');
        assert_1.default(this._amount, 'Amount must be set before building the transaction');
        if (this._sender === this._stakingAddress) {
            throw new sdk_core_1.BuildTransactionError('Sender address cannot be the same as the Staking address');
        }
        const stakingAccountData = {
            type: constants_1.InstructionBuilderTypes.StakingActivate,
            params: {
                fromAddress: this._sender,
                stakingAddress: this._stakingAddress,
                amount: this._amount,
                validator: this._validator,
            },
        };
        this._instructionsData = [stakingAccountData];
        return await super.buildImplementation();
    }
}
exports.StakingActivateBuilder = StakingActivateBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Rha2luZ0FjdGl2YXRlQnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvc3Rha2luZ0FjdGl2YXRlQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSw4Q0FBeUU7QUFFekUsNkRBQTBEO0FBQzFELDJDQUFzRDtBQUV0RCxvREFBNEI7QUFFNUIsbUNBQWdFO0FBRWhFLE1BQWEsc0JBQXVCLFNBQVEsdUNBQWtCO0lBSzVELFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxJQUFjLGVBQWU7UUFDM0IsT0FBTywwQkFBZSxDQUFDLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFdBQVcsQ0FBQyxFQUFlO1FBQ3pCLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEIsS0FBSyxNQUFNLFdBQVcsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDaEQsSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLG1DQUF1QixDQUFDLGVBQWUsRUFBRTtnQkFDaEUsTUFBTSxtQkFBbUIsR0FBb0IsV0FBVyxDQUFDO2dCQUN6RCxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQy9ELElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUMvQyxJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUN0RDtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNILE1BQU0sQ0FBQyxNQUFjO1FBQ25CLElBQUksQ0FBQyw0QkFBb0IsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNqQyxNQUFNLElBQUksZ0NBQXFCLENBQUMsOEJBQThCLENBQUMsQ0FBQztTQUNqRTtRQUNELElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3RCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxjQUFjLENBQUMsY0FBc0I7UUFDbkMsdUJBQWUsQ0FBQyxjQUFjLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsZUFBZSxHQUFHLGNBQWMsQ0FBQztRQUN0QyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxTQUFTLENBQUMsU0FBaUI7UUFDekIsdUJBQWUsQ0FBQyxTQUFTLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDeEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7UUFDNUIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsa0JBQWtCO0lBQ1IsS0FBSyxDQUFDLG1CQUFtQjtRQUNqQyxnQkFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsb0RBQW9ELENBQUMsQ0FBQztRQUMzRSxnQkFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsNkRBQTZELENBQUMsQ0FBQztRQUM1RixnQkFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsdURBQXVELENBQUMsQ0FBQztRQUNqRixnQkFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsb0RBQW9ELENBQUMsQ0FBQztRQUUzRSxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN6QyxNQUFNLElBQUksZ0NBQXFCLENBQUMsMERBQTBELENBQUMsQ0FBQztTQUM3RjtRQUVELE1BQU0sa0JBQWtCLEdBQW9CO1lBQzFDLElBQUksRUFBRSxtQ0FBdUIsQ0FBQyxlQUFlO1lBQzdDLE1BQU0sRUFBRTtnQkFDTixXQUFXLEVBQUUsSUFBSSxDQUFDLE9BQU87Z0JBQ3pCLGNBQWMsRUFBRSxJQUFJLENBQUMsZUFBZTtnQkFDcEMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPO2dCQUNwQixTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVU7YUFDM0I7U0FDRixDQUFDO1FBQ0YsSUFBSSxDQUFDLGlCQUFpQixHQUFHLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUU5QyxPQUFPLE1BQU0sS0FBSyxDQUFDLG1CQUFtQixFQUFFLENBQUM7SUFDM0MsQ0FBQztDQUNGO0FBN0ZELHdEQTZGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi90cmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHsgSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcbmltcG9ydCB7IFN0YWtpbmdBY3RpdmF0ZSB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgaXNWYWxpZFN0YWtpbmdBbW91bnQsIHZhbGlkYXRlQWRkcmVzcyB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgU3Rha2luZ0FjdGl2YXRlQnVpbGRlciBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIHByb3RlY3RlZCBfYW1vdW50OiBzdHJpbmc7XG4gIHByb3RlY3RlZCBfc3Rha2luZ0FkZHJlc3M6IHN0cmluZztcbiAgcHJvdGVjdGVkIF92YWxpZGF0b3I6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IHRyYW5zYWN0aW9uVHlwZSgpOiBUcmFuc2FjdGlvblR5cGUge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0FjdGl2YXRlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGluaXRCdWlsZGVyKHR4OiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIHN1cGVyLmluaXRCdWlsZGVyKHR4KTtcbiAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRoaXMuX2luc3RydWN0aW9uc0RhdGEpIHtcbiAgICAgIGlmIChpbnN0cnVjdGlvbi50eXBlID09PSBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcy5TdGFraW5nQWN0aXZhdGUpIHtcbiAgICAgICAgY29uc3QgYWN0aXZhdGVJbnN0cnVjdGlvbjogU3Rha2luZ0FjdGl2YXRlID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuc2VuZGVyKGFjdGl2YXRlSW5zdHJ1Y3Rpb24ucGFyYW1zLmZyb21BZGRyZXNzKTtcbiAgICAgICAgdGhpcy5zdGFraW5nQWRkcmVzcyhhY3RpdmF0ZUluc3RydWN0aW9uLnBhcmFtcy5zdGFraW5nQWRkcmVzcyk7XG4gICAgICAgIHRoaXMuYW1vdW50KGFjdGl2YXRlSW5zdHJ1Y3Rpb24ucGFyYW1zLmFtb3VudCk7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yKGFjdGl2YXRlSW5zdHJ1Y3Rpb24ucGFyYW1zLnZhbGlkYXRvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgdG8gc3Rha2UgZXhwcmVzc2VkIGluIExhbXBvcnRzLCAxIFNPTCA9IDFfMDAwXzAwMF8wMDAgbGFtcG9ydHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnQgZXhwcmVzc2VkIGluIExhbXBvcnRzLlxuICAgKiBAcmV0dXJucyB7U3Rha2VCdWlsZGVyfSBUaGlzIHN0YWtpbmcgYnVpbGRlci5cbiAgICpcbiAgICovXG4gIGFtb3VudChhbW91bnQ6IHN0cmluZyk6IHRoaXMge1xuICAgIGlmICghaXNWYWxpZFN0YWtpbmdBbW91bnQoYW1vdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVmFsdWUgY2Fubm90IGJlIHplcm8gb3IgbGVzcycpO1xuICAgIH1cbiAgICB0aGlzLl9hbW91bnQgPSBhbW91bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFkZHJlc3Mgb2YgdGhlIHN0YWtpbmcgYWNjb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdBZGRyZXNzIHB1YmxpYyBhZGRyZXNzIG9mIHRoZSBzdGFraW5nIGFjY291bnQuXG4gICAqIEByZXR1cm5zIHtTdGFraW5nQWN0aXZhdGVCdWlsZGVyfSBUaGlzIHN0YWtpbmcgYnVpbGRlci5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS9zdGFraW5nL3N0YWtlLWFjY291bnRzI2FjY291bnQtYWRkcmVzc1xuICAgKi9cbiAgc3Rha2luZ0FkZHJlc3Moc3Rha2luZ0FkZHJlc3M6IHN0cmluZyk6IHRoaXMge1xuICAgIHZhbGlkYXRlQWRkcmVzcyhzdGFraW5nQWRkcmVzcywgJ3N0YWtpbmdBZGRyZXNzJyk7XG4gICAgdGhpcy5fc3Rha2luZ0FkZHJlc3MgPSBzdGFraW5nQWRkcmVzcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdmFsaWRhdG9yIGFkZHJlc3MgdG8gZGVsZWdhdGUgZnVuZHMgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3IgVmFsaWRhdG9yIGFkZHJlc3MgdG8gZGVsZWdhdGUgZnVuZHMgdG8uXG4gICAqIEByZXR1cm5zIHtTdGFraW5nQWN0aXZhdGVCdWlsZGVyfSBUaGlzIHN0YWtpbmcgYnVpbGRlci5cbiAgICpcbiAgICovXG4gIHZhbGlkYXRvcih2YWxpZGF0b3I6IHN0cmluZyk6IHRoaXMge1xuICAgIHZhbGlkYXRlQWRkcmVzcyh2YWxpZGF0b3IsICd2YWxpZGF0b3InKTtcbiAgICB0aGlzLl92YWxpZGF0b3IgPSB2YWxpZGF0b3I7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIGFzc2VydCh0aGlzLl9zZW5kZXIsICdTZW5kZXIgbXVzdCBiZSBzZXQgYmVmb3JlIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbicpO1xuICAgIGFzc2VydCh0aGlzLl9zdGFraW5nQWRkcmVzcywgJ1N0YWtpbmcgQWRkcmVzcyBtdXN0IGJlIHNldCBiZWZvcmUgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgYXNzZXJ0KHRoaXMuX3ZhbGlkYXRvciwgJ1ZhbGlkYXRvciBtdXN0IGJlIHNldCBiZWZvcmUgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgYXNzZXJ0KHRoaXMuX2Ftb3VudCwgJ0Ftb3VudCBtdXN0IGJlIHNldCBiZWZvcmUgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uJyk7XG5cbiAgICBpZiAodGhpcy5fc2VuZGVyID09PSB0aGlzLl9zdGFraW5nQWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignU2VuZGVyIGFkZHJlc3MgY2Fubm90IGJlIHRoZSBzYW1lIGFzIHRoZSBTdGFraW5nIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFraW5nQWNjb3VudERhdGE6IFN0YWtpbmdBY3RpdmF0ZSA9IHtcbiAgICAgIHR5cGU6IEluc3RydWN0aW9uQnVpbGRlclR5cGVzLlN0YWtpbmdBY3RpdmF0ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBmcm9tQWRkcmVzczogdGhpcy5fc2VuZGVyLFxuICAgICAgICBzdGFraW5nQWRkcmVzczogdGhpcy5fc3Rha2luZ0FkZHJlc3MsXG4gICAgICAgIGFtb3VudDogdGhpcy5fYW1vdW50LFxuICAgICAgICB2YWxpZGF0b3I6IHRoaXMuX3ZhbGlkYXRvcixcbiAgICAgIH0sXG4gICAgfTtcbiAgICB0aGlzLl9pbnN0cnVjdGlvbnNEYXRhID0gW3N0YWtpbmdBY2NvdW50RGF0YV07XG5cbiAgICByZXR1cm4gYXdhaXQgc3VwZXIuYnVpbGRJbXBsZW1lbnRhdGlvbigpO1xuICB9XG59XG4iXX0=