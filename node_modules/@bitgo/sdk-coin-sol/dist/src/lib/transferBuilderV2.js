"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferBuilderV2 = void 0;
const transactionBuilder_1 = require("./transactionBuilder");
const sdk_core_1 = require("@bitgo/sdk-core");
const utils_1 = require("./utils");
const statics_1 = require("@bitgo/statics");
const assert_1 = __importDefault(require("assert"));
const constants_1 = require("./constants");
const UNSIGNED_BIGINT_MAX = BigInt('18446744073709551615');
class TransferBuilderV2 extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
        this._sendParams = [];
    }
    get transactionType() {
        return sdk_core_1.TransactionType.Send;
    }
    initBuilder(tx) {
        super.initBuilder(tx);
        for (const instruction of this._instructionsData) {
            if (instruction.type === constants_1.InstructionBuilderTypes.Transfer) {
                const transferInstruction = instruction;
                this.sender(transferInstruction.params.fromAddress);
                this.send({
                    address: transferInstruction.params.toAddress,
                    amount: transferInstruction.params.amount,
                });
            }
            else if (instruction.type === constants_1.InstructionBuilderTypes.TokenTransfer) {
                const transferInstruction = instruction;
                this.sender(transferInstruction.params.fromAddress);
                this.send({
                    address: transferInstruction.params.toAddress,
                    amount: transferInstruction.params.amount,
                    tokenName: transferInstruction.params.tokenName,
                });
            }
        }
    }
    /**
     * Set a feePayer
     * @param payerAddress
     */
    feePayer(payerAddress) {
        utils_1.validateAddress(payerAddress, 'address');
        this._feePayer = payerAddress;
        return this;
    }
    /**
     *  Set a transfer
     *
     * @param {SendParams} sendParams - sendParams
     * @returns {TransactionBuilder} This transaction builder
     */
    send(sendParams) {
        utils_1.validateAddress(sendParams.address, 'address');
        if (!sendParams.amount || !utils_1.isValidAmount(sendParams.amount)) {
            throw new sdk_core_1.BuildTransactionError('Invalid or missing amount, got: ' + sendParams.amount);
        }
        if (sendParams.tokenName && BigInt(sendParams.amount) > UNSIGNED_BIGINT_MAX) {
            throw new sdk_core_1.BuildTransactionError(`input amount ${sendParams.amount} exceeds big int limit ${UNSIGNED_BIGINT_MAX}`);
        }
        else if (!sendParams.tokenName && BigInt(sendParams.amount) > BigInt(Number.MAX_SAFE_INTEGER)) {
            throw new sdk_core_1.BuildTransactionError(`input amount ${sendParams.amount} exceeds max safe int ${Number.MAX_SAFE_INTEGER}`);
        }
        this._sendParams.push(sendParams);
        return this;
    }
    /** @inheritdoc */
    async buildImplementation() {
        assert_1.default(this._sender, 'Sender must be set before building the transaction');
        this._instructionsData = await Promise.all(this._sendParams.map(async (sendParams) => {
            if (sendParams.tokenName) {
                const coin = utils_1.getSolTokenFromTokenName(sendParams.tokenName);
                assert_1.default(coin instanceof statics_1.SolCoin);
                const sourceAddress = await utils_1.getAssociatedTokenAccountAddress(coin.tokenAddress, this._sender);
                return {
                    type: constants_1.InstructionBuilderTypes.TokenTransfer,
                    params: {
                        fromAddress: this._sender,
                        toAddress: sendParams.address,
                        amount: sendParams.amount,
                        tokenName: sendParams.tokenName,
                        sourceAddress: sourceAddress,
                    },
                };
            }
            else {
                return {
                    type: constants_1.InstructionBuilderTypes.Transfer,
                    params: {
                        fromAddress: this._sender,
                        toAddress: sendParams.address,
                        amount: sendParams.amount,
                    },
                };
            }
        }));
        return await super.buildImplementation();
    }
}
exports.TransferBuilderV2 = TransferBuilderV2;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJCdWlsZGVyVjIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zZmVyQnVpbGRlclYyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDZEQUEwRDtBQUMxRCw4Q0FBeUU7QUFDekUsbUNBQXFIO0FBQ3JILDRDQUFpRTtBQUVqRSxvREFBNEI7QUFFNUIsMkNBQXNEO0FBUXRELE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFFM0QsTUFBYSxpQkFBa0IsU0FBUSx1Q0FBa0I7SUFHdkQsWUFBWSxXQUFpQztRQUMzQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFIYixnQkFBVyxHQUFpQixFQUFFLENBQUM7SUFJdkMsQ0FBQztJQUVELElBQWMsZUFBZTtRQUMzQixPQUFPLDBCQUFlLENBQUMsSUFBSSxDQUFDO0lBQzlCLENBQUM7SUFFRCxXQUFXLENBQUMsRUFBZTtRQUN6QixLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXRCLEtBQUssTUFBTSxXQUFXLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQ2hELElBQUksV0FBVyxDQUFDLElBQUksS0FBSyxtQ0FBdUIsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3pELE1BQU0sbUJBQW1CLEdBQWEsV0FBVyxDQUFDO2dCQUNsRCxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxDQUFDLElBQUksQ0FBQztvQkFDUixPQUFPLEVBQUUsbUJBQW1CLENBQUMsTUFBTSxDQUFDLFNBQVM7b0JBQzdDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsTUFBTTtpQkFDMUMsQ0FBQyxDQUFDO2FBQ0o7aUJBQU0sSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLG1DQUF1QixDQUFDLGFBQWEsRUFBRTtnQkFDckUsTUFBTSxtQkFBbUIsR0FBa0IsV0FBVyxDQUFDO2dCQUN2RCxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxDQUFDLElBQUksQ0FBQztvQkFDUixPQUFPLEVBQUUsbUJBQW1CLENBQUMsTUFBTSxDQUFDLFNBQVM7b0JBQzdDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsTUFBTTtvQkFDekMsU0FBUyxFQUFFLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxTQUFTO2lCQUNoRCxDQUFDLENBQUM7YUFDSjtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVEsQ0FBQyxZQUFvQjtRQUMzQix1QkFBZSxDQUFDLFlBQVksRUFBRSxTQUFTLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQztRQUM5QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILElBQUksQ0FBQyxVQUFzQjtRQUN6Qix1QkFBZSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDL0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLElBQUksQ0FBQyxxQkFBYSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUMzRCxNQUFNLElBQUksZ0NBQXFCLENBQUMsa0NBQWtDLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3pGO1FBQ0QsSUFBSSxVQUFVLENBQUMsU0FBUyxJQUFJLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEdBQUcsbUJBQW1CLEVBQUU7WUFDM0UsTUFBTSxJQUFJLGdDQUFxQixDQUFDLGdCQUFnQixVQUFVLENBQUMsTUFBTSwwQkFBMEIsbUJBQW1CLEVBQUUsQ0FBQyxDQUFDO1NBQ25IO2FBQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLElBQUksTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDL0YsTUFBTSxJQUFJLGdDQUFxQixDQUM3QixnQkFBZ0IsVUFBVSxDQUFDLE1BQU0seUJBQXlCLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxDQUNwRixDQUFDO1NBQ0g7UUFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsQyxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxrQkFBa0I7SUFDUixLQUFLLENBQUMsbUJBQW1CO1FBQ2pDLGdCQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxvREFBb0QsQ0FBQyxDQUFDO1FBRTNFLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQ3hDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxVQUFzQixFQUFxQyxFQUFFO1lBQ3ZGLElBQUksVUFBVSxDQUFDLFNBQVMsRUFBRTtnQkFDeEIsTUFBTSxJQUFJLEdBQUcsZ0NBQXdCLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUM1RCxnQkFBTSxDQUFDLElBQUksWUFBWSxpQkFBTyxDQUFDLENBQUM7Z0JBQ2hDLE1BQU0sYUFBYSxHQUFHLE1BQU0sd0NBQWdDLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzlGLE9BQU87b0JBQ0wsSUFBSSxFQUFFLG1DQUF1QixDQUFDLGFBQWE7b0JBQzNDLE1BQU0sRUFBRTt3QkFDTixXQUFXLEVBQUUsSUFBSSxDQUFDLE9BQU87d0JBQ3pCLFNBQVMsRUFBRSxVQUFVLENBQUMsT0FBTzt3QkFDN0IsTUFBTSxFQUFFLFVBQVUsQ0FBQyxNQUFNO3dCQUN6QixTQUFTLEVBQUUsVUFBVSxDQUFDLFNBQVM7d0JBQy9CLGFBQWEsRUFBRSxhQUFhO3FCQUM3QjtpQkFDRixDQUFDO2FBQ0g7aUJBQU07Z0JBQ0wsT0FBTztvQkFDTCxJQUFJLEVBQUUsbUNBQXVCLENBQUMsUUFBUTtvQkFDdEMsTUFBTSxFQUFFO3dCQUNOLFdBQVcsRUFBRSxJQUFJLENBQUMsT0FBTzt3QkFDekIsU0FBUyxFQUFFLFVBQVUsQ0FBQyxPQUFPO3dCQUM3QixNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU07cUJBQzFCO2lCQUNGLENBQUM7YUFDSDtRQUNILENBQUMsQ0FBQyxDQUNILENBQUM7UUFFRixPQUFPLE1BQU0sS0FBSyxDQUFDLG1CQUFtQixFQUFFLENBQUM7SUFDM0MsQ0FBQztDQUNGO0FBdEdELDhDQXNHQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4vdHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7IEJ1aWxkVHJhbnNhY3Rpb25FcnJvciwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IGdldEFzc29jaWF0ZWRUb2tlbkFjY291bnRBZGRyZXNzLCBnZXRTb2xUb2tlbkZyb21Ub2tlbk5hbWUsIGlzVmFsaWRBbW91bnQsIHZhbGlkYXRlQWRkcmVzcyB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgQmFzZUNvaW4gYXMgQ29pbkNvbmZpZywgU29sQ29pbiB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBUb2tlblRyYW5zZmVyLCBUcmFuc2ZlciB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VuZFBhcmFtcyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgYW1vdW50OiBzdHJpbmc7XG4gIHRva2VuTmFtZT86IHN0cmluZztcbn1cblxuY29uc3QgVU5TSUdORURfQklHSU5UX01BWCA9IEJpZ0ludCgnMTg0NDY3NDQwNzM3MDk1NTE2MTUnKTtcblxuZXhwb3J0IGNsYXNzIFRyYW5zZmVyQnVpbGRlclYyIGV4dGVuZHMgVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJpdmF0ZSBfc2VuZFBhcmFtczogU2VuZFBhcmFtc1tdID0gW107XG5cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvblR5cGUoKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlNlbmQ7XG4gIH1cblxuICBpbml0QnVpbGRlcih0eDogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICBzdXBlci5pbml0QnVpbGRlcih0eCk7XG5cbiAgICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIHRoaXMuX2luc3RydWN0aW9uc0RhdGEpIHtcbiAgICAgIGlmIChpbnN0cnVjdGlvbi50eXBlID09PSBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcy5UcmFuc2Zlcikge1xuICAgICAgICBjb25zdCB0cmFuc2Zlckluc3RydWN0aW9uOiBUcmFuc2ZlciA9IGluc3RydWN0aW9uO1xuICAgICAgICB0aGlzLnNlbmRlcih0cmFuc2Zlckluc3RydWN0aW9uLnBhcmFtcy5mcm9tQWRkcmVzcyk7XG4gICAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgICAgYWRkcmVzczogdHJhbnNmZXJJbnN0cnVjdGlvbi5wYXJhbXMudG9BZGRyZXNzLFxuICAgICAgICAgIGFtb3VudDogdHJhbnNmZXJJbnN0cnVjdGlvbi5wYXJhbXMuYW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zdHJ1Y3Rpb24udHlwZSA9PT0gSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuVG9rZW5UcmFuc2Zlcikge1xuICAgICAgICBjb25zdCB0cmFuc2Zlckluc3RydWN0aW9uOiBUb2tlblRyYW5zZmVyID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgIHRoaXMuc2VuZGVyKHRyYW5zZmVySW5zdHJ1Y3Rpb24ucGFyYW1zLmZyb21BZGRyZXNzKTtcbiAgICAgICAgdGhpcy5zZW5kKHtcbiAgICAgICAgICBhZGRyZXNzOiB0cmFuc2Zlckluc3RydWN0aW9uLnBhcmFtcy50b0FkZHJlc3MsXG4gICAgICAgICAgYW1vdW50OiB0cmFuc2Zlckluc3RydWN0aW9uLnBhcmFtcy5hbW91bnQsXG4gICAgICAgICAgdG9rZW5OYW1lOiB0cmFuc2Zlckluc3RydWN0aW9uLnBhcmFtcy50b2tlbk5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBmZWVQYXllclxuICAgKiBAcGFyYW0gcGF5ZXJBZGRyZXNzXG4gICAqL1xuICBmZWVQYXllcihwYXllckFkZHJlc3M6IHN0cmluZyk6IHRoaXMge1xuICAgIHZhbGlkYXRlQWRkcmVzcyhwYXllckFkZHJlc3MsICdhZGRyZXNzJyk7XG4gICAgdGhpcy5fZmVlUGF5ZXIgPSBwYXllckFkZHJlc3M7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogIFNldCBhIHRyYW5zZmVyXG4gICAqXG4gICAqIEBwYXJhbSB7U2VuZFBhcmFtc30gc2VuZFBhcmFtcyAtIHNlbmRQYXJhbXNcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uQnVpbGRlcn0gVGhpcyB0cmFuc2FjdGlvbiBidWlsZGVyXG4gICAqL1xuICBzZW5kKHNlbmRQYXJhbXM6IFNlbmRQYXJhbXMpOiB0aGlzIHtcbiAgICB2YWxpZGF0ZUFkZHJlc3Moc2VuZFBhcmFtcy5hZGRyZXNzLCAnYWRkcmVzcycpO1xuICAgIGlmICghc2VuZFBhcmFtcy5hbW91bnQgfHwgIWlzVmFsaWRBbW91bnQoc2VuZFBhcmFtcy5hbW91bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIG9yIG1pc3NpbmcgYW1vdW50LCBnb3Q6ICcgKyBzZW5kUGFyYW1zLmFtb3VudCk7XG4gICAgfVxuICAgIGlmIChzZW5kUGFyYW1zLnRva2VuTmFtZSAmJiBCaWdJbnQoc2VuZFBhcmFtcy5hbW91bnQpID4gVU5TSUdORURfQklHSU5UX01BWCkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgaW5wdXQgYW1vdW50ICR7c2VuZFBhcmFtcy5hbW91bnR9IGV4Y2VlZHMgYmlnIGludCBsaW1pdCAke1VOU0lHTkVEX0JJR0lOVF9NQVh9YCk7XG4gICAgfSBlbHNlIGlmICghc2VuZFBhcmFtcy50b2tlbk5hbWUgJiYgQmlnSW50KHNlbmRQYXJhbXMuYW1vdW50KSA+IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpIHtcbiAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgIGBpbnB1dCBhbW91bnQgJHtzZW5kUGFyYW1zLmFtb3VudH0gZXhjZWVkcyBtYXggc2FmZSBpbnQgJHtOdW1iZXIuTUFYX1NBRkVfSU5URUdFUn1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX3NlbmRQYXJhbXMucHVzaChzZW5kUGFyYW1zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgYXNzZXJ0KHRoaXMuX3NlbmRlciwgJ1NlbmRlciBtdXN0IGJlIHNldCBiZWZvcmUgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uJyk7XG5cbiAgICB0aGlzLl9pbnN0cnVjdGlvbnNEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLl9zZW5kUGFyYW1zLm1hcChhc3luYyAoc2VuZFBhcmFtczogU2VuZFBhcmFtcyk6IFByb21pc2U8VHJhbnNmZXIgfCBUb2tlblRyYW5zZmVyPiA9PiB7XG4gICAgICAgIGlmIChzZW5kUGFyYW1zLnRva2VuTmFtZSkge1xuICAgICAgICAgIGNvbnN0IGNvaW4gPSBnZXRTb2xUb2tlbkZyb21Ub2tlbk5hbWUoc2VuZFBhcmFtcy50b2tlbk5hbWUpO1xuICAgICAgICAgIGFzc2VydChjb2luIGluc3RhbmNlb2YgU29sQ29pbik7XG4gICAgICAgICAgY29uc3Qgc291cmNlQWRkcmVzcyA9IGF3YWl0IGdldEFzc29jaWF0ZWRUb2tlbkFjY291bnRBZGRyZXNzKGNvaW4udG9rZW5BZGRyZXNzLCB0aGlzLl9zZW5kZXIpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcy5Ub2tlblRyYW5zZmVyLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIGZyb21BZGRyZXNzOiB0aGlzLl9zZW5kZXIsXG4gICAgICAgICAgICAgIHRvQWRkcmVzczogc2VuZFBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICBhbW91bnQ6IHNlbmRQYXJhbXMuYW1vdW50LFxuICAgICAgICAgICAgICB0b2tlbk5hbWU6IHNlbmRQYXJhbXMudG9rZW5OYW1lLFxuICAgICAgICAgICAgICBzb3VyY2VBZGRyZXNzOiBzb3VyY2VBZGRyZXNzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcy5UcmFuc2ZlcixcbiAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICBmcm9tQWRkcmVzczogdGhpcy5fc2VuZGVyLFxuICAgICAgICAgICAgICB0b0FkZHJlc3M6IHNlbmRQYXJhbXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgYW1vdW50OiBzZW5kUGFyYW1zLmFtb3VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxufVxuIl19