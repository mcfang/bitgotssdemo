"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateOwnerAddress = exports.validateMintAddress = exports.getAssociatedTokenAccountAddress = exports.getSolTokenFromTokenName = exports.getSolTokenFromAddress = exports.validateAddress = exports.validateRawTransaction = exports.validateRawMsgInstruction = exports.validateIntructionTypes = exports.getInstructionType = exports.getTransactionType = exports.matchTransactionTypeByInstructionsOrder = exports.requiresAllSignatures = exports.countNotNullSignatures = exports.Uint8ArrayTobase58 = exports.base58ToUint8Array = exports.verifySignature = exports.isValidRawTransaction = exports.isValidMemo = exports.isValidStakingAmount = exports.isValidAmount = exports.isValidTransactionId = exports.isValidSignature = exports.isValidPublicKey = exports.isValidPrivateKey = exports.isValidBlockId = exports.isValidAddress = void 0;
const web3_js_1 = require("@solana/web3.js");
const bs58_1 = __importDefault(require("bs58"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const constants_1 = require("./constants");
const sdk_core_1 = require("@bitgo/sdk-core");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const spl_token_1 = require("@solana/spl-token");
const statics_1 = require("@bitgo/statics");
const assert_1 = __importDefault(require("assert"));
const DECODED_BLOCK_HASH_LENGTH = 32; // https://docs.solana.com/developing/programming-model/transactions#blockhash-format
const DECODED_SIGNATURE_LENGTH = 64; // https://docs.solana.com/terminology#signature
const BASE_58_ENCONDING_REGEX = '[1-9A-HJ-NP-Za-km-z]';
/** @inheritdoc */
function isValidAddress(address) {
    return isValidPublicKey(address);
}
exports.isValidAddress = isValidAddress;
/** @inheritdoc */
function isValidBlockId(hash) {
    try {
        return (!!hash && new RegExp(BASE_58_ENCONDING_REGEX).test(hash) && bs58_1.default.decode(hash).length === DECODED_BLOCK_HASH_LENGTH);
    }
    catch (e) {
        return false;
    }
}
exports.isValidBlockId = isValidBlockId;
/** @inheritdoc */
function isValidPrivateKey(prvKey) {
    try {
        const key = typeof prvKey === 'string' ? base58ToUint8Array(prvKey) : prvKey;
        return !!web3_js_1.Keypair.fromSecretKey(key);
    }
    catch (e) {
        return false;
    }
}
exports.isValidPrivateKey = isValidPrivateKey;
/** @inheritdoc */
function isValidPublicKey(pubKey) {
    try {
        if (sdk_core_1.isValidXpub(pubKey))
            return true;
        new web3_js_1.PublicKey(pubKey);
        return true;
    }
    catch {
        return false;
    }
}
exports.isValidPublicKey = isValidPublicKey;
/** @inheritdoc */
function isValidSignature(signature) {
    try {
        return !!signature && bs58_1.default.decode(signature).length === DECODED_SIGNATURE_LENGTH;
    }
    catch (e) {
        return false;
    }
}
exports.isValidSignature = isValidSignature;
/** @inheritdoc */
// TransactionId are the first signature on a Transaction
function isValidTransactionId(txId) {
    return isValidSignature(txId);
}
exports.isValidTransactionId = isValidTransactionId;
/**
 * Returns whether or not the string is a valid amount of lamports number
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidAmount(amount) {
    const bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThanOrEqualTo(0);
}
exports.isValidAmount = isValidAmount;
/**
 * Check if the string is a valid amount of lamports number on staking
 *
 * @param {string} amount - the string to validate
 * @returns {boolean} - the validation result
 */
function isValidStakingAmount(amount) {
    const bigNumberAmount = new bignumber_js_1.default(amount);
    return bigNumberAmount.isInteger() && bigNumberAmount.isGreaterThan(0);
}
exports.isValidStakingAmount = isValidStakingAmount;
/**
 * Check if this is a valid memo or not.
 *
 * @param memo - the memo string
 * @returns {boolean} - the validation result
 */
function isValidMemo(memo) {
    return Buffer.from(memo).length <= constants_1.MAX_MEMO_LENGTH;
}
exports.isValidMemo = isValidMemo;
/**
 * Checks if raw transaction can be deserialized
 *
 * @param {string} rawTransaction - transaction in base64 string format
 * @returns {boolean} - the validation result
 */
function isValidRawTransaction(rawTransaction) {
    try {
        const tx = web3_js_1.Transaction.from(Buffer.from(rawTransaction, 'base64'));
        tx.serialize({ requireAllSignatures: false, verifySignatures: false });
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.isValidRawTransaction = isValidRawTransaction;
/**
 * Verifies if signature for message is valid.
 *
 * @param {Buffer} serializedTx - tx as a base64 string
 * @param {string} signature - signature as a string
 * @param {string} publicKey - public key as base 58
 * @returns {Boolean} true if signature is valid.
 */
function verifySignature(serializedTx, signature, publicKey) {
    if (!isValidRawTransaction(serializedTx)) {
        throw new sdk_core_1.UtilsError('Invalid serializedTx');
    }
    if (!isValidPublicKey(publicKey)) {
        throw new sdk_core_1.UtilsError('Invalid publicKey');
    }
    if (!isValidSignature(signature)) {
        throw new sdk_core_1.UtilsError('Invalid signature');
    }
    const msg = web3_js_1.Transaction.from(Buffer.from(serializedTx, 'base64')).serializeMessage();
    const sig = base58ToUint8Array(signature);
    const pub = new web3_js_1.PublicKey(publicKey);
    return tweetnacl_1.default.sign.detached.verify(msg, sig, pub.toBuffer());
}
exports.verifySignature = verifySignature;
/**
 * Converts a base58 string into a Uint8Array.
 *
 * @param {string} input - a string in base58
 * @returns {Uint8Array} - an Uint8Array
 */
function base58ToUint8Array(input) {
    return new Uint8Array(bs58_1.default.decode(input));
}
exports.base58ToUint8Array = base58ToUint8Array;
/**
 * Converts a Uint8Array to a base58 string.
 *
 * @param {Uint8Array} input - an Uint8Array
 * @returns {string} - a string in base58
 */
function Uint8ArrayTobase58(input) {
    return bs58_1.default.encode(input);
}
exports.Uint8ArrayTobase58 = Uint8ArrayTobase58;
/**
 * Count the amount of signatures are not null.
 *
 * @param {SignaturePubkeyPair[]} signatures - an array of SignaturePubkeyPair
 * @returns {number} - the amount of valid signatures
 */
function countNotNullSignatures(signatures) {
    return signatures.filter((sig) => !!sig.signature).length;
}
exports.countNotNullSignatures = countNotNullSignatures;
/**
 * Check if all signatures are completed.
 *
 * @param {SignaturePubkeyPair[]} signatures - signatures
 * @returns {boolean}
 */
function requiresAllSignatures(signatures) {
    return signatures.length > 0 && countNotNullSignatures(signatures) === signatures.length;
}
exports.requiresAllSignatures = requiresAllSignatures;
/**
 * Check the transaction type matching instructions by order. Memo and AdvanceNonceAccount instructions
 * are ignored.
 *
 * @param {TransactionInstruction[]} instructions - the array of supported Solana instructions to be parsed
 * @param {Record<string, number>} instructionIndexes - the instructions indexes of the current transaction
 * @returns true if it matches by order.
 */
function matchTransactionTypeByInstructionsOrder(instructions, instructionIndexes) {
    const instructionsCopy = [...instructions]; // Make a copy since we may modify the array below
    // AdvanceNonceAccount is optional and the first instruction added, it does not matter to match the type
    if (instructionsCopy.length > 0) {
        if (getInstructionType(instructions[0]) === 'AdvanceNonceAccount') {
            instructionsCopy.shift();
        }
    }
    // Memo is optional and the last instruction added, it does not matter to match the type
    // Why have it in instructionKeys if we are going to ignore it?
    const instructionsKeys = Object.keys(instructionIndexes);
    if (instructionsKeys[instructionsKeys.length - 1] === 'Memo') {
        instructionsKeys.pop();
    }
    // Check instructions by order using the index.
    for (const keyName of instructionsKeys) {
        const result = getInstructionType(instructionsCopy[instructionIndexes[keyName]]);
        if (result !== keyName) {
            return false;
        }
    }
    return true;
}
exports.matchTransactionTypeByInstructionsOrder = matchTransactionTypeByInstructionsOrder;
/**
 * Returns the transaction Type based on the  transaction instructions.
 * Wallet initialization, Transfer and Staking transactions are supported.
 *
 * @param {SolTransaction} transaction - the solana transaction
 * @returns {TransactionType} - the type of transaction
 */
function getTransactionType(transaction) {
    const { instructions } = transaction;
    if (validateRawMsgInstruction(instructions)) {
        return sdk_core_1.TransactionType.StakingAuthorizeRaw;
    }
    validateIntructionTypes(instructions);
    for (const instruction of instructions) {
        const instructionType = getInstructionType(instruction);
        if (instructionType === constants_1.ValidInstructionTypesEnum.Transfer ||
            instructionType === constants_1.ValidInstructionTypesEnum.TokenTransfer) {
            return sdk_core_1.TransactionType.Send;
        }
    }
    if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.walletInitInstructionIndexes)) {
        return sdk_core_1.TransactionType.WalletInitialization;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingActivateInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingActivate;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingAuthorizeInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingAuthorize;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingDelegateInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingDelegate;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingDeactivateInstructionsIndexes) ||
        matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingPartialDeactivateInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingDeactivate;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.stakingWithdrawInstructionsIndexes)) {
        return sdk_core_1.TransactionType.StakingWithdraw;
    }
    else if (matchTransactionTypeByInstructionsOrder(instructions, constants_1.ataInitInstructionIndexes)) {
        return sdk_core_1.TransactionType.AssociatedTokenAccountInitialization;
    }
    else {
        throw new sdk_core_1.NotSupported('Invalid transaction, transaction not supported or invalid');
    }
}
exports.getTransactionType = getTransactionType;
/**
 * Returns the instruction Type based on the solana instructions.
 * Throws if the solana instruction program is not supported
 *
 * @param {TransactionInstruction} instruction - a solana instruction
 * @returns {ValidInstructionTypes} - a solana instruction type
 */
function getInstructionType(instruction) {
    switch (instruction.programId.toString()) {
        case new web3_js_1.PublicKey(constants_1.MEMO_PROGRAM_PK).toString():
            return 'Memo';
        case web3_js_1.SystemProgram.programId.toString():
            return web3_js_1.SystemInstruction.decodeInstructionType(instruction);
        case spl_token_1.TOKEN_PROGRAM_ID.toString():
            return 'TokenTransfer';
        case web3_js_1.StakeProgram.programId.toString():
            return web3_js_1.StakeInstruction.decodeInstructionType(instruction);
        case spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID.toString():
            // TODO: change this when @spl-token supports decoding associated token instructions
            if (instruction.data.length === 0) {
                return 'InitializeAssociatedTokenAccount';
            }
            else {
                throw new sdk_core_1.NotSupported('Invalid transaction, instruction program id not supported: ' + instruction.programId.toString());
            }
        default:
            throw new sdk_core_1.NotSupported('Invalid transaction, instruction program id not supported: ' + instruction.programId.toString());
    }
}
exports.getInstructionType = getInstructionType;
/**
 * Validate solana instructions types to see if they are supported by the builder.
 * Throws if the instruction type is invalid.
 *
 * @param {TransactionInstruction} instructions - a solana instruction
 * @returns {void}
 */
function validateIntructionTypes(instructions) {
    for (const instruction of instructions) {
        if (!constants_1.VALID_SYSTEM_INSTRUCTION_TYPES.includes(getInstructionType(instruction))) {
            throw new sdk_core_1.NotSupported('Invalid transaction, instruction type not supported: ' + getInstructionType(instruction));
        }
    }
}
exports.validateIntructionTypes = validateIntructionTypes;
/**
 * Validate solana instructions match raw msg authorize transaction
 *
 * @param {TransactionInstruction} instructions - a solana instruction
 * @returns {boolean} true if the instructions match the raw msg authorize transaction
 */
function validateRawMsgInstruction(instructions) {
    // as web3.js cannot decode authorize instruction from CLI, we need to check it manually first
    if (instructions.length === 2) {
        const programId1 = instructions[0].programId.toString();
        const programId2 = instructions[1].programId.toString();
        if (programId1 === web3_js_1.SystemProgram.programId.toString() && programId2 === web3_js_1.StakeProgram.programId.toString()) {
            const instructionName1 = web3_js_1.SystemInstruction.decodeInstructionType(instructions[0]);
            const data = instructions[1].data.toString('hex');
            if (instructionName1 === constants_1.nonceAdvanceInstruction && data === constants_1.validInstructionData) {
                return true;
            }
        }
    }
    return false;
}
exports.validateRawMsgInstruction = validateRawMsgInstruction;
/**
 * Check the raw transaction has a valid format in the blockchain context, throw otherwise.
 *
 * @param {string} rawTransaction - Transaction in base64 string  format
 */
function validateRawTransaction(rawTransaction) {
    if (!rawTransaction) {
        throw new sdk_core_1.ParseTransactionError('Invalid raw transaction: Undefined');
    }
    if (!isValidRawTransaction(rawTransaction)) {
        throw new sdk_core_1.ParseTransactionError('Invalid raw transaction');
    }
}
exports.validateRawTransaction = validateRawTransaction;
/**
 * Validates address to check if it exists and is a valid Solana public key
 *
 * @param {string} address The address to be validated
 * @param {string} fieldName Name of the field to validate, its needed to return which field is failing on case of error.
 */
function validateAddress(address, fieldName) {
    if (!address || !isValidPublicKey(address)) {
        throw new sdk_core_1.BuildTransactionError(`Invalid or missing ${fieldName}, got: ${address}`);
    }
}
exports.validateAddress = validateAddress;
/**
 * Get the statics coin object matching a given Solana token address if it exists
 *
 * @param tokenAddress The token address to match against
 * @param network Solana Mainnet or Testnet
 * @returns statics BaseCoin object for the matching token
 */
function getSolTokenFromAddress(tokenAddress, network) {
    const tokens = statics_1.coins.filter((coin) => {
        if (coin instanceof statics_1.SolCoin) {
            return coin.network.type === network.type && coin.tokenAddress.toLowerCase() === tokenAddress.toLowerCase();
        }
        return false;
    });
    const tokensArray = tokens.map((token) => token);
    if (tokensArray.length >= 1) {
        // there should never be two tokens with the same contract address, so we assert that here
        assert_1.default(tokensArray.length === 1);
        return tokensArray[0];
    }
    return undefined;
}
exports.getSolTokenFromAddress = getSolTokenFromAddress;
/**
 * Get the solana token object from token name
 * @param tokenName The token name to match against
 * */
function getSolTokenFromTokenName(tokenName) {
    try {
        const token = statics_1.coins.get(tokenName);
        if (!(token.isToken && token instanceof statics_1.SolCoin)) {
            return undefined;
        }
        return token;
    }
    catch (e) {
        if (!(e instanceof statics_1.CoinNotDefinedError)) {
            throw e;
        }
        return undefined;
    }
}
exports.getSolTokenFromTokenName = getSolTokenFromTokenName;
/**
 * Get the solana associated token account address
 * @param tokenAddress The token address
 * @param ownerAddress The owner of the associated token account
 * @returns The associated token account address
 * */
async function getAssociatedTokenAccountAddress(tokenAddress, ownerAddress) {
    const ownerPublicKey = new web3_js_1.PublicKey(ownerAddress);
    // tokenAddress are not on ed25519 curve, so they can't be used as ownerAddress
    if (!web3_js_1.PublicKey.isOnCurve(ownerPublicKey.toBuffer())) {
        throw new sdk_core_1.UtilsError('Invalid ownerAddress - address off ed25519 curve, got: ' + ownerAddress);
    }
    const ataAddress = await spl_token_1.getAssociatedTokenAddress(new web3_js_1.PublicKey(tokenAddress), ownerPublicKey);
    return ataAddress.toString();
}
exports.getAssociatedTokenAccountAddress = getAssociatedTokenAccountAddress;
function validateMintAddress(mintAddress) {
    if (!mintAddress || !isValidAddress(mintAddress)) {
        throw new sdk_core_1.BuildTransactionError('Invalid or missing mintAddress, got: ' + mintAddress);
    }
}
exports.validateMintAddress = validateMintAddress;
function validateOwnerAddress(ownerAddress) {
    if (!ownerAddress || !isValidAddress(ownerAddress)) {
        throw new sdk_core_1.BuildTransactionError('Invalid or missing ownerAddress, got: ' + ownerAddress);
    }
}
exports.validateOwnerAddress = validateOwnerAddress;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDZDQVV5QjtBQUN6QixnREFBd0I7QUFDeEIsZ0VBQXFDO0FBQ3JDLDJDQWVxQjtBQUNyQiw4Q0FPeUI7QUFFekIsMERBQTZCO0FBQzdCLGlEQUE2RztBQUM3Ryw0Q0FBNEY7QUFDNUYsb0RBQTRCO0FBRTVCLE1BQU0seUJBQXlCLEdBQUcsRUFBRSxDQUFDLENBQUMscUZBQXFGO0FBQzNILE1BQU0sd0JBQXdCLEdBQUcsRUFBRSxDQUFDLENBQUMsZ0RBQWdEO0FBQ3JGLE1BQU0sdUJBQXVCLEdBQUcsc0JBQXNCLENBQUM7QUFFdkQsa0JBQWtCO0FBQ2xCLFNBQWdCLGNBQWMsQ0FBQyxPQUFlO0lBQzVDLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQUZELHdDQUVDO0FBRUQsa0JBQWtCO0FBQ2xCLFNBQWdCLGNBQWMsQ0FBQyxJQUFZO0lBQ3pDLElBQUk7UUFDRixPQUFPLENBQ0wsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxjQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyx5QkFBeUIsQ0FDbkgsQ0FBQztLQUNIO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0gsQ0FBQztBQVJELHdDQVFDO0FBRUQsa0JBQWtCO0FBQ2xCLFNBQWdCLGlCQUFpQixDQUFDLE1BQTJCO0lBQzNELElBQUk7UUFDRixNQUFNLEdBQUcsR0FBZSxPQUFPLE1BQU0sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFDekYsT0FBTyxD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QUFDLENBQUM7S0FDeEY7QUFDSCxDQUFDO0FBSkQsa0RBSUM7QUFFRCxTQUFnQixvQkFBb0IsQ0FBQyxZQUFvQjtJQUN2RCxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxFQUFFO1FBQ2xELE1BQU0sSUFBSSxnQ0FBcUIsQ0FBQyx3Q0FBd0MsR0FBRyxZQUFZLENBQUMsQ0FBQztLQUMxRjtBQUNILENBQUM7QUFKRCxvREFJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEtleXBhaXIsXG4gIFB1YmxpY0tleSxcbiAgU2lnbmF0dXJlUHVia2V5UGFpcixcbiAgU3Rha2VJbnN0cnVjdGlvbixcbiAgU3Rha2VQcm9ncmFtLFxuICBTeXN0ZW1JbnN0cnVjdGlvbixcbiAgU3lzdGVtUHJvZ3JhbSxcbiAgVHJhbnNhY3Rpb24gYXMgU29sVHJhbnNhY3Rpb24sXG4gIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sXG59IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgYnM1OCBmcm9tICdiczU4JztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7XG4gIGF0YUluaXRJbnN0cnVjdGlvbkluZGV4ZXMsXG4gIE1BWF9NRU1PX0xFTkdUSCxcbiAgTUVNT19QUk9HUkFNX1BLLFxuICBzdGFraW5nQWN0aXZhdGVJbnN0cnVjdGlvbnNJbmRleGVzLFxuICBzdGFraW5nRGVhY3RpdmF0ZUluc3RydWN0aW9uc0luZGV4ZXMsXG4gIHN0YWtpbmdQYXJ0aWFsRGVhY3RpdmF0ZUluc3RydWN0aW9uc0luZGV4ZXMsXG4gIHN0YWtpbmdXaXRoZHJhd0luc3RydWN0aW9uc0luZGV4ZXMsXG4gIHN0YWtpbmdBdXRob3JpemVJbnN0cnVjdGlvbnNJbmRleGVzLFxuICBzdGFraW5nRGVsZWdhdGVJbnN0cnVjdGlvbnNJbmRleGVzLFxuICBWQUxJRF9TWVNURU1fSU5TVFJVQ1RJT05fVFlQRVMsXG4gIFZhbGlkSW5zdHJ1Y3Rpb25UeXBlc0VudW0sXG4gIHdhbGxldEluaXRJbnN0cnVjdGlvbkluZGV4ZXMsXG4gIG5vbmNlQWR2YW5jZUluc3RydWN0aW9uLFxuICB2YWxpZEluc3RydWN0aW9uRGF0YSxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgQnVpbGRUcmFuc2FjdGlvbkVycm9yLFxuICBpc1ZhbGlkWHB1YixcbiAgTm90U3VwcG9ydGVkLFxuICBQYXJzZVRyYW5zYWN0aW9uRXJyb3IsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgVXRpbHNFcnJvcixcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IFZhbGlkSW5zdHJ1Y3Rpb25UeXBlcyB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IG5hY2wgZnJvbSAndHdlZXRuYWNsJztcbmltcG9ydCB7IEFTU09DSUFURURfVE9LRU5fUFJPR1JBTV9JRCwgVE9LRU5fUFJPR1JBTV9JRCwgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzcyB9IGZyb20gJ0Bzb2xhbmEvc3BsLXRva2VuJztcbmltcG9ydCB7IEJhc2VDb2luLCBCYXNlTmV0d29yaywgQ29pbk5vdERlZmluZWRFcnJvciwgY29pbnMsIFNvbENvaW4gfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmNvbnN0IERFQ09ERURfQkxPQ0tfSEFTSF9MRU5HVEggPSAzMjsgLy8gaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vZGV2ZWxvcGluZy9wcm9ncmFtbWluZy1tb2RlbC90cmFuc2FjdGlvbnMjYmxvY2toYXNoLWZvcm1hdFxuY29uc3QgREVDT0RFRF9TSUdOQVRVUkVfTEVOR1RIID0gNjQ7IC8vIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I3NpZ25hdHVyZVxuY29uc3QgQkFTRV81OF9FTkNPTkRJTkdfUkVHRVggPSAnWzEtOUEtSEotTlAtWmEta20tel0nO1xuXG4vKiogQGluaGVyaXRkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRQdWJsaWNLZXkoYWRkcmVzcyk7XG59XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRCbG9ja0lkKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICAhIWhhc2ggJiYgbmV3IFJlZ0V4cChCQVNFXzU4X0VOQ09ORElOR19SRUdFWCkudGVzdChoYXNoKSAmJiBiczU4LmRlY29kZShoYXNoKS5sZW5ndGggPT09IERFQ09ERURfQkxPQ0tfSEFTSF9MRU5HVEhcbiAgICApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKiBAaW5oZXJpdGRvYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQcml2YXRlS2V5KHBydktleTogc3RyaW5nIHwgVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IGtleTogVWludDhBcnJheSA9IHR5cGVvZiBwcnZLZXkgPT09ICdzdHJpbmcnID8gYmFzZTU4VG9VaW50OEFycmF5KHBydktleSkgOiBwcnZLZXk7XG4gICAgcmV0dXJuICEhS2V5cGFpci5mcm9tU2VjcmV0S2V5KGtleSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqIEBpbmhlcml0ZG9jICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFB1YmxpY0tleShwdWJLZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGlmIChpc1ZhbGlkWHB1YihwdWJLZXkpKSByZXR1cm4gdHJ1ZTtcbiAgICBuZXcgUHVibGljS2V5KHB1YktleSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKiogQGluaGVyaXRkb2MgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKHNpZ25hdHVyZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhc2lnbmF0dXJlICYmIGJzNTguZGVjb2RlKHNpZ25hdHVyZSkubGVuZ3RoID09PSBERUNPREVEX1NJR05BVFVSRV9MRU5HVEg7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqIEBpbmhlcml0ZG9jICovXG4vLyBUcmFuc2FjdGlvbklkIGFyZSB0aGUgZmlyc3Qgc2lnbmF0dXJlIG9uIGEgVHJhbnNhY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkVHJhbnNhY3Rpb25JZCh0eElkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRTaWduYXR1cmUodHhJZCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgYW1vdW50IG9mIGxhbXBvcnRzIG51bWJlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbW91bnQgLSB0aGUgc3RyaW5nIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBbW91bnQoYW1vdW50OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgYmlnTnVtYmVyQW1vdW50ID0gbmV3IEJpZ051bWJlcihhbW91bnQpO1xuICByZXR1cm4gYmlnTnVtYmVyQW1vdW50LmlzSW50ZWdlcigpICYmIGJpZ051bWJlckFtb3VudC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvKDApO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBhbW91bnQgb2YgbGFtcG9ydHMgbnVtYmVyIG9uIHN0YWtpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IC0gdGhlIHN0cmluZyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkU3Rha2luZ0Ftb3VudChhbW91bnQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBiaWdOdW1iZXJBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGFtb3VudCk7XG4gIHJldHVybiBiaWdOdW1iZXJBbW91bnQuaXNJbnRlZ2VyKCkgJiYgYmlnTnVtYmVyQW1vdW50LmlzR3JlYXRlclRoYW4oMCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBpcyBhIHZhbGlkIG1lbW8gb3Igbm90LlxuICpcbiAqIEBwYXJhbSBtZW1vIC0gdGhlIG1lbW8gc3RyaW5nXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0aGUgdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRNZW1vKG1lbW86IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gQnVmZmVyLmZyb20obWVtbykubGVuZ3RoIDw9IE1BWF9NRU1PX0xFTkdUSDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcmF3IHRyYW5zYWN0aW9uIGNhbiBiZSBkZXNlcmlhbGl6ZWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3VHJhbnNhY3Rpb24gLSB0cmFuc2FjdGlvbiBpbiBiYXNlNjQgc3RyaW5nIGZvcm1hdFxuICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb246IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IHR4ID0gU29sVHJhbnNhY3Rpb24uZnJvbShCdWZmZXIuZnJvbShyYXdUcmFuc2FjdGlvbiwgJ2Jhc2U2NCcpKTtcbiAgICB0eC5zZXJpYWxpemUoeyByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2UsIHZlcmlmeVNpZ25hdHVyZXM6IGZhbHNlIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVmVyaWZpZXMgaWYgc2lnbmF0dXJlIGZvciBtZXNzYWdlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBzZXJpYWxpemVkVHggLSB0eCBhcyBhIGJhc2U2NCBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWduYXR1cmUgLSBzaWduYXR1cmUgYXMgYSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNLZXkgLSBwdWJsaWMga2V5IGFzIGJhc2UgNThcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZShzZXJpYWxpemVkVHg6IHN0cmluZywgc2lnbmF0dXJlOiBzdHJpbmcsIHB1YmxpY0tleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICghaXNWYWxpZFJhd1RyYW5zYWN0aW9uKHNlcmlhbGl6ZWRUeCkpIHtcbiAgICB0aHJvdyBuZXcgVXRpbHNFcnJvcignSW52YWxpZCBzZXJpYWxpemVkVHgnKTtcbiAgfVxuICBpZiAoIWlzVmFsaWRQdWJsaWNLZXkocHVibGljS2V5KSkge1xuICAgIHRocm93IG5ldyBVdGlsc0Vycm9yKCdJbnZhbGlkIHB1YmxpY0tleScpO1xuICB9XG4gIGlmICghaXNWYWxpZFNpZ25hdHVyZShzaWduYXR1cmUpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlJyk7XG4gIH1cbiAgY29uc3QgbXNnID0gU29sVHJhbnNhY3Rpb24uZnJvbShCdWZmZXIuZnJvbShzZXJpYWxpemVkVHgsICdiYXNlNjQnKSkuc2VyaWFsaXplTWVzc2FnZSgpO1xuICBjb25zdCBzaWcgPSBiYXNlNThUb1VpbnQ4QXJyYXkoc2lnbmF0dXJlKTtcbiAgY29uc3QgcHViID0gbmV3IFB1YmxpY0tleShwdWJsaWNLZXkpO1xuICByZXR1cm4gbmFjbC5zaWduLmRldGFjaGVkLnZlcmlmeShtc2csIHNpZywgcHViLnRvQnVmZmVyKCkpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzZTU4IHN0cmluZyBpbnRvIGEgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBhIHN0cmluZyBpbiBiYXNlNThcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSAtIGFuIFVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U1OFRvVWludDhBcnJheShpbnB1dDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShiczU4LmRlY29kZShpbnB1dCkpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIGJhc2U1OCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dCAtIGFuIFVpbnQ4QXJyYXlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gYSBzdHJpbmcgaW4gYmFzZTU4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBVaW50OEFycmF5VG9iYXNlNTgoaW5wdXQ6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gYnM1OC5lbmNvZGUoaW5wdXQpO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBhbW91bnQgb2Ygc2lnbmF0dXJlcyBhcmUgbm90IG51bGwuXG4gKlxuICogQHBhcmFtIHtTaWduYXR1cmVQdWJrZXlQYWlyW119IHNpZ25hdHVyZXMgLSBhbiBhcnJheSBvZiBTaWduYXR1cmVQdWJrZXlQYWlyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAtIHRoZSBhbW91bnQgb2YgdmFsaWQgc2lnbmF0dXJlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY291bnROb3ROdWxsU2lnbmF0dXJlcyhzaWduYXR1cmVzOiBTaWduYXR1cmVQdWJrZXlQYWlyW10pOiBudW1iZXIge1xuICByZXR1cm4gc2lnbmF0dXJlcy5maWx0ZXIoKHNpZykgPT4gISFzaWcuc2lnbmF0dXJlKS5sZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYWxsIHNpZ25hdHVyZXMgYXJlIGNvbXBsZXRlZC5cbiAqXG4gKiBAcGFyYW0ge1NpZ25hdHVyZVB1YmtleVBhaXJbXX0gc2lnbmF0dXJlcyAtIHNpZ25hdHVyZXNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZXNBbGxTaWduYXR1cmVzKHNpZ25hdHVyZXM6IFNpZ25hdHVyZVB1YmtleVBhaXJbXSk6IGJvb2xlYW4ge1xuICByZXR1cm4gc2lnbmF0dXJlcy5sZW5ndGggPiAwICYmIGNvdW50Tm90TnVsbFNpZ25hdHVyZXMoc2lnbmF0dXJlcykgPT09IHNpZ25hdHVyZXMubGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrIHRoZSB0cmFuc2FjdGlvbiB0eXBlIG1hdGNoaW5nIGluc3RydWN0aW9ucyBieSBvcmRlci4gTWVtbyBhbmQgQWR2YW5jZU5vbmNlQWNjb3VudCBpbnN0cnVjdGlvbnNcbiAqIGFyZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25JbnN0cnVjdGlvbltdfSBpbnN0cnVjdGlvbnMgLSB0aGUgYXJyYXkgb2Ygc3VwcG9ydGVkIFNvbGFuYSBpbnN0cnVjdGlvbnMgdG8gYmUgcGFyc2VkXG4gKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIG51bWJlcj59IGluc3RydWN0aW9uSW5kZXhlcyAtIHRoZSBpbnN0cnVjdGlvbnMgaW5kZXhlcyBvZiB0aGUgY3VycmVudCB0cmFuc2FjdGlvblxuICogQHJldHVybnMgdHJ1ZSBpZiBpdCBtYXRjaGVzIGJ5IG9yZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hUcmFuc2FjdGlvblR5cGVCeUluc3RydWN0aW9uc09yZGVyKFxuICBpbnN0cnVjdGlvbnM6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXSxcbiAgaW5zdHJ1Y3Rpb25JbmRleGVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+XG4pOiBib29sZWFuIHtcbiAgY29uc3QgaW5zdHJ1Y3Rpb25zQ29weSA9IFsuLi5pbnN0cnVjdGlvbnNdOyAvLyBNYWtlIGEgY29weSBzaW5jZSB3ZSBtYXkgbW9kaWZ5IHRoZSBhcnJheSBiZWxvd1xuICAvLyBBZHZhbmNlTm9uY2VBY2NvdW50IGlzIG9wdGlvbmFsIGFuZCB0aGUgZmlyc3QgaW5zdHJ1Y3Rpb24gYWRkZWQsIGl0IGRvZXMgbm90IG1hdHRlciB0byBtYXRjaCB0aGUgdHlwZVxuICBpZiAoaW5zdHJ1Y3Rpb25zQ29weS5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGdldEluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbnNbMF0pID09PSAnQWR2YW5jZU5vbmNlQWNjb3VudCcpIHtcbiAgICAgIGluc3RydWN0aW9uc0NvcHkuc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICAvLyBNZW1vIGlzIG9wdGlvbmFsIGFuZCB0aGUgbGFzdCBpbnN0cnVjdGlvbiBhZGRlZCwgaXQgZG9lcyBub3QgbWF0dGVyIHRvIG1hdGNoIHRoZSB0eXBlXG4gIC8vIFdoeSBoYXZlIGl0IGluIGluc3RydWN0aW9uS2V5cyBpZiB3ZSBhcmUgZ29pbmcgdG8gaWdub3JlIGl0P1xuICBjb25zdCBpbnN0cnVjdGlvbnNLZXlzID0gT2JqZWN0LmtleXMoaW5zdHJ1Y3Rpb25JbmRleGVzKTtcbiAgaWYgKGluc3RydWN0aW9uc0tleXNbaW5zdHJ1Y3Rpb25zS2V5cy5sZW5ndGggLSAxXSA9PT0gJ01lbW8nKSB7XG4gICAgaW5zdHJ1Y3Rpb25zS2V5cy5wb3AoKTtcbiAgfVxuXG4gIC8vIENoZWNrIGluc3RydWN0aW9ucyBieSBvcmRlciB1c2luZyB0aGUgaW5kZXguXG4gIGZvciAoY29uc3Qga2V5TmFtZSBvZiBpbnN0cnVjdGlvbnNLZXlzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0SW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uc0NvcHlbaW5zdHJ1Y3Rpb25JbmRleGVzW2tleU5hbWVdXSk7XG4gICAgaWYgKHJlc3VsdCAhPT0ga2V5TmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBUeXBlIGJhc2VkIG9uIHRoZSAgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb25zLlxuICogV2FsbGV0IGluaXRpYWxpemF0aW9uLCBUcmFuc2ZlciBhbmQgU3Rha2luZyB0cmFuc2FjdGlvbnMgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBAcGFyYW0ge1NvbFRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAtIHRoZSBzb2xhbmEgdHJhbnNhY3Rpb25cbiAqIEByZXR1cm5zIHtUcmFuc2FjdGlvblR5cGV9IC0gdGhlIHR5cGUgb2YgdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uVHlwZSh0cmFuc2FjdGlvbjogU29sVHJhbnNhY3Rpb24pOiBUcmFuc2FjdGlvblR5cGUge1xuICBjb25zdCB7IGluc3RydWN0aW9ucyB9ID0gdHJhbnNhY3Rpb247XG4gIGlmICh2YWxpZGF0ZVJhd01zZ0luc3RydWN0aW9uKGluc3RydWN0aW9ucykpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBdXRob3JpemVSYXc7XG4gIH1cbiAgdmFsaWRhdGVJbnRydWN0aW9uVHlwZXMoaW5zdHJ1Y3Rpb25zKTtcbiAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiBpbnN0cnVjdGlvbnMpIHtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGUgPSBnZXRJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pO1xuICAgIGlmIChcbiAgICAgIGluc3RydWN0aW9uVHlwZSA9PT0gVmFsaWRJbnN0cnVjdGlvblR5cGVzRW51bS5UcmFuc2ZlciB8fFxuICAgICAgaW5zdHJ1Y3Rpb25UeXBlID09PSBWYWxpZEluc3RydWN0aW9uVHlwZXNFbnVtLlRva2VuVHJhbnNmZXJcbiAgICApIHtcbiAgICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU2VuZDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihpbnN0cnVjdGlvbnMsIHdhbGxldEluaXRJbnN0cnVjdGlvbkluZGV4ZXMpKSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbjtcbiAgfSBlbHNlIGlmIChtYXRjaFRyYW5zYWN0aW9uVHlwZUJ5SW5zdHJ1Y3Rpb25zT3JkZXIoaW5zdHJ1Y3Rpb25zLCBzdGFraW5nQWN0aXZhdGVJbnN0cnVjdGlvbnNJbmRleGVzKSkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0FjdGl2YXRlO1xuICB9IGVsc2UgaWYgKG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihpbnN0cnVjdGlvbnMsIHN0YWtpbmdBdXRob3JpemVJbnN0cnVjdGlvbnNJbmRleGVzKSkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0F1dGhvcml6ZTtcbiAgfSBlbHNlIGlmIChtYXRjaFRyYW5zYWN0aW9uVHlwZUJ5SW5zdHJ1Y3Rpb25zT3JkZXIoaW5zdHJ1Y3Rpb25zLCBzdGFraW5nRGVsZWdhdGVJbnN0cnVjdGlvbnNJbmRleGVzKSkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0RlbGVnYXRlO1xuICB9IGVsc2UgaWYgKFxuICAgIG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihpbnN0cnVjdGlvbnMsIHN0YWtpbmdEZWFjdGl2YXRlSW5zdHJ1Y3Rpb25zSW5kZXhlcykgfHxcbiAgICBtYXRjaFRyYW5zYWN0aW9uVHlwZUJ5SW5zdHJ1Y3Rpb25zT3JkZXIoaW5zdHJ1Y3Rpb25zLCBzdGFraW5nUGFydGlhbERlYWN0aXZhdGVJbnN0cnVjdGlvbnNJbmRleGVzKVxuICApIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdEZWFjdGl2YXRlO1xuICB9IGVsc2UgaWYgKG1hdGNoVHJhbnNhY3Rpb25UeXBlQnlJbnN0cnVjdGlvbnNPcmRlcihpbnN0cnVjdGlvbnMsIHN0YWtpbmdXaXRoZHJhd0luc3RydWN0aW9uc0luZGV4ZXMpKSB7XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nV2l0aGRyYXc7XG4gIH0gZWxzZSBpZiAobWF0Y2hUcmFuc2FjdGlvblR5cGVCeUluc3RydWN0aW9uc09yZGVyKGluc3RydWN0aW9ucywgYXRhSW5pdEluc3RydWN0aW9uSW5kZXhlcykpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLkFzc29jaWF0ZWRUb2tlbkFjY291bnRJbml0aWFsaXphdGlvbjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkKCdJbnZhbGlkIHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbiBub3Qgc3VwcG9ydGVkIG9yIGludmFsaWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGluc3RydWN0aW9uIFR5cGUgYmFzZWQgb24gdGhlIHNvbGFuYSBpbnN0cnVjdGlvbnMuXG4gKiBUaHJvd3MgaWYgdGhlIHNvbGFuYSBpbnN0cnVjdGlvbiBwcm9ncmFtIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uSW5zdHJ1Y3Rpb259IGluc3RydWN0aW9uIC0gYSBzb2xhbmEgaW5zdHJ1Y3Rpb25cbiAqIEByZXR1cm5zIHtWYWxpZEluc3RydWN0aW9uVHlwZXN9IC0gYSBzb2xhbmEgaW5zdHJ1Y3Rpb24gdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uKTogVmFsaWRJbnN0cnVjdGlvblR5cGVzIHtcbiAgc3dpdGNoIChpbnN0cnVjdGlvbi5wcm9ncmFtSWQudG9TdHJpbmcoKSkge1xuICAgIGNhc2UgbmV3IFB1YmxpY0tleShNRU1PX1BST0dSQU1fUEspLnRvU3RyaW5nKCk6XG4gICAgICByZXR1cm4gJ01lbW8nO1xuICAgIGNhc2UgU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQudG9TdHJpbmcoKTpcbiAgICAgIHJldHVybiBTeXN0ZW1JbnN0cnVjdGlvbi5kZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pO1xuICAgIGNhc2UgVE9LRU5fUFJPR1JBTV9JRC50b1N0cmluZygpOlxuICAgICAgcmV0dXJuICdUb2tlblRyYW5zZmVyJztcbiAgICBjYXNlIFN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQudG9TdHJpbmcoKTpcbiAgICAgIHJldHVybiBTdGFrZUluc3RydWN0aW9uLmRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbik7XG4gICAgY2FzZSBBU1NPQ0lBVEVEX1RPS0VOX1BST0dSQU1fSUQudG9TdHJpbmcoKTpcbiAgICAgIC8vIFRPRE86IGNoYW5nZSB0aGlzIHdoZW4gQHNwbC10b2tlbiBzdXBwb3J0cyBkZWNvZGluZyBhc3NvY2lhdGVkIHRva2VuIGluc3RydWN0aW9uc1xuICAgICAgaWYgKGluc3RydWN0aW9uLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnSW5pdGlhbGl6ZUFzc29jaWF0ZWRUb2tlbkFjY291bnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZChcbiAgICAgICAgICAnSW52YWxpZCB0cmFuc2FjdGlvbiwgaW5zdHJ1Y3Rpb24gcHJvZ3JhbSBpZCBub3Qgc3VwcG9ydGVkOiAnICsgaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLnRvU3RyaW5nKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZChcbiAgICAgICAgJ0ludmFsaWQgdHJhbnNhY3Rpb24sIGluc3RydWN0aW9uIHByb2dyYW0gaWQgbm90IHN1cHBvcnRlZDogJyArIGluc3RydWN0aW9uLnByb2dyYW1JZC50b1N0cmluZygpXG4gICAgICApO1xuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgc29sYW5hIGluc3RydWN0aW9ucyB0eXBlcyB0byBzZWUgaWYgdGhleSBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBidWlsZGVyLlxuICogVGhyb3dzIGlmIHRoZSBpbnN0cnVjdGlvbiB0eXBlIGlzIGludmFsaWQuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBpbnN0cnVjdGlvbnMgLSBhIHNvbGFuYSBpbnN0cnVjdGlvblxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUludHJ1Y3Rpb25UeXBlcyhpbnN0cnVjdGlvbnM6IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb25bXSk6IHZvaWQge1xuICBmb3IgKGNvbnN0IGluc3RydWN0aW9uIG9mIGluc3RydWN0aW9ucykge1xuICAgIGlmICghVkFMSURfU1lTVEVNX0lOU1RSVUNUSU9OX1RZUEVTLmluY2x1ZGVzKGdldEluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikpKSB7XG4gICAgICB0aHJvdyBuZXcgTm90U3VwcG9ydGVkKCdJbnZhbGlkIHRyYW5zYWN0aW9uLCBpbnN0cnVjdGlvbiB0eXBlIG5vdCBzdXBwb3J0ZWQ6ICcgKyBnZXRJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBzb2xhbmEgaW5zdHJ1Y3Rpb25zIG1hdGNoIHJhdyBtc2cgYXV0aG9yaXplIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbkluc3RydWN0aW9ufSBpbnN0cnVjdGlvbnMgLSBhIHNvbGFuYSBpbnN0cnVjdGlvblxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGluc3RydWN0aW9ucyBtYXRjaCB0aGUgcmF3IG1zZyBhdXRob3JpemUgdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUmF3TXNnSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25zOiBUcmFuc2FjdGlvbkluc3RydWN0aW9uW10pOiBib29sZWFuIHtcbiAgLy8gYXMgd2ViMy5qcyBjYW5ub3QgZGVjb2RlIGF1dGhvcml6ZSBpbnN0cnVjdGlvbiBmcm9tIENMSSwgd2UgbmVlZCB0byBjaGVjayBpdCBtYW51YWxseSBmaXJzdFxuICBpZiAoaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHByb2dyYW1JZDEgPSBpbnN0cnVjdGlvbnNbMF0ucHJvZ3JhbUlkLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgcHJvZ3JhbUlkMiA9IGluc3RydWN0aW9uc1sxXS5wcm9ncmFtSWQudG9TdHJpbmcoKTtcbiAgICBpZiAocHJvZ3JhbUlkMSA9PT0gU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQudG9TdHJpbmcoKSAmJiBwcm9ncmFtSWQyID09PSBTdGFrZVByb2dyYW0ucHJvZ3JhbUlkLnRvU3RyaW5nKCkpIHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uTmFtZTEgPSBTeXN0ZW1JbnN0cnVjdGlvbi5kZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb25zWzBdKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBpbnN0cnVjdGlvbnNbMV0uZGF0YS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb25OYW1lMSA9PT0gbm9uY2VBZHZhbmNlSW5zdHJ1Y3Rpb24gJiYgZGF0YSA9PT0gdmFsaWRJbnN0cnVjdGlvbkRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQ2hlY2sgdGhlIHJhdyB0cmFuc2FjdGlvbiBoYXMgYSB2YWxpZCBmb3JtYXQgaW4gdGhlIGJsb2NrY2hhaW4gY29udGV4dCwgdGhyb3cgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByYXdUcmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIGluIGJhc2U2NCBzdHJpbmcgIGZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbjogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghcmF3VHJhbnNhY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIHJhdyB0cmFuc2FjdGlvbjogVW5kZWZpbmVkJyk7XG4gIH1cbiAgaWYgKCFpc1ZhbGlkUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCByYXcgdHJhbnNhY3Rpb24nKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBhZGRyZXNzIHRvIGNoZWNrIGlmIGl0IGV4aXN0cyBhbmQgaXMgYSB2YWxpZCBTb2xhbmEgcHVibGljIGtleVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIFRoZSBhZGRyZXNzIHRvIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSBOYW1lIG9mIHRoZSBmaWVsZCB0byB2YWxpZGF0ZSwgaXRzIG5lZWRlZCB0byByZXR1cm4gd2hpY2ggZmllbGQgaXMgZmFpbGluZyBvbiBjYXNlIG9mIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBZGRyZXNzKGFkZHJlc3M6IHN0cmluZywgZmllbGROYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKCFhZGRyZXNzIHx8ICFpc1ZhbGlkUHVibGljS2V5KGFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBvciBtaXNzaW5nICR7ZmllbGROYW1lfSwgZ290OiAke2FkZHJlc3N9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHN0YXRpY3MgY29pbiBvYmplY3QgbWF0Y2hpbmcgYSBnaXZlbiBTb2xhbmEgdG9rZW4gYWRkcmVzcyBpZiBpdCBleGlzdHNcbiAqXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIFRoZSB0b2tlbiBhZGRyZXNzIHRvIG1hdGNoIGFnYWluc3RcbiAqIEBwYXJhbSBuZXR3b3JrIFNvbGFuYSBNYWlubmV0IG9yIFRlc3RuZXRcbiAqIEByZXR1cm5zIHN0YXRpY3MgQmFzZUNvaW4gb2JqZWN0IGZvciB0aGUgbWF0Y2hpbmcgdG9rZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNvbFRva2VuRnJvbUFkZHJlc3ModG9rZW5BZGRyZXNzOiBzdHJpbmcsIG5ldHdvcms6IEJhc2VOZXR3b3JrKTogUmVhZG9ubHk8QmFzZUNvaW4+IHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdG9rZW5zID0gY29pbnMuZmlsdGVyKChjb2luKSA9PiB7XG4gICAgaWYgKGNvaW4gaW5zdGFuY2VvZiBTb2xDb2luKSB7XG4gICAgICByZXR1cm4gY29pbi5uZXR3b3JrLnR5cGUgPT09IG5ldHdvcmsudHlwZSAmJiBjb2luLnRva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSB0b2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbiAgY29uc3QgdG9rZW5zQXJyYXkgPSB0b2tlbnMubWFwKCh0b2tlbikgPT4gdG9rZW4pO1xuICBpZiAodG9rZW5zQXJyYXkubGVuZ3RoID49IDEpIHtcbiAgICAvLyB0aGVyZSBzaG91bGQgbmV2ZXIgYmUgdHdvIHRva2VucyB3aXRoIHRoZSBzYW1lIGNvbnRyYWN0IGFkZHJlc3MsIHNvIHdlIGFzc2VydCB0aGF0IGhlcmVcbiAgICBhc3NlcnQodG9rZW5zQXJyYXkubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdG9rZW5zQXJyYXlbMF07XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNvbGFuYSB0b2tlbiBvYmplY3QgZnJvbSB0b2tlbiBuYW1lXG4gKiBAcGFyYW0gdG9rZW5OYW1lIFRoZSB0b2tlbiBuYW1lIHRvIG1hdGNoIGFnYWluc3RcbiAqICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U29sVG9rZW5Gcm9tVG9rZW5OYW1lKHRva2VuTmFtZTogc3RyaW5nKTogUmVhZG9ubHk8U29sQ29pbj4gfCB1bmRlZmluZWQge1xuICB0cnkge1xuICAgIGNvbnN0IHRva2VuID0gY29pbnMuZ2V0KHRva2VuTmFtZSk7XG4gICAgaWYgKCEodG9rZW4uaXNUb2tlbiAmJiB0b2tlbiBpbnN0YW5jZW9mIFNvbENvaW4pKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW47XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIShlIGluc3RhbmNlb2YgQ29pbk5vdERlZmluZWRFcnJvcikpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNvbGFuYSBhc3NvY2lhdGVkIHRva2VuIGFjY291bnQgYWRkcmVzc1xuICogQHBhcmFtIHRva2VuQWRkcmVzcyBUaGUgdG9rZW4gYWRkcmVzc1xuICogQHBhcmFtIG93bmVyQWRkcmVzcyBUaGUgb3duZXIgb2YgdGhlIGFzc29jaWF0ZWQgdG9rZW4gYWNjb3VudFxuICogQHJldHVybnMgVGhlIGFzc29jaWF0ZWQgdG9rZW4gYWNjb3VudCBhZGRyZXNzXG4gKiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFzc29jaWF0ZWRUb2tlbkFjY291bnRBZGRyZXNzKHRva2VuQWRkcmVzczogc3RyaW5nLCBvd25lckFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IG93bmVyUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShvd25lckFkZHJlc3MpO1xuXG4gIC8vIHRva2VuQWRkcmVzcyBhcmUgbm90IG9uIGVkMjU1MTkgY3VydmUsIHNvIHRoZXkgY2FuJ3QgYmUgdXNlZCBhcyBvd25lckFkZHJlc3NcbiAgaWYgKCFQdWJsaWNLZXkuaXNPbkN1cnZlKG93bmVyUHVibGljS2V5LnRvQnVmZmVyKCkpKSB7XG4gICAgdGhyb3cgbmV3IFV0aWxzRXJyb3IoJ0ludmFsaWQgb3duZXJBZGRyZXNzIC0gYWRkcmVzcyBvZmYgZWQyNTUxOSBjdXJ2ZSwgZ290OiAnICsgb3duZXJBZGRyZXNzKTtcbiAgfVxuICBjb25zdCBhdGFBZGRyZXNzID0gYXdhaXQgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzcyhuZXcgUHVibGljS2V5KHRva2VuQWRkcmVzcyksIG93bmVyUHVibGljS2V5KTtcbiAgcmV0dXJuIGF0YUFkZHJlc3MudG9TdHJpbmcoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTWludEFkZHJlc3MobWludEFkZHJlc3M6IHN0cmluZykge1xuICBpZiAoIW1pbnRBZGRyZXNzIHx8ICFpc1ZhbGlkQWRkcmVzcyhtaW50QWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIG9yIG1pc3NpbmcgbWludEFkZHJlc3MsIGdvdDogJyArIG1pbnRBZGRyZXNzKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPd25lckFkZHJlc3Mob3duZXJBZGRyZXNzOiBzdHJpbmcpIHtcbiAgaWYgKCFvd25lckFkZHJlc3MgfHwgIWlzVmFsaWRBZGRyZXNzKG93bmVyQWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIG9yIG1pc3Npbmcgb3duZXJBZGRyZXNzLCBnb3Q6ICcgKyBvd25lckFkZHJlc3MpO1xuICB9XG59XG4iXX0=