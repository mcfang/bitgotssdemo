"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakingDeactivateBuilder = void 0;
const assert_1 = __importDefault(require("assert"));
const sdk_core_1 = require("@bitgo/sdk-core");
const constants_1 = require("./constants");
const transactionBuilder_1 = require("./transactionBuilder");
const utils_1 = require("./utils");
class StakingDeactivateBuilder extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    get transactionType() {
        return sdk_core_1.TransactionType.StakingDeactivate;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        const stakingAddresses = [];
        for (const instruction of this._instructionsData) {
            if (instruction.type === constants_1.InstructionBuilderTypes.StakingDeactivate) {
                const deactivateInstruction = instruction;
                this.sender(deactivateInstruction.params.fromAddress);
                stakingAddresses.push(deactivateInstruction.params.stakingAddress);
                if (deactivateInstruction.params.amount && deactivateInstruction.params.unstakingAddress) {
                    this.amount(deactivateInstruction.params.amount);
                    this.unstakingAddress(deactivateInstruction.params.unstakingAddress);
                }
            }
        }
        if (stakingAddresses.length > 1) {
            this.stakingAddresses(stakingAddresses);
        }
        else {
            this.stakingAddress(stakingAddresses[0]);
        }
    }
    /**
     * The staking address of the staking account.
     *
     * @param {string} stakingAddress public address of the staking account
     * @returns {StakingDeactivateBuilder} This staking deactivate builder.
     *
     * @see https://docs.solana.com/staking/stake-accounts#account-address
     */
    stakingAddress(stakingAddress) {
        utils_1.validateAddress(stakingAddress, 'stakingAddress');
        this._stakingAddress = stakingAddress;
        return this;
    }
    /**
     * The staking addresses of the staking account.
     *
     * @param {string[]} stakingAddresses public address of the staking accounts
     * @returns {StakingDeactivateBuilder} This staking deactivate builder.
     *
     * @see https://docs.solana.com/staking/stake-accounts#account-address
     */
    stakingAddresses(stakingAddresses) {
        for (const stakingAddress of stakingAddresses) {
            utils_1.validateAddress(stakingAddress, 'stakingAddress');
        }
        this._stakingAddresses = stakingAddresses;
        return this;
    }
    /**
     * Optional amount to unstake expressed in Lamports, 1 SOL = 1_000_000_000 lamports, to be used
     * when partially unstaking. If not given then the entire staked amount will be unstaked.
     *
     * @param {string} amount The partial amount to unstake, expressed in Lamports.
     * @returns {StakingDeactivateBuilder} This staking builder.
     *
     * @see https://docs.solana.com/cli/delegate-stake#split-stake
     */
    amount(amount) {
        if (!utils_1.isValidStakingAmount(amount)) {
            throw new sdk_core_1.BuildTransactionError('If given, amount cannot be zero or less');
        }
        this._amount = amount;
        return this;
    }
    /**
     * When partially unstaking move the amount to unstake to this account and initiate the
     * unstake process. The original stake account will continue staking.
     *
     * @param {string} unstakingAddress An account used to unstake a partial amount.
     * @returns {StakingDeactivateBuilder} This staking builder.
     *
     * @see https://docs.solana.com/cli/delegate-stake#split-stake
     */
    unstakingAddress(unstakingAddress) {
        utils_1.validateAddress(unstakingAddress, 'unstakingAddress');
        this._unstakingAddress = unstakingAddress;
        return this;
    }
    /** @inheritdoc */
    async buildImplementation() {
        assert_1.default(this._sender, 'Sender must be set before building the transaction');
        if (this._stakingAddresses && this._stakingAddresses.length > 0) {
            this._instructionsData = [];
            for (const stakingAddress of this._stakingAddresses) {
                const stakingDeactivateData = {
                    type: constants_1.InstructionBuilderTypes.StakingDeactivate,
                    params: {
                        fromAddress: this._sender,
                        stakingAddress: stakingAddress,
                    },
                };
                this._instructionsData.push(stakingDeactivateData);
            }
        }
        else {
            assert_1.default(this._stakingAddress, 'Staking address must be set before building the transaction');
            if (this._sender === this._stakingAddress) {
                throw new sdk_core_1.BuildTransactionError('Sender address cannot be the same as the Staking address');
            }
            if (this._amount) {
                assert_1.default(this._unstakingAddress, 'When partially unstaking the unstaking address must be set before building the transaction');
            }
            if (this._unstakingAddress) {
                assert_1.default(this._amount, 'If an unstaking address is given then a partial amount to unstake must also be set before building the transaction');
            }
            const stakingDeactivateData = {
                type: constants_1.InstructionBuilderTypes.StakingDeactivate,
                params: {
                    fromAddress: this._sender,
                    stakingAddress: this._stakingAddress,
                    amount: this._amount,
                    unstakingAddress: this._unstakingAddress,
                },
            };
            this._instructionsData = [stakingDeactivateData];
        }
        return await super.buildImplementation();
    }
}
exports.StakingDeactivateBuilder = StakingDeactivateBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Rha2luZ0RlYWN0aXZhdGVCdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9zdGFraW5nRGVhY3RpdmF0ZUJ1aWxkZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0Esb0RBQTRCO0FBRTVCLDhDQUF5RTtBQUN6RSwyQ0FBc0Q7QUFHdEQsNkRBQTBEO0FBQzFELG1DQUFnRTtBQUVoRSxNQUFhLHdCQUF5QixTQUFRLHVDQUFrQjtJQU05RCxZQUFZLFdBQWlDO1FBQzNDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyQixDQUFDO0lBRUQsSUFBYyxlQUFlO1FBQzNCLE9BQU8sMEJBQWUsQ0FBQyxpQkFBaUIsQ0FBQztJQUMzQyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFdBQVcsQ0FBQyxFQUFlO1FBQ3pCLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEIsTUFBTSxnQkFBZ0IsR0FBYSxFQUFFLENBQUM7UUFDdEMsS0FBSyxNQUFNLFdBQVcsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDaEQsSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLG1DQUF1QixDQUFDLGlCQUFpQixFQUFFO2dCQUNsRSxNQUFNLHFCQUFxQixHQUFzQixXQUFXLENBQUM7Z0JBQzdELElBQUksQ0FBQyxNQUFNLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO2dCQUN0RCxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUNuRSxJQUFJLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUkscUJBQXFCLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFO29CQUN4RixJQUFJLENBQUMsTUFBTSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDakQsSUFBSSxDQUFD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Q0FBQyxpQkFBaUI7Z0JBQy9DLE1BQU0sRUFBRTtvQkFDTixXQUFXLEVBQUUsSUFBSSxDQUFDLE9BQU87b0JBQ3pCLGNBQWMsRUFBRSxJQUFJLENBQUMsZUFBZTtvQkFDcEMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPO29CQUNwQixnQkFBZ0IsRUFBRSxJQUFJLENBQUMsaUJBQWlCO2lCQUN6QzthQUNGLENBQUM7WUFDRixJQUFJLENBQUMsaUJBQWlCLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1NBQ2xEO1FBQ0QsT0FBTyxNQUFNLEtBQUssQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQzNDLENBQUM7Q0FDRjtBQXBKRCw0REFvSkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5pbXBvcnQgeyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IsIFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IFN0YWtpbmdEZWFjdGl2YXRlIH0gZnJvbSAnLi9pZmFjZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25CdWlsZGVyIH0gZnJvbSAnLi90cmFuc2FjdGlvbkJ1aWxkZXInO1xuaW1wb3J0IHsgaXNWYWxpZFN0YWtpbmdBbW91bnQsIHZhbGlkYXRlQWRkcmVzcyB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgU3Rha2luZ0RlYWN0aXZhdGVCdWlsZGVyIGV4dGVuZHMgVHJhbnNhY3Rpb25CdWlsZGVyIHtcbiAgcHJvdGVjdGVkIF9zdGFraW5nQWRkcmVzczogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX3N0YWtpbmdBZGRyZXNzZXM6IHN0cmluZ1tdO1xuICBwcm90ZWN0ZWQgX2Ftb3VudD86IHN0cmluZztcbiAgcHJvdGVjdGVkIF91bnN0YWtpbmdBZGRyZXNzOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvblR5cGUoKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdEZWFjdGl2YXRlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGluaXRCdWlsZGVyKHR4OiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIHN1cGVyLmluaXRCdWlsZGVyKHR4KTtcbiAgICBjb25zdCBzdGFraW5nQWRkcmVzc2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgdGhpcy5faW5zdHJ1Y3Rpb25zRGF0YSkge1xuICAgICAgaWYgKGluc3RydWN0aW9uLnR5cGUgPT09IEluc3RydWN0aW9uQnVpbGRlclR5cGVzLlN0YWtpbmdEZWFjdGl2YXRlKSB7XG4gICAgICAgIGNvbnN0IGRlYWN0aXZhdGVJbnN0cnVjdGlvbjogU3Rha2luZ0RlYWN0aXZhdGUgPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgdGhpcy5zZW5kZXIoZGVhY3RpdmF0ZUluc3RydWN0aW9uLnBhcmFtcy5mcm9tQWRkcmVzcyk7XG4gICAgICAgIHN0YWtpbmdBZGRyZXNzZXMucHVzaChkZWFjdGl2YXRlSW5zdHJ1Y3Rpb24ucGFyYW1zLnN0YWtpbmdBZGRyZXNzKTtcbiAgICAgICAgaWYgKGRlYWN0aXZhdGVJbnN0cnVjdGlvbi5wYXJhbXMuYW1vdW50ICYmIGRlYWN0aXZhdGVJbnN0cnVjdGlvbi5wYXJhbXMudW5zdGFraW5nQWRkcmVzcykge1xuICAgICAgICAgIHRoaXMuYW1vdW50KGRlYWN0aXZhdGVJbnN0cnVjdGlvbi5wYXJhbXMuYW1vdW50KTtcbiAgICAgICAgICB0aGlzLnVuc3Rha2luZ0FkZHJlc3MoZGVhY3RpdmF0ZUluc3RydWN0aW9uLnBhcmFtcy51bnN0YWtpbmdBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3Rha2luZ0FkZHJlc3Nlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnN0YWtpbmdBZGRyZXNzZXMoc3Rha2luZ0FkZHJlc3Nlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3Rha2luZ0FkZHJlc3Moc3Rha2luZ0FkZHJlc3Nlc1swXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFraW5nIGFkZHJlc3Mgb2YgdGhlIHN0YWtpbmcgYWNjb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdBZGRyZXNzIHB1YmxpYyBhZGRyZXNzIG9mIHRoZSBzdGFraW5nIGFjY291bnRcbiAgICogQHJldHVybnMge1N0YWtpbmdEZWFjdGl2YXRlQnVpbGRlcn0gVGhpcyBzdGFraW5nIGRlYWN0aXZhdGUgYnVpbGRlci5cbiAgICpcbiAgICogQHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS9zdGFraW5nL3N0YWtlLWFjY291bnRzI2FjY291bnQtYWRkcmVzc1xuICAgKi9cbiAgc3Rha2luZ0FkZHJlc3Moc3Rha2luZ0FkZHJlc3M6IHN0cmluZyk6IHRoaXMge1xuICAgIHZhbGlkYXRlQWRkcmVzcyhzdGFraW5nQWRkcmVzcywgJ3N0YWtpbmdBZGRyZXNzJyk7XG4gICAgdGhpcy5fc3Rha2luZ0FkZHJlc3MgPSBzdGFraW5nQWRkcmVzcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3Rha2luZyBhZGRyZXNzZXMgb2YgdGhlIHN0YWtpbmcgYWNjb3VudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gc3Rha2luZ0FkZHJlc3NlcyBwdWJsaWMgYWRkcmVzcyBvZiB0aGUgc3Rha2luZyBhY2NvdW50c1xuICAgKiBAcmV0dXJucyB7U3Rha2luZ0RlYWN0aXZhdGVCdWlsZGVyfSBUaGlzIHN0YWtpbmcgZGVhY3RpdmF0ZSBidWlsZGVyLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3N0YWtpbmcvc3Rha2UtYWNjb3VudHMjYWNjb3VudC1hZGRyZXNzXG4gICAqL1xuICBzdGFraW5nQWRkcmVzc2VzKHN0YWtpbmdBZGRyZXNzZXM6IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgZm9yIChjb25zdCBzdGFraW5nQWRkcmVzcyBvZiBzdGFraW5nQWRkcmVzc2VzKSB7XG4gICAgICB2YWxpZGF0ZUFkZHJlc3Moc3Rha2luZ0FkZHJlc3MsICdzdGFraW5nQWRkcmVzcycpO1xuICAgIH1cbiAgICB0aGlzLl9zdGFraW5nQWRkcmVzc2VzID0gc3Rha2luZ0FkZHJlc3NlcztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBhbW91bnQgdG8gdW5zdGFrZSBleHByZXNzZWQgaW4gTGFtcG9ydHMsIDEgU09MID0gMV8wMDBfMDAwXzAwMCBsYW1wb3J0cywgdG8gYmUgdXNlZFxuICAgKiB3aGVuIHBhcnRpYWxseSB1bnN0YWtpbmcuIElmIG5vdCBnaXZlbiB0aGVuIHRoZSBlbnRpcmUgc3Rha2VkIGFtb3VudCB3aWxsIGJlIHVuc3Rha2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IFRoZSBwYXJ0aWFsIGFtb3VudCB0byB1bnN0YWtlLCBleHByZXNzZWQgaW4gTGFtcG9ydHMuXG4gICAqIEByZXR1cm5zIHtTdGFraW5nRGVhY3RpdmF0ZUJ1aWxkZXJ9IFRoaXMgc3Rha2luZyBidWlsZGVyLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL2NsaS9kZWxlZ2F0ZS1zdGFrZSNzcGxpdC1zdGFrZVxuICAgKi9cbiAgYW1vdW50KGFtb3VudDogc3RyaW5nKTogdGhpcyB7XG4gICAgaWYgKCFpc1ZhbGlkU3Rha2luZ0Ftb3VudChhbW91bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdJZiBnaXZlbiwgYW1vdW50IGNhbm5vdCBiZSB6ZXJvIG9yIGxlc3MnKTtcbiAgICB9XG4gICAgdGhpcy5fYW1vdW50ID0gYW1vdW50O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gcGFydGlhbGx5IHVuc3Rha2luZyBtb3ZlIHRoZSBhbW91bnQgdG8gdW5zdGFrZSB0byB0aGlzIGFjY291bnQgYW5kIGluaXRpYXRlIHRoZVxuICAgKiB1bnN0YWtlIHByb2Nlc3MuIFRoZSBvcmlnaW5hbCBzdGFrZSBhY2NvdW50IHdpbGwgY29udGludWUgc3Rha2luZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuc3Rha2luZ0FkZHJlc3MgQW4gYWNjb3VudCB1c2VkIHRvIHVuc3Rha2UgYSBwYXJ0aWFsIGFtb3VudC5cbiAgICogQHJldHVybnMge1N0YWtpbmdEZWFjdGl2YXRlQnVpbGRlcn0gVGhpcyBzdGFraW5nIGJ1aWxkZXIuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vY2xpL2RlbGVnYXRlLXN0YWtlI3NwbGl0LXN0YWtlXG4gICAqL1xuICB1bnN0YWtpbmdBZGRyZXNzKHVuc3Rha2luZ0FkZHJlc3M6IHN0cmluZyk6IHRoaXMge1xuICAgIHZhbGlkYXRlQWRkcmVzcyh1bnN0YWtpbmdBZGRyZXNzLCAndW5zdGFraW5nQWRkcmVzcycpO1xuICAgIHRoaXMuX3Vuc3Rha2luZ0FkZHJlc3MgPSB1bnN0YWtpbmdBZGRyZXNzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHByb3RlY3RlZCBhc3luYyBidWlsZEltcGxlbWVudGF0aW9uKCk6IFByb21pc2U8VHJhbnNhY3Rpb24+IHtcbiAgICBhc3NlcnQodGhpcy5fc2VuZGVyLCAnU2VuZGVyIG11c3QgYmUgc2V0IGJlZm9yZSBidWlsZGluZyB0aGUgdHJhbnNhY3Rpb24nKTtcblxuICAgIGlmICh0aGlzLl9zdGFraW5nQWRkcmVzc2VzICYmIHRoaXMuX3N0YWtpbmdBZGRyZXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zRGF0YSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzdGFraW5nQWRkcmVzcyBvZiB0aGlzLl9zdGFraW5nQWRkcmVzc2VzKSB7XG4gICAgICAgIGNvbnN0IHN0YWtpbmdEZWFjdGl2YXRlRGF0YTogU3Rha2luZ0RlYWN0aXZhdGUgPSB7XG4gICAgICAgICAgdHlwZTogSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuU3Rha2luZ0RlYWN0aXZhdGUsXG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBmcm9tQWRkcmVzczogdGhpcy5fc2VuZGVyLFxuICAgICAgICAgICAgc3Rha2luZ0FkZHJlc3M6IHN0YWtpbmdBZGRyZXNzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9uc0RhdGEucHVzaChzdGFraW5nRGVhY3RpdmF0ZURhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodGhpcy5fc3Rha2luZ0FkZHJlc3MsICdTdGFraW5nIGFkZHJlc3MgbXVzdCBiZSBzZXQgYmVmb3JlIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbicpO1xuXG4gICAgICBpZiAodGhpcy5fc2VuZGVyID09PSB0aGlzLl9zdGFraW5nQWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgQnVpbGRUcmFuc2FjdGlvbkVycm9yKCdTZW5kZXIgYWRkcmVzcyBjYW5ub3QgYmUgdGhlIHNhbWUgYXMgdGhlIFN0YWtpbmcgYWRkcmVzcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYW1vdW50KSB7XG4gICAgICAgIGFzc2VydChcbiAgICAgICAgICB0aGlzLl91bnN0YWtpbmdBZGRyZXNzLFxuICAgICAgICAgICdXaGVuIHBhcnRpYWxseSB1bnN0YWtpbmcgdGhlIHVuc3Rha2luZyBhZGRyZXNzIG11c3QgYmUgc2V0IGJlZm9yZSBidWlsZGluZyB0aGUgdHJhbnNhY3Rpb24nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl91bnN0YWtpbmdBZGRyZXNzKSB7XG4gICAgICAgIGFzc2VydChcbiAgICAgICAgICB0aGlzLl9hbW91bnQsXG4gICAgICAgICAgJ0lmIGFuIHVuc3Rha2luZyBhZGRyZXNzIGlzIGdpdmVuIHRoZW4gYSBwYXJ0aWFsIGFtb3VudCB0byB1bnN0YWtlIG11c3QgYWxzbyBiZSBzZXQgYmVmb3JlIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3Rha2luZ0RlYWN0aXZhdGVEYXRhOiBTdGFraW5nRGVhY3RpdmF0ZSA9IHtcbiAgICAgICAgdHlwZTogSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuU3Rha2luZ0RlYWN0aXZhdGUsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGZyb21BZGRyZXNzOiB0aGlzLl9zZW5kZXIsXG4gICAgICAgICAgc3Rha2luZ0FkZHJlc3M6IHRoaXMuX3N0YWtpbmdBZGRyZXNzLFxuICAgICAgICAgIGFtb3VudDogdGhpcy5fYW1vdW50LFxuICAgICAgICAgIHVuc3Rha2luZ0FkZHJlc3M6IHRoaXMuX3Vuc3Rha2luZ0FkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zRGF0YSA9IFtzdGFraW5nRGVhY3RpdmF0ZURhdGFdO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgc3VwZXIuYnVpbGRJbXBsZW1lbnRhdGlvbigpO1xuICB9XG59XG4iXX0=