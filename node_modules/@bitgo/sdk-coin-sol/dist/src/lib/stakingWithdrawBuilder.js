"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakingWithdrawBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const transactionBuilder_1 = require("./transactionBuilder");
const constants_1 = require("./constants");
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("./utils");
class StakingWithdrawBuilder extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    get transactionType() {
        return sdk_core_1.TransactionType.StakingWithdraw;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        for (const instruction of this._instructionsData) {
            if (instruction.type === constants_1.InstructionBuilderTypes.StakingWithdraw) {
                const withdrawInstruction = instruction;
                this.sender(withdrawInstruction.params.fromAddress);
                this.stakingAddress(withdrawInstruction.params.stakingAddress);
                this.amount(withdrawInstruction.params.amount);
            }
        }
    }
    /**
     * The address of the staking account.
     *
     * @param {string} stakingAddress public address of the staking account
     * @returns {StakeBuilder} This staking builder.
     *
     */
    stakingAddress(stakingAddress) {
        utils_1.validateAddress(stakingAddress, 'stakingAddress');
        this._stakingAddress = stakingAddress;
        return this;
    }
    /**
     * The amount to withdraw expressed in Lamports, 1 SOL = 1_000_000_000 lamports
     *
     * @param {string} amount expressed in Lamports
     * @returns {StakeBuilder} This staking builder.
     *
     */
    amount(amount) {
        if (!utils_1.isValidStakingAmount(amount)) {
            throw new sdk_core_1.BuildTransactionError('Value cannot be zero or less');
        }
        this._amount = amount;
        return this;
    }
    /** @inheritdoc */
    async buildImplementation() {
        assert_1.default(this._sender, 'Sender must be set before building the transaction');
        assert_1.default(this._stakingAddress, 'Staking address must be set before building the transaction');
        assert_1.default(this._amount, 'Amount must be set before building the transaction');
        if (this._sender === this._stakingAddress) {
            throw new sdk_core_1.BuildTransactionError('Sender address cannot be the same as the Staking address');
        }
        const stakingWithdrawData = {
            type: constants_1.InstructionBuilderTypes.StakingWithdraw,
            params: {
                fromAddress: this._sender,
                stakingAddress: this._stakingAddress,
                amount: this._amount,
            },
        };
        this._instructionsData = [stakingWithdrawData];
        return await super.buildImplementation();
    }
}
exports.StakingWithdrawBuilder = StakingWithdrawBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Rha2luZ1dpdGhkcmF3QnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvc3Rha2luZ1dpdGhkcmF3QnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSw4Q0FBeUU7QUFFekUsNkRBQTBEO0FBQzFELDJDQUFzRDtBQUV0RCxvREFBNEI7QUFFNUIsbUNBQWdFO0FBRWhFLE1BQWEsc0JBQXVCLFNBQVEsdUNBQWtCO0lBSTVELFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxJQUFjLGVBQWU7UUFDM0IsT0FBTywwQkFBZSxDQUFDLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFdBQVcsQ0FBQyxFQUFlO1FBQ3pCLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEIsS0FBSyxNQUFNLFdBQVcsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDaEQsSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLG1DQUF1QixDQUFDLGVBQWUsRUFBRTtnQkFDaEUsTUFBTSxtQkFBbUIsR0FBb0IsV0FBVyxDQUFDO2dCQUN6RCxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7Z0JBQy9ELElBQUksQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ2hEO1NBQ0Y7SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsY0FBYyxDQUFDLGNBQXNCO1FBQ25DLHVCQUFlLENBQUMsY0FBYyxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFDbEQsSUFBSSxDQUFDLGVBQWUsR0FBRyxjQUFjLENBQUM7UUFDdEMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLE1BQWM7UUFDbkIsSUFBSSxDQUFDLDRCQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLE1BQU0sSUFBSSxnQ0FBcUIsQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1NBQ2pFO1FBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7UUFDdEIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsa0JBQWtCO0lBQ1IsS0FBSyxDQUFDLG1CQUFtQjtRQUNqQyxnQkFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsb0RBQW9ELENBQUMsQ0FBQztRQUMzRSxnQkFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLEVBQUUsNkRBQTZELENBQUMsQ0FBQztRQUM1RixnQkFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsb0RBQW9ELENBQUMsQ0FBQztRQUUzRSxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN6QyxNQUFNLElBQUksZ0NBQXFCLENBQUMsMERBQTBELENBQUMsQ0FBQztTQUM3RjtRQUVELE1BQU0sbUJBQW1CLEdBQW9CO1lBQzNDLElBQUksRUFBRSxtQ0FBdUIsQ0FBQyxlQUFlO1lBQzdDLE1BQU0sRUFBRTtnQkFDTixXQUFXLEVBQUUsSUFBSSxDQUFDLE9BQU87Z0JBQ3pCLGNBQWMsRUFBRSxJQUFJLENBQUMsZUFBZTtnQkFDcEMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPO2FBQ3JCO1NBQ0YsQ0FBQztRQUNGLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFFL0MsT0FBTyxNQUFNLEtBQUssQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQzNDLENBQUM7Q0FDRjtBQTNFRCx3REEyRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgQnVpbGRUcmFuc2FjdGlvbkVycm9yLCBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4vdHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7IEluc3RydWN0aW9uQnVpbGRlclR5cGVzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBTdGFraW5nV2l0aGRyYXcgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IGlzVmFsaWRTdGFraW5nQW1vdW50LCB2YWxpZGF0ZUFkZHJlc3MgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGNsYXNzIFN0YWtpbmdXaXRoZHJhd0J1aWxkZXIgZXh0ZW5kcyBUcmFuc2FjdGlvbkJ1aWxkZXIge1xuICBwcm90ZWN0ZWQgX3N0YWtpbmdBZGRyZXNzOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBfYW1vdW50OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoX2NvaW5Db25maWc6IFJlYWRvbmx5PENvaW5Db25maWc+KSB7XG4gICAgc3VwZXIoX2NvaW5Db25maWcpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldCB0cmFuc2FjdGlvblR5cGUoKTogVHJhbnNhY3Rpb25UeXBlIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpbml0QnVpbGRlcih0eDogVHJhbnNhY3Rpb24pOiB2b2lkIHtcbiAgICBzdXBlci5pbml0QnVpbGRlcih0eCk7XG4gICAgZm9yIChjb25zdCBpbnN0cnVjdGlvbiBvZiB0aGlzLl9pbnN0cnVjdGlvbnNEYXRhKSB7XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb24udHlwZSA9PT0gSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuU3Rha2luZ1dpdGhkcmF3KSB7XG4gICAgICAgIGNvbnN0IHdpdGhkcmF3SW5zdHJ1Y3Rpb246IFN0YWtpbmdXaXRoZHJhdyA9IGluc3RydWN0aW9uO1xuICAgICAgICB0aGlzLnNlbmRlcih3aXRoZHJhd0luc3RydWN0aW9uLnBhcmFtcy5mcm9tQWRkcmVzcyk7XG4gICAgICAgIHRoaXMuc3Rha2luZ0FkZHJlc3Mod2l0aGRyYXdJbnN0cnVjdGlvbi5wYXJhbXMuc3Rha2luZ0FkZHJlc3MpO1xuICAgICAgICB0aGlzLmFtb3VudCh3aXRoZHJhd0luc3RydWN0aW9uLnBhcmFtcy5hbW91bnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYWRkcmVzcyBvZiB0aGUgc3Rha2luZyBhY2NvdW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ0FkZHJlc3MgcHVibGljIGFkZHJlc3Mgb2YgdGhlIHN0YWtpbmcgYWNjb3VudFxuICAgKiBAcmV0dXJucyB7U3Rha2VCdWlsZGVyfSBUaGlzIHN0YWtpbmcgYnVpbGRlci5cbiAgICpcbiAgICovXG4gIHN0YWtpbmdBZGRyZXNzKHN0YWtpbmdBZGRyZXNzOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB2YWxpZGF0ZUFkZHJlc3Moc3Rha2luZ0FkZHJlc3MsICdzdGFraW5nQWRkcmVzcycpO1xuICAgIHRoaXMuX3N0YWtpbmdBZGRyZXNzID0gc3Rha2luZ0FkZHJlc3M7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFtb3VudCB0byB3aXRoZHJhdyBleHByZXNzZWQgaW4gTGFtcG9ydHMsIDEgU09MID0gMV8wMDBfMDAwXzAwMCBsYW1wb3J0c1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW1vdW50IGV4cHJlc3NlZCBpbiBMYW1wb3J0c1xuICAgKiBAcmV0dXJucyB7U3Rha2VCdWlsZGVyfSBUaGlzIHN0YWtpbmcgYnVpbGRlci5cbiAgICpcbiAgICovXG4gIGFtb3VudChhbW91bnQ6IHN0cmluZyk6IHRoaXMge1xuICAgIGlmICghaXNWYWxpZFN0YWtpbmdBbW91bnQoYW1vdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignVmFsdWUgY2Fubm90IGJlIHplcm8gb3IgbGVzcycpO1xuICAgIH1cbiAgICB0aGlzLl9hbW91bnQgPSBhbW91bnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGJ1aWxkSW1wbGVtZW50YXRpb24oKTogUHJvbWlzZTxUcmFuc2FjdGlvbj4ge1xuICAgIGFzc2VydCh0aGlzLl9zZW5kZXIsICdTZW5kZXIgbXVzdCBiZSBzZXQgYmVmb3JlIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbicpO1xuICAgIGFzc2VydCh0aGlzLl9zdGFraW5nQWRkcmVzcywgJ1N0YWtpbmcgYWRkcmVzcyBtdXN0IGJlIHNldCBiZWZvcmUgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgYXNzZXJ0KHRoaXMuX2Ftb3VudCwgJ0Ftb3VudCBtdXN0IGJlIHNldCBiZWZvcmUgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uJyk7XG5cbiAgICBpZiAodGhpcy5fc2VuZGVyID09PSB0aGlzLl9zdGFraW5nQWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignU2VuZGVyIGFkZHJlc3MgY2Fubm90IGJlIHRoZSBzYW1lIGFzIHRoZSBTdGFraW5nIGFkZHJlc3MnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFraW5nV2l0aGRyYXdEYXRhOiBTdGFraW5nV2l0aGRyYXcgPSB7XG4gICAgICB0eXBlOiBJbnN0cnVjdGlvbkJ1aWxkZXJUeXBlcy5TdGFraW5nV2l0aGRyYXcsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgZnJvbUFkZHJlc3M6IHRoaXMuX3NlbmRlcixcbiAgICAgICAgc3Rha2luZ0FkZHJlc3M6IHRoaXMuX3N0YWtpbmdBZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IHRoaXMuX2Ftb3VudCxcbiAgICAgIH0sXG4gICAgfTtcbiAgICB0aGlzLl9pbnN0cnVjdGlvbnNEYXRhID0gW3N0YWtpbmdXaXRoZHJhd0RhdGFdO1xuXG4gICAgcmV0dXJuIGF3YWl0IHN1cGVyLmJ1aWxkSW1wbGVtZW50YXRpb24oKTtcbiAgfVxufVxuIl19