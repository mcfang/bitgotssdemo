"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StakingDelegateBuilder = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const transactionBuilder_1 = require("./transactionBuilder");
const constants_1 = require("./constants");
const assert_1 = __importDefault(require("assert"));
const utils_1 = require("./utils");
class StakingDelegateBuilder extends transactionBuilder_1.TransactionBuilder {
    constructor(_coinConfig) {
        super(_coinConfig);
    }
    get transactionType() {
        return sdk_core_1.TransactionType.StakingDelegate;
    }
    /** @inheritdoc */
    initBuilder(tx) {
        super.initBuilder(tx);
        const stakingAddresses = [];
        for (const instruction of this._instructionsData) {
            if (instruction.type === constants_1.InstructionBuilderTypes.StakingDelegate) {
                const activateInstruction = instruction;
                this.sender(activateInstruction.params.fromAddress);
                stakingAddresses.push(activateInstruction.params.stakingAddress);
                this.validator(activateInstruction.params.validator);
            }
        }
        if (stakingAddresses.length > 1) {
            this.stakingAddresses(stakingAddresses);
        }
        else {
            this.stakingAddress(stakingAddresses[0]);
        }
    }
    /**
     * The address of the staking account.
     *
     * @param {string} stakingAddress public address of the staking account.
     * @returns {StakingDelegateBuilder} This staking delegate builder.
     *
     * @see https://docs.solana.com/staking/stake-accounts#account-address
     */
    stakingAddress(stakingAddress) {
        utils_1.validateAddress(stakingAddress, 'stakingAddress');
        this._stakingAddress = stakingAddress;
        return this;
    }
    /**
     * The staking addresses of the staking account.
     *
     * @param {string[]} stakingAddresses public address of the staking accounts
     * @returns {StakingDelegateBuilder} This staking delegate builder.
     *
     * @see https://docs.solana.com/staking/stake-accounts#account-address
     */
    stakingAddresses(stakingAddresses) {
        assert_1.default(stakingAddresses.length > 0, 'stakingAddresses must not be empty');
        for (const stakingAddress of stakingAddresses) {
            utils_1.validateAddress(stakingAddress, 'stakingAddress');
        }
        this._stakingAddresses = stakingAddresses;
        return this;
    }
    /**
     * Set validator address to delegate funds to.
     *
     * @param {string} validator Validator address to delegate funds to.
     * @returns {StakingDelegateBuilder} This staking builder.
     *
     */
    validator(validator) {
        utils_1.validateAddress(validator, 'validator');
        this._validator = validator;
        return this;
    }
    /** @inheritdoc */
    async buildImplementation() {
        assert_1.default(this._sender, 'Sender must be set before building the transaction');
        assert_1.default(this._validator, 'Validator must be set before building the transaction');
        if (this._stakingAddresses && this._stakingAddresses.length > 0) {
            this._instructionsData = [];
            for (const stakingAddress of this._stakingAddresses) {
                assert_1.default(stakingAddress, 'Staking Address must be set before building the transaction');
                if (this._sender === stakingAddress) {
                    throw new sdk_core_1.BuildTransactionError('Sender address cannot be the same as the Staking address');
                }
                const stakingAccountData = {
                    type: constants_1.InstructionBuilderTypes.StakingDelegate,
                    params: {
                        fromAddress: this._sender,
                        stakingAddress: stakingAddress,
                        validator: this._validator,
                    },
                };
                this._instructionsData.push(stakingAccountData);
            }
        }
        else {
            assert_1.default(this._stakingAddress, 'Staking Address must be set before building the transaction');
            if (this._sender === this._stakingAddress) {
                throw new sdk_core_1.BuildTransactionError('Sender address cannot be the same as the Staking address');
            }
            const stakingAccountData = {
                type: constants_1.InstructionBuilderTypes.StakingDelegate,
                params: {
                    fromAddress: this._sender,
                    stakingAddress: this._stakingAddress,
                    validator: this._validator,
                },
            };
            this._instructionsData = [stakingAccountData];
        }
        return await super.buildImplementation();
    }
}
exports.StakingDelegateBuilder = StakingDelegateBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3Rha2luZ0RlbGVnYXRlQnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvc3Rha2luZ0RlbGVnYXRlQnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSw4Q0FBeUU7QUFFekUsNkRBQTBEO0FBQzFELDJDQUFzRDtBQUV0RCxvREFBNEI7QUFFNUIsbUNBQTBDO0FBRTFDLE1BQWEsc0JBQXVCLFNBQVEsdUNBQWtCO0lBSzVELFlBQVksV0FBaUM7UUFDM0MsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxJQUFjLGVBQWU7UUFDM0IsT0FBTywwQkFBZSxDQUFDLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLFdBQVcsQ0FBQyxFQUFlO1FBQ3pCLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEIsTUFBTSxnQkFBZ0IsR0FBYSxFQUFFLENBQUM7UUFDdEMsS0FBSyxNQUFNLFdBQVcsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDaEQsSUFBSSxXQUFXLENBQUMsSUFBSSxLQUFLLG1DQUF1QixDQUFDLGVBQWUsRUFBRTtnQkFDaEUsTUFBTSxtQkFBbUIsR0FBb0IsV0FBVyxDQUFDO2dCQUN6RCxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztnQkFDcEQsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDakUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDdEQ7U0FDRjtRQUNELElBQUksZ0JBQWdCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMvQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUN6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b3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlQ29pbiBhcyBDb2luQ29uZmlnIH0gZnJvbSAnQGJpdGdvL3N0YXRpY3MnO1xuaW1wb3J0IHsgQnVpbGRUcmFuc2FjdGlvbkVycm9yLCBUcmFuc2FjdGlvblR5cGUgfSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uQnVpbGRlciB9IGZyb20gJy4vdHJhbnNhY3Rpb25CdWlsZGVyJztcbmltcG9ydCB7IEluc3RydWN0aW9uQnVpbGRlclR5cGVzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgeyBTdGFraW5nRGVsZWdhdGUgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IHZhbGlkYXRlQWRkcmVzcyB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgY2xhc3MgU3Rha2luZ0RlbGVnYXRlQnVpbGRlciBleHRlbmRzIFRyYW5zYWN0aW9uQnVpbGRlciB7XG4gIHByb3RlY3RlZCBfc3Rha2luZ0FkZHJlc3M6IHN0cmluZztcbiAgcHJvdGVjdGVkIF9zdGFraW5nQWRkcmVzc2VzOiBzdHJpbmdbXTtcbiAgcHJvdGVjdGVkIF92YWxpZGF0b3I6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihfY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihfY29pbkNvbmZpZyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IHRyYW5zYWN0aW9uVHlwZSgpOiBUcmFuc2FjdGlvblR5cGUge1xuICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0RlbGVnYXRlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGluaXRCdWlsZGVyKHR4OiBUcmFuc2FjdGlvbik6IHZvaWQge1xuICAgIHN1cGVyLmluaXRCdWlsZGVyKHR4KTtcbiAgICBjb25zdCBzdGFraW5nQWRkcmVzc2VzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgdGhpcy5faW5zdHJ1Y3Rpb25zRGF0YSkge1xuICAgICAgaWYgKGluc3RydWN0aW9uLnR5cGUgPT09IEluc3RydWN0aW9uQnVpbGRlclR5cGVzLlN0YWtpbmdEZWxlZ2F0ZSkge1xuICAgICAgICBjb25zdCBhY3RpdmF0ZUluc3RydWN0aW9uOiBTdGFraW5nRGVsZWdhdGUgPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgdGhpcy5zZW5kZXIoYWN0aXZhdGVJbnN0cnVjdGlvbi5wYXJhbXMuZnJvbUFkZHJlc3MpO1xuICAgICAgICBzdGFraW5nQWRkcmVzc2VzLnB1c2goYWN0aXZhdGVJbnN0cnVjdGlvbi5wYXJhbXMuc3Rha2luZ0FkZHJlc3MpO1xuICAgICAgICB0aGlzLnZhbGlkYXRvcihhY3RpdmF0ZUluc3RydWN0aW9uLnBhcmFtcy52YWxpZGF0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3Rha2luZ0FkZHJlc3Nlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLnN0YWtpbmdBZGRyZXNzZXMoc3Rha2luZ0FkZHJlc3Nlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3Rha2luZ0FkZHJlc3Moc3Rha2luZ0FkZHJlc3Nlc1swXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhZGRyZXNzIG9mIHRoZSBzdGFraW5nIGFjY291bnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nQWRkcmVzcyBwdWJsaWMgYWRkcmVzcyBvZiB0aGUgc3Rha2luZyBhY2NvdW50LlxuICAgKiBAcmV0dXJucyB7U3Rha2luZ0RlbGVnYXRlQnVpbGRlcn0gVGhpcyBzdGFraW5nIGRlbGVnYXRlIGJ1aWxkZXIuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kb2NzLnNvbGFuYS5jb20vc3Rha2luZy9zdGFrZS1hY2NvdW50cyNhY2NvdW50LWFkZHJlc3NcbiAgICovXG4gIHN0YWtpbmdBZGRyZXNzKHN0YWtpbmdBZGRyZXNzOiBzdHJpbmcpOiB0aGlzIHtcbiAgICB2YWxpZGF0ZUFkZHJlc3Moc3Rha2luZ0FkZHJlc3MsICdzdGFraW5nQWRkcmVzcycpO1xuICAgIHRoaXMuX3N0YWtpbmdBZGRyZXNzID0gc3Rha2luZ0FkZHJlc3M7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YWtpbmcgYWRkcmVzc2VzIG9mIHRoZSBzdGFraW5nIGFjY291bnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHN0YWtpbmdBZGRyZXNzZXMgcHVibGljIGFkZHJlc3Mgb2YgdGhlIHN0YWtpbmcgYWNjb3VudHNcbiAgICogQHJldHVybnMge1N0YWtpbmdEZWxlZ2F0ZUJ1aWxkZXJ9IFRoaXMgc3Rha2luZyBkZWxlZ2F0ZSBidWlsZGVyLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3N0YWtpbmcvc3Rha2UtYWNjb3VudHMjYWNjb3VudC1hZGRyZXNzXG4gICAqL1xuICBzdGFraW5nQWRkcmVzc2VzKHN0YWtpbmdBZGRyZXNzZXM6IHN0cmluZ1tdKTogdGhpcyB7XG4gICAgYXNzZXJ0KHN0YWtpbmdBZGRyZXNzZXMubGVuZ3RoID4gMCwgJ3N0YWtpbmdBZGRyZXNzZXMgbXVzdCBub3QgYmUgZW1wdHknKTtcbiAgICBmb3IgKGNvbnN0IHN0YWtpbmdBZGRyZXNzIG9mIHN0YWtpbmdBZGRyZXNzZXMpIHtcbiAgICAgIHZhbGlkYXRlQWRkcmVzcyhzdGFraW5nQWRkcmVzcywgJ3N0YWtpbmdBZGRyZXNzJyk7XG4gICAgfVxuICAgIHRoaXMuX3N0YWtpbmdBZGRyZXNzZXMgPSBzdGFraW5nQWRkcmVzc2VzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB2YWxpZGF0b3IgYWRkcmVzcyB0byBkZWxlZ2F0ZSBmdW5kcyB0by5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRvciBWYWxpZGF0b3IgYWRkcmVzcyB0byBkZWxlZ2F0ZSBmdW5kcyB0by5cbiAgICogQHJldHVybnMge1N0YWtpbmdEZWxlZ2F0ZUJ1aWxkZXJ9IFRoaXMgc3Rha2luZyBidWlsZGVyLlxuICAgKlxuICAgKi9cbiAgdmFsaWRhdG9yKHZhbGlkYXRvcjogc3RyaW5nKTogdGhpcyB7XG4gICAgdmFsaWRhdGVBZGRyZXNzKHZhbGlkYXRvciwgJ3ZhbGlkYXRvcicpO1xuICAgIHRoaXMuX3ZhbGlkYXRvciA9IHZhbGlkYXRvcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgYnVpbGRJbXBsZW1lbnRhdGlvbigpOiBQcm9taXNlPFRyYW5zYWN0aW9uPiB7XG4gICAgYXNzZXJ0KHRoaXMuX3NlbmRlciwgJ1NlbmRlciBtdXN0IGJlIHNldCBiZWZvcmUgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgYXNzZXJ0KHRoaXMuX3ZhbGlkYXRvciwgJ1ZhbGlkYXRvciBtdXN0IGJlIHNldCBiZWZvcmUgYnVpbGRpbmcgdGhlIHRyYW5zYWN0aW9uJyk7XG5cbiAgICBpZiAodGhpcy5fc3Rha2luZ0FkZHJlc3NlcyAmJiB0aGlzLl9zdGFraW5nQWRkcmVzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX2luc3RydWN0aW9uc0RhdGEgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc3Rha2luZ0FkZHJlc3Mgb2YgdGhpcy5fc3Rha2luZ0FkZHJlc3Nlcykge1xuICAgICAgICBhc3NlcnQoc3Rha2luZ0FkZHJlc3MsICdTdGFraW5nIEFkZHJlc3MgbXVzdCBiZSBzZXQgYmVmb3JlIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbicpO1xuICAgICAgICBpZiAodGhpcy5fc2VuZGVyID09PSBzdGFraW5nQWRkcmVzcykge1xuICAgICAgICAgIHRocm93IG5ldyBCdWlsZFRyYW5zYWN0aW9uRXJyb3IoJ1NlbmRlciBhZGRyZXNzIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgU3Rha2luZyBhZGRyZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3Rha2luZ0FjY291bnREYXRhOiBTdGFraW5nRGVsZWdhdGUgPSB7XG4gICAgICAgICAgdHlwZTogSW5zdHJ1Y3Rpb25CdWlsZGVyVHlwZXMuU3Rha2luZ0RlbGVnYXRlLFxuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgZnJvbUFkZHJlc3M6IHRoaXMuX3NlbmRlcixcbiAgICAgICAgICAgIHN0YWtpbmdBZGRyZXNzOiBzdGFraW5nQWRkcmVzcyxcbiAgICAgICAgICAgIHZhbGlkYXRvcjogdGhpcy5fdmFsaWRhdG9yLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luc3RydWN0aW9uc0RhdGEucHVzaChzdGFraW5nQWNjb3VudERhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQodGhpcy5fc3Rha2luZ0FkZHJlc3MsICdTdGFraW5nIEFkZHJlc3MgbXVzdCBiZSBzZXQgYmVmb3JlIGJ1aWxkaW5nIHRoZSB0cmFuc2FjdGlvbicpO1xuICAgICAgaWYgKHRoaXMuX3NlbmRlciA9PT0gdGhpcy5fc3Rha2luZ0FkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJ1aWxkVHJhbnNhY3Rpb25FcnJvcignU2VuZGVyIGFkZHJlc3MgY2Fubm90IGJlIHRoZSBzYW1lIGFzIHRoZSBTdGFraW5nIGFkZHJlc3MnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3Rha2luZ0FjY291bnREYXRhOiBTdGFraW5nRGVsZWdhdGUgPSB7XG4gICAgICAgIHR5cGU6IEluc3RydWN0aW9uQnVpbGRlclR5cGVzLlN0YWtpbmdEZWxlZ2F0ZSxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgZnJvbUFkZHJlc3M6IHRoaXMuX3NlbmRlcixcbiAgICAgICAgICBzdGFraW5nQWRkcmVzczogdGhpcy5fc3Rha2luZ0FkZHJlc3MsXG4gICAgICAgICAgdmFsaWRhdG9yOiB0aGlzLl92YWxpZGF0b3IsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgICAgdGhpcy5faW5zdHJ1Y3Rpb25zRGF0YSA9IFtzdGFraW5nQWNjb3VudERhdGFdO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgc3VwZXIuYnVpbGRJbXBsZW1lbnRhdGlvbigpO1xuICB9XG59XG4iXX0=