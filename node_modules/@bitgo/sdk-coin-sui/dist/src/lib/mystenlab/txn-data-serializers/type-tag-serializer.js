"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeTagSerializer = void 0;
const types_1 = require("../types");
const VECTOR_REGEX = /^vector<(.+)>$/;
const STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;
class TypeTagSerializer {
    static parseFromStr(str, normalizeAddress = false) {
        if (str === 'address') {
            return { address: null };
        }
        else if (str === 'bool') {
            return { bool: null };
        }
        else if (str === 'u8') {
            return { u8: null };
        }
        else if (str === 'u16') {
            return { u16: null };
        }
        else if (str === 'u32') {
            return { u32: null };
        }
        else if (str === 'u64') {
            return { u64: null };
        }
        else if (str === 'u128') {
            return { u128: null };
        }
        else if (str === 'u256') {
            return { u256: null };
        }
        else if (str === 'signer') {
            return { signer: null };
        }
        const vectorMatch = str.match(VECTOR_REGEX);
        if (vectorMatch) {
            return {
                vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),
            };
        }
        const structMatch = str.match(STRUCT_REGEX);
        if (structMatch) {
            const address = normalizeAddress ? types_1.normalizeSuiAddress(structMatch[1]) : structMatch[1];
            return {
                struct: {
                    address,
                    module: structMatch[2],
                    name: structMatch[3],
                    typeParams: structMatch[5] === undefined ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),
                },
            };
        }
        throw new Error(`Encountered unexpected token when parsing type args for ${str}`);
    }
    static parseStructTypeArgs(str, normalizeAddress = false) {
        // split `str` by all `,` outside angle brackets
        const tok = [];
        let word = '';
        let nestedAngleBrackets = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            if (char === '<') {
                nestedAngleBrackets++;
            }
            if (char === '>') {
                nestedAngleBrackets--;
            }
            if (nestedAngleBrackets === 0 && char === ',') {
                tok.push(word.trim());
                word = '';
                continue;
            }
            word += char;
        }
        tok.push(word.trim());
        return tok.map((tok) => TypeTagSerializer.parseFromStr(tok, normalizeAddress));
    }
    static tagToString(tag) {
        if ('bool' in tag) {
            return 'bool';
        }
        if ('u8' in tag) {
            return 'u8';
        }
        if ('u16' in tag) {
            return 'u16';
        }
        if ('u32' in tag) {
            return 'u32';
        }
        if ('u64' in tag) {
            return 'u64';
        }
        if ('u128' in tag) {
            return 'u128';
        }
        if ('u256' in tag) {
            return 'u256';
        }
        if ('address' in tag) {
            return 'address';
        }
        if ('signer' in tag) {
            return 'signer';
        }
        if ('vector' in tag) {
            return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;
        }
        if ('struct' in tag) {
            const struct = tag.struct;
            const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');
            return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : ''}`;
        }
        throw new Error('Invalid TypeTag');
    }
}
exports.TypeTagSerializer = TypeTagSerializer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS10YWctc2VyaWFsaXplci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvbXlzdGVubGFiL3R4bi1kYXRhLXNlcmlhbGl6ZXJzL3R5cGUtdGFnLXNlcmlhbGl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsb0NBQXdEO0FBRXhELE1BQU0sWUFBWSxHQUFHLGdCQUFnQixDQUFDO0FBQ3RDLE1BQU0sWUFBWSxHQUFHLHFDQUFxQyxDQUFDO0FBRTNELE1BQWEsaUJBQWlCO0lBQzVCLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBVyxFQUFFLGdCQUFnQixHQUFHLEtBQUs7UUFDdkQsSUFBSSxHQUFHLEtBQUssU0FBUyxFQUFFO1lBQ3JCLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDMUI7YUFBTSxJQUFJLEdBQUcsS0FBSyxNQUFNLEVBQUU7WUFDekIsT0FBTyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUN2QjthQUFNLElBQUksR0FBRyxLQUFLLElBQUksRUFBRTtZQUN2QixPQUFPLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ3JCO2FBQU0sSUFBSSxHQUFHLEtBQUssS0FBSyxFQUFFO1lBQ3hCLE9BQU8sRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDdEI7YUFBTSxJQUFJLEdBQUcsS0FBSyxLQUFLLEVBQUU7WUFDeEIsT0FBTyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztTQUN0QjthQUFNLElBQUksR0FBRyxLQUFLLEtBQUssRUFBRTtZQUN4QixPQUFPLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxDQUFDO1NBQ3RCO2FBQU0sSUFBSSxHQUFHLEtBQUssTUFBTSxFQUFFO1lBQ3pCLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUM7U0FDdkI7YUFBTSxJQUFJLEdBQUcsS0FBSyxNQUFNLEVBQUU7WUFD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Q0QsSUFBSSxLQUFLLElBQUksR0FBRyxFQUFFO1lBQ2hCLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxJQUFJLEtBQUssSUFBSSxHQUFHLEVBQUU7WUFDaEIsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELElBQUksTUFBTSxJQUFJLEdBQUcsRUFBRTtZQUNqQixPQUFPLE1BQU0sQ0FBQztTQUNmO1FBQ0QsSUFBSSxNQUFNLElBQUksR0FBRyxFQUFFO1lBQ2pCLE9BQU8sTUFBTSxDQUFDO1NBQ2Y7UUFDRCxJQUFJLFNBQVMsSUFBSSxHQUFHLEVBQUU7WUFDcEIsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFDRCxJQUFJLFFBQVEsSUFBSSxHQUFHLEVBQUU7WUFDbkIsT0FBTyxRQUFRLENBQUM7U0FDakI7UUFDRCxJQUFJLFFBQVEsSUFBSSxHQUFHLEVBQUU7WUFDbkIsT0FBTyxVQUFVLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQztTQUMvRDtRQUNELElBQUksUUFBUSxJQUFJLEdBQUcsRUFBRTtZQUNuQixNQUFNLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDO1lBQzFCLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNuRixPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sS0FBSyxNQUFNLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztTQUNwRztRQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBQ0Y7QUE3R0QsOENBNkdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbm9ybWFsaXplU3VpQWRkcmVzcywgVHlwZVRhZyB9IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgVkVDVE9SX1JFR0VYID0gL152ZWN0b3I8KC4rKT4kLztcbmNvbnN0IFNUUlVDVF9SRUdFWCA9IC9eKFteOl0rKTo6KFteOl0rKTo6KFtePF0rKSg8KC4rKT4pPy87XG5cbmV4cG9ydCBjbGFzcyBUeXBlVGFnU2VyaWFsaXplciB7XG4gIHN0YXRpYyBwYXJzZUZyb21TdHIoc3RyOiBzdHJpbmcsIG5vcm1hbGl6ZUFkZHJlc3MgPSBmYWxzZSk6IFR5cGVUYWcge1xuICAgIGlmIChzdHIgPT09ICdhZGRyZXNzJykge1xuICAgICAgcmV0dXJuIHsgYWRkcmVzczogbnVsbCB9O1xuICAgIH0gZWxzZSBpZiAoc3RyID09PSAnYm9vbCcpIHtcbiAgICAgIHJldHVybiB7IGJvb2w6IG51bGwgfTtcbiAgICB9IGVsc2UgaWYgKHN0ciA9PT0gJ3U4Jykge1xuICAgICAgcmV0dXJuIHsgdTg6IG51bGwgfTtcbiAgICB9IGVsc2UgaWYgKHN0ciA9PT0gJ3UxNicpIHtcbiAgICAgIHJldHVybiB7IHUxNjogbnVsbCB9O1xuICAgIH0gZWxzZSBpZiAoc3RyID09PSAndTMyJykge1xuICAgICAgcmV0dXJuIHsgdTMyOiBudWxsIH07XG4gICAgfSBlbHNlIGlmIChzdHIgPT09ICd1NjQnKSB7XG4gICAgICByZXR1cm4geyB1NjQ6IG51bGwgfTtcbiAgICB9IGVsc2UgaWYgKHN0ciA9PT0gJ3UxMjgnKSB7XG4gICAgICByZXR1cm4geyB1MTI4OiBudWxsIH07XG4gICAgfSBlbHNlIGlmIChzdHIgPT09ICd1MjU2Jykge1xuICAgICAgcmV0dXJuIHsgdTI1NjogbnVsbCB9O1xuICAgIH0gZWxzZSBpZiAoc3RyID09PSAnc2lnbmVyJykge1xuICAgICAgcmV0dXJuIHsgc2lnbmVyOiBudWxsIH07XG4gICAgfVxuICAgIGNvbnN0IHZlY3Rvck1hdGNoID0gc3RyLm1hdGNoKFZFQ1RPUl9SRUdFWCk7XG4gICAgaWYgKHZlY3Rvck1hdGNoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2ZWN0b3I6IFR5cGVUYWdTZXJpYWxpemVyLnBhcnNlRnJvbVN0cih2ZWN0b3JNYXRjaFsxXSwgbm9ybWFsaXplQWRkcmVzcyksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHN0cnVjdE1hdGNoID0gc3RyLm1hdGNoKFNUUlVDVF9SRUdFWCk7XG4gICAgaWYgKHN0cnVjdE1hdGNoKSB7XG4gICAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyA/IG5vcm1hbGl6ZVN1aUFkZHJlc3Moc3RydWN0TWF0Y2hbMV0pIDogc3RydWN0TWF0Y2hbMV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJ1Y3Q6IHtcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIG1vZHVsZTogc3RydWN0TWF0Y2hbMl0sXG4gICAgICAgICAgbmFtZTogc3RydWN0TWF0Y2hbM10sXG4gICAgICAgICAgdHlwZVBhcmFtczpcbiAgICAgICAgICAgIHN0cnVjdE1hdGNoWzVdID09PSB1bmRlZmluZWQgPyBbXSA6IFR5cGVUYWdTZXJpYWxpemVyLnBhcnNlU3RydWN0VHlwZUFyZ3Moc3RydWN0TWF0Y2hbNV0sIG5vcm1hbGl6ZUFkZHJlc3MpLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVuY291bnRlcmVkIHVuZXhwZWN0ZWQgdG9rZW4gd2hlbiBwYXJzaW5nIHR5cGUgYXJncyBmb3IgJHtzdHJ9YCk7XG4gIH1cblxuICBzdGF0aWMgcGFyc2VTdHJ1Y3RUeXBlQXJncyhzdHI6IHN0cmluZywgbm9ybWFsaXplQWRkcmVzcyA9IGZhbHNlKTogVHlwZVRhZ1tdIHtcbiAgICAvLyBzcGxpdCBgc3RyYCBieSBhbGwgYCxgIG91dHNpZGUgYW5nbGUgYnJhY2tldHNcbiAgICBjb25zdCB0b2s6IEFycmF5PHN0cmluZz4gPSBbXTtcbiAgICBsZXQgd29yZCA9ICcnO1xuICAgIGxldCBuZXN0ZWRBbmdsZUJyYWNrZXRzID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hhciA9IHN0cltpXTtcbiAgICAgIGlmIChjaGFyID09PSAnPCcpIHtcbiAgICAgICAgbmVzdGVkQW5nbGVCcmFja2V0cysrO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXIgPT09ICc+Jykge1xuICAgICAgICBuZXN0ZWRBbmdsZUJyYWNrZXRzLS07XG4gICAgICB9XG4gICAgICBpZiAobmVzdGVkQW5nbGVCcmFja2V0cyA9PT0gMCAmJiBjaGFyID09PSAnLCcpIHtcbiAgICAgICAgdG9rLnB1c2god29yZC50cmltKCkpO1xuICAgICAgICB3b3JkID0gJyc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd29yZCArPSBjaGFyO1xuICAgIH1cblxuICAgIHRvay5wdXNoKHdvcmQudHJpbSgpKTtcblxuICAgIHJldHVybiB0b2subWFwKCh0b2spID0+IFR5cGVUYWdTZXJpYWxpemVyLnBhcnNlRnJvbVN0cih0b2ssIG5vcm1hbGl6ZUFkZHJlc3MpKTtcbiAgfVxuXG4gIHN0YXRpYyB0YWdUb1N0cmluZyh0YWc6IFR5cGVUYWcpOiBzdHJpbmcge1xuICAgIGlmICgnYm9vbCcgaW4gdGFnKSB7XG4gICAgICByZXR1cm4gJ2Jvb2wnO1xuICAgIH1cbiAgICBpZiAoJ3U4JyBpbiB0YWcpIHtcbiAgICAgIHJldHVybiAndTgnO1xuICAgIH1cbiAgICBpZiAoJ3UxNicgaW4gdGFnKSB7XG4gICAgICByZXR1cm4gJ3UxNic7XG4gICAgfVxuICAgIGlmICgndTMyJyBpbiB0YWcpIHtcbiAgICAgIHJldHVybiAndTMyJztcbiAgICB9XG4gICAgaWYgKCd1NjQnIGluIHRhZykge1xuICAgICAgcmV0dXJuICd1NjQnO1xuICAgIH1cbiAgICBpZiAoJ3UxMjgnIGluIHRhZykge1xuICAgICAgcmV0dXJuICd1MTI4JztcbiAgICB9XG4gICAgaWYgKCd1MjU2JyBpbiB0YWcpIHtcbiAgICAgIHJldHVybiAndTI1Nic7XG4gICAgfVxuICAgIGlmICgnYWRkcmVzcycgaW4gdGFnKSB7XG4gICAgICByZXR1cm4gJ2FkZHJlc3MnO1xuICAgIH1cbiAgICBpZiAoJ3NpZ25lcicgaW4gdGFnKSB7XG4gICAgICByZXR1cm4gJ3NpZ25lcic7XG4gICAgfVxuICAgIGlmICgndmVjdG9yJyBpbiB0YWcpIHtcbiAgICAgIHJldHVybiBgdmVjdG9yPCR7VHlwZVRhZ1NlcmlhbGl6ZXIudGFnVG9TdHJpbmcodGFnLnZlY3Rvcil9PmA7XG4gICAgfVxuICAgIGlmICgnc3RydWN0JyBpbiB0YWcpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IHRhZy5zdHJ1Y3Q7XG4gICAgICBjb25zdCB0eXBlUGFyYW1zID0gc3RydWN0LnR5cGVQYXJhbXMubWFwKFR5cGVUYWdTZXJpYWxpemVyLnRhZ1RvU3RyaW5nKS5qb2luKCcsICcpO1xuICAgICAgcmV0dXJuIGAke3N0cnVjdC5hZGRyZXNzfTo6JHtzdHJ1Y3QubW9kdWxlfTo6JHtzdHJ1Y3QubmFtZX0ke3R5cGVQYXJhbXMgPyBgPCR7dHlwZVBhcmFtc30+YCA6ICcnfWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBUeXBlVGFnJyk7XG4gIH1cbn1cbiJdfQ==