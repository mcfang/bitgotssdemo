"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.builder = exports.PROGRAMMABLE_CALL = exports.ARGUMENT = exports.TRANSACTION = exports.ENUM_KIND = exports.TRANSACTION_INNER = exports.PROGRAMMABLE_CALL_INNER = exports.PROGRAMMABLE_TX_BLOCK = exports.OBJECT_ARG = exports.TYPE_TAG = exports.CALL_ARG = exports.OPTION = exports.VECTOR = exports.ARGUMENT_INNER = void 0;
const bcs_1 = require("@mysten/bcs");
const sui_bcs_1 = require("../types/sui-bcs");
const common_1 = require("../types/common");
const type_tag_serializer_1 = require("../txn-data-serializers/type-tag-serializer");
exports.ARGUMENT_INNER = 'Argument';
exports.VECTOR = 'vector';
exports.OPTION = 'Option';
exports.CALL_ARG = 'CallArg';
exports.TYPE_TAG = 'TypeTag';
exports.OBJECT_ARG = 'ObjectArg';
exports.PROGRAMMABLE_TX_BLOCK = 'ProgrammableTransaction';
exports.PROGRAMMABLE_CALL_INNER = 'ProgrammableMoveCall';
exports.TRANSACTION_INNER = 'Transaction';
exports.ENUM_KIND = 'EnumKind';
/** Wrapper around transaction Enum to support `kind` matching in TS */
exports.TRANSACTION = [exports.ENUM_KIND, exports.TRANSACTION_INNER];
/** Wrapper around Argument Enum to support `kind` matching in TS */
exports.ARGUMENT = [exports.ENUM_KIND, exports.ARGUMENT_INNER];
/** Custom serializer for decoding package, module, function easier */
exports.PROGRAMMABLE_CALL = 'SimpleProgrammableMoveCall';
exports.builder = new bcs_1.BCS(sui_bcs_1.bcs)
    .registerStructType(exports.PROGRAMMABLE_TX_BLOCK, {
    inputs: [exports.VECTOR, exports.CALL_ARG],
    transactions: [exports.VECTOR, exports.TRANSACTION],
})
    .registerEnumType(exports.ARGUMENT_INNER, {
    GasCoin: null,
    Input: { index: bcs_1.BCS.U16 },
    Result: { index: bcs_1.BCS.U16 },
    NestedResult: { index: bcs_1.BCS.U16, resultIndex: bcs_1.BCS.U16 },
})
    .registerStructType(exports.PROGRAMMABLE_CALL_INNER, {
    package: bcs_1.BCS.ADDRESS,
    module: bcs_1.BCS.STRING,
    function: bcs_1.BCS.STRING,
    type_arguments: [exports.VECTOR, exports.TYPE_TAG],
    arguments: [exports.VECTOR, exports.ARGUMENT],
})
    .registerEnumType(exports.TRANSACTION_INNER, {
    /**
     * A Move Call - any public Move function can be called via
     * this transaction. The results can be used that instant to pass
     * into the next transaction.
     */
    MoveCall: exports.PROGRAMMABLE_CALL,
    /**
     * Transfer vector of objects to a receiver.
     */
    TransferObjects: {
        objects: [exports.VECTOR, exports.ARGUMENT],
        address: exports.ARGUMENT,
    },
    /**
     * Split `amount` from a `coin`.
     */
    SplitCoins: { coin: exports.ARGUMENT, amounts: [exports.VECTOR, exports.ARGUMENT] },
    /**
     * Merge Vector of Coins (`sources`) into a `destination`.
     */
    MergeCoins: { destination: exports.ARGUMENT, sources: [exports.VECTOR, exports.ARGUMENT] },
    /**
     * Publish a Move module.
     */
    Publish: {
        modules: [exports.VECTOR, [exports.VECTOR, bcs_1.BCS.U8]],
        dependencies: [exports.VECTOR, bcs_1.BCS.ADDRESS],
    },
    /**
     * Build a vector of objects using the input arguments.
     * It is impossible to construct a `vector<T: key>` otherwise,
     * so this call serves a utility function.
     */
    MakeMoveVec: {
        type: [exports.OPTION, exports.TYPE_TAG],
        objects: [exports.VECTOR, exports.ARGUMENT],
    },
});
/**
 * Wrapper around Enum, which transforms any `T` into an object with `kind` property:
 * @example
 * ```
 * let bcsEnum = { TransferObjects: { objects: [], address: ... } }
 * // becomes
 * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };
 * ```
 */
exports.builder.registerType([exports.ENUM_KIND, 'T'], function encode(writer, data, typeParams, typeMap) {
    const kind = data.kind;
    const invariant = { [kind]: data };
    const [enumType] = typeParams;
    return this.getTypeInterface(enumType)._encodeRaw.call(this, writer, invariant, typeParams, typeMap);
}, function decode(reader, typeParams, typeMap) {
    const [enumType] = typeParams;
    const data = this.getTypeInterface(enumType)._decodeRaw.call(this, reader, typeParams, typeMap);
    // enum invariant can only have one `key` field
    const kind = Object.keys(data)[0];
    return { kind, ...data[kind] };
}, (data) => {
    if (typeof data !== 'object' && !('kind' in data)) {
        throw new Error(`EnumKind: Missing property "kind" in the input ${JSON.stringify(data)}`);
    }
    return true;
});
/**
 * Custom deserializer for the ProgrammableCall.
 *
 * Hides the inner structure and gives a simpler, more convenient
 * interface to encode and decode this struct as a part of `TransactionData`.
 *
 * - `(package)::(module)::(function)` are now `target` property.
 * - `TypeTag[]` array is now passed as strings, not as a struct.
 */
exports.builder.registerType(exports.PROGRAMMABLE_CALL, function encodeProgrammableTx(writer, data, typeParams, typeMap) {
    const [pkg, module, fun] = data.target.split('::');
    const type_arguments = data.typeArguments.map((tag) => type_tag_serializer_1.TypeTagSerializer.parseFromStr(tag, true));
    return this.getTypeInterface(exports.PROGRAMMABLE_CALL_INNER)._encodeRaw.call(this, writer, {
        package: common_1.normalizeSuiAddress(pkg),
        module,
        function: fun,
        type_arguments,
        arguments: data.arguments,
    }, typeParams, typeMap);
}, function decodeProgrammableTx(reader, typeParams, typeMap) {
    let data = exports.builder
        .getTypeInterface(exports.PROGRAMMABLE_CALL_INNER)
        ._decodeRaw.call(this, reader, typeParams, typeMap);
    return {
        target: [data.package, data.module, data.function].join('::'),
        arguments: data.arguments,
        typeArguments: data.type_arguments.map(type_tag_serializer_1.TypeTagSerializer.tagToString),
    };
}, 
// Validation callback to error out if the data format is invalid.
// TODO: make sure TypeTag can be parsed.
(data) => {
    return data.target.split('::').length === 3;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9teXN0ZW5sYWIvYnVpbGRlci9iY3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQTRDO0FBQzVDLDhDQUFnRDtBQUNoRCw0Q0FBc0Q7QUFDdEQscUZBQWdGO0FBR25FLFFBQUEsY0FBYyxHQUFHLFVBQVUsQ0FBQztBQUM1QixRQUFBLE1BQU0sR0FBRyxRQUFRLENBQUM7QUFDbEIsUUFBQSxNQUFNLEdBQUcsUUFBUSxDQUFDO0FBQ2xCLFFBQUEsUUFBUSxHQUFHLFNBQVMsQ0FBQztBQUNyQixRQUFBLFFBQVEsR0FBRyxTQUFTLENBQUM7QUFDckIsUUFBQSxVQUFVLEdBQUcsV0FBVyxDQUFDO0FBQ3pCLFFBQUEscUJBQXFCLEdBQUcseUJBQXlCLENBQUM7QUFDbEQsUUFBQSx1QkFBdUIsR0FBRyxzQkFBc0IsQ0FBQztBQUNqRCxRQUFBLGlCQUFpQixHQUFHLGFBQWEsQ0FBQztBQUVsQyxRQUFBLFNBQVMsR0FBRyxVQUFVLENBQUM7QUFFcEMsdUVBQXVFO0FBQzFELFFBQUEsV0FBVyxHQUFhLENBQUMsaUJBQVMsRUFBRSx5QkFBaUIsQ0FBQyxDQUFDO0FBQ3BFLG9FQUFvRTtBQUN2RCxRQUFBLFFBQVEsR0FBYSxDQUFDLGlCQUFTLEVBQUUsc0JBQWMsQ0FBQyxDQUFDO0FBRTlELHNFQUFzRTtBQUN6RCxRQUFBLGlCQUFpQixHQUFHLDRCQUE0QixDQUFDO0FBTWpELFFBQUEsT0FBTyxHQUFHLElBQUksU0FBRyxDQUFDLGFBQUcsQ0FBQztLQUNoQyxrQkFBa0IsQ0FBQyw2QkFBcUIsRUFBRTtJQUN6QyxNQUFNLEVBQUUsQ0FBQyxjQUFNLEVBQUUsZ0JBQVEsQ0FBQztJQUMxQixZQUFZLEVBQUUsQ0FBQyxjQUFNLEVBQUUsbUJBQVcsQ0FBQztDQUNwQyxDQUFDO0tBQ0QsZ0JBQWdCLENBQUMsc0JBQWMsRUFBRTtJQUNoQyxPQUFPLEVBQUUs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QUFnQixDQUFDLCtCQUF1QixDQUFDO1NBQ3pDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFFdEQsT0FBTztRQUNMLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztRQUM3RCxTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVM7UUFDekIsYUFBYSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLHVDQUFpQixDQUFDLFdBQVcsQ0FBQztLQUN0RSxDQUFDO0FBQ0osQ0FBQztBQUNELGtFQUFrRTtBQUNsRSx5Q0FBeUM7QUFDekMsQ0FBQyxJQUF5QixFQUFFLEVBQUU7SUFDNUIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FDRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQkNTLCBUeXBlTmFtZSB9IGZyb20gJ0BteXN0ZW4vYmNzJztcbmltcG9ydCB7IGJjcywgVHlwZVRhZyB9IGZyb20gJy4uL3R5cGVzL3N1aS1iY3MnO1xuaW1wb3J0IHsgbm9ybWFsaXplU3VpQWRkcmVzcyB9IGZyb20gJy4uL3R5cGVzL2NvbW1vbic7XG5pbXBvcnQgeyBUeXBlVGFnU2VyaWFsaXplciB9IGZyb20gJy4uL3R4bi1kYXRhLXNlcmlhbGl6ZXJzL3R5cGUtdGFnLXNlcmlhbGl6ZXInO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25Bcmd1bWVudCwgTW92ZUNhbGxUcmFuc2FjdGlvbiB9IGZyb20gJy4vVHJhbnNhY3Rpb25zJztcblxuZXhwb3J0IGNvbnN0IEFSR1VNRU5UX0lOTkVSID0gJ0FyZ3VtZW50JztcbmV4cG9ydCBjb25zdCBWRUNUT1IgPSAndmVjdG9yJztcbmV4cG9ydCBjb25zdCBPUFRJT04gPSAnT3B0aW9uJztcbmV4cG9ydCBjb25zdCBDQUxMX0FSRyA9ICdDYWxsQXJnJztcbmV4cG9ydCBjb25zdCBUWVBFX1RBRyA9ICdUeXBlVGFnJztcbmV4cG9ydCBjb25zdCBPQkpFQ1RfQVJHID0gJ09iamVjdEFyZyc7XG5leHBvcnQgY29uc3QgUFJPR1JBTU1BQkxFX1RYX0JMT0NLID0gJ1Byb2dyYW1tYWJsZVRyYW5zYWN0aW9uJztcbmV4cG9ydCBjb25zdCBQUk9HUkFNTUFCTEVfQ0FMTF9JTk5FUiA9ICdQcm9ncmFtbWFibGVNb3ZlQ2FsbCc7XG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fSU5ORVIgPSAnVHJhbnNhY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgRU5VTV9LSU5EID0gJ0VudW1LaW5kJztcblxuLyoqIFdyYXBwZXIgYXJvdW5kIHRyYW5zYWN0aW9uIEVudW0gdG8gc3VwcG9ydCBga2luZGAgbWF0Y2hpbmcgaW4gVFMgKi9cbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTjogVHlwZU5hbWUgPSBbRU5VTV9LSU5ELCBUUkFOU0FDVElPTl9JTk5FUl07XG4vKiogV3JhcHBlciBhcm91bmQgQXJndW1lbnQgRW51bSB0byBzdXBwb3J0IGBraW5kYCBtYXRjaGluZyBpbiBUUyAqL1xuZXhwb3J0IGNvbnN0IEFSR1VNRU5UOiBUeXBlTmFtZSA9IFtFTlVNX0tJTkQsIEFSR1VNRU5UX0lOTkVSXTtcblxuLyoqIEN1c3RvbSBzZXJpYWxpemVyIGZvciBkZWNvZGluZyBwYWNrYWdlLCBtb2R1bGUsIGZ1bmN0aW9uIGVhc2llciAqL1xuZXhwb3J0IGNvbnN0IFBST0dSQU1NQUJMRV9DQUxMID0gJ1NpbXBsZVByb2dyYW1tYWJsZU1vdmVDYWxsJztcblxuLyoqIFRyYW5zYWN0aW9uIHR5cGVzICovXG5cbmV4cG9ydCB0eXBlIE9wdGlvbjxUPiA9IHsgc29tZTogVCB9IHwgeyBub25lOiB0cnVlIH07XG5cbmV4cG9ydCBjb25zdCBidWlsZGVyID0gbmV3IEJDUyhiY3MpXG4gIC5yZWdpc3RlclN0cnVjdFR5cGUoUFJPR1JBTU1BQkxFX1RYX0JMT0NLLCB7XG4gICAgaW5wdXRzOiBbVkVDVE9SLCBDQUxMX0FSR10sXG4gICAgdHJhbnNhY3Rpb25zOiBbVkVDVE9SLCBUUkFOU0FDVElPTl0sXG4gIH0pXG4gIC5yZWdpc3RlckVudW1UeXBlKEFSR1VNRU5UX0lOTkVSLCB7XG4gICAgR2FzQ29pbjogbnVsbCxcbiAgICBJbnB1dDogeyBpbmRleDogQkNTLlUxNiB9LFxuICAgIFJlc3VsdDogeyBpbmRleDogQkNTLlUxNiB9LFxuICAgIE5lc3RlZFJlc3VsdDogeyBpbmRleDogQkNTLlUxNiwgcmVzdWx0SW5kZXg6IEJDUy5VMTYgfSxcbiAgfSlcbiAgLnJlZ2lzdGVyU3RydWN0VHlwZShQUk9HUkFNTUFCTEVfQ0FMTF9JTk5FUiwge1xuICAgIHBhY2thZ2U6IEJDUy5BRERSRVNTLFxuICAgIG1vZHVsZTogQkNTLlNUUklORyxcbiAgICBmdW5jdGlvbjogQkNTLlNUUklORyxcbiAgICB0eXBlX2FyZ3VtZW50czogW1ZFQ1RPUiwgVFlQRV9UQUddLFxuICAgIGFyZ3VtZW50czogW1ZFQ1RPUiwgQVJHVU1FTlRdLFxuICB9KVxuICAucmVnaXN0ZXJFbnVtVHlwZShUUkFOU0FDVElPTl9JTk5FUiwge1xuICAgIC8qKlxuICAgICAqIEEgTW92ZSBDYWxsIC0gYW55IHB1YmxpYyBNb3ZlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgdmlhXG4gICAgICogdGhpcyB0cmFuc2FjdGlvbi4gVGhlIHJlc3VsdHMgY2FuIGJlIHVzZWQgdGhhdCBpbnN0YW50IHRvIHBhc3NcbiAgICAgKiBpbnRvIHRoZSBuZXh0IHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIE1vdmVDYWxsOiBQUk9HUkFNTUFCTEVfQ0FMTCxcbiAgICAvKipcbiAgICAgKiBUcmFuc2ZlciB2ZWN0b3Igb2Ygb2JqZWN0cyB0byBhIHJlY2VpdmVyLlxuICAgICAqL1xuICAgIFRyYW5zZmVyT2JqZWN0czoge1xuICAgICAgb2JqZWN0czogW1ZFQ1RPUiwgQVJHVU1FTlRdLFxuICAgICAgYWRkcmVzczogQVJHVU1FTlQsXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTcGxpdCBgYW1vdW50YCBmcm9tIGEgYGNvaW5gLlxuICAgICAqL1xuICAgIFNwbGl0Q29pbnM6IHsgY29pbjogQVJHVU1FTlQsIGFtb3VudHM6IFtWRUNUT1IsIEFSR1VNRU5UXSB9LFxuICAgIC8qKlxuICAgICAqIE1lcmdlIFZlY3RvciBvZiBDb2lucyAoYHNvdXJjZXNgKSBpbnRvIGEgYGRlc3RpbmF0aW9uYC5cbiAgICAgKi9cbiAgICBNZXJnZUNvaW5zOiB7IGRlc3RpbmF0aW9uOiBBUkdVTUVOVCwgc291cmNlczogW1ZFQ1RPUiwgQVJHVU1FTlRdIH0sXG4gICAgLyoqXG4gICAgICogUHVibGlzaCBhIE1vdmUgbW9kdWxlLlxuICAgICAqL1xuICAgIFB1Ymxpc2g6IHtcbiAgICAgIG1vZHVsZXM6IFtWRUNUT1IsIFtWRUNUT1IsIEJDUy5VOF1dLFxuICAgICAgZGVwZW5kZW5jaWVzOiBbVkVDVE9SLCBCQ1MuQUREUkVTU10sXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIHZlY3RvciBvZiBvYmplY3RzIHVzaW5nIHRoZSBpbnB1dCBhcmd1bWVudHMuXG4gICAgICogSXQgaXMgaW1wb3NzaWJsZSB0byBjb25zdHJ1Y3QgYSBgdmVjdG9yPFQ6IGtleT5gIG90aGVyd2lzZSxcbiAgICAgKiBzbyB0aGlzIGNhbGwgc2VydmVzIGEgdXRpbGl0eSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBNYWtlTW92ZVZlYzoge1xuICAgICAgdHlwZTogW09QVElPTiwgVFlQRV9UQUddLFxuICAgICAgb2JqZWN0czogW1ZFQ1RPUiwgQVJHVU1FTlRdLFxuICAgIH0sXG4gIH0pO1xuXG4vKipcbiAqIFV0aWxpdGllcyBmb3IgYmV0dGVyIGRlY29kaW5nLlxuICovXG5cbnR5cGUgUHJvZ3JhbW1hYmxlQ2FsbElubmVyID0ge1xuICBwYWNrYWdlOiBzdHJpbmc7XG4gIG1vZHVsZTogc3RyaW5nO1xuICBmdW5jdGlvbjogc3RyaW5nO1xuICB0eXBlX2FyZ3VtZW50czogVHlwZVRhZ1tdO1xuICBhcmd1bWVudHM6IFRyYW5zYWN0aW9uQXJndW1lbnRbXTtcbn07XG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgRW51bSwgd2hpY2ggdHJhbnNmb3JtcyBhbnkgYFRgIGludG8gYW4gb2JqZWN0IHdpdGggYGtpbmRgIHByb3BlcnR5OlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogbGV0IGJjc0VudW0gPSB7IFRyYW5zZmVyT2JqZWN0czogeyBvYmplY3RzOiBbXSwgYWRkcmVzczogLi4uIH0gfVxuICogLy8gYmVjb21lc1xuICogbGV0IHRyYW5zbGF0ZWRFbnVtID0geyBraW5kOiAnVHJhbnNmZXJPYmplY3RzJywgb2JqZWN0czogW10sIGFkZHJlc3M6IC4uLiB9O1xuICogYGBgXG4gKi9cbmJ1aWxkZXIucmVnaXN0ZXJUeXBlKFxuICBbRU5VTV9LSU5ELCAnVCddLFxuICBmdW5jdGlvbiBlbmNvZGUodGhpczogQkNTLCB3cml0ZXIsIGRhdGE6IHsga2luZDogc3RyaW5nIH0sIHR5cGVQYXJhbXMsIHR5cGVNYXApIHtcbiAgICBjb25zdCBraW5kID0gZGF0YS5raW5kO1xuICAgIGNvbnN0IGludmFyaWFudCA9IHsgW2tpbmRdOiBkYXRhIH07XG4gICAgY29uc3QgW2VudW1UeXBlXSA9IHR5cGVQYXJhbXM7XG5cbiAgICByZXR1cm4gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKGVudW1UeXBlIGFzIHN0cmluZykuX2VuY29kZVJhdy5jYWxsKHRoaXMsIHdyaXRlciwgaW52YXJpYW50LCB0eXBlUGFyYW1zLCB0eXBlTWFwKTtcbiAgfSxcbiAgZnVuY3Rpb24gZGVjb2RlKHRoaXM6IEJDUywgcmVhZGVyLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgY29uc3QgW2VudW1UeXBlXSA9IHR5cGVQYXJhbXM7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0VHlwZUludGVyZmFjZShlbnVtVHlwZSBhcyBzdHJpbmcpLl9kZWNvZGVSYXcuY2FsbCh0aGlzLCByZWFkZXIsIHR5cGVQYXJhbXMsIHR5cGVNYXApO1xuXG4gICAgLy8gZW51bSBpbnZhcmlhbnQgY2FuIG9ubHkgaGF2ZSBvbmUgYGtleWAgZmllbGRcbiAgICBjb25zdCBraW5kID0gT2JqZWN0LmtleXMoZGF0YSlbMF07XG4gICAgcmV0dXJuIHsga2luZCwgLi4uZGF0YVtraW5kXSB9O1xuICB9LFxuICAoZGF0YTogeyBraW5kOiBzdHJpbmcgfSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgJiYgISgna2luZCcgaW4gZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRW51bUtpbmQ6IE1pc3NpbmcgcHJvcGVydHkgXCJraW5kXCIgaW4gdGhlIGlucHV0ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbik7XG5cbi8qKlxuICogQ3VzdG9tIGRlc2VyaWFsaXplciBmb3IgdGhlIFByb2dyYW1tYWJsZUNhbGwuXG4gKlxuICogSGlkZXMgdGhlIGlubmVyIHN0cnVjdHVyZSBhbmQgZ2l2ZXMgYSBzaW1wbGVyLCBtb3JlIGNvbnZlbmllbnRcbiAqIGludGVyZmFjZSB0byBlbmNvZGUgYW5kIGRlY29kZSB0aGlzIHN0cnVjdCBhcyBhIHBhcnQgb2YgYFRyYW5zYWN0aW9uRGF0YWAuXG4gKlxuICogLSBgKHBhY2thZ2UpOjoobW9kdWxlKTo6KGZ1bmN0aW9uKWAgYXJlIG5vdyBgdGFyZ2V0YCBwcm9wZXJ0eS5cbiAqIC0gYFR5cGVUYWdbXWAgYXJyYXkgaXMgbm93IHBhc3NlZCBhcyBzdHJpbmdzLCBub3QgYXMgYSBzdHJ1Y3QuXG4gKi9cbmJ1aWxkZXIucmVnaXN0ZXJUeXBlKFxuICBQUk9HUkFNTUFCTEVfQ0FMTCxcbiAgZnVuY3Rpb24gZW5jb2RlUHJvZ3JhbW1hYmxlVHgodGhpczogQkNTLCB3cml0ZXIsIGRhdGE6IE1vdmVDYWxsVHJhbnNhY3Rpb24sIHR5cGVQYXJhbXMsIHR5cGVNYXApIHtcbiAgICBjb25zdCBbcGtnLCBtb2R1bGUsIGZ1bl0gPSBkYXRhLnRhcmdldC5zcGxpdCgnOjonKTtcbiAgICBjb25zdCB0eXBlX2FyZ3VtZW50cyA9IGRhdGEudHlwZUFyZ3VtZW50cy5tYXAoKHRhZykgPT4gVHlwZVRhZ1NlcmlhbGl6ZXIucGFyc2VGcm9tU3RyKHRhZywgdHJ1ZSkpO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZUludGVyZmFjZShQUk9HUkFNTUFCTEVfQ0FMTF9JTk5FUikuX2VuY29kZVJhdy5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIHdyaXRlcixcbiAgICAgIHtcbiAgICAgICAgcGFja2FnZTogbm9ybWFsaXplU3VpQWRkcmVzcyhwa2cpLFxuICAgICAgICBtb2R1bGUsXG4gICAgICAgIGZ1bmN0aW9uOiBmdW4sXG4gICAgICAgIHR5cGVfYXJndW1lbnRzLFxuICAgICAgICBhcmd1bWVudHM6IGRhdGEuYXJndW1lbnRzLFxuICAgICAgfSBhcyBQcm9ncmFtbWFibGVDYWxsSW5uZXIsXG4gICAgICB0eXBlUGFyYW1zLFxuICAgICAgdHlwZU1hcFxuICAgICk7XG4gIH0sXG4gIGZ1bmN0aW9uIGRlY29kZVByb2dyYW1tYWJsZVR4KHRoaXM6IEJDUywgcmVhZGVyLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgbGV0IGRhdGE6IFByb2dyYW1tYWJsZUNhbGxJbm5lciA9IGJ1aWxkZXJcbiAgICAgIC5nZXRUeXBlSW50ZXJmYWNlKFBST0dSQU1NQUJMRV9DQUxMX0lOTkVSKVxuICAgICAgLl9kZWNvZGVSYXcuY2FsbCh0aGlzLCByZWFkZXIsIHR5cGVQYXJhbXMsIHR5cGVNYXApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldDogW2RhdGEucGFja2FnZSwgZGF0YS5tb2R1bGUsIGRhdGEuZnVuY3Rpb25dLmpvaW4oJzo6JyksXG4gICAgICBhcmd1bWVudHM6IGRhdGEuYXJndW1lbnRzLFxuICAgICAgdHlwZUFyZ3VtZW50czogZGF0YS50eXBlX2FyZ3VtZW50cy5tYXAoVHlwZVRhZ1NlcmlhbGl6ZXIudGFnVG9TdHJpbmcpLFxuICAgIH07XG4gIH0sXG4gIC8vIFZhbGlkYXRpb24gY2FsbGJhY2sgdG8gZXJyb3Igb3V0IGlmIHRoZSBkYXRhIGZvcm1hdCBpcyBpbnZhbGlkLlxuICAvLyBUT0RPOiBtYWtlIHN1cmUgVHlwZVRhZyBjYW4gYmUgcGFyc2VkLlxuICAoZGF0YTogTW92ZUNhbGxUcmFuc2FjdGlvbikgPT4ge1xuICAgIHJldHVybiBkYXRhLnRhcmdldC5zcGxpdCgnOjonKS5sZW5ndGggPT09IDM7XG4gIH1cbik7XG4iXX0=