"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const local_forging_1 = require("@taquito/local-forging");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const multisigUtils_1 = require("./multisigUtils");
const Utils = __importStar(require("./utils"));
/**
 * Tezos transaction model.
 */
class Transaction extends sdk_core_1.BaseTransaction {
    /**
     * Public constructor.
     *
     * @param {Readonly<CoinConfig>} coinConfig
     */
    constructor(coinConfig) {
        super(coinConfig);
        this._owners = [];
    }
    /**
     * Initialize the transaction fields based on another serialized transaction.
     *
     * @param serializedTransaction Transaction in broadcast format.
     */
    async initFromSerializedTransaction(serializedTransaction) {
        this._encodedTransaction = serializedTransaction;
        try {
            const parsedTransaction = await local_forging_1.localForger.parse(serializedTransaction);
            await this.initFromParsedTransaction(parsedTransaction);
        }
        catch (e) {
            // If it throws, it is possible the serialized transaction is signed, which is not supported
            // by local-forging. Try extracting the last 64 bytes and parse it again.
            const unsignedSerializedTransaction = serializedTransaction.slice(0, -128);
            const signature = serializedTransaction.slice(-128);
            if (Utils.isValidSignature(signature)) {
                throw new sdk_core_1.ParseTransactionError('Invalid transaction');
            }
            // TODO: encode the signature and save it in _signature
            const parsedTransaction = await local_forging_1.localForger.parse(unsignedSerializedTransaction);
            const transactionId = await Utils.calculateTransactionId(serializedTransaction);
            await this.initFromParsedTransaction(parsedTransaction, transactionId);
        }
    }
    /**
     * Initialize the transaction fields based on another parsed transaction.
     *
     * @param {ParsedTransaction} parsedTransaction A Tezos transaction object
     * @param {string} transactionId The transaction id of the parsedTransaction if it is signed
     */
    async initFromParsedTransaction(parsedTransaction, transactionId) {
        if (!this._encodedTransaction) {
            this._encodedTransaction = await local_forging_1.localForger.forge(parsedTransaction);
        }
        if (transactionId) {
            // If the transaction id is passed, save it and clean up the entries since they will be
            // recalculated
            this._id = transactionId;
            this._inputs = [];
            this._outputs = [];
        }
        else {
            this._id = '';
        }
        this._parsedTransaction = parsedTransaction;
        let operationIndex = 0;
        for (const operation of parsedTransaction.contents) {
            if (this._source && this._source !== operation.source) {
                throw new sdk_core_1.InvalidTransactionError('Source must be the same for every operation but it changed from ' + this._source + ' to ' + operation.source);
            }
            else {
                this._source = operation.source;
            }
            switch (operation.kind) {
                case local_forging_1.CODEC.OP_ORIGINATION:
                    await this.recordOriginationOpFields(operation, operationIndex);
                    operationIndex++;
                    break;
                case local_forging_1.CODEC.OP_REVEAL:
                    this.recordRevealOpFields(operation);
                    break;
                case local_forging_1.CODEC.OP_TRANSACTION:
                    this.recordTransactionOpFields(operation);
                    break;
                default:
                    break;
            }
        }
    }
    /**
     * Record the most important fields from an origination operation.
     *
     * @param {Operation} operation An operation object from a Tezos transaction
     * @param {number} index The origination operation index in the transaction. Used to calculate the
     *      originated address
     */
    async recordOriginationOpFields(operation, index) {
        const originationData = multisigUtils_1.getOriginationDataFromOperation(operation);
        if (originationData.forwarderDestination) {
            this._type = sdk_core_1.TransactionType.AddressInitialization;
            this._forwarderDestination = originationData.forwarderDestination;
        }
        else {
            this._type = sdk_core_1.TransactionType.WalletInitialization;
            this._owners = multisigUtils_1.getOwnersPublicKeys(operation);
        }
        this._delegate = operation.delegate;
        this._outputs.push({
            // Kt addresses can only be calculated for signed transactions with an id
            address: this._id ? await Utils.calculateOriginatedAddress(this._id, index) : '',
            // Balance
            value: operation.balance,
        });
        this._inputs.push({
            address: operation.source,
            // Balance + fees + max gas + max storage are paid by the source account
            value: new bignumber_js_1.default(operation.balance).plus(operation.fee).toString(),
        });
    }
    /**
     * Record the most important fields from a reveal operation.
     *
     * @param {RevealOp} operation A reveal operation object from a Tezos transaction
     */
    recordRevealOpFields(operation) {
        this._type = sdk_core_1.TransactionType.AccountUpdate;
        this._publicKeyToReveal = operation.public_key;
        this._inputs.push({
            address: operation.source,
            // Balance + fees + max gas + max storage are paid by the source account
            value: operation.fee,
        });
    }
    /**
     * Record the most important fields for a Transaction operation.
     *
     * @param {TransactionOp} operation A transaction object from a Tezos operation
     */
    recordTransactionOpFields(operation) {
        if (operation.parameters) {
            this._type = sdk_core_1.TransactionType.Send;
        }
        else {
            this._type = sdk_core_1.TransactionType.SingleSigSend;
        }
        const transferData = multisigUtils_1.getMultisigTransferDataFromOperation(operation);
        // Fees are paid by the source account, along with the amount in the transaction
        this._inputs.push({
            address: operation.source,
            value: new bignumber_js_1.default(transferData.fee.fee).toFixed(0),
        });
        if (transferData.coin === 'mutez') {
            this._outputs.push({
                // Kt addresses can only be calculated for signed transactions with an id
                address: transferData.to,
                // Balance
                value: transferData.amount,
            });
            // The funds being transferred from the wallet
            this._inputs.push({
                address: transferData.from,
                // Balance + fees + max gas + max storage are paid by the source account
                value: transferData.amount,
            });
        }
    }
    /**
     * Sign the transaction with the provided key. It does not check if the signer is allowed to sign
     * it or not.
     *
     * @param {KeyPair} keyPair The key to sign the transaction with
     */
    async sign(keyPair) {
        // TODO: fail if the transaction is already signed
        // Check if there is a transaction to sign
        if (!this._parsedTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction');
        }
        // Get the transaction body to sign
        const encodedTransaction = await local_forging_1.localForger.forge(this._parsedTransaction);
        const signedTransaction = await Utils.sign(keyPair, encodedTransaction);
        this._encodedTransaction = signedTransaction.sbytes;
        // The transaction id can only be calculated for signed transactions
        this._id = await Utils.calculateTransactionId(this._encodedTransaction);
        await this.initFromParsedTransaction(this._parsedTransaction, this._id);
        this._signatures.push(signedTransaction.sig);
    }
    /**
     * Update the list of signatures for a multisig transaction operation.
     *
     * @param {IndexedSignature[]} signatures List of signatures and the index they should be put on
     *    in the multisig transfer
     * @param {number} index The transfer index to add the signatures to
     */
    async addTransferSignature(signatures, index) {
        if (!this._parsedTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction');
        }
        multisigUtils_1.updateMultisigTransferSignatures(this._parsedTransaction.contents[index], signatures);
        this._encodedTransaction = await local_forging_1.localForger.forge(this._parsedTransaction);
    }
    /** @inheritdoc */
    canSign(key) {
        // TODO: check the key belongs to the _source account in _parsedTransaction
        return true;
    }
    /** @inheritdoc */
    toJson() {
        if (!this._parsedTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Empty transaction');
        }
        return this._parsedTransaction;
    }
    /** @inheritdoc */
    toBroadcastFormat() {
        if (!this._encodedTransaction) {
            throw new sdk_core_1.InvalidTransactionError('Missing encoded transaction');
        }
        return this._encodedTransaction;
    }
    /**
     * Get the transaction source if it is available.
     *
     * @returns {string} Source of the transaction
     */
    get source() {
        if (!this._source) {
            throw new sdk_core_1.InvalidTransactionError('Transaction not initialized');
        }
        return this._source;
    }
    /**
     * Get the transaction delegation address if it is available.
     *
     * @returns {string} transaction delegation address
     */
    get delegate() {
        return this._delegate;
    }
    /**
     * Get the public key revealed by the transaction if it exists
     *
     * @returns {string} public key
     */
    get publicKeyToReveal() {
        return this._publicKeyToReveal;
    }
    /**
     * Get the destination of an address initialization transaction if it exists
     *
     * @returns {string} forwarder destination
     */
    get forwarderDestination() {
        return this._forwarderDestination;
    }
    get owners() {
        return this._owners;
    }
    /**
     * Get the signatures for the given multisig transfer,
     *
     * @param {number} transferIndex The transfer script index in the Tezos transaction
     * @returns {IndexedSignature[]} A list of signatures with their index inside the multisig transfer
     *      script
     */
    getTransferSignatures(transferIndex = 0) {
        if (!this._parsedTransaction) {
            return [];
        }
        return multisigUtils_1.getMultisigTransferSignatures(this._parsedTransaction.contents[transferIndex]);
    }
    /**
     * Get the list of index per tezos transaction type. This is useful to locate specific operations
     * within the transaction and verify or sign them.
     *
     * @returns {{[p: string]: number[]}} List of indexes where the key is the transaction kind
     */
    getIndexesByTransactionType() {
        if (!this._parsedTransaction) {
            return {};
        }
        const indexes = {};
        for (let i = 0; i < this._parsedTransaction.contents.length; i++) {
            const kind = this._parsedTransaction.contents[i].kind;
            indexes[kind] = indexes[kind] ? indexes[kind].concat([i]) : [i];
        }
        return indexes;
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3RyYW5zYWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw4Q0FNeUI7QUFFekIsMERBQTREO0FBQzVELGdFQUFxQztBQUdyQyxtREFNeUI7QUFDekIsK0NBQWlDO0FBRWpDOztHQUVHO0FBQ0gsTUFBYSxXQUFZLFNBQVEsMEJBQWU7SUFTOUM7Ozs7T0FJRztJQUNILFlBQVksVUFBZ0M7UUFDMUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xCLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsS0FBSyxDQUFDLDZCQUE2QixDQUFDLHFCQUE2QjtRQUMvRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcscUJBQXFCLENBQUM7UUFDakQsSUFBSTtZQUNGLE1BQU0saUJBQWlCLEdBQUcsTUFBTSwyQkFBVyxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1lBQ3pFLE1BQU0sSUFBSSxDQUFDLHlCQUF5QixDQUFDLGlCQUFpQixDQUFDLENBQUM7U0FDekQ7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLDRGQUE0RjtZQUM1Rix5RUFBeUU7WUFDekUsTUFBTSw2QkFBNkIsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0UsTUFBTSxTQUFTLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDcEQsSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ3JDLE1BQU0sSUFBSSxnQ0FBcUIsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO2FBQ3hEO1lBQ0QsdURBQXVEO1lBQ3ZELE1BQU0saUJBQWlCLEdBQUcsTUFBTSwy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QUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqRTtRQUNELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7Q0FDRjtBQWxURCxrQ0FrVEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCYXNlS2V5LFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxuICBQYXJzZVRyYW5zYWN0aW9uRXJyb3IsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIENvaW5Db25maWcgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgeyBDT0RFQywgbG9jYWxGb3JnZXIgfSBmcm9tICdAdGFxdWl0by9sb2NhbC1mb3JnaW5nJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IEluZGV4ZWRTaWduYXR1cmUsIE9yaWdpbmF0aW9uT3AsIFBhcnNlZFRyYW5zYWN0aW9uLCBSZXZlYWxPcCwgVHJhbnNhY3Rpb25PcCB9IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQge1xuICBnZXRNdWx0aXNpZ1RyYW5zZmVyRGF0YUZyb21PcGVyYXRpb24sXG4gIGdldE11bHRpc2lnVHJhbnNmZXJTaWduYXR1cmVzLFxuICBnZXRPcmlnaW5hdGlvbkRhdGFGcm9tT3BlcmF0aW9uLFxuICBnZXRPd25lcnNQdWJsaWNLZXlzLFxuICB1cGRhdGVNdWx0aXNpZ1RyYW5zZmVyU2lnbmF0dXJlcyxcbn0gZnJvbSAnLi9tdWx0aXNpZ1V0aWxzJztcbmltcG9ydCAqIGFzIFV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIFRlem9zIHRyYW5zYWN0aW9uIG1vZGVsLlxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb24gZXh0ZW5kcyBCYXNlVHJhbnNhY3Rpb24ge1xuICBwcml2YXRlIF9wYXJzZWRUcmFuc2FjdGlvbj86IFBhcnNlZFRyYW5zYWN0aW9uOyAvLyB0cmFuc2FjdGlvbiBpbiBKU09OIGZvcm1hdFxuICBwcml2YXRlIF9lbmNvZGVkVHJhbnNhY3Rpb24/OiBzdHJpbmc7IC8vIHRyYW5zYWN0aW9uIGluIGhleCBmb3JtYXRcbiAgcHJpdmF0ZSBfc291cmNlOiBzdHJpbmc7XG4gIHByaXZhdGUgX2RlbGVnYXRlPzogc3RyaW5nO1xuICBwcml2YXRlIF9mb3J3YXJkZXJEZXN0aW5hdGlvbj86IHN0cmluZztcbiAgcHJpdmF0ZSBfcHVibGljS2V5VG9SZXZlYWw/OiBzdHJpbmc7XG4gIHByaXZhdGUgX293bmVyczogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFkb25seTxDb2luQ29uZmlnPn0gY29pbkNvbmZpZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoY29pbkNvbmZpZzogUmVhZG9ubHk8Q29pbkNvbmZpZz4pIHtcbiAgICBzdXBlcihjb2luQ29uZmlnKTtcbiAgICB0aGlzLl9vd25lcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSB0cmFuc2FjdGlvbiBmaWVsZHMgYmFzZWQgb24gYW5vdGhlciBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc2VyaWFsaXplZFRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIGluIGJyb2FkY2FzdCBmb3JtYXQuXG4gICAqL1xuICBhc3luYyBpbml0RnJvbVNlcmlhbGl6ZWRUcmFuc2FjdGlvbihzZXJpYWxpemVkVHJhbnNhY3Rpb246IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbiA9IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkVHJhbnNhY3Rpb24gPSBhd2FpdCBsb2NhbEZvcmdlci5wYXJzZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xuICAgICAgYXdhaXQgdGhpcy5pbml0RnJvbVBhcnNlZFRyYW5zYWN0aW9uKHBhcnNlZFRyYW5zYWN0aW9uKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJZiBpdCB0aHJvd3MsIGl0IGlzIHBvc3NpYmxlIHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGlzIHNpZ25lZCwgd2hpY2ggaXMgbm90IHN1cHBvcnRlZFxuICAgICAgLy8gYnkgbG9jYWwtZm9yZ2luZy4gVHJ5IGV4dHJhY3RpbmcgdGhlIGxhc3QgNjQgYnl0ZXMgYW5kIHBhcnNlIGl0IGFnYWluLlxuICAgICAgY29uc3QgdW5zaWduZWRTZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBzZXJpYWxpemVkVHJhbnNhY3Rpb24uc2xpY2UoMCwgLTEyOCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzZXJpYWxpemVkVHJhbnNhY3Rpb24uc2xpY2UoLTEyOCk7XG4gICAgICBpZiAoVXRpbHMuaXNWYWxpZFNpZ25hdHVyZShzaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGVuY29kZSB0aGUgc2lnbmF0dXJlIGFuZCBzYXZlIGl0IGluIF9zaWduYXR1cmVcbiAgICAgIGNvbnN0IHBhcnNlZFRyYW5zYWN0aW9uID0gYXdhaXQgbG9jYWxGb3JnZXIucGFyc2UodW5zaWduZWRTZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IGF3YWl0IFV0aWxzLmNhbGN1bGF0ZVRyYW5zYWN0aW9uSWQoc2VyaWFsaXplZFRyYW5zYWN0aW9uKTtcbiAgICAgIGF3YWl0IHRoaXMuaW5pdEZyb21QYXJzZWRUcmFuc2FjdGlvbihwYXJzZWRUcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25JZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHRyYW5zYWN0aW9uIGZpZWxkcyBiYXNlZCBvbiBhbm90aGVyIHBhcnNlZCB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJzZWRUcmFuc2FjdGlvbn0gcGFyc2VkVHJhbnNhY3Rpb24gQSBUZXpvcyB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uSWQgVGhlIHRyYW5zYWN0aW9uIGlkIG9mIHRoZSBwYXJzZWRUcmFuc2FjdGlvbiBpZiBpdCBpcyBzaWduZWRcbiAgICovXG4gIGFzeW5jIGluaXRGcm9tUGFyc2VkVHJhbnNhY3Rpb24ocGFyc2VkVHJhbnNhY3Rpb246IFBhcnNlZFRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbklkPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLl9lbmNvZGVkVHJhbnNhY3Rpb24pIHtcbiAgICAgIHRoaXMuX2VuY29kZWRUcmFuc2FjdGlvbiA9IGF3YWl0IGxvY2FsRm9yZ2VyLmZvcmdlKHBhcnNlZFRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zYWN0aW9uSWQpIHtcbiAgICAgIC8vIElmIHRoZSB0cmFuc2FjdGlvbiBpZCBpcyBwYXNzZWQsIHNhdmUgaXQgYW5kIGNsZWFuIHVwIHRoZSBlbnRyaWVzIHNpbmNlIHRoZXkgd2lsbCBiZVxuICAgICAgLy8gcmVjYWxjdWxhdGVkXG4gICAgICB0aGlzLl9pZCA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICB0aGlzLl9pbnB1dHMgPSBbXTtcbiAgICAgIHRoaXMuX291dHB1dHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faWQgPSAnJztcbiAgICB9XG4gICAgdGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24gPSBwYXJzZWRUcmFuc2FjdGlvbjtcbiAgICBsZXQgb3BlcmF0aW9uSW5kZXggPSAwO1xuICAgIGZvciAoY29uc3Qgb3BlcmF0aW9uIG9mIHBhcnNlZFRyYW5zYWN0aW9uLmNvbnRlbnRzKSB7XG4gICAgICBpZiAodGhpcy5fc291cmNlICYmIHRoaXMuX3NvdXJjZSAhPT0gb3BlcmF0aW9uLnNvdXJjZSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZSBtdXN0IGJlIHRoZSBzYW1lIGZvciBldmVyeSBvcGVyYXRpb24gYnV0IGl0IGNoYW5nZWQgZnJvbSAnICsgdGhpcy5fc291cmNlICsgJyB0byAnICsgb3BlcmF0aW9uLnNvdXJjZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc291cmNlID0gb3BlcmF0aW9uLnNvdXJjZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0aW9uLmtpbmQpIHtcbiAgICAgICAgY2FzZSBDT0RFQy5PUF9PUklHSU5BVElPTjpcbiAgICAgICAgICBhd2FpdCB0aGlzLnJlY29yZE9yaWdpbmF0aW9uT3BGaWVsZHMob3BlcmF0aW9uIGFzIE9yaWdpbmF0aW9uT3AsIG9wZXJhdGlvbkluZGV4KTtcbiAgICAgICAgICBvcGVyYXRpb25JbmRleCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIENPREVDLk9QX1JFVkVBTDpcbiAgICAgICAgICB0aGlzLnJlY29yZFJldmVhbE9wRmllbGRzKG9wZXJhdGlvbiBhcyBSZXZlYWxPcCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ09ERUMuT1BfVFJBTlNBQ1RJT046XG4gICAgICAgICAgdGhpcy5yZWNvcmRUcmFuc2FjdGlvbk9wRmllbGRzKG9wZXJhdGlvbiBhcyBUcmFuc2FjdGlvbk9wKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjb3JkIHRoZSBtb3N0IGltcG9ydGFudCBmaWVsZHMgZnJvbSBhbiBvcmlnaW5hdGlvbiBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7T3BlcmF0aW9ufSBvcGVyYXRpb24gQW4gb3BlcmF0aW9uIG9iamVjdCBmcm9tIGEgVGV6b3MgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBvcmlnaW5hdGlvbiBvcGVyYXRpb24gaW5kZXggaW4gdGhlIHRyYW5zYWN0aW9uLiBVc2VkIHRvIGNhbGN1bGF0ZSB0aGVcbiAgICogICAgICBvcmlnaW5hdGVkIGFkZHJlc3NcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVjb3JkT3JpZ2luYXRpb25PcEZpZWxkcyhvcGVyYXRpb246IE9yaWdpbmF0aW9uT3AsIGluZGV4OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBvcmlnaW5hdGlvbkRhdGEgPSBnZXRPcmlnaW5hdGlvbkRhdGFGcm9tT3BlcmF0aW9uKG9wZXJhdGlvbik7XG4gICAgaWYgKG9yaWdpbmF0aW9uRGF0YS5mb3J3YXJkZXJEZXN0aW5hdGlvbikge1xuICAgICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5BZGRyZXNzSW5pdGlhbGl6YXRpb247XG4gICAgICB0aGlzLl9mb3J3YXJkZXJEZXN0aW5hdGlvbiA9IG9yaWdpbmF0aW9uRGF0YS5mb3J3YXJkZXJEZXN0aW5hdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbjtcbiAgICAgIHRoaXMuX293bmVycyA9IGdldE93bmVyc1B1YmxpY0tleXMob3BlcmF0aW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWxlZ2F0ZSA9IG9wZXJhdGlvbi5kZWxlZ2F0ZTtcbiAgICB0aGlzLl9vdXRwdXRzLnB1c2goe1xuICAgICAgLy8gS3QgYWRkcmVzc2VzIGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgZm9yIHNpZ25lZCB0cmFuc2FjdGlvbnMgd2l0aCBhbiBpZFxuICAgICAgYWRkcmVzczogdGhpcy5faWQgPyBhd2FpdCBVdGlscy5jYWxjdWxhdGVPcmlnaW5hdGVkQWRkcmVzcyh0aGlzLl9pZCwgaW5kZXgpIDogJycsXG4gICAgICAvLyBCYWxhbmNlXG4gICAgICB2YWx1ZTogb3BlcmF0aW9uLmJhbGFuY2UsXG4gICAgfSk7XG4gICAgdGhpcy5faW5wdXRzLnB1c2goe1xuICAgICAgYWRkcmVzczogb3BlcmF0aW9uLnNvdXJjZSxcbiAgICAgIC8vIEJhbGFuY2UgKyBmZWVzICsgbWF4IGdhcyArIG1heCBzdG9yYWdlIGFyZSBwYWlkIGJ5IHRoZSBzb3VyY2UgYWNjb3VudFxuICAgICAgdmFsdWU6IG5ldyBCaWdOdW1iZXIob3BlcmF0aW9uLmJhbGFuY2UpLnBsdXMob3BlcmF0aW9uLmZlZSkudG9TdHJpbmcoKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmQgdGhlIG1vc3QgaW1wb3J0YW50IGZpZWxkcyBmcm9tIGEgcmV2ZWFsIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtSZXZlYWxPcH0gb3BlcmF0aW9uIEEgcmV2ZWFsIG9wZXJhdGlvbiBvYmplY3QgZnJvbSBhIFRlem9zIHRyYW5zYWN0aW9uXG4gICAqL1xuICBwcml2YXRlIHJlY29yZFJldmVhbE9wRmllbGRzKG9wZXJhdGlvbjogUmV2ZWFsT3ApOiB2b2lkIHtcbiAgICB0aGlzLl90eXBlID0gVHJhbnNhY3Rpb25UeXBlLkFjY291bnRVcGRhdGU7XG4gICAgdGhpcy5fcHVibGljS2V5VG9SZXZlYWwgPSBvcGVyYXRpb24ucHVibGljX2tleTtcbiAgICB0aGlzLl9pbnB1dHMucHVzaCh7XG4gICAgICBhZGRyZXNzOiBvcGVyYXRpb24uc291cmNlLFxuICAgICAgLy8gQmFsYW5jZSArIGZlZXMgKyBtYXggZ2FzICsgbWF4IHN0b3JhZ2UgYXJlIHBhaWQgYnkgdGhlIHNvdXJjZSBhY2NvdW50XG4gICAgICB2YWx1ZTogb3BlcmF0aW9uLmZlZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWNvcmQgdGhlIG1vc3QgaW1wb3J0YW50IGZpZWxkcyBmb3IgYSBUcmFuc2FjdGlvbiBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25PcH0gb3BlcmF0aW9uIEEgdHJhbnNhY3Rpb24gb2JqZWN0IGZyb20gYSBUZXpvcyBvcGVyYXRpb25cbiAgICovXG4gIHByaXZhdGUgcmVjb3JkVHJhbnNhY3Rpb25PcEZpZWxkcyhvcGVyYXRpb246IFRyYW5zYWN0aW9uT3ApOiB2b2lkIHtcbiAgICBpZiAob3BlcmF0aW9uLnBhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSBUcmFuc2FjdGlvblR5cGUuU2VuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5TaW5nbGVTaWdTZW5kO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2ZlckRhdGEgPSBnZXRNdWx0aXNpZ1RyYW5zZmVyRGF0YUZyb21PcGVyYXRpb24ob3BlcmF0aW9uKTtcbiAgICAvLyBGZWVzIGFyZSBwYWlkIGJ5IHRoZSBzb3VyY2UgYWNjb3VudCwgYWxvbmcgd2l0aCB0aGUgYW1vdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgIHRoaXMuX2lucHV0cy5wdXNoKHtcbiAgICAgIGFkZHJlc3M6IG9wZXJhdGlvbi5zb3VyY2UsXG4gICAgICB2YWx1ZTogbmV3IEJpZ051bWJlcih0cmFuc2ZlckRhdGEuZmVlLmZlZSkudG9GaXhlZCgwKSxcbiAgICB9KTtcblxuICAgIGlmICh0cmFuc2ZlckRhdGEuY29pbiA9PT0gJ211dGV6Jykge1xuICAgICAgdGhpcy5fb3V0cHV0cy5wdXNoKHtcbiAgICAgICAgLy8gS3QgYWRkcmVzc2VzIGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgZm9yIHNpZ25lZCB0cmFuc2FjdGlvbnMgd2l0aCBhbiBpZFxuICAgICAgICBhZGRyZXNzOiB0cmFuc2ZlckRhdGEudG8sXG4gICAgICAgIC8vIEJhbGFuY2VcbiAgICAgICAgdmFsdWU6IHRyYW5zZmVyRGF0YS5hbW91bnQsXG4gICAgICB9KTtcbiAgICAgIC8vIFRoZSBmdW5kcyBiZWluZyB0cmFuc2ZlcnJlZCBmcm9tIHRoZSB3YWxsZXRcbiAgICAgIHRoaXMuX2lucHV0cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzczogdHJhbnNmZXJEYXRhLmZyb20sXG4gICAgICAgIC8vIEJhbGFuY2UgKyBmZWVzICsgbWF4IGdhcyArIG1heCBzdG9yYWdlIGFyZSBwYWlkIGJ5IHRoZSBzb3VyY2UgYWNjb3VudFxuICAgICAgICB2YWx1ZTogdHJhbnNmZXJEYXRhLmFtb3VudCxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBrZXkuIEl0IGRvZXMgbm90IGNoZWNrIGlmIHRoZSBzaWduZXIgaXMgYWxsb3dlZCB0byBzaWduXG4gICAqIGl0IG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlQYWlyfSBrZXlQYWlyIFRoZSBrZXkgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb24gd2l0aFxuICAgKi9cbiAgYXN5bmMgc2lnbihrZXlQYWlyOiBLZXlQYWlyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gVE9ETzogZmFpbCBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYWxyZWFkeSBzaWduZWRcbiAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhIHRyYW5zYWN0aW9uIHRvIHNpZ25cbiAgICBpZiAoIXRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgdHJhbnNhY3Rpb24gYm9keSB0byBzaWduXG4gICAgY29uc3QgZW5jb2RlZFRyYW5zYWN0aW9uID0gYXdhaXQgbG9jYWxGb3JnZXIuZm9yZ2UodGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24pO1xuXG4gICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCBVdGlscy5zaWduKGtleVBhaXIsIGVuY29kZWRUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5fZW5jb2RlZFRyYW5zYWN0aW9uID0gc2lnbmVkVHJhbnNhY3Rpb24uc2J5dGVzO1xuXG4gICAgLy8gVGhlIHRyYW5zYWN0aW9uIGlkIGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgZm9yIHNpZ25lZCB0cmFuc2FjdGlvbnNcbiAgICB0aGlzLl9pZCA9IGF3YWl0IFV0aWxzLmNhbGN1bGF0ZVRyYW5zYWN0aW9uSWQodGhpcy5fZW5jb2RlZFRyYW5zYWN0aW9uKTtcbiAgICBhd2FpdCB0aGlzLmluaXRGcm9tUGFyc2VkVHJhbnNhY3Rpb24odGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24sIHRoaXMuX2lkKTtcblxuICAgIHRoaXMuX3NpZ25hdHVyZXMucHVzaChzaWduZWRUcmFuc2FjdGlvbi5zaWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgbGlzdCBvZiBzaWduYXR1cmVzIGZvciBhIG11bHRpc2lnIHRyYW5zYWN0aW9uIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtJbmRleGVkU2lnbmF0dXJlW119IHNpZ25hdHVyZXMgTGlzdCBvZiBzaWduYXR1cmVzIGFuZCB0aGUgaW5kZXggdGhleSBzaG91bGQgYmUgcHV0IG9uXG4gICAqICAgIGluIHRoZSBtdWx0aXNpZyB0cmFuc2ZlclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIHRyYW5zZmVyIGluZGV4IHRvIGFkZCB0aGUgc2lnbmF0dXJlcyB0b1xuICAgKi9cbiAgYXN5bmMgYWRkVHJhbnNmZXJTaWduYXR1cmUoc2lnbmF0dXJlczogSW5kZXhlZFNpZ25hdHVyZVtdLCBpbmRleDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdFbXB0eSB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICB1cGRhdGVNdWx0aXNpZ1RyYW5zZmVyU2lnbmF0dXJlcyh0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbi5jb250ZW50c1tpbmRleF0gYXMgVHJhbnNhY3Rpb25PcCwgc2lnbmF0dXJlcyk7XG4gICAgdGhpcy5fZW5jb2RlZFRyYW5zYWN0aW9uID0gYXdhaXQgbG9jYWxGb3JnZXIuZm9yZ2UodGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24pO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGNhblNpZ24oa2V5OiBCYXNlS2V5KTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETzogY2hlY2sgdGhlIGtleSBiZWxvbmdzIHRvIHRoZSBfc291cmNlIGFjY291bnQgaW4gX3BhcnNlZFRyYW5zYWN0aW9uXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgdG9Kc29uKCk6IFBhcnNlZFRyYW5zYWN0aW9uIHtcbiAgICBpZiAoIXRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0VtcHR5IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICB0b0Jyb2FkY2FzdEZvcm1hdCgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fZW5jb2RlZFRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ01pc3NpbmcgZW5jb2RlZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW5jb2RlZFRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHJhbnNhY3Rpb24gc291cmNlIGlmIGl0IGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gU291cmNlIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZ2V0IHNvdXJjZSgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5fc291cmNlKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdHJhbnNhY3Rpb24gZGVsZWdhdGlvbiBhZGRyZXNzIGlmIGl0IGlzIGF2YWlsYWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gdHJhbnNhY3Rpb24gZGVsZWdhdGlvbiBhZGRyZXNzXG4gICAqL1xuICBnZXQgZGVsZWdhdGUoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwdWJsaWMga2V5IHJldmVhbGVkIGJ5IHRoZSB0cmFuc2FjdGlvbiBpZiBpdCBleGlzdHNcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gcHVibGljIGtleVxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleVRvUmV2ZWFsKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleVRvUmV2ZWFsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVzdGluYXRpb24gb2YgYW4gYWRkcmVzcyBpbml0aWFsaXphdGlvbiB0cmFuc2FjdGlvbiBpZiBpdCBleGlzdHNcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gZm9yd2FyZGVyIGRlc3RpbmF0aW9uXG4gICAqL1xuICBnZXQgZm9yd2FyZGVyRGVzdGluYXRpb24oKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fZm9yd2FyZGVyRGVzdGluYXRpb247XG4gIH1cblxuICBnZXQgb3duZXJzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5fb3duZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2lnbmF0dXJlcyBmb3IgdGhlIGdpdmVuIG11bHRpc2lnIHRyYW5zZmVyLFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNmZXJJbmRleCBUaGUgdHJhbnNmZXIgc2NyaXB0IGluZGV4IGluIHRoZSBUZXpvcyB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7SW5kZXhlZFNpZ25hdHVyZVtdfSBBIGxpc3Qgb2Ygc2lnbmF0dXJlcyB3aXRoIHRoZWlyIGluZGV4IGluc2lkZSB0aGUgbXVsdGlzaWcgdHJhbnNmZXJcbiAgICogICAgICBzY3JpcHRcbiAgICovXG4gIGdldFRyYW5zZmVyU2lnbmF0dXJlcyh0cmFuc2ZlckluZGV4ID0gMCk6IEluZGV4ZWRTaWduYXR1cmVbXSB7XG4gICAgaWYgKCF0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0TXVsdGlzaWdUcmFuc2ZlclNpZ25hdHVyZXModGhpcy5fcGFyc2VkVHJhbnNhY3Rpb24uY29udGVudHNbdHJhbnNmZXJJbmRleF0gYXMgVHJhbnNhY3Rpb25PcCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsaXN0IG9mIGluZGV4IHBlciB0ZXpvcyB0cmFuc2FjdGlvbiB0eXBlLiBUaGlzIGlzIHVzZWZ1bCB0byBsb2NhdGUgc3BlY2lmaWMgb3BlcmF0aW9uc1xuICAgKiB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uIGFuZCB2ZXJpZnkgb3Igc2lnbiB0aGVtLlxuICAgKlxuICAgKiBAcmV0dXJucyB7e1twOiBzdHJpbmddOiBudW1iZXJbXX19IExpc3Qgb2YgaW5kZXhlcyB3aGVyZSB0aGUga2V5IGlzIHRoZSB0cmFuc2FjdGlvbiBraW5kXG4gICAqL1xuICBnZXRJbmRleGVzQnlUcmFuc2FjdGlvblR5cGUoKTogeyBba2luZDogc3RyaW5nXTogbnVtYmVyW10gfSB7XG4gICAgaWYgKCF0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbikge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCBpbmRleGVzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYXJzZWRUcmFuc2FjdGlvbi5jb250ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2luZCA9IHRoaXMuX3BhcnNlZFRyYW5zYWN0aW9uLmNvbnRlbnRzW2ldLmtpbmQ7XG4gICAgICBpbmRleGVzW2tpbmRdID0gaW5kZXhlc1traW5kXSA/IGluZGV4ZXNba2luZF0uY29uY2F0KFtpXSkgOiBbaV07XG4gICAgfVxuICAgIHJldHVybiBpbmRleGVzO1xuICB9XG59XG4iXX0=