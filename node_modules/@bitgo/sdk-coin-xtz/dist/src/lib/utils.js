"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_STORAGE_LIMIT = exports.DEFAULT_FEE = exports.DEFAULT_GAS_LIMIT = exports.hashTypes = exports.decodeSignature = exports.decodeKey = exports.isValidKey = exports.isValidTransactionHash = exports.isValidBlockHash = exports.isValidPrivateKey = exports.isValidPublicKey = exports.isValidSignature = exports.isValidOriginatedAddress = exports.isValidImplicitAddress = exports.isValidAddress = exports.isValidHash = exports.generateDataToSign = exports.verifySignature = exports.sign = exports.calculateOriginatedAddress = exports.calculateTransactionId = exports.base58encode = exports.DEFAULT_WATERMARK = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const signer_1 = require("@taquito/signer");
const base58check = __importStar(require("bs58check"));
const elliptic_1 = require("elliptic");
const libsodium_wrappers_1 = __importDefault(require("libsodium-wrappers"));
const multisigUtils_1 = require("./multisigUtils");
// By default, use the transactions prefix
exports.DEFAULT_WATERMARK = new Uint8Array([3]);
/**
 * Encode the payload to base58 with a specific Tezos prefix.
 *
 * @param {Buffer} prefix to add to the encoded payload
 * @param {Buffer} payload to encode
 * @returns {any} base58 payload with a Tezos prefix
 */
function base58encode(prefix, payload) {
    const n = Buffer.alloc(prefix.length + payload.length);
    n.set(prefix);
    n.set(payload, prefix.length);
    return base58check.encode(n);
}
exports.base58encode = base58encode;
/**
 * Calculate the transaction id for a for a signed transaction.
 *
 * @param {string} encodedTransaction Signed transaction in hexadecimal
 * @returns {Promise<string>} The transaction id
 */
async function calculateTransactionId(encodedTransaction) {
    await libsodium_wrappers_1.default.ready;
    const encodedTransactionBuffer = Uint8Array.from(Buffer.from(encodedTransaction, 'hex'));
    const operationHashPayload = libsodium_wrappers_1.default.crypto_generichash(32, encodedTransactionBuffer);
    return base58encode(exports.hashTypes.o.prefix, Buffer.from(operationHashPayload));
}
exports.calculateTransactionId = calculateTransactionId;
/**
 * Calculate the address of a new originated account.
 *
 * @param {string} transactionId The transaction id
 * @param {number} index The index of the origination operation inside the transaction (starts at 0)
 * @returns {Promise<string>} An originated address with the KT prefix
 */
async function calculateOriginatedAddress(transactionId, index) {
    // From https://github.com/TezTech/eztz/blob/cfdc4fcfc891f4f4f077c3056f414476dde3610b/src/main.js#L768
    const ob = base58check.decode(transactionId).slice(exports.hashTypes.o.prefix.length);
    let tt = [];
    for (let i = 0; i < ob.length; i++) {
        tt.push(ob[i]);
    }
    tt = tt.concat([
        (index & 0xff000000) >> 24,
        (index & 0x00ff0000) >> 16,
        (index & 0x0000ff00) >> 8,
        index & 0x000000ff,
    ]);
    await libsodium_wrappers_1.default.ready;
    const payload = libsodium_wrappers_1.default.crypto_generichash(20, new Uint8Array(tt));
    return base58encode(exports.hashTypes.KT.prefix, Buffer.from(payload));
}
exports.calculateOriginatedAddress = calculateOriginatedAddress;
/**
 * Generic data signing using Tezos library.
 *
 * @param {KeyPair} keyPair A Key Pair with a private key set
 * @param {string} data The data in hexadecimal to sign
 * @param {Uint8Array} watermark Magic byte: 1 for block, 2 for endorsement, 3 for generic
 * @returns {Promise<SignResponse>}
 */
async function sign(keyPair, data, watermark = exports.DEFAULT_WATERMARK) {
    if (!keyPair.getKeys().prv) {
        throw new sdk_core_1.SigningError('Missing private key');
    }
    const signer = new signer_1.InMemorySigner(keyPair.getKeys().prv);
    return signer.sign(data, watermark);
}
exports.sign = sign;
/**
 * Verifies the signature produced for a given message belongs to a secp256k1 public key.
 *
 * @param {string} message Message in hex format to verify
 * @param {string} publicKey secp256k1 public key with "sppk" prefix to verify the signature with
 * @param {string} signature Tezos signature with "sig" prefix
 * @param {Uint8Array} watermark Optional watermark used to generate the signature
 * @returns {Promise<boolean>}
 */
async function verifySignature(message, publicKey, signature, watermark = exports.DEFAULT_WATERMARK) {
    const rawPublicKey = decodeKey(publicKey, exports.hashTypes.sppk);
    const ec = new elliptic_1.ec('secp256k1');
    const key = ec.keyFromPublic(rawPublicKey);
    const messageBuffer = Uint8Array.from(Buffer.from(message, 'hex'));
    // Tezos signatures always have a watermark
    const messageWithWatermark = new Uint8Array(watermark.length + messageBuffer.length);
    messageWithWatermark.set(watermark);
    messageWithWatermark.set(messageBuffer, watermark.length);
    await libsodium_wrappers_1.default.ready;
    const bytesHash = Buffer.from(libsodium_wrappers_1.default.crypto_generichash(32, messageWithWatermark));
    const rawSignature = decodeSignature(signature, exports.hashTypes.sig);
    return key.verify(bytesHash, { r: rawSignature.slice(0, 32), s: rawSignature.slice(32, 64) });
}
exports.verifySignature = verifySignature;
/**
 * Useful wrapper to create the generic multisig contract data to sign when moving funds.
 *
 * @param {string} contractAddress The wallet contract address with the funds to withdraw
 * @param {string} destinationAddress The address to transfer the funds to
 * @param {number} amount Number mutez to transfer
 * @param {string} contractCounter Wallet counter to use in the transaction
 * @returns {any} A JSON representation of the Michelson script to sign and approve a transfer
 */
function generateDataToSign(contractAddress, destinationAddress, amount, contractCounter) {
    if (!isValidOriginatedAddress(contractAddress)) {
        throw new Error('Invalid contract address ' + contractAddress + '. An originated account address was expected');
    }
    if (!isValidAddress(destinationAddress)) {
        throw new Error('Invalid destination address ' + destinationAddress);
    }
    return multisigUtils_1.genericMultisigDataToSign(contractAddress, destinationAddress, amount, contractCounter);
}
exports.generateDataToSign = generateDataToSign;
/**
 * Returns whether or not the string is a valid Tezos hash of the given type
 *
 * @param {string} hash - the string to validate
 * @param {HashType} hashType - the type of the provided hash
 * @returns {boolean}
 */
function isValidHash(hash, hashType) {
    // Validate encoding
    let decodedHash;
    try {
        decodedHash = base58check.decode(hash);
    }
    catch (e) {
        return false;
    }
    const hashPrefix = decodedHash.slice(0, hashType.prefix.length);
    // Check prefix
    if (!hashPrefix.equals(Buffer.from(hashType.prefix))) {
        return false;
    }
    // Check length
    const hashLength = decodedHash.length - hashPrefix.length;
    return hashLength === hashType.byteLength;
}
exports.isValidHash = isValidHash;
/**
 * Returns whether or not the string is a valid Tezos address
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidAddress(hash) {
    return isValidImplicitAddress(hash) || isValidHash(hash, exports.hashTypes.KT);
}
exports.isValidAddress = isValidAddress;
/**
 * Returns whether or not the string is a valid Tezos implicit account address
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidImplicitAddress(hash) {
    return isValidHash(hash, exports.hashTypes.tz1) || isValidHash(hash, exports.hashTypes.tz2) || isValidHash(hash, exports.hashTypes.tz3);
}
exports.isValidImplicitAddress = isValidImplicitAddress;
/**
 * Returns whether or not the string is a valid Tezos originated account address
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidOriginatedAddress(hash) {
    return isValidHash(hash, exports.hashTypes.KT);
}
exports.isValidOriginatedAddress = isValidOriginatedAddress;
/**
 * Returns whether or not the string is a valid Tezos signature
 *
 * @param {string} hash - the signature to validate
 * @returns {boolean}
 */
function isValidSignature(hash) {
    return (isValidHash(hash, exports.hashTypes.edsig) ||
        isValidHash(hash, exports.hashTypes.spsig1) ||
        isValidHash(hash, exports.hashTypes.p2sig) ||
        isValidHash(hash, exports.hashTypes.sig));
}
exports.isValidSignature = isValidSignature;
/**
 * Returns whether or not the string is a valid Tezos public key
 *
 * @param {string} publicKey The public key to validate
 * @returns {boolean}
 */
function isValidPublicKey(publicKey) {
    return (isValidHash(publicKey, exports.hashTypes.sppk) ||
        isValidHash(publicKey, exports.hashTypes.p2pk) ||
        isValidHash(publicKey, exports.hashTypes.edpk) ||
        sdk_core_1.isValidXpub(publicKey) // xpubs are valid too.
    );
}
exports.isValidPublicKey = isValidPublicKey;
/**
 * Returns whether or not the string is a valid Tezos private key
 *
 * @param {string} privateKey The private key to validate
 * @returns {boolean}
 */
function isValidPrivateKey(privateKey) {
    return (isValidHash(privateKey, exports.hashTypes.edesk) ||
        isValidHash(privateKey, exports.hashTypes.edsk) ||
        isValidHash(privateKey, exports.hashTypes.spsk) ||
        isValidHash(privateKey, exports.hashTypes.p2sk));
}
exports.isValidPrivateKey = isValidPrivateKey;
/**
 * Returns whether or not the string is a valid Tezos block hash
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidBlockHash(hash) {
    return isValidHash(hash, exports.hashTypes.b);
}
exports.isValidBlockHash = isValidBlockHash;
/**
 * Returns whether or not the string is a valid Tezos transaction hash
 *
 * @param {string} hash - the address to validate
 * @returns {boolean}
 */
function isValidTransactionHash(hash) {
    return isValidHash(hash, exports.hashTypes.o);
}
exports.isValidTransactionHash = isValidTransactionHash;
/**
 * Returns whether or not the string is a valid Tezos key given a prefix
 *
 * @param {string} hash - the key to validate
 * @param {HashType} hashType - the type of the provided hash
 * @returns {boolean}
 */
function isValidKey(hash, hashType) {
    return isValidHash(hash, hashType);
}
exports.isValidKey = isValidKey;
/**
 * Get the original key form the text without the given prefix.
 *
 * @param {string} hash - base58 encoded key with a Tezos prefix
 * @param {HashType} hashType - the type of the provided hash
 * @returns {Buffer} the original decoded key
 */
function decodeKey(hash, hashType) {
    if (!isValidKey(hash, hashType)) {
        throw new Error('Unsupported private key');
    }
    const decodedPrv = base58check.decode(hash);
    return Buffer.from(decodedPrv.slice(hashType.prefix.length, decodedPrv.length));
}
exports.decodeKey = decodeKey;
/**
 * Get the raw signature from a Tezos encoded one.
 *
 * @param {string} signature Tezos signatures prefixed with sig, edsig, p2sig or spsig
 * @param {HashType} hashType The prefix of remove
 * @returns {Buffer} The decoded signature without prefix
 */
function decodeSignature(signature, hashType) {
    if (!isValidSignature(signature)) {
        throw new Error('Unsupported signature');
    }
    const decodedPrv = base58check.decode(signature);
    return Buffer.from(decodedPrv.slice(hashType.prefix.length, decodedPrv.length));
}
exports.decodeSignature = decodeSignature;
// Base58Check is used for encoding
// hashedTypes is used to validate hashes by type, by checking their prefix and
// the length of the Buffer obtained by decoding the hash (excluding the prefix)
exports.hashTypes = {
    /* 20 bytes long */
    // ed25519 public key hash
    tz1: {
        prefix: Buffer.from([6, 161, 159]),
        byteLength: 20,
    },
    // secp256k1 public key hash
    tz2: {
        prefix: Buffer.from([6, 161, 161]),
        byteLength: 20,
    },
    // p256 public key hash
    tz3: {
        prefix: Buffer.from([6, 161, 164]),
        byteLength: 20,
    },
    KT: {
        prefix: Buffer.from([2, 90, 121]),
        byteLength: 20,
    },
    /* 32 bytes long */
    // ed25519 public key
    edpk: {
        prefix: Buffer.from([13, 15, 37, 217]),
        byteLength: 32,
    },
    // ed25519 secret key
    edsk2: {
        prefix: Buffer.from([13, 15, 58, 7]),
        byteLength: 32,
    },
    // secp256k1 secret key
    spsk: {
        prefix: Buffer.from([17, 162, 224, 201]),
        byteLength: 32,
    },
    // p256 secret key
    p2sk: {
        prefix: Buffer.from([16, 81, 238, 189]),
        byteLength: 32,
    },
    // block hash
    b: {
        prefix: Buffer.from([1, 52]),
        byteLength: 32,
    },
    // operation hash
    o: {
        prefix: Buffer.from([5, 116]),
        byteLength: 32,
    },
    // operation list hash
    Lo: {
        prefix: Buffer.from([133, 233]),
        byteLength: 32,
    },
    // operation list list hash
    LLo: {
        prefix: Buffer.from([29, 159, 109]),
        byteLength: 32,
    },
    // protocol hash
    P: {
        prefix: Buffer.from([2, 170]),
        byteLength: 32,
    },
    // context hash
    Co: {
        prefix: Buffer.from([79, 179]),
        byteLength: 32,
    },
    /* 33 bytes long */
    // secp256k1 public key
    sppk: {
        prefix: Buffer.from([3, 254, 226, 86]),
        byteLength: 33,
    },
    // p256 public key
    p2pk: {
        prefix: Buffer.from([3, 178, 139, 127]),
        byteLength: 33,
    },
    /* 56 bytes long */
    // ed25519 encrypted seed
    edesk: {
        prefix: Buffer.from([7, 90, 60, 179, 41]),
        byteLength: 56,
    },
    /* 63 bytes long */
    // ed25519 secret key
    edsk: {
        prefix: Buffer.from([43, 246, 78, 7]),
        byteLength: 64,
    },
    // ed25519 signature
    edsig: {
        prefix: Buffer.from([9, 245, 205, 134, 18]),
        byteLength: 64,
    },
    // secp256k1 signature
    spsig1: {
        prefix: Buffer.from([13, 115, 101, 19, 63]),
        byteLength: 64,
    },
    // p256_signature
    p2sig: {
        prefix: Buffer.from([54, 240, 44, 52]),
        byteLength: 64,
    },
    // generic signature
    sig: {
        prefix: Buffer.from([4, 130, 43]),
        byteLength: 64,
    },
    /* 15 bytes long */
    // network hash
    Net: {
        prefix: Buffer.from([87, 82, 0]),
        byteLength: 15,
    },
    // nonce hash
    nce: {
        prefix: Buffer.from([69, 220, 169]),
        byteLength: 15,
    },
    /* 4 bytes long */
    // chain id
    id: {
        prefix: Buffer.from([153, 103]),
        byteLength: 4,
    },
};
// From https://github.com/ecadlabs/taquito/blob/master/packages/taquito/src/constants.ts
var DEFAULT_GAS_LIMIT;
(function (DEFAULT_GAS_LIMIT) {
    DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["DELEGATION"] = 10600] = "DELEGATION";
    DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["ORIGINATION"] = 10600] = "ORIGINATION";
    DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["TRANSFER"] = 10600] = "TRANSFER";
    DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT["REVEAL"] = 10600] = "REVEAL";
})(DEFAULT_GAS_LIMIT = exports.DEFAULT_GAS_LIMIT || (exports.DEFAULT_GAS_LIMIT = {}));
var DEFAULT_FEE;
(function (DEFAULT_FEE) {
    DEFAULT_FEE[DEFAULT_FEE["DELEGATION"] = 1257] = "DELEGATION";
    DEFAULT_FEE[DEFAULT_FEE["ORIGINATION"] = 10000] = "ORIGINATION";
    DEFAULT_FEE[DEFAULT_FEE["TRANSFER"] = 10000] = "TRANSFER";
    DEFAULT_FEE[DEFAULT_FEE["REVEAL"] = 1420] = "REVEAL";
})(DEFAULT_FEE = exports.DEFAULT_FEE || (exports.DEFAULT_FEE = {}));
var DEFAULT_STORAGE_LIMIT;
(function (DEFAULT_STORAGE_LIMIT) {
    DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["DELEGATION"] = 0] = "DELEGATION";
    DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["ORIGINATION"] = 257] = "ORIGINATION";
    DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["TRANSFER"] = 257] = "TRANSFER";
    DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT["REVEAL"] = 0] = "REVEAL";
})(DEFAULT_STORAGE_LIMIT = exports.DEFAULT_STORAGE_LIMIT || (exports.DEFAULT_STORAGE_LIMIT = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw4Q0FBNEQ7QUFDNUQsNENBQWlEO0FBQ2pELHVEQUF5QztBQUN6Qyx1Q0FBb0M7QUFDcEMsNEVBQXdDO0FBR3hDLG1EQUE0RDtBQUU1RCwwQ0FBMEM7QUFDN0IsUUFBQSxpQkFBaUIsR0FBRyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFckQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLE1BQWMsRUFBRSxPQUFlO0lBQzFELE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdkQsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNkLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUU5QixPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0IsQ0FBQztBQU5ELG9DQU1DO0FBRUQ7Ozs7O0dBS0c7QUFDSSxLQUFLLFVBQVUsc0JBQXNCLENBQUMsa0JBQTBCO0lBQ3JFLE1BQU0sNEJBQU0sQ0FBQyxLQUFLLENBQUM7SUFDbkIsTUFBTSx3QkFBd0IsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN6RixNQUFNLG9CQUFvQixHQUFHLDRCQUFNLENBQUMsa0JBQWtCLENBQUMsRUFBRSxFQUFFLHdCQUF3QixDQUFDLENBQUM7SUFDckYsT0FBTyxZQUFZLENBQUMsaUJBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLE1BQU0s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QUFMRCxXQUFZLFdBQVc7SUFDckIsNERBQWlCLENBQUE7SUFDakIsK0RBQW1CLENBQUE7SUFDbkIseURBQWdCLENBQUE7SUFDaEIsb0RBQWEsQ0FBQTtBQUNmLENBQUMsRUFMVyxXQUFXLEdBQVgsbUJBQVcsS0FBWCxtQkFBVyxRQUt0QjtBQUVELElBQVkscUJBS1g7QUFMRCxXQUFZLHFCQUFxQjtJQUMvQiw2RUFBYyxDQUFBO0lBQ2QsaUZBQWlCLENBQUE7SUFDakIsMkVBQWMsQ0FBQTtJQUNkLHFFQUFVLENBQUE7QUFDWixDQUFDLEVBTFcscUJBQXFCLEdBQXJCLDZCQUFxQixLQUFyQiw2QkFBcUIsUUFLaEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1ZhbGlkWHB1YiwgU2lnbmluZ0Vycm9yIH0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEluTWVtb3J5U2lnbmVyIH0gZnJvbSAnQHRhcXVpdG8vc2lnbmVyJztcbmltcG9ydCAqIGFzIGJhc2U1OGNoZWNrIGZyb20gJ2JzNThjaGVjayc7XG5pbXBvcnQgeyBlYyBhcyBFQyB9IGZyb20gJ2VsbGlwdGljJztcbmltcG9ydCBzb2RpdW0gZnJvbSAnbGlic29kaXVtLXdyYXBwZXJzJztcbmltcG9ydCB7IEhhc2hUeXBlLCBTaWduUmVzcG9uc2UgfSBmcm9tICcuL2lmYWNlJztcbmltcG9ydCB7IEtleVBhaXIgfSBmcm9tICcuL2tleVBhaXInO1xuaW1wb3J0IHsgZ2VuZXJpY011bHRpc2lnRGF0YVRvU2lnbiB9IGZyb20gJy4vbXVsdGlzaWdVdGlscyc7XG5cbi8vIEJ5IGRlZmF1bHQsIHVzZSB0aGUgdHJhbnNhY3Rpb25zIHByZWZpeFxuZXhwb3J0IGNvbnN0IERFRkFVTFRfV0FURVJNQVJLID0gbmV3IFVpbnQ4QXJyYXkoWzNdKTtcblxuLyoqXG4gKiBFbmNvZGUgdGhlIHBheWxvYWQgdG8gYmFzZTU4IHdpdGggYSBzcGVjaWZpYyBUZXpvcyBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHByZWZpeCB0byBhZGQgdG8gdGhlIGVuY29kZWQgcGF5bG9hZFxuICogQHBhcmFtIHtCdWZmZXJ9IHBheWxvYWQgdG8gZW5jb2RlXG4gKiBAcmV0dXJucyB7YW55fSBiYXNlNTggcGF5bG9hZCB3aXRoIGEgVGV6b3MgcHJlZml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNThlbmNvZGUocHJlZml4OiBCdWZmZXIsIHBheWxvYWQ6IEJ1ZmZlcik6IHN0cmluZyB7XG4gIGNvbnN0IG4gPSBCdWZmZXIuYWxsb2MocHJlZml4Lmxlbmd0aCArIHBheWxvYWQubGVuZ3RoKTtcbiAgbi5zZXQocHJlZml4KTtcbiAgbi5zZXQocGF5bG9hZCwgcHJlZml4Lmxlbmd0aCk7XG5cbiAgcmV0dXJuIGJhc2U1OGNoZWNrLmVuY29kZShuKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHRyYW5zYWN0aW9uIGlkIGZvciBhIGZvciBhIHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RlZFRyYW5zYWN0aW9uIFNpZ25lZCB0cmFuc2FjdGlvbiBpbiBoZXhhZGVjaW1hbFxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gVGhlIHRyYW5zYWN0aW9uIGlkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVUcmFuc2FjdGlvbklkKGVuY29kZWRUcmFuc2FjdGlvbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgYXdhaXQgc29kaXVtLnJlYWR5O1xuICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb25CdWZmZXIgPSBVaW50OEFycmF5LmZyb20oQnVmZmVyLmZyb20oZW5jb2RlZFRyYW5zYWN0aW9uLCAnaGV4JykpO1xuICBjb25zdCBvcGVyYXRpb25IYXNoUGF5bG9hZCA9IHNvZGl1bS5jcnlwdG9fZ2VuZXJpY2hhc2goMzIsIGVuY29kZWRUcmFuc2FjdGlvbkJ1ZmZlcik7XG4gIHJldHVybiBiYXNlNThlbmNvZGUoaGFzaFR5cGVzLm8ucHJlZml4LCBCdWZmZXIuZnJvbShvcGVyYXRpb25IYXNoUGF5bG9hZCkpO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYWRkcmVzcyBvZiBhIG5ldyBvcmlnaW5hdGVkIGFjY291bnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uSWQgVGhlIHRyYW5zYWN0aW9uIGlkXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBvcmlnaW5hdGlvbiBvcGVyYXRpb24gaW5zaWRlIHRoZSB0cmFuc2FjdGlvbiAoc3RhcnRzIGF0IDApXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBbiBvcmlnaW5hdGVkIGFkZHJlc3Mgd2l0aCB0aGUgS1QgcHJlZml4XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVPcmlnaW5hdGVkQWRkcmVzcyh0cmFuc2FjdGlvbklkOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAvLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9UZXpUZWNoL2V6dHovYmxvYi9jZmRjNGZjZmM4OTFmNGY0ZjA3N2MzMDU2ZjQxNDQ3NmRkZTM2MTBiL3NyYy9tYWluLmpzI0w3NjhcbiAgY29uc3Qgb2IgPSBiYXNlNThjaGVjay5kZWNvZGUodHJhbnNhY3Rpb25JZCkuc2xpY2UoaGFzaFR5cGVzLm8ucHJlZml4Lmxlbmd0aCk7XG5cbiAgbGV0IHR0OiBudW1iZXJbXSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9iLmxlbmd0aDsgaSsrKSB7XG4gICAgdHQucHVzaChvYltpXSk7XG4gIH1cblxuICB0dCA9IHR0LmNvbmNhdChbXG4gICAgKGluZGV4ICYgMHhmZjAwMDAwMCkgPj4gMjQsXG4gICAgKGluZGV4ICYgMHgwMGZmMDAwMCkgPj4gMTYsXG4gICAgKGluZGV4ICYgMHgwMDAwZmYwMCkgPj4gOCxcbiAgICBpbmRleCAmIDB4MDAwMDAwZmYsXG4gIF0pO1xuXG4gIGF3YWl0IHNvZGl1bS5yZWFkeTtcbiAgY29uc3QgcGF5bG9hZCA9IHNvZGl1bS5jcnlwdG9fZ2VuZXJpY2hhc2goMjAsIG5ldyBVaW50OEFycmF5KHR0KSk7XG4gIHJldHVybiBiYXNlNThlbmNvZGUoaGFzaFR5cGVzLktULnByZWZpeCwgQnVmZmVyLmZyb20ocGF5bG9hZCkpO1xufVxuXG4vKipcbiAqIEdlbmVyaWMgZGF0YSBzaWduaW5nIHVzaW5nIFRlem9zIGxpYnJhcnkuXG4gKlxuICogQHBhcmFtIHtLZXlQYWlyfSBrZXlQYWlyIEEgS2V5IFBhaXIgd2l0aCBhIHByaXZhdGUga2V5IHNldFxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgVGhlIGRhdGEgaW4gaGV4YWRlY2ltYWwgdG8gc2lnblxuICogQHBhcmFtIHtVaW50OEFycmF5fSB3YXRlcm1hcmsgTWFnaWMgYnl0ZTogMSBmb3IgYmxvY2ssIDIgZm9yIGVuZG9yc2VtZW50LCAzIGZvciBnZW5lcmljXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTaWduUmVzcG9uc2U+fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2lnbihcbiAga2V5UGFpcjogS2V5UGFpcixcbiAgZGF0YTogc3RyaW5nLFxuICB3YXRlcm1hcms6IFVpbnQ4QXJyYXkgPSBERUZBVUxUX1dBVEVSTUFSS1xuKTogUHJvbWlzZTxTaWduUmVzcG9uc2U+IHtcbiAgaWYgKCFrZXlQYWlyLmdldEtleXMoKS5wcnYpIHtcbiAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5Jyk7XG4gIH1cbiAgY29uc3Qgc2lnbmVyID0gbmV3IEluTWVtb3J5U2lnbmVyKGtleVBhaXIuZ2V0S2V5cygpLnBydiEpO1xuICByZXR1cm4gc2lnbmVyLnNpZ24oZGF0YSwgd2F0ZXJtYXJrKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgc2lnbmF0dXJlIHByb2R1Y2VkIGZvciBhIGdpdmVuIG1lc3NhZ2UgYmVsb25ncyB0byBhIHNlY3AyNTZrMSBwdWJsaWMga2V5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIE1lc3NhZ2UgaW4gaGV4IGZvcm1hdCB0byB2ZXJpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNLZXkgc2VjcDI1NmsxIHB1YmxpYyBrZXkgd2l0aCBcInNwcGtcIiBwcmVmaXggdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmUgd2l0aFxuICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSBUZXpvcyBzaWduYXR1cmUgd2l0aCBcInNpZ1wiIHByZWZpeFxuICogQHBhcmFtIHtVaW50OEFycmF5fSB3YXRlcm1hcmsgT3B0aW9uYWwgd2F0ZXJtYXJrIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHNpZ25hdHVyZVxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUoXG4gIG1lc3NhZ2U6IHN0cmluZyxcbiAgcHVibGljS2V5OiBzdHJpbmcsXG4gIHNpZ25hdHVyZTogc3RyaW5nLFxuICB3YXRlcm1hcms6IFVpbnQ4QXJyYXkgPSBERUZBVUxUX1dBVEVSTUFSS1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGNvbnN0IHJhd1B1YmxpY0tleSA9IGRlY29kZUtleShwdWJsaWNLZXksIGhhc2hUeXBlcy5zcHBrKTtcbiAgY29uc3QgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpO1xuICBjb25zdCBrZXkgPSBlYy5rZXlGcm9tUHVibGljKHJhd1B1YmxpY0tleSk7XG5cbiAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IFVpbnQ4QXJyYXkuZnJvbShCdWZmZXIuZnJvbShtZXNzYWdlLCAnaGV4JykpO1xuICAvLyBUZXpvcyBzaWduYXR1cmVzIGFsd2F5cyBoYXZlIGEgd2F0ZXJtYXJrXG4gIGNvbnN0IG1lc3NhZ2VXaXRoV2F0ZXJtYXJrID0gbmV3IFVpbnQ4QXJyYXkod2F0ZXJtYXJrLmxlbmd0aCArIG1lc3NhZ2VCdWZmZXIubGVuZ3RoKTtcbiAgbWVzc2FnZVdpdGhXYXRlcm1hcmsuc2V0KHdhdGVybWFyayk7XG4gIG1lc3NhZ2VXaXRoV2F0ZXJtYXJrLnNldChtZXNzYWdlQnVmZmVyLCB3YXRlcm1hcmsubGVuZ3RoKTtcblxuICBhd2FpdCBzb2RpdW0ucmVhZHk7XG4gIGNvbnN0IGJ5dGVzSGFzaCA9IEJ1ZmZlci5mcm9tKHNvZGl1bS5jcnlwdG9fZ2VuZXJpY2hhc2goMzIsIG1lc3NhZ2VXaXRoV2F0ZXJtYXJrKSk7XG5cbiAgY29uc3QgcmF3U2lnbmF0dXJlID0gZGVjb2RlU2lnbmF0dXJlKHNpZ25hdHVyZSwgaGFzaFR5cGVzLnNpZyk7XG4gIHJldHVybiBrZXkudmVyaWZ5KGJ5dGVzSGFzaCwgeyByOiByYXdTaWduYXR1cmUuc2xpY2UoMCwgMzIpLCBzOiByYXdTaWduYXR1cmUuc2xpY2UoMzIsIDY0KSB9KTtcbn1cblxuLyoqXG4gKiBVc2VmdWwgd3JhcHBlciB0byBjcmVhdGUgdGhlIGdlbmVyaWMgbXVsdGlzaWcgY29udHJhY3QgZGF0YSB0byBzaWduIHdoZW4gbW92aW5nIGZ1bmRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgVGhlIHdhbGxldCBjb250cmFjdCBhZGRyZXNzIHdpdGggdGhlIGZ1bmRzIHRvIHdpdGhkcmF3XG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25BZGRyZXNzIFRoZSBhZGRyZXNzIHRvIHRyYW5zZmVyIHRoZSBmdW5kcyB0b1xuICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBOdW1iZXIgbXV0ZXogdG8gdHJhbnNmZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdENvdW50ZXIgV2FsbGV0IGNvdW50ZXIgdG8gdXNlIGluIHRoZSB0cmFuc2FjdGlvblxuICogQHJldHVybnMge2FueX0gQSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBNaWNoZWxzb24gc2NyaXB0IHRvIHNpZ24gYW5kIGFwcHJvdmUgYSB0cmFuc2ZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEYXRhVG9TaWduKFxuICBjb250cmFjdEFkZHJlc3M6IHN0cmluZyxcbiAgZGVzdGluYXRpb25BZGRyZXNzOiBzdHJpbmcsXG4gIGFtb3VudDogc3RyaW5nLFxuICBjb250cmFjdENvdW50ZXI6IHN0cmluZ1xuKTogYW55IHtcbiAgaWYgKCFpc1ZhbGlkT3JpZ2luYXRlZEFkZHJlc3MoY29udHJhY3RBZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb250cmFjdCBhZGRyZXNzICcgKyBjb250cmFjdEFkZHJlc3MgKyAnLiBBbiBvcmlnaW5hdGVkIGFjY291bnQgYWRkcmVzcyB3YXMgZXhwZWN0ZWQnKTtcbiAgfVxuICBpZiAoIWlzVmFsaWRBZGRyZXNzKGRlc3RpbmF0aW9uQWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVzdGluYXRpb24gYWRkcmVzcyAnICsgZGVzdGluYXRpb25BZGRyZXNzKTtcbiAgfVxuICByZXR1cm4gZ2VuZXJpY011bHRpc2lnRGF0YVRvU2lnbihjb250cmFjdEFkZHJlc3MsIGRlc3RpbmF0aW9uQWRkcmVzcywgYW1vdW50LCBjb250cmFjdENvdW50ZXIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIGhhc2ggb2YgdGhlIGdpdmVuIHR5cGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIHRoZSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSB7SGFzaFR5cGV9IGhhc2hUeXBlIC0gdGhlIHR5cGUgb2YgdGhlIHByb3ZpZGVkIGhhc2hcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhhc2goaGFzaDogc3RyaW5nLCBoYXNoVHlwZTogSGFzaFR5cGUpOiBib29sZWFuIHtcbiAgLy8gVmFsaWRhdGUgZW5jb2RpbmdcbiAgbGV0IGRlY29kZWRIYXNoO1xuICB0cnkge1xuICAgIGRlY29kZWRIYXNoID0gYmFzZTU4Y2hlY2suZGVjb2RlKGhhc2gpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGhhc2hQcmVmaXggPSBkZWNvZGVkSGFzaC5zbGljZSgwLCBoYXNoVHlwZS5wcmVmaXgubGVuZ3RoKTtcblxuICAvLyBDaGVjayBwcmVmaXhcbiAgaWYgKCFoYXNoUHJlZml4LmVxdWFscyhCdWZmZXIuZnJvbShoYXNoVHlwZS5wcmVmaXgpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGxlbmd0aFxuICBjb25zdCBoYXNoTGVuZ3RoID0gZGVjb2RlZEhhc2gubGVuZ3RoIC0gaGFzaFByZWZpeC5sZW5ndGg7XG4gIHJldHVybiBoYXNoTGVuZ3RoID09PSBoYXNoVHlwZS5ieXRlTGVuZ3RoO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIGFkZHJlc3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIHRoZSBhZGRyZXNzIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRBZGRyZXNzKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNWYWxpZEltcGxpY2l0QWRkcmVzcyhoYXNoKSB8fCBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMuS1QpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIGltcGxpY2l0IGFjY291bnQgYWRkcmVzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIC0gdGhlIGFkZHJlc3MgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEltcGxpY2l0QWRkcmVzcyhoYXNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy50ejEpIHx8IGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy50ejIpIHx8IGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy50ejMpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIG9yaWdpbmF0ZWQgYWNjb3VudCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggLSB0aGUgYWRkcmVzcyB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkT3JpZ2luYXRlZEFkZHJlc3MoaGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMuS1QpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIHNpZ25hdHVyZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIC0gdGhlIHNpZ25hdHVyZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkU2lnbmF0dXJlKGhhc2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy5lZHNpZykgfHxcbiAgICBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMuc3BzaWcxKSB8fFxuICAgIGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy5wMnNpZykgfHxcbiAgICBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMuc2lnKVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIHB1YmxpYyBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkocHVibGljS2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBpc1ZhbGlkSGFzaChwdWJsaWNLZXksIGhhc2hUeXBlcy5zcHBrKSB8fFxuICAgIGlzVmFsaWRIYXNoKHB1YmxpY0tleSwgaGFzaFR5cGVzLnAycGspIHx8XG4gICAgaXNWYWxpZEhhc2gocHVibGljS2V5LCBoYXNoVHlwZXMuZWRwaykgfHxcbiAgICBpc1ZhbGlkWHB1YihwdWJsaWNLZXkpIC8vIHhwdWJzIGFyZSB2YWxpZCB0b28uXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgVGV6b3MgcHJpdmF0ZSBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJpdmF0ZUtleSBUaGUgcHJpdmF0ZSBrZXkgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgaXNWYWxpZEhhc2gocHJpdmF0ZUtleSwgaGFzaFR5cGVzLmVkZXNrKSB8fFxuICAgIGlzVmFsaWRIYXNoKHByaXZhdGVLZXksIGhhc2hUeXBlcy5lZHNrKSB8fFxuICAgIGlzVmFsaWRIYXNoKHByaXZhdGVLZXksIGhhc2hUeXBlcy5zcHNrKSB8fFxuICAgIGlzVmFsaWRIYXNoKHByaXZhdGVLZXksIGhhc2hUeXBlcy5wMnNrKVxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFRlem9zIGJsb2NrIGhhc2hcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIHRoZSBhZGRyZXNzIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRCbG9ja0hhc2goaGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc1ZhbGlkSGFzaChoYXNoLCBoYXNoVHlwZXMuYik7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgVGV6b3MgdHJhbnNhY3Rpb24gaGFzaFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIC0gdGhlIGFkZHJlc3MgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFRyYW5zYWN0aW9uSGFzaChoYXNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzVmFsaWRIYXNoKGhhc2gsIGhhc2hUeXBlcy5vKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBUZXpvcyBrZXkgZ2l2ZW4gYSBwcmVmaXhcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCAtIHRoZSBrZXkgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSB7SGFzaFR5cGV9IGhhc2hUeXBlIC0gdGhlIHR5cGUgb2YgdGhlIHByb3ZpZGVkIGhhc2hcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEtleShoYXNoOiBzdHJpbmcsIGhhc2hUeXBlOiBIYXNoVHlwZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gaXNWYWxpZEhhc2goaGFzaCwgaGFzaFR5cGUpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3JpZ2luYWwga2V5IGZvcm0gdGhlIHRleHQgd2l0aG91dCB0aGUgZ2l2ZW4gcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIC0gYmFzZTU4IGVuY29kZWQga2V5IHdpdGggYSBUZXpvcyBwcmVmaXhcbiAqIEBwYXJhbSB7SGFzaFR5cGV9IGhhc2hUeXBlIC0gdGhlIHR5cGUgb2YgdGhlIHByb3ZpZGVkIGhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IHRoZSBvcmlnaW5hbCBkZWNvZGVkIGtleVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlS2V5KGhhc2g6IHN0cmluZywgaGFzaFR5cGU6IEhhc2hUeXBlKTogQnVmZmVyIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGhhc2gsIGhhc2hUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcHJpdmF0ZSBrZXknKTtcbiAgfVxuICBjb25zdCBkZWNvZGVkUHJ2ID0gYmFzZTU4Y2hlY2suZGVjb2RlKGhhc2gpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oZGVjb2RlZFBydi5zbGljZShoYXNoVHlwZS5wcmVmaXgubGVuZ3RoLCBkZWNvZGVkUHJ2Lmxlbmd0aCkpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHNpZ25hdHVyZSBmcm9tIGEgVGV6b3MgZW5jb2RlZCBvbmUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNpZ25hdHVyZSBUZXpvcyBzaWduYXR1cmVzIHByZWZpeGVkIHdpdGggc2lnLCBlZHNpZywgcDJzaWcgb3Igc3BzaWdcbiAqIEBwYXJhbSB7SGFzaFR5cGV9IGhhc2hUeXBlIFRoZSBwcmVmaXggb2YgcmVtb3ZlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBUaGUgZGVjb2RlZCBzaWduYXR1cmUgd2l0aG91dCBwcmVmaXhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVNpZ25hdHVyZShzaWduYXR1cmU6IHN0cmluZywgaGFzaFR5cGU6IEhhc2hUeXBlKTogQnVmZmVyIHtcbiAgaWYgKCFpc1ZhbGlkU2lnbmF0dXJlKHNpZ25hdHVyZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNpZ25hdHVyZScpO1xuICB9XG4gIGNvbnN0IGRlY29kZWRQcnYgPSBiYXNlNThjaGVjay5kZWNvZGUoc2lnbmF0dXJlKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRlY29kZWRQcnYuc2xpY2UoaGFzaFR5cGUucHJlZml4Lmxlbmd0aCwgZGVjb2RlZFBydi5sZW5ndGgpKTtcbn1cblxuLy8gQmFzZTU4Q2hlY2sgaXMgdXNlZCBmb3IgZW5jb2Rpbmdcbi8vIGhhc2hlZFR5cGVzIGlzIHVzZWQgdG8gdmFsaWRhdGUgaGFzaGVzIGJ5IHR5cGUsIGJ5IGNoZWNraW5nIHRoZWlyIHByZWZpeCBhbmRcbi8vIHRoZSBsZW5ndGggb2YgdGhlIEJ1ZmZlciBvYnRhaW5lZCBieSBkZWNvZGluZyB0aGUgaGFzaCAoZXhjbHVkaW5nIHRoZSBwcmVmaXgpXG5leHBvcnQgY29uc3QgaGFzaFR5cGVzID0ge1xuICAvKiAyMCBieXRlcyBsb25nICovXG4gIC8vIGVkMjU1MTkgcHVibGljIGtleSBoYXNoXG4gIHR6MToge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzYsIDE2MSwgMTU5XSksXG4gICAgYnl0ZUxlbmd0aDogMjAsXG4gIH0sXG4gIC8vIHNlY3AyNTZrMSBwdWJsaWMga2V5IGhhc2hcbiAgdHoyOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbNiwgMTYxLCAxNjFdKSxcbiAgICBieXRlTGVuZ3RoOiAyMCxcbiAgfSxcbiAgLy8gcDI1NiBwdWJsaWMga2V5IGhhc2hcbiAgdHozOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbNiwgMTYxLCAxNjRdKSxcbiAgICBieXRlTGVuZ3RoOiAyMCxcbiAgfSxcbiAgS1Q6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFsyLCA5MCwgMTIxXSksXG4gICAgYnl0ZUxlbmd0aDogMjAsXG4gIH0sXG4gIC8qIDMyIGJ5dGVzIGxvbmcgKi9cbiAgLy8gZWQyNTUxOSBwdWJsaWMga2V5XG4gIGVkcGs6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFsxMywgMTUsIDM3LCAyMTddKSxcbiAgICBieXRlTGVuZ3RoOiAzMixcbiAgfSxcbiAgLy8gZWQyNTUxOSBzZWNyZXQga2V5XG4gIGVkc2syOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMTMsIDE1LCA1OCwgN10pLFxuICAgIGJ5dGVMZW5ndGg6IDMyLFxuICB9LFxuICAvLyBzZWNwMjU2azEgc2VjcmV0IGtleVxuICBzcHNrOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMTcsIDE2MiwgMjI0LCAyMDFdKSxcbiAgICBieXRlTGVuZ3RoOiAzMixcbiAgfSxcbiAgLy8gcDI1NiBzZWNyZXQga2V5XG4gIHAyc2s6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFsxNiwgODEsIDIzOCwgMTg5XSksXG4gICAgYnl0ZUxlbmd0aDogMzIsXG4gIH0sXG4gIC8vIGJsb2NrIGhhc2hcbiAgYjoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzEsIDUyXSksXG4gICAgYnl0ZUxlbmd0aDogMzIsXG4gIH0sXG4gIC8vIG9wZXJhdGlvbiBoYXNoXG4gIG86IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFs1LCAxMTZdKSxcbiAgICBieXRlTGVuZ3RoOiAzMixcbiAgfSxcbiAgLy8gb3BlcmF0aW9uIGxpc3QgaGFzaFxuICBMbzoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzEzMywgMjMzXSksXG4gICAgYnl0ZUxlbmd0aDogMzIsXG4gIH0sXG4gIC8vIG9wZXJhdGlvbiBsaXN0IGxpc3QgaGFzaFxuICBMTG86IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFsyOSwgMTU5LCAxMDldKSxcbiAgICBieXRlTGVuZ3RoOiAzMixcbiAgfSxcbiAgLy8gcHJvdG9jb2wgaGFzaFxuICBQOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMiwgMTcwXSksXG4gICAgYnl0ZUxlbmd0aDogMzIsXG4gIH0sXG4gIC8vIGNvbnRleHQgaGFzaFxuICBDbzoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzc5LCAxNzldKSxcbiAgICBieXRlTGVuZ3RoOiAzMixcbiAgfSxcbiAgLyogMzMgYnl0ZXMgbG9uZyAqL1xuICAvLyBzZWNwMjU2azEgcHVibGljIGtleVxuICBzcHBrOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMywgMjU0LCAyMjYsIDg2XSksXG4gICAgYnl0ZUxlbmd0aDogMzMsXG4gIH0sXG4gIC8vIHAyNTYgcHVibGljIGtleVxuICBwMnBrOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbMywgMTc4LCAxMzksIDEyN10pLFxuICAgIGJ5dGVMZW5ndGg6IDMzLFxuICB9LFxuICAvKiA1NiBieXRlcyBsb25nICovXG4gIC8vIGVkMjU1MTkgZW5jcnlwdGVkIHNlZWRcbiAgZWRlc2s6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFs3LCA5MCwgNjAsIDE3OSwgNDFdKSxcbiAgICBieXRlTGVuZ3RoOiA1NixcbiAgfSxcbiAgLyogNjMgYnl0ZXMgbG9uZyAqL1xuICAvLyBlZDI1NTE5IHNlY3JldCBrZXlcbiAgZWRzazoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzQzLCAyNDYsIDc4LCA3XSksXG4gICAgYnl0ZUxlbmd0aDogNjQsXG4gIH0sXG4gIC8vIGVkMjU1MTkgc2lnbmF0dXJlXG4gIGVkc2lnOiB7XG4gICAgcHJlZml4OiBCdWZmZXIuZnJvbShbOSwgMjQ1LCAyMDUsIDEzNCwgMThdKSxcbiAgICBieXRlTGVuZ3RoOiA2NCxcbiAgfSxcbiAgLy8gc2VjcDI1NmsxIHNpZ25hdHVyZVxuICBzcHNpZzE6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFsxMywgMTE1LCAxMDEsIDE5LCA2M10pLFxuICAgIGJ5dGVMZW5ndGg6IDY0LFxuICB9LFxuICAvLyBwMjU2X3NpZ25hdHVyZVxuICBwMnNpZzoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzU0LCAyNDAsIDQ0LCA1Ml0pLFxuICAgIGJ5dGVMZW5ndGg6IDY0LFxuICB9LFxuICAvLyBnZW5lcmljIHNpZ25hdHVyZVxuICBzaWc6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFs0LCAxMzAsIDQzXSksXG4gICAgYnl0ZUxlbmd0aDogNjQsXG4gIH0sXG4gIC8qIDE1IGJ5dGVzIGxvbmcgKi9cbiAgLy8gbmV0d29yayBoYXNoXG4gIE5ldDoge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzg3LCA4MiwgMF0pLFxuICAgIGJ5dGVMZW5ndGg6IDE1LFxuICB9LFxuICAvLyBub25jZSBoYXNoXG4gIG5jZToge1xuICAgIHByZWZpeDogQnVmZmVyLmZyb20oWzY5LCAyMjAsIDE2OV0pLFxuICAgIGJ5dGVMZW5ndGg6IDE1LFxuICB9LFxuICAvKiA0IGJ5dGVzIGxvbmcgKi9cbiAgLy8gY2hhaW4gaWRcbiAgaWQ6IHtcbiAgICBwcmVmaXg6IEJ1ZmZlci5mcm9tKFsxNTMsIDEwM10pLFxuICAgIGJ5dGVMZW5ndGg6IDQsXG4gIH0sXG59O1xuXG4vLyBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lY2FkbGFicy90YXF1aXRvL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3RhcXVpdG8vc3JjL2NvbnN0YW50cy50c1xuXG5leHBvcnQgZW51bSBERUZBVUxUX0dBU19MSU1JVCB7XG4gIERFTEVHQVRJT04gPSAxMDYwMCxcbiAgT1JJR0lOQVRJT04gPSAxMDYwMCxcbiAgVFJBTlNGRVIgPSAxMDYwMCxcbiAgUkVWRUFMID0gMTA2MDAsXG59XG5cbmV4cG9ydCBlbnVtIERFRkFVTFRfRkVFIHtcbiAgREVMRUdBVElPTiA9IDEyNTcsXG4gIE9SSUdJTkFUSU9OID0gMTAwMDAsXG4gIFRSQU5TRkVSID0gMTAwMDAsXG4gIFJFVkVBTCA9IDE0MjAsXG59XG5cbmV4cG9ydCBlbnVtIERFRkFVTFRfU1RPUkFHRV9MSU1JVCB7XG4gIERFTEVHQVRJT04gPSAwLFxuICBPUklHSU5BVElPTiA9IDI1NyxcbiAgVFJBTlNGRVIgPSAyNTcsXG4gIFJFVkVBTCA9IDAsXG59XG4iXX0=