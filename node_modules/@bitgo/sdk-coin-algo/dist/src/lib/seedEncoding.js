"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SeedEncoding = void 0;
const base32 = __importStar(require("hi-base32"));
const js_sha512_1 = __importDefault(require("js-sha512"));
const SEED_BYTES_LENGTH = 32;
const ALGORAND_SEED_BYTE_LENGTH = 36;
const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_SEED_LENGTH = 58;
class SeedEncoding {
    static genericHash(arr) {
        return js_sha512_1.default.sha512_256.array(arr);
    }
    /**
     * Checks if a seed is valid
     * @param {String} seed - encoded Algorand seed
     * @returns {Boolean} true if valid, false otherwise
     */
    static isValidSeed(seed) {
        if (seed.length !== ALGORAND_SEED_LENGTH) {
            return false;
        }
        // Try to decode
        let decoded;
        try {
            decoded = SeedEncoding.decode(seed);
        }
        catch (e) {
            return false;
        }
        // Compute checksum
        const checksum = SeedEncoding.genericHash(decoded.seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH);
        // Check if the checksum and the seed are equal
        if (checksum.length !== decoded.checksum.length) {
            return false;
        }
        return checksum.every((val, i) => val === decoded.checksum[i]);
    }
    /**
     * Decode a seed
     *
     * @param seed
     * @return {{checksum: Uint8Array, seed: Uint8Array}}
     */
    static decode(seed) {
        // try to decode
        const decoded = base32.decode.asBytes(seed);
        // Sanity check
        if (decoded.length !== ALGORAND_SEED_BYTE_LENGTH)
            throw new Error('seed seems to be malformed');
        return {
            seed: new Uint8Array(decoded.slice(0, ALGORAND_SEED_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH)),
            checksum: new Uint8Array(decoded.slice(SEED_BYTES_LENGTH, ALGORAND_SEED_BYTE_LENGTH)),
        };
    }
    /**
     * Encode a secret key into a seed
     *
     * @param secretKey
     * @return {String} encoded seed
     */
    static encode(secretKey) {
        // get seed
        const seed = secretKey.slice(0, SEED_BYTES_LENGTH);
        // compute checksum
        const checksum = SeedEncoding.genericHash(seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH);
        const arraySeed = new Uint8Array(seed.length + checksum.length);
        arraySeed.set(seed);
        arraySeed.set(checksum, seed.length);
        const encodedSeed = base32.encode(arraySeed);
        return encodedSeed.toString().slice(0, ALGORAND_SEED_LENGTH); // removing the extra '===='
    }
}
exports.SeedEncoding = SeedEncoding;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VlZEVuY29kaW5nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9zZWVkRW5jb2RpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtEQUFvQztBQUNwQywwREFBK0I7QUFHL0IsTUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUM7QUFDN0IsTUFBTSx5QkFBeUIsR0FBRyxFQUFFLENBQUM7QUFDckMsTUFBTSw2QkFBNkIsR0FBRyxDQUFDLENBQUM7QUFDeEMsTUFBTSxvQkFBb0IsR0FBRyxFQUFFLENBQUM7QUFFaEMsTUFBYSxZQUFZO0lBQ2YsTUFBTSxDQUFDLFdBQVcsQ0FBQyxHQUFlO1FBQ3hDLE9BQU8sbUJBQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFZO1FBQzdCLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxvQkFBb0IsRUFBRTtZQUN4QyxPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsZ0JBQWdCO1FBQ2hCLElBQUksT0FBYSxDQUFDO1FBQ2xCLElBQUk7WUFDRixPQUFPLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNyQztRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELG1CQUFtQjtRQUNuQixNQUFNLFFBQVEsR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQzNELGlCQUFpQixHQUFHLDZCQUE2QixFQUNqRCxpQkFBaUIsQ0FDbEIsQ0FBQztRQUVGLCtDQUErQztRQUMvQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUU7WUFDL0MsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUNELE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFZO1FBQ3hCLGdCQUFnQjtRQUNoQixNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUU1QyxlQUFlO1FBQ2YsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLHlCQUF5QjtZQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztRQUVoRyxPQUFPO1lBQ0wsSUFBSSxFQUFFLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLHlCQUF5QixHQUFHLDZCQUE2QixDQUFDLENBQUM7WUFDakcsUUFBUSxFQUFFLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUUseUJBQXlCLENBQUMsQ0FBQztTQUN0RixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFxQjtRQUNqQyxXQUFXO1FBQ1gsTUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUNuRCxtQkFBbUI7UUFDbkIsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQ25ELGlCQUFpQixHQUFHLDZCQUE2QixFQUNqRCxpQkFBaUIsQ0FDbEIsQ0FBQztRQUNGLE1BQU0sU0FBUyxHQUFHLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hFLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEIsU0FBUyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3JDLE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFN0MsT0FBTyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsNEJBQTRCO0lBQzVGLENBQUM7Q0FDRjtBQTVFRCxvQ0E0RUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBiYXNlMzIgZnJvbSAnaGktYmFzZTMyJztcbmltcG9ydCBzaGE1MTIgZnJvbSAnanMtc2hhNTEyJztcbmltcG9ydCB7IFNlZWQgfSBmcm9tICcuL2lmYWNlcyc7XG5cbmNvbnN0IFNFRURfQllURVNfTEVOR1RIID0gMzI7XG5jb25zdCBBTEdPUkFORF9TRUVEX0JZVEVfTEVOR1RIID0gMzY7XG5jb25zdCBBTEdPUkFORF9DSEVDS1NVTV9CWVRFX0xFTkdUSCA9IDQ7XG5jb25zdCBBTEdPUkFORF9TRUVEX0xFTkdUSCA9IDU4O1xuXG5leHBvcnQgY2xhc3MgU2VlZEVuY29kaW5nIHtcbiAgcHJpdmF0ZSBzdGF0aWMgZ2VuZXJpY0hhc2goYXJyOiBVaW50OEFycmF5KTogbnVtYmVyW10ge1xuICAgIHJldHVybiBzaGE1MTIuc2hhNTEyXzI1Ni5hcnJheShhcnIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHNlZWQgaXMgdmFsaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlZWQgLSBlbmNvZGVkIEFsZ29yYW5kIHNlZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRTZWVkKHNlZWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmIChzZWVkLmxlbmd0aCAhPT0gQUxHT1JBTkRfU0VFRF9MRU5HVEgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gZGVjb2RlXG4gICAgbGV0IGRlY29kZWQ6IFNlZWQ7XG4gICAgdHJ5IHtcbiAgICAgIGRlY29kZWQgPSBTZWVkRW5jb2RpbmcuZGVjb2RlKHNlZWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGNoZWNrc3VtXG4gICAgY29uc3QgY2hlY2tzdW0gPSBTZWVkRW5jb2RpbmcuZ2VuZXJpY0hhc2goZGVjb2RlZC5zZWVkKS5zbGljZShcbiAgICAgIFNFRURfQllURVNfTEVOR1RIIC0gQUxHT1JBTkRfQ0hFQ0tTVU1fQllURV9MRU5HVEgsXG4gICAgICBTRUVEX0JZVEVTX0xFTkdUSFxuICAgICk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2hlY2tzdW0gYW5kIHRoZSBzZWVkIGFyZSBlcXVhbFxuICAgIGlmIChjaGVja3N1bS5sZW5ndGggIT09IGRlY29kZWQuY2hlY2tzdW0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bS5ldmVyeSgodmFsLCBpKSA9PiB2YWwgPT09IGRlY29kZWQuY2hlY2tzdW1baV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNlZWRcbiAgICpcbiAgICogQHBhcmFtIHNlZWRcbiAgICogQHJldHVybiB7e2NoZWNrc3VtOiBVaW50OEFycmF5LCBzZWVkOiBVaW50OEFycmF5fX1cbiAgICovXG4gIHN0YXRpYyBkZWNvZGUoc2VlZDogc3RyaW5nKTogU2VlZCB7XG4gICAgLy8gdHJ5IHRvIGRlY29kZVxuICAgIGNvbnN0IGRlY29kZWQgPSBiYXNlMzIuZGVjb2RlLmFzQnl0ZXMoc2VlZCk7XG5cbiAgICAvLyBTYW5pdHkgY2hlY2tcbiAgICBpZiAoZGVjb2RlZC5sZW5ndGggIT09IEFMR09SQU5EX1NFRURfQllURV9MRU5HVEgpIHRocm93IG5ldyBFcnJvcignc2VlZCBzZWVtcyB0byBiZSBtYWxmb3JtZWQnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzZWVkOiBuZXcgVWludDhBcnJheShkZWNvZGVkLnNsaWNlKDAsIEFMR09SQU5EX1NFRURfQllURV9MRU5HVEggLSBBTEdPUkFORF9DSEVDS1NVTV9CWVRFX0xFTkdUSCkpLFxuICAgICAgY2hlY2tzdW06IG5ldyBVaW50OEFycmF5KGRlY29kZWQuc2xpY2UoU0VFRF9CWVRFU19MRU5HVEgsIEFMR09SQU5EX1NFRURfQllURV9MRU5HVEgpKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIHNlY3JldCBrZXkgaW50byBhIHNlZWRcbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWQgc2VlZFxuICAgKi9cbiAgc3RhdGljIGVuY29kZShzZWNyZXRLZXk6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICAgIC8vIGdldCBzZWVkXG4gICAgY29uc3Qgc2VlZCA9IHNlY3JldEtleS5zbGljZSgwLCBTRUVEX0JZVEVTX0xFTkdUSCk7XG4gICAgLy8gY29tcHV0ZSBjaGVja3N1bVxuICAgIGNvbnN0IGNoZWNrc3VtID0gU2VlZEVuY29kaW5nLmdlbmVyaWNIYXNoKHNlZWQpLnNsaWNlKFxuICAgICAgU0VFRF9CWVRFU19MRU5HVEggLSBBTEdPUkFORF9DSEVDS1NVTV9CWVRFX0xFTkdUSCxcbiAgICAgIFNFRURfQllURVNfTEVOR1RIXG4gICAgKTtcbiAgICBjb25zdCBhcnJheVNlZWQgPSBuZXcgVWludDhBcnJheShzZWVkLmxlbmd0aCArIGNoZWNrc3VtLmxlbmd0aCk7XG4gICAgYXJyYXlTZWVkLnNldChzZWVkKTtcbiAgICBhcnJheVNlZWQuc2V0KGNoZWNrc3VtLCBzZWVkLmxlbmd0aCk7XG4gICAgY29uc3QgZW5jb2RlZFNlZWQgPSBiYXNlMzIuZW5jb2RlKGFycmF5U2VlZCk7XG5cbiAgICByZXR1cm4gZW5jb2RlZFNlZWQudG9TdHJpbmcoKS5zbGljZSgwLCBBTEdPUkFORF9TRUVEX0xFTkdUSCk7IC8vIHJlbW92aW5nIHRoZSBleHRyYSAnPT09PSdcbiAgfVxufVxuIl19