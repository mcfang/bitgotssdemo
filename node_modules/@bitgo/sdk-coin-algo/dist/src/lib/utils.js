"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const algosdk_1 = __importDefault(require("algosdk"));
const stellar_sdk_1 = __importDefault(require("stellar-sdk"));
const hex = __importStar(require("@stablelib/hex"));
const nacl = __importStar(require("tweetnacl"));
const hi_base32_1 = __importDefault(require("hi-base32"));
const js_sha512_1 = __importDefault(require("js-sha512"));
const lodash_1 = __importDefault(require("lodash"));
const keyPair_1 = require("./keyPair");
const seedEncoding_1 = require("./seedEncoding");
const algoNacl = __importStar(require("algosdk/dist/cjs/src/nacl/naclWrappers"));
const encoding = __importStar(require("algosdk/dist/cjs/src/encoding/encoding"));
const sdk_core_1 = require("@bitgo/sdk-core");
const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
const ALGORAND_SEED_LENGTH = 58;
const ALGORAND_SEED_BYTE_LENGTH = 36;
const ALGORAND_TRANSACTION_LENGTH = 52;
const SEED_BYTES_LENGTH = 32;
/**
 * Determines whether the string is only composed of hex chars.
 *
 * @param {string} maybe The string to be validated.
 * @returns {boolean} true if the string consists of only hex characters, otherwise false.
 */
function allHexChars(maybe) {
    return /^([0-9a-f]{2})+$/i.test(maybe);
}
/**
 * ConcatArrays takes two array and returns a joint array of both
 *
 * @param a {Uint8Array} first array to concat
 * @param b {Uint8Array} second array
 * @returns {Uint8Array} a new array containing all elements of 'a' followed by all elements of 'b'
 */
function concatArrays(a, b) {
    const c = new Uint8Array(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
}
class Utils {
    /** @inheritdoc */
    isValidAddress(address) {
        return algosdk_1.default.isValidAddress(address);
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        if (txId.length !== 104) {
            return false;
        }
        return allHexChars(txId);
    }
    /** @inheritdoc */
    isValidPublicKey(key) {
        return sdk_core_1.isValidEd25519PublicKey(key);
    }
    /** @inheritdoc */
    isValidPrivateKey(key) {
        return sdk_core_1.isValidEd25519SecretKey(key);
    }
    /**
     * Returns an hex string of the given buffer
     *
     * @param {Uint8Array} buffer - the buffer to be converted to hex
     * @returns {string} - the hex value
     */
    toHex(buffer) {
        return hex.encode(buffer, true);
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        throw new sdk_core_1.NotImplementedError('isValidSignature not implemented.');
    }
    /** @inheritdoc */
    isValidBlockId(hash) {
        throw new sdk_core_1.NotImplementedError('hash not implemented.');
    }
    /**
     * Compare two Keys
     *
     * @param {Uint8Array} key1 - key to be compare
     * @param {Uint8Array} key2 - key to be compare
     * @returns {boolean} - returns true if both keys are equal
     */
    areKeysEqual(key1, key2) {
        return nacl.verify(key1, key2);
    }
    /**
     * Returns a Uint8Array of the given hex string
     *
     * @param {string} str - the hex string to be converted
     * @returns {string} - the Uint8Array value
     */
    toUint8Array(str) {
        return Buffer.from(str, 'hex');
    }
    /**
     * Determines whether a seed is valid.
     *
     * @param {string} seed - the seed to be validated
     * @returns {boolean} - true if the seed is valid
     */
    isValidSeed(seed) {
        if (typeof seed !== 'string')
            return false;
        if (seed.length !== ALGORAND_SEED_LENGTH)
            return false;
        // Try to decode
        let decoded;
        try {
            decoded = this.decodeSeed(seed);
        }
        catch (e) {
            return false;
        }
        // Compute checksum
        const checksum = new Uint8Array(js_sha512_1.default.sha512_256.array(decoded.seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH));
        // Check if the checksum matches the one from the decoded seed
        return lodash_1.default.isEqual(checksum, decoded.checksum);
    }
    /**
     * Encode an algo seed
     *
     * @param  {Buffer} secretKey - the valid secretKey .
     * @returns {string} - the seed to be validated.
     */
    encodeSeed(secretKey) {
        // get seed
        const seed = secretKey.slice(0, SEED_BYTES_LENGTH);
        // compute checksum
        const checksum = Buffer.from(js_sha512_1.default.sha512_256.array(seed).slice(SEED_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, SEED_BYTES_LENGTH));
        const encodedSeed = hi_base32_1.default.encode(concatArrays(seed, checksum));
        return encodedSeed.toString().slice(0, ALGORAND_SEED_LENGTH); // removing the extra '===='
    }
    /**
     * decodeSeed decodes an algo seed
     *
     * Decoding algo seed is same as decoding address.
     * Latest version of algo sdk (1.9, at this writing) does not expose explicit method for decoding seed.
     * Parameter is decoded and split into seed and checksum.
     *
     * @param {string} seed - hex or base64 encoded seed to be validated
     * @returns {Seed} - validated object Seed
     */
    decodeSeed(seed) {
        // try to decode
        const decoded = hi_base32_1.default.decode.asBytes(seed);
        // Sanity check
        if (decoded.length !== ALGORAND_SEED_BYTE_LENGTH)
            throw new Error('seed seems to be malformed');
        return {
            seed: new Uint8Array(decoded.slice(0, ALGORAND_SEED_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH)),
            checksum: new Uint8Array(decoded.slice(SEED_BYTES_LENGTH, ALGORAND_SEED_BYTE_LENGTH)),
        };
    }
    /**
     * Verifies if signature for message is valid.
     *
     * @param pub {Uint8Array} public key
     * @param message {Uint8Array} signed message
     * @param signature {Buffer} signature to verify
     * @returns {Boolean} true if signature is valid.
     */
    verifySignature(message, signature, pub) {
        return nacl.sign.detached.verify(message, signature, pub);
    }
    /**
     * Transforms an Ed25519 public key into an algorand address.
     *
     * @param {Uint8Array} pk The Ed25519 public key.
     * @see https://developer.algorand.org/docs/features/accounts/#transformation-public-key-to-algorand-address
     *
     * @returns {string} The algorand address.
     */
    publicKeyToAlgoAddress(pk) {
        return new keyPair_1.KeyPair({ pub: Buffer.from(pk).toString('hex') }).getAddress();
    }
    /**
     * Checks if a unsigned algo transaction can be decoded.
     *
     * @param {Uint8Array} txn The encoded unsigned transaction.
     * @returns {boolean} true if the transaction can be decoded, otherwise false
     */
    isDecodableUnsignedAlgoTxn(txn) {
        try {
            algosdk_1.default.decodeUnsignedTransaction(txn);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Checks if a signed algo transaction can be decoded.
     *
     * @param {Uint8Array} txn The encoded signed transaction.
     * @returns {boolean} true if the transaction can be decoded, otherwise false
     */
    isDecodableSignedTransaction(txn) {
        try {
            algosdk_1.default.decodeSignedTransaction(txn);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Decodes a signed or unsigned algo transaction.
     *
     * @param {Uint8Array | string} txnBytes The encoded unsigned or signed txn.
     * @returns {EncodedTx} The decoded transaction.
     */
    decodeAlgoTxn(txnBytes) {
        let buffer = typeof txnBytes === 'string'
            ? Buffer.from(txnBytes, allHexChars(txnBytes) ? 'hex' : 'base64')
            : Buffer.from(txnBytes);
        // In order to maintain backward compatibility with old keyreg transactions encoded with
        // forked algosdk 1.2.0 (https://github.com/BitGo/algosdk-bitgo),
        // the relevant information is extracted and parsed following the latest algosdk
        // release standard.
        // This way we can decode transactions successfully by still maintaining backward compatibility.
        const decodedTx = encoding.decode(buffer);
        if (decodedTx.txn &&
            decodedTx.txn.type === 'keyreg' &&
            decodedTx.txn.votefst &&
            decodedTx.txn.votelst &&
            decodedTx.txn.votekd) {
            decodedTx.txn.votekey = decodedTx.txn.votekey || decodedTx.msig.subsig[0].pk;
            decodedTx.txn.selkey = decodedTx.txn.selkey || decodedTx.msig.subsig[0].pk;
            buffer = decodedTx.msig || decodedTx.sig ? encoding.encode(decodedTx) : encoding.encode(decodedTx.txn);
        }
        try {
            return this.tryToDecodeUnsignedTransaction(buffer);
        }
        catch {
            // Ignore error to try different format
        }
        try {
            return this.tryToDecodeSignedTransaction(buffer);
        }
        catch {
            throw new sdk_core_1.InvalidTransactionError('Transaction cannot be decoded');
        }
    }
    /**
     * Try to decode a signed Algo transaction
     * @param buffer the encoded transaction
     * @returns { EncodedTx } the decoded signed transaction
     * @throws error if it is not a valid encoded signed transaction
     */
    tryToDecodeSignedTransaction(buffer) {
        // TODO: Replace with
        // return algosdk.Transaction.from_obj_for_encoding(algosdk.decodeSignedTransaction(buffer).txn);
        // see: https://github.com/algorand/js-algorand-sdk/issues/364
        // "...some parts of the codebase treat the output of Transaction.from_obj_for_encoding as EncodedTransaction.
        // They need to be fixed(or we at least need to make it so Transaction conforms to EncodedTransaction)."
        const tx = algosdk_1.default.decodeSignedTransaction(buffer);
        const signers = [];
        const signedBy = [];
        if (tx.msig && tx.msig.subsig) {
            for (const sig of tx.msig.subsig) {
                const addr = algosdk_1.default.encodeAddress(sig.pk);
                signers.push(addr);
                if (sig.s) {
                    signedBy.push(addr);
                }
            }
        }
        return {
            rawTransaction: new Uint8Array(buffer),
            txn: tx.txn,
            signed: true,
            signers: signers,
            signedBy: signedBy,
        };
    }
    /**
     * Try to decode an unsigned Algo transaction
     * @param buffer the encoded transaction
     * @returns {EncodedTx} the decoded unsigned transaction
     * @throws error if it is not a valid encoded unsigned transaction
     */
    tryToDecodeUnsignedTransaction(buffer) {
        const txn = algosdk_1.default.decodeUnsignedTransaction(buffer);
        return {
            rawTransaction: new Uint8Array(buffer),
            txn,
            signed: false,
        };
    }
    /*
     * encodeObj takes a javascript object and returns its msgpack encoding
     * Note that the encoding sorts the fields alphabetically
     *
     * @param {Record<string | number | symbol, any>} obj js obj
     * @returns {Uint8Array} Uint8Array binary representation
     */
    encodeObj(obj) {
        return algosdk_1.default.encodeObj(obj);
    }
    /**
     * decodeObj takes a Uint8Array and returns its javascript obj
     * @param o - Uint8Array to decode
     * @returns object
     */
    decodeObj(o) {
        return algosdk_1.default.decodeObj(o);
    }
    /**
     * secretKeyToMnemonic takes an Algorant secret key and returns the corresponding mnemonic
     *
     * @param sk - Algorant secret key
     * @return Secret key is associated mnemonic
     */
    secretKeyToMnemonic(sk) {
        const skValid = Buffer.from(sk.toString('hex'));
        if (!this.isValidPrivateKey(skValid.toString('hex'))) {
            throw new sdk_core_1.InvalidKey(`The secret key: ${sk.toString('hex')} is invalid`);
        }
        const skUnit8Array = Buffer.from(sk);
        return algosdk_1.default.secretKeyToMnemonic(skUnit8Array);
    }
    /**
     * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it
     * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one
     * of the passed words is not found in the words list
     *
     * @param mnemonic - 25 words mnemonic
     * @returns 32 bytes long seed
     */
    seedFromMnemonic(mnemonic) {
        return algosdk_1.default.mnemonicToMasterDerivationKey(mnemonic);
    }
    /**
     * keyPairFromSeed generates an object with secretKey and publicKey using the algosdk
     * @param seed 32 bytes long seed
     * @returns KeyPair
     */
    keyPairFromSeed(seed) {
        const mn = this.mnemonicFromSeed(seed);
        const base64PrivateKey = algosdk_1.default.mnemonicToSecretKey(mn).sk;
        return this.createKeyPair(base64PrivateKey);
    }
    /**
     * Generate a new `KeyPair` object from the given private key.
     *
     * @param base64PrivateKey 64 bytes long privateKey
     * @returns KeyPair
     */
    createKeyPair(base64PrivateKey) {
        const sk = base64PrivateKey.slice(0, 32);
        return new keyPair_1.KeyPair({ prv: Buffer.from(sk).toString('hex') });
    }
    /**
     * decodePrivateKey generates a seed with a mnemonic and using algosdk.
     *
     * @param seed 32 bytes long seed
     * @returns mnemonic - 25 words mnemonic - 25 words mnemonic
     */
    mnemonicFromSeed(seed) {
        return algosdk_1.default.masterDerivationKeyToMnemonic(seed);
    }
    /**
     * Validates the key with the stellar-sdk
     *
     * @param publicKey
     * @returns boolean
     */
    isValidEd25519PublicKeyStellar(publicKey) {
        return stellar_sdk_1.default.StrKey.isValidEd25519PublicKey(publicKey);
    }
    /**
     * Decodes the key with the stellar-sdk
     *
     * @param publicKey
     * @returns Buffer
     */
    decodeEd25519PublicKeyStellar(publicKey) {
        return stellar_sdk_1.default.StrKey.decodeEd25519PublicKey(publicKey);
    }
    /**
     * Convert a stellar seed to algorand encoding
     *
     * @param seed
     * @returns string the encoded seed
     */
    convertFromStellarSeed(seed) {
        return seedEncoding_1.SeedEncoding.encode(stellar_sdk_1.default.StrKey.decodeEd25519SecretSeed(seed));
    }
    /**
     * Returns an address encoded with algosdk
     *
     * @param addr
     * @returns string
     */
    encodeAddress(addr) {
        return algosdk_1.default.encodeAddress(addr);
    }
    /**
     * Return an address decoded with algosdk
     *
     * @param addr
     * @returns Address
     */
    decodeAddress(addr) {
        return algosdk_1.default.decodeAddress(addr);
    }
    /**
     * Converts an address into an ALGO one
     * If the given data is a Stellar address or public key, it is converted to ALGO address.
     *
     * @param addressOrPubKey an ALGO address, or an Stellar address or public key
     * @returns address algo address string
     */
    stellarAddressToAlgoAddress(addressOrPubKey) {
        // we have an Algorand address
        if (this.isValidAddress(addressOrPubKey)) {
            return addressOrPubKey;
        }
        // we have a stellar key
        if (this.isValidEd25519PublicKeyStellar(addressOrPubKey)) {
            const stellarPub = this.decodeEd25519PublicKeyStellar(addressOrPubKey);
            const algoAddress = this.encodeAddress(stellarPub);
            if (this.isValidAddress(algoAddress)) {
                return algoAddress;
            }
            throw new Error('Cannot convert Stellar address to an Algorand address via pubkey.');
        }
        throw new Error('Neither an Algorand address nor a stellar pubkey.');
    }
    /**
     * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.
     *
     * @param {number} version mutlisig version
     * @param {number} threshold multisig threshold
     * @param {string[]} addrs list of Algorand addresses
     * @returns {string} human readable Algorand address.
     */
    multisigAddress(version, threshold, addrs) {
        return algosdk_1.default.multisigAddress({
            version,
            threshold,
            addrs,
        });
    }
    /**
     * generateAccount generates un account with a secretKey and an address
     *
     * Function has not params
     * @returns Account
     */
    generateAccount() {
        return algosdk_1.default.generateAccount();
    }
    generateAccountFromSeed(seed) {
        const keys = nacl.sign.keyPair.fromSeed(seed);
        return {
            addr: algosdk_1.default.encodeAddress(keys.publicKey),
            sk: keys.secretKey,
        };
    }
    /**
     * Generates Tx ID from an encoded multisig transaction
     *
     * This is done because of a change made on version 1.10.1 on algosdk so method txID() only supports SignedTransaction type.
     * (https://github.com/algorand/js-algorand-sdk/blob/develop/CHANGELOG.md#1101)
     *
     * @param {string} txBase64 - encoded base64 multisig transaction
     * @returns {string} - transaction ID
     */
    getMultisigTxID(txBase64) {
        const txBytes = Buffer.from(txBase64, 'base64');
        const decodeSignTx = algosdk_1.default.decodeSignedTransaction(txBytes);
        const wellFormedDecodedSignTx = decodeSignTx.txn.get_obj_for_encoding();
        const txForEncoding = { msig: decodeSignTx.msig, txn: wellFormedDecodedSignTx };
        const en_msg = encoding.encode(txForEncoding);
        const tag = Buffer.from([84, 88]);
        const gh = Buffer.from(concatArrays(tag, en_msg));
        const hash = Buffer.from(algoNacl.genericHash(gh));
        return hi_base32_1.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
    }
    /**
     * Determines if a given transaction data is to enable or disable a token
     * @param amount the amount in transaction
     * @param from the originated address
     * @param to the target address
     * @param closeRemainderTo (optional) address to send remaining units in originated address
     * @returns 'enableToken' or 'disableToken'
     */
    getTokenTxType(amount, from, to, closeRemainderTo) {
        let type = 'transferToken';
        if (amount === '0' && from === to) {
            type = !closeRemainderTo ? 'enableToken' : 'disableToken';
        }
        return type;
    }
    /**
     * Validate if the key is a valid base64 string
     * @param key the key to validate
     */
    validateBase64(key) {
        if (!key || typeof key !== 'string') {
            throw new Error('Invalid base64 string');
        }
        const base64RegExp = /^(?:[a-zA-Z0-9+\/]{4})*(?:|(?:[a-zA-Z0-9+\/]{3}=)|(?:[a-zA-Z0-9+\/]{2}==)|(?:[a-zA-Z0-9+\/]{1}===))$/;
        if (!base64RegExp.test(key)) {
            throw new Error('Invalid base64 string');
        }
    }
}
exports.Utils = Utils;
const utils = new Utils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBOEI7QUFDOUIsOERBQWtDO0FBQ2xDLG9EQUFzQztBQUN0QyxnREFBa0M7QUFDbEMsMERBQStCO0FBQy9CLDBEQUErQjtBQUMvQixvREFBdUI7QUFFdkIsdUNBQW9DO0FBQ3BDLGlEQUE4QztBQUM5QyxpRkFBbUU7QUFDbkUsaUZBQW1FO0FBQ25FLDhDQU95QjtBQUV6QixNQUFNLDZCQUE2QixHQUFHLENBQUMsQ0FBQztBQUN4QyxNQUFNLG9CQUFvQixHQUFHLEVBQUUsQ0FBQztBQUNoQyxNQUFNLHlCQUF5QixHQUFHLEVBQUUsQ0FBQztBQUNyQyxNQUFNLDJCQUEyQixHQUFHLEVBQUUsQ0FBQztBQUN2QyxNQUFNLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztBQUU3Qjs7Ozs7R0FLRztBQUNILFNBQVMsV0FBVyxDQUFDLEtBQWE7SUFDaEMsT0FBTyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDekMsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQVMsWUFBWSxDQUFDLENBQWEsRUFBRSxDQUFhO0lBQ2hELE1BQU0sQ0FBQyxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDVCxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDbkIsT0FBTyxDQUFDLENBQUM7QUFDWCxDQUFDO0FBRUQsTUFBYSxLQUFLO0lBQ2hCLGtCQUFrQjtJQUNsQixjQUFjLENBQUMsT0FBZTtRQUM1QixPQUFPLGlCQUFPLENBQUMsY0FBYyxDQUFDLE9B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LE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDbEQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDbkQsT0FBTyxtQkFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLDJCQUEyQixDQUFDLENBQUM7SUFDbkUsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxjQUFjLENBQUMsTUFBYyxFQUFFLElBQVksRUFBRSxFQUFVLEVBQUUsZ0JBQXlCO1FBQ2hGLElBQUksSUFBSSxHQUFHLGVBQWUsQ0FBQztRQUMzQixJQUFJLE1BQU0sS0FBSyxHQUFHLElBQUksSUFBSSxLQUFLLEVBQUUsRUFBRTtZQUNqQyxJQUFJLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUM7U0FDM0Q7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7O09BR0c7SUFDSCxjQUFjLENBQUMsR0FBVztRQUN4QixJQUFJLENBQUMsR0FBRyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsRUFBRTtZQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUM7U0FDMUM7UUFDRCxNQUFNLFlBQVksR0FDaEIsc0dBQXNHLENBQUM7UUFDekcsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1NBQzFDO0lBQ0gsQ0FBQztDQUNGO0FBdGdCRCxzQkFzZ0JDO0FBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztBQUUxQixrQkFBZSxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYWxnb3NkayBmcm9tICdhbGdvc2RrJztcbmltcG9ydCBzdGVsbGFyIGZyb20gJ3N0ZWxsYXItc2RrJztcbmltcG9ydCAqIGFzIGhleCBmcm9tICdAc3RhYmxlbGliL2hleCc7XG5pbXBvcnQgKiBhcyBuYWNsIGZyb20gJ3R3ZWV0bmFjbCc7XG5pbXBvcnQgYmFzZTMyIGZyb20gJ2hpLWJhc2UzMic7XG5pbXBvcnQgc2hhNTEyIGZyb20gJ2pzLXNoYTUxMic7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgQWRkcmVzcywgRW5jb2RlZFR4LCBTZWVkIH0gZnJvbSAnLi9pZmFjZXMnO1xuaW1wb3J0IHsgS2V5UGFpciB9IGZyb20gJy4va2V5UGFpcic7XG5pbXBvcnQgeyBTZWVkRW5jb2RpbmcgfSBmcm9tICcuL3NlZWRFbmNvZGluZyc7XG5pbXBvcnQgKiBhcyBhbGdvTmFjbCBmcm9tICdhbGdvc2RrL2Rpc3QvY2pzL3NyYy9uYWNsL25hY2xXcmFwcGVycyc7XG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdhbGdvc2RrL2Rpc3QvY2pzL3NyYy9lbmNvZGluZy9lbmNvZGluZyc7XG5pbXBvcnQge1xuICBCYXNlVXRpbHMsXG4gIE5vdEltcGxlbWVudGVkRXJyb3IsXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxuICBJbnZhbGlkS2V5LFxuICBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleSxcbiAgaXNWYWxpZEVkMjU1MTlTZWNyZXRLZXksXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5cbmNvbnN0IEFMR09SQU5EX0NIRUNLU1VNX0JZVEVfTEVOR1RIID0gNDtcbmNvbnN0IEFMR09SQU5EX1NFRURfTEVOR1RIID0gNTg7XG5jb25zdCBBTEdPUkFORF9TRUVEX0JZVEVfTEVOR1RIID0gMzY7XG5jb25zdCBBTEdPUkFORF9UUkFOU0FDVElPTl9MRU5HVEggPSA1MjtcbmNvbnN0IFNFRURfQllURVNfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdHJpbmcgaXMgb25seSBjb21wb3NlZCBvZiBoZXggY2hhcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1heWJlIFRoZSBzdHJpbmcgdG8gYmUgdmFsaWRhdGVkLlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHN0cmluZyBjb25zaXN0cyBvZiBvbmx5IGhleCBjaGFyYWN0ZXJzLCBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIGFsbEhleENoYXJzKG1heWJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9eKFswLTlhLWZdezJ9KSskL2kudGVzdChtYXliZSk7XG59XG5cbi8qKlxuICogQ29uY2F0QXJyYXlzIHRha2VzIHR3byBhcnJheSBhbmQgcmV0dXJucyBhIGpvaW50IGFycmF5IG9mIGJvdGhcbiAqXG4gKiBAcGFyYW0gYSB7VWludDhBcnJheX0gZmlyc3QgYXJyYXkgdG8gY29uY2F0XG4gKiBAcGFyYW0gYiB7VWludDhBcnJheX0gc2Vjb25kIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gYSBuZXcgYXJyYXkgY29udGFpbmluZyBhbGwgZWxlbWVudHMgb2YgJ2EnIGZvbGxvd2VkIGJ5IGFsbCBlbGVtZW50cyBvZiAnYidcbiAqL1xuZnVuY3Rpb24gY29uY2F0QXJyYXlzKGE6IFVpbnQ4QXJyYXksIGI6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuICBjLnNldChhKTtcbiAgYy5zZXQoYiwgYS5sZW5ndGgpO1xuICByZXR1cm4gYztcbn1cblxuZXhwb3J0IGNsYXNzIFV0aWxzIGltcGxlbWVudHMgQmFzZVV0aWxzIHtcbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBhbGdvc2RrLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRUcmFuc2FjdGlvbklkKHR4SWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0eElkLmxlbmd0aCAhPT0gMTA0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbEhleENoYXJzKHR4SWQpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRQdWJsaWNLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoa2V5KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkUHJpdmF0ZUtleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1ZhbGlkRWQyNTUxOVNlY3JldEtleShrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaGV4IHN0cmluZyBvZiB0aGUgZ2l2ZW4gYnVmZmVyXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIC0gdGhlIGJ1ZmZlciB0byBiZSBjb252ZXJ0ZWQgdG8gaGV4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGhleCB2YWx1ZVxuICAgKi9cbiAgdG9IZXgoYnVmZmVyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gaGV4LmVuY29kZShidWZmZXIsIHRydWUpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRTaWduYXR1cmUoc2lnbmF0dXJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignaXNWYWxpZFNpZ25hdHVyZSBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZEJsb2NrSWQoaGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoJ2hhc2ggbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgdHdvIEtleXNcbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBrZXkxIC0ga2V5IHRvIGJlIGNvbXBhcmVcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBrZXkyIC0ga2V5IHRvIGJlIGNvbXBhcmVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gcmV0dXJucyB0cnVlIGlmIGJvdGgga2V5cyBhcmUgZXF1YWxcbiAgICovXG4gIGFyZUtleXNFcXVhbChrZXkxOiBVaW50OEFycmF5LCBrZXkyOiBVaW50OEFycmF5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5hY2wudmVyaWZ5KGtleTEsIGtleTIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBVaW50OEFycmF5IG9mIHRoZSBnaXZlbiBoZXggc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSB0aGUgaGV4IHN0cmluZyB0byBiZSBjb252ZXJ0ZWRcbiAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgVWludDhBcnJheSB2YWx1ZVxuICAgKi9cbiAgdG9VaW50OEFycmF5KHN0cjogc3RyaW5nKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgJ2hleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHNlZWQgaXMgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWVkIC0gdGhlIHNlZWQgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRydWUgaWYgdGhlIHNlZWQgaXMgdmFsaWRcbiAgICovXG4gIGlzVmFsaWRTZWVkKHNlZWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0eXBlb2Ygc2VlZCAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChzZWVkLmxlbmd0aCAhPT0gQUxHT1JBTkRfU0VFRF9MRU5HVEgpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFRyeSB0byBkZWNvZGVcbiAgICBsZXQgZGVjb2RlZDtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IHRoaXMuZGVjb2RlU2VlZChzZWVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBjaGVja3N1bVxuICAgIGNvbnN0IGNoZWNrc3VtID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICBzaGE1MTIuc2hhNTEyXzI1Ni5hcnJheShkZWNvZGVkLnNlZWQpLnNsaWNlKFNFRURfQllURVNfTEVOR1RIIC0gQUxHT1JBTkRfQ0hFQ0tTVU1fQllURV9MRU5HVEgsIFNFRURfQllURVNfTEVOR1RIKVxuICAgICk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgY2hlY2tzdW0gbWF0Y2hlcyB0aGUgb25lIGZyb20gdGhlIGRlY29kZWQgc2VlZFxuICAgIHJldHVybiBfLmlzRXF1YWwoY2hlY2tzdW0sIGRlY29kZWQuY2hlY2tzdW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhbiBhbGdvIHNlZWRcbiAgICpcbiAgICogQHBhcmFtICB7QnVmZmVyfSBzZWNyZXRLZXkgLSB0aGUgdmFsaWQgc2VjcmV0S2V5IC5cbiAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgc2VlZCB0byBiZSB2YWxpZGF0ZWQuXG4gICAqL1xuICBlbmNvZGVTZWVkKHNlY3JldEtleTogQnVmZmVyKTogc3RyaW5nIHtcbiAgICAvLyBnZXQgc2VlZFxuICAgIGNvbnN0IHNlZWQgPSBzZWNyZXRLZXkuc2xpY2UoMCwgU0VFRF9CWVRFU19MRU5HVEgpO1xuICAgIC8vIGNvbXB1dGUgY2hlY2tzdW1cbiAgICBjb25zdCBjaGVja3N1bSA9IEJ1ZmZlci5mcm9tKFxuICAgICAgc2hhNTEyLnNoYTUxMl8yNTYuYXJyYXkoc2VlZCkuc2xpY2UoU0VFRF9CWVRFU19MRU5HVEggLSBBTEdPUkFORF9DSEVDS1NVTV9CWVRFX0xFTkdUSCwgU0VFRF9CWVRFU19MRU5HVEgpXG4gICAgKTtcbiAgICBjb25zdCBlbmNvZGVkU2VlZCA9IGJhc2UzMi5lbmNvZGUoY29uY2F0QXJyYXlzKHNlZWQsIGNoZWNrc3VtKSk7XG5cbiAgICByZXR1cm4gZW5jb2RlZFNlZWQudG9TdHJpbmcoKS5zbGljZSgwLCBBTEdPUkFORF9TRUVEX0xFTkdUSCk7IC8vIHJlbW92aW5nIHRoZSBleHRyYSAnPT09PSdcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWNvZGVTZWVkIGRlY29kZXMgYW4gYWxnbyBzZWVkXG4gICAqXG4gICAqIERlY29kaW5nIGFsZ28gc2VlZCBpcyBzYW1lIGFzIGRlY29kaW5nIGFkZHJlc3MuXG4gICAqIExhdGVzdCB2ZXJzaW9uIG9mIGFsZ28gc2RrICgxLjksIGF0IHRoaXMgd3JpdGluZykgZG9lcyBub3QgZXhwb3NlIGV4cGxpY2l0IG1ldGhvZCBmb3IgZGVjb2Rpbmcgc2VlZC5cbiAgICogUGFyYW1ldGVyIGlzIGRlY29kZWQgYW5kIHNwbGl0IGludG8gc2VlZCBhbmQgY2hlY2tzdW0uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWVkIC0gaGV4IG9yIGJhc2U2NCBlbmNvZGVkIHNlZWQgdG8gYmUgdmFsaWRhdGVkXG4gICAqIEByZXR1cm5zIHtTZWVkfSAtIHZhbGlkYXRlZCBvYmplY3QgU2VlZFxuICAgKi9cbiAgZGVjb2RlU2VlZChzZWVkOiBzdHJpbmcpOiBTZWVkIHtcbiAgICAvLyB0cnkgdG8gZGVjb2RlXG4gICAgY29uc3QgZGVjb2RlZCA9IGJhc2UzMi5kZWNvZGUuYXNCeXRlcyhzZWVkKTtcblxuICAgIC8vIFNhbml0eSBjaGVja1xuICAgIGlmIChkZWNvZGVkLmxlbmd0aCAhPT0gQUxHT1JBTkRfU0VFRF9CWVRFX0xFTkdUSCkgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHNlZW1zIHRvIGJlIG1hbGZvcm1lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWVkOiBuZXcgVWludDhBcnJheShkZWNvZGVkLnNsaWNlKDAsIEFMR09SQU5EX1NFRURfQllURV9MRU5HVEggLSBBTEdPUkFORF9DSEVDS1NVTV9CWVRFX0xFTkdUSCkpLFxuICAgICAgY2hlY2tzdW06IG5ldyBVaW50OEFycmF5KGRlY29kZWQuc2xpY2UoU0VFRF9CWVRFU19MRU5HVEgsIEFMR09SQU5EX1NFRURfQllURV9MRU5HVEgpKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGlmIHNpZ25hdHVyZSBmb3IgbWVzc2FnZSBpcyB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHB1YiB7VWludDhBcnJheX0gcHVibGljIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZSB7VWludDhBcnJheX0gc2lnbmVkIG1lc3NhZ2VcbiAgICogQHBhcmFtIHNpZ25hdHVyZSB7QnVmZmVyfSBzaWduYXR1cmUgdG8gdmVyaWZ5XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHNpZ25hdHVyZSBpcyB2YWxpZC5cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZShtZXNzYWdlOiBVaW50OEFycmF5LCBzaWduYXR1cmU6IEJ1ZmZlciwgcHViOiBVaW50OEFycmF5KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5hY2wuc2lnbi5kZXRhY2hlZC52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgYW4gRWQyNTUxOSBwdWJsaWMga2V5IGludG8gYW4gYWxnb3JhbmQgYWRkcmVzcy5cbiAgICpcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBwayBUaGUgRWQyNTUxOSBwdWJsaWMga2V5LlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFsZ29yYW5kLm9yZy9kb2NzL2ZlYXR1cmVzL2FjY291bnRzLyN0cmFuc2Zvcm1hdGlvbi1wdWJsaWMta2V5LXRvLWFsZ29yYW5kLWFkZHJlc3NcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGFsZ29yYW5kIGFkZHJlc3MuXG4gICAqL1xuICBwdWJsaWNLZXlUb0FsZ29BZGRyZXNzKHBrOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gbmV3IEtleVBhaXIoeyBwdWI6IEJ1ZmZlci5mcm9tKHBrKS50b1N0cmluZygnaGV4JykgfSkuZ2V0QWRkcmVzcygpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSB1bnNpZ25lZCBhbGdvIHRyYW5zYWN0aW9uIGNhbiBiZSBkZWNvZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHR4biBUaGUgZW5jb2RlZCB1bnNpZ25lZCB0cmFuc2FjdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGNhbiBiZSBkZWNvZGVkLCBvdGhlcndpc2UgZmFsc2VcbiAgICovXG4gIHByb3RlY3RlZCBpc0RlY29kYWJsZVVuc2lnbmVkQWxnb1R4bih0eG46IFVpbnQ4QXJyYXkpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgYWxnb3Nkay5kZWNvZGVVbnNpZ25lZFRyYW5zYWN0aW9uKHR4bik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgc2lnbmVkIGFsZ28gdHJhbnNhY3Rpb24gY2FuIGJlIGRlY29kZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdHhuIFRoZSBlbmNvZGVkIHNpZ25lZCB0cmFuc2FjdGlvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGNhbiBiZSBkZWNvZGVkLCBvdGhlcndpc2UgZmFsc2VcbiAgICovXG4gIHByb3RlY3RlZCBpc0RlY29kYWJsZVNpZ25lZFRyYW5zYWN0aW9uKHR4bjogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBhbGdvc2RrLmRlY29kZVNpZ25lZFRyYW5zYWN0aW9uKHR4bik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyBhIHNpZ25lZCBvciB1bnNpZ25lZCBhbGdvIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBzdHJpbmd9IHR4bkJ5dGVzIFRoZSBlbmNvZGVkIHVuc2lnbmVkIG9yIHNpZ25lZCB0eG4uXG4gICAqIEByZXR1cm5zIHtFbmNvZGVkVHh9IFRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgZGVjb2RlQWxnb1R4bih0eG5CeXRlczogVWludDhBcnJheSB8IHN0cmluZyk6IEVuY29kZWRUeCB7XG4gICAgbGV0IGJ1ZmZlciA9XG4gICAgICB0eXBlb2YgdHhuQnl0ZXMgPT09ICdzdHJpbmcnXG4gICAgICAgID8gQnVmZmVyLmZyb20odHhuQnl0ZXMsIGFsbEhleENoYXJzKHR4bkJ5dGVzKSA/ICdoZXgnIDogJ2Jhc2U2NCcpXG4gICAgICAgIDogQnVmZmVyLmZyb20odHhuQnl0ZXMpO1xuXG4gICAgLy8gSW4gb3JkZXIgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBrZXlyZWcgdHJhbnNhY3Rpb25zIGVuY29kZWQgd2l0aFxuICAgIC8vIGZvcmtlZCBhbGdvc2RrIDEuMi4wIChodHRwczovL2dpdGh1Yi5jb20vQml0R28vYWxnb3Nkay1iaXRnbyksXG4gICAgLy8gdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIGlzIGV4dHJhY3RlZCBhbmQgcGFyc2VkIGZvbGxvd2luZyB0aGUgbGF0ZXN0IGFsZ29zZGtcbiAgICAvLyByZWxlYXNlIHN0YW5kYXJkLlxuICAgIC8vIFRoaXMgd2F5IHdlIGNhbiBkZWNvZGUgdHJhbnNhY3Rpb25zIHN1Y2Nlc3NmdWxseSBieSBzdGlsbCBtYWludGFpbmluZyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgIGNvbnN0IGRlY29kZWRUeCA9IGVuY29kaW5nLmRlY29kZShidWZmZXIpO1xuICAgIGlmIChcbiAgICAgIGRlY29kZWRUeC50eG4gJiZcbiAgICAgIGRlY29kZWRUeC50eG4udHlwZSA9PT0gJ2tleXJlZycgJiZcbiAgICAgIGRlY29kZWRUeC50eG4udm90ZWZzdCAmJlxuICAgICAgZGVjb2RlZFR4LnR4bi52b3RlbHN0ICYmXG4gICAgICBkZWNvZGVkVHgudHhuLnZvdGVrZFxuICAgICkge1xuICAgICAgZGVjb2RlZFR4LnR4bi52b3Rla2V5ID0gZGVjb2RlZFR4LnR4bi52b3Rla2V5IHx8IGRlY29kZWRUeC5tc2lnLnN1YnNpZ1swXS5waztcbiAgICAgIGRlY29kZWRUeC50eG4uc2Vsa2V5ID0gZGVjb2RlZFR4LnR4bi5zZWxrZXkgfHwgZGVjb2RlZFR4Lm1zaWcuc3Vic2lnWzBdLnBrO1xuICAgICAgYnVmZmVyID0gZGVjb2RlZFR4Lm1zaWcgfHwgZGVjb2RlZFR4LnNpZyA/IGVuY29kaW5nLmVuY29kZShkZWNvZGVkVHgpIDogZW5jb2RpbmcuZW5jb2RlKGRlY29kZWRUeC50eG4pO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy50cnlUb0RlY29kZVVuc2lnbmVkVHJhbnNhY3Rpb24oYnVmZmVyKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIElnbm9yZSBlcnJvciB0byB0cnkgZGlmZmVyZW50IGZvcm1hdFxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy50cnlUb0RlY29kZVNpZ25lZFRyYW5zYWN0aW9uKGJ1ZmZlcik7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ1RyYW5zYWN0aW9uIGNhbm5vdCBiZSBkZWNvZGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBkZWNvZGUgYSBzaWduZWQgQWxnbyB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gYnVmZmVyIHRoZSBlbmNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHsgRW5jb2RlZFR4IH0gdGhlIGRlY29kZWQgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIEB0aHJvd3MgZXJyb3IgaWYgaXQgaXMgbm90IGEgdmFsaWQgZW5jb2RlZCBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIHRyeVRvRGVjb2RlU2lnbmVkVHJhbnNhY3Rpb24oYnVmZmVyOiBCdWZmZXIpOiBFbmNvZGVkVHgge1xuICAgIC8vIFRPRE86IFJlcGxhY2Ugd2l0aFxuICAgIC8vIHJldHVybiBhbGdvc2RrLlRyYW5zYWN0aW9uLmZyb21fb2JqX2Zvcl9lbmNvZGluZyhhbGdvc2RrLmRlY29kZVNpZ25lZFRyYW5zYWN0aW9uKGJ1ZmZlcikudHhuKTtcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZC9qcy1hbGdvcmFuZC1zZGsvaXNzdWVzLzM2NFxuICAgIC8vIFwiLi4uc29tZSBwYXJ0cyBvZiB0aGUgY29kZWJhc2UgdHJlYXQgdGhlIG91dHB1dCBvZiBUcmFuc2FjdGlvbi5mcm9tX29ial9mb3JfZW5jb2RpbmcgYXMgRW5jb2RlZFRyYW5zYWN0aW9uLlxuICAgIC8vIFRoZXkgbmVlZCB0byBiZSBmaXhlZChvciB3ZSBhdCBsZWFzdCBuZWVkIHRvIG1ha2UgaXQgc28gVHJhbnNhY3Rpb24gY29uZm9ybXMgdG8gRW5jb2RlZFRyYW5zYWN0aW9uKS5cIlxuICAgIGNvbnN0IHR4ID0gYWxnb3Nkay5kZWNvZGVTaWduZWRUcmFuc2FjdGlvbihidWZmZXIpO1xuXG4gICAgY29uc3Qgc2lnbmVyczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBzaWduZWRCeTogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAodHgubXNpZyAmJiB0eC5tc2lnLnN1YnNpZykge1xuICAgICAgZm9yIChjb25zdCBzaWcgb2YgdHgubXNpZy5zdWJzaWcpIHtcbiAgICAgICAgY29uc3QgYWRkciA9IGFsZ29zZGsuZW5jb2RlQWRkcmVzcyhzaWcucGspO1xuICAgICAgICBzaWduZXJzLnB1c2goYWRkcik7XG4gICAgICAgIGlmIChzaWcucykge1xuICAgICAgICAgIHNpZ25lZEJ5LnB1c2goYWRkcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmF3VHJhbnNhY3Rpb246IG5ldyBVaW50OEFycmF5KGJ1ZmZlciksXG4gICAgICB0eG46IHR4LnR4bixcbiAgICAgIHNpZ25lZDogdHJ1ZSxcbiAgICAgIHNpZ25lcnM6IHNpZ25lcnMsXG4gICAgICBzaWduZWRCeTogc2lnbmVkQnksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gZGVjb2RlIGFuIHVuc2lnbmVkIEFsZ28gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIGJ1ZmZlciB0aGUgZW5jb2RlZCB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7RW5jb2RlZFR4fSB0aGUgZGVjb2RlZCB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgKiBAdGhyb3dzIGVycm9yIGlmIGl0IGlzIG5vdCBhIHZhbGlkIGVuY29kZWQgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIHRyeVRvRGVjb2RlVW5zaWduZWRUcmFuc2FjdGlvbihidWZmZXI6IEJ1ZmZlcik6IEVuY29kZWRUeCB7XG4gICAgY29uc3QgdHhuID0gYWxnb3Nkay5kZWNvZGVVbnNpZ25lZFRyYW5zYWN0aW9uKGJ1ZmZlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJhd1RyYW5zYWN0aW9uOiBuZXcgVWludDhBcnJheShidWZmZXIpLFxuICAgICAgdHhuLFxuICAgICAgc2lnbmVkOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgLypcbiAgICogZW5jb2RlT2JqIHRha2VzIGEgamF2YXNjcmlwdCBvYmplY3QgYW5kIHJldHVybnMgaXRzIG1zZ3BhY2sgZW5jb2RpbmdcbiAgICogTm90ZSB0aGF0IHRoZSBlbmNvZGluZyBzb3J0cyB0aGUgZmllbGRzIGFscGhhYmV0aWNhbGx5XG4gICAqXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgYW55Pn0gb2JqIGpzIG9ialxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gVWludDhBcnJheSBiaW5hcnkgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIGVuY29kZU9iaihvYmo6IFJlY29yZDxzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIGFueT4pOiBVaW50OEFycmF5IHtcbiAgICByZXR1cm4gYWxnb3Nkay5lbmNvZGVPYmoob2JqKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWNvZGVPYmogdGFrZXMgYSBVaW50OEFycmF5IGFuZCByZXR1cm5zIGl0cyBqYXZhc2NyaXB0IG9ialxuICAgKiBAcGFyYW0gbyAtIFVpbnQ4QXJyYXkgdG8gZGVjb2RlXG4gICAqIEByZXR1cm5zIG9iamVjdFxuICAgKi9cbiAgZGVjb2RlT2JqKG86IEFycmF5TGlrZTxudW1iZXI+KTogdW5rbm93biB7XG4gICAgcmV0dXJuIGFsZ29zZGsuZGVjb2RlT2JqKG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIHNlY3JldEtleVRvTW5lbW9uaWMgdGFrZXMgYW4gQWxnb3JhbnQgc2VjcmV0IGtleSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBtbmVtb25pY1xuICAgKlxuICAgKiBAcGFyYW0gc2sgLSBBbGdvcmFudCBzZWNyZXQga2V5XG4gICAqIEByZXR1cm4gU2VjcmV0IGtleSBpcyBhc3NvY2lhdGVkIG1uZW1vbmljXG4gICAqL1xuICBzZWNyZXRLZXlUb01uZW1vbmljKHNrOiBCdWZmZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNrVmFsaWQgPSBCdWZmZXIuZnJvbShzay50b1N0cmluZygnaGV4JykpO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkUHJpdmF0ZUtleShza1ZhbGlkLnRvU3RyaW5nKCdoZXgnKSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkS2V5KGBUaGUgc2VjcmV0IGtleTogJHtzay50b1N0cmluZygnaGV4Jyl9IGlzIGludmFsaWRgKTtcbiAgICB9XG4gICAgY29uc3Qgc2tVbml0OEFycmF5ID0gQnVmZmVyLmZyb20oc2spO1xuICAgIHJldHVybiBhbGdvc2RrLnNlY3JldEtleVRvTW5lbW9uaWMoc2tVbml0OEFycmF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBzZWVkRnJvbU1uZW1vbmljIGNvbnZlcnRzIGEgbW5lbW9uaWMgZ2VuZXJhdGVkIHVzaW5nIHRoaXMgbGlicmFyeSBpbnRvIHRoZSBzb3VyY2Uga2V5IHVzZWQgdG8gY3JlYXRlIGl0XG4gICAqIEl0IHJldHVybnMgYW4gZXJyb3IgaWYgdGhlIHBhc3NlZCBtbmVtb25pYyBoYXMgYW4gaW5jb3JyZWN0IGNoZWNrc3VtLCBpZiB0aGUgbnVtYmVyIG9mIHdvcmRzIGlzIHVuZXhwZWN0ZWQsIG9yIGlmIG9uZVxuICAgKiBvZiB0aGUgcGFzc2VkIHdvcmRzIGlzIG5vdCBmb3VuZCBpbiB0aGUgd29yZHMgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0gbW5lbW9uaWMgLSAyNSB3b3JkcyBtbmVtb25pY1xuICAgKiBAcmV0dXJucyAzMiBieXRlcyBsb25nIHNlZWRcbiAgICovXG4gIHNlZWRGcm9tTW5lbW9uaWMobW5lbW9uaWM6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBhbGdvc2RrLm1uZW1vbmljVG9NYXN0ZXJEZXJpdmF0aW9uS2V5KG1uZW1vbmljKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBrZXlQYWlyRnJvbVNlZWQgZ2VuZXJhdGVzIGFuIG9iamVjdCB3aXRoIHNlY3JldEtleSBhbmQgcHVibGljS2V5IHVzaW5nIHRoZSBhbGdvc2RrXG4gICAqIEBwYXJhbSBzZWVkIDMyIGJ5dGVzIGxvbmcgc2VlZFxuICAgKiBAcmV0dXJucyBLZXlQYWlyXG4gICAqL1xuICBrZXlQYWlyRnJvbVNlZWQoc2VlZDogVWludDhBcnJheSk6IEtleVBhaXIge1xuICAgIGNvbnN0IG1uID0gdGhpcy5tbmVtb25pY0Zyb21TZWVkKHNlZWQpO1xuICAgIGNvbnN0IGJhc2U2NFByaXZhdGVLZXkgPSBhbGdvc2RrLm1uZW1vbmljVG9TZWNyZXRLZXkobW4pLnNrO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUtleVBhaXIoYmFzZTY0UHJpdmF0ZUtleSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBuZXcgYEtleVBhaXJgIG9iamVjdCBmcm9tIHRoZSBnaXZlbiBwcml2YXRlIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGJhc2U2NFByaXZhdGVLZXkgNjQgYnl0ZXMgbG9uZyBwcml2YXRlS2V5XG4gICAqIEByZXR1cm5zIEtleVBhaXJcbiAgICovXG4gIHByb3RlY3RlZCBjcmVhdGVLZXlQYWlyKGJhc2U2NFByaXZhdGVLZXk6IFVpbnQ4QXJyYXkpOiBLZXlQYWlyIHtcbiAgICBjb25zdCBzayA9IGJhc2U2NFByaXZhdGVLZXkuc2xpY2UoMCwgMzIpO1xuICAgIHJldHVybiBuZXcgS2V5UGFpcih7IHBydjogQnVmZmVyLmZyb20oc2spLnRvU3RyaW5nKCdoZXgnKSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkZWNvZGVQcml2YXRlS2V5IGdlbmVyYXRlcyBhIHNlZWQgd2l0aCBhIG1uZW1vbmljIGFuZCB1c2luZyBhbGdvc2RrLlxuICAgKlxuICAgKiBAcGFyYW0gc2VlZCAzMiBieXRlcyBsb25nIHNlZWRcbiAgICogQHJldHVybnMgbW5lbW9uaWMgLSAyNSB3b3JkcyBtbmVtb25pYyAtIDI1IHdvcmRzIG1uZW1vbmljXG4gICAqL1xuICBwcm90ZWN0ZWQgbW5lbW9uaWNGcm9tU2VlZChzZWVkOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWxnb3Nkay5tYXN0ZXJEZXJpdmF0aW9uS2V5VG9NbmVtb25pYyhzZWVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGtleSB3aXRoIHRoZSBzdGVsbGFyLXNka1xuICAgKlxuICAgKiBAcGFyYW0gcHVibGljS2V5XG4gICAqIEByZXR1cm5zIGJvb2xlYW5cbiAgICovXG4gIHByb3RlY3RlZCBpc1ZhbGlkRWQyNTUxOVB1YmxpY0tleVN0ZWxsYXIocHVibGljS2V5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHRoZSBrZXkgd2l0aCB0aGUgc3RlbGxhci1zZGtcbiAgICpcbiAgICogQHBhcmFtIHB1YmxpY0tleVxuICAgKiBAcmV0dXJucyBCdWZmZXJcbiAgICovXG4gIHByb3RlY3RlZCBkZWNvZGVFZDI1NTE5UHVibGljS2V5U3RlbGxhcihwdWJsaWNLZXk6IHN0cmluZyk6IEJ1ZmZlciB7XG4gICAgcmV0dXJuIHN0ZWxsYXIuU3RyS2V5LmRlY29kZUVkMjU1MTlQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc3RlbGxhciBzZWVkIHRvIGFsZ29yYW5kIGVuY29kaW5nXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqIEByZXR1cm5zIHN0cmluZyB0aGUgZW5jb2RlZCBzZWVkXG4gICAqL1xuICBjb252ZXJ0RnJvbVN0ZWxsYXJTZWVkKHNlZWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFNlZWRFbmNvZGluZy5lbmNvZGUoc3RlbGxhci5TdHJLZXkuZGVjb2RlRWQyNTUxOVNlY3JldFNlZWQoc2VlZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYWRkcmVzcyBlbmNvZGVkIHdpdGggYWxnb3Nka1xuICAgKlxuICAgKiBAcGFyYW0gYWRkclxuICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICovXG4gIGVuY29kZUFkZHJlc3MoYWRkcjogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGFsZ29zZGsuZW5jb2RlQWRkcmVzcyhhZGRyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYWRkcmVzcyBkZWNvZGVkIHdpdGggYWxnb3Nka1xuICAgKlxuICAgKiBAcGFyYW0gYWRkclxuICAgKiBAcmV0dXJucyBBZGRyZXNzXG4gICAqL1xuICBkZWNvZGVBZGRyZXNzKGFkZHI6IHN0cmluZyk6IEFkZHJlc3Mge1xuICAgIHJldHVybiBhbGdvc2RrLmRlY29kZUFkZHJlc3MoYWRkcik7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYW4gYWRkcmVzcyBpbnRvIGFuIEFMR08gb25lXG4gICAqIElmIHRoZSBnaXZlbiBkYXRhIGlzIGEgU3RlbGxhciBhZGRyZXNzIG9yIHB1YmxpYyBrZXksIGl0IGlzIGNvbnZlcnRlZCB0byBBTEdPIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzT3JQdWJLZXkgYW4gQUxHTyBhZGRyZXNzLCBvciBhbiBTdGVsbGFyIGFkZHJlc3Mgb3IgcHVibGljIGtleVxuICAgKiBAcmV0dXJucyBhZGRyZXNzIGFsZ28gYWRkcmVzcyBzdHJpbmdcbiAgICovXG4gIHN0ZWxsYXJBZGRyZXNzVG9BbGdvQWRkcmVzcyhhZGRyZXNzT3JQdWJLZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gd2UgaGF2ZSBhbiBBbGdvcmFuZCBhZGRyZXNzXG4gICAgaWYgKHRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzc09yUHViS2V5KSkge1xuICAgICAgcmV0dXJuIGFkZHJlc3NPclB1YktleTtcbiAgICB9XG4gICAgLy8gd2UgaGF2ZSBhIHN0ZWxsYXIga2V5XG4gICAgaWYgKHRoaXMuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXlTdGVsbGFyKGFkZHJlc3NPclB1YktleSkpIHtcbiAgICAgIGNvbnN0IHN0ZWxsYXJQdWIgPSB0aGlzLmRlY29kZUVkMjU1MTlQdWJsaWNLZXlTdGVsbGFyKGFkZHJlc3NPclB1YktleSk7XG4gICAgICBjb25zdCBhbGdvQWRkcmVzcyA9IHRoaXMuZW5jb2RlQWRkcmVzcyhzdGVsbGFyUHViKTtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRBZGRyZXNzKGFsZ29BZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gYWxnb0FkZHJlc3M7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IFN0ZWxsYXIgYWRkcmVzcyB0byBhbiBBbGdvcmFuZCBhZGRyZXNzIHZpYSBwdWJrZXkuJyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciBhbiBBbGdvcmFuZCBhZGRyZXNzIG5vciBhIHN0ZWxsYXIgcHVia2V5LicpO1xuICB9XG5cbiAgLyoqXG4gICAqIG11bHRpc2lnQWRkcmVzcyB0YWtlcyBtdWx0aXNpZyBtZXRhZGF0YSAocHJlaW1hZ2UpIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGh1bWFuIHJlYWRhYmxlIEFsZ29yYW5kIGFkZHJlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uIG11dGxpc2lnIHZlcnNpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRocmVzaG9sZCBtdWx0aXNpZyB0aHJlc2hvbGRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWRkcnMgbGlzdCBvZiBBbGdvcmFuZCBhZGRyZXNzZXNcbiAgICogQHJldHVybnMge3N0cmluZ30gaHVtYW4gcmVhZGFibGUgQWxnb3JhbmQgYWRkcmVzcy5cbiAgICovXG4gIG11bHRpc2lnQWRkcmVzcyh2ZXJzaW9uOiBudW1iZXIsIHRocmVzaG9sZDogbnVtYmVyLCBhZGRyczogc3RyaW5nW10pOiBzdHJpbmcge1xuICAgIHJldHVybiBhbGdvc2RrLm11bHRpc2lnQWRkcmVzcyh7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgYWRkcnMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogZ2VuZXJhdGVBY2NvdW50IGdlbmVyYXRlcyB1biBhY2NvdW50IHdpdGggYSBzZWNyZXRLZXkgYW5kIGFuIGFkZHJlc3NcbiAgICpcbiAgICogRnVuY3Rpb24gaGFzIG5vdCBwYXJhbXNcbiAgICogQHJldHVybnMgQWNjb3VudFxuICAgKi9cbiAgZ2VuZXJhdGVBY2NvdW50KCk6IGFsZ29zZGsuQWNjb3VudCB7XG4gICAgcmV0dXJuIGFsZ29zZGsuZ2VuZXJhdGVBY2NvdW50KCk7XG4gIH1cblxuICBnZW5lcmF0ZUFjY291bnRGcm9tU2VlZChzZWVkOiBVaW50OEFycmF5KTogYWxnb3Nkay5BY2NvdW50IHtcbiAgICBjb25zdCBrZXlzID0gbmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQoc2VlZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZHI6IGFsZ29zZGsuZW5jb2RlQWRkcmVzcyhrZXlzLnB1YmxpY0tleSksXG4gICAgICBzazoga2V5cy5zZWNyZXRLZXksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgVHggSUQgZnJvbSBhbiBlbmNvZGVkIG11bHRpc2lnIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIFRoaXMgaXMgZG9uZSBiZWNhdXNlIG9mIGEgY2hhbmdlIG1hZGUgb24gdmVyc2lvbiAxLjEwLjEgb24gYWxnb3NkayBzbyBtZXRob2QgdHhJRCgpIG9ubHkgc3VwcG9ydHMgU2lnbmVkVHJhbnNhY3Rpb24gdHlwZS5cbiAgICogKGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZC9qcy1hbGdvcmFuZC1zZGsvYmxvYi9kZXZlbG9wL0NIQU5HRUxPRy5tZCMxMTAxKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHhCYXNlNjQgLSBlbmNvZGVkIGJhc2U2NCBtdWx0aXNpZyB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRyYW5zYWN0aW9uIElEXG4gICAqL1xuICBnZXRNdWx0aXNpZ1R4SUQodHhCYXNlNjQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgdHhCeXRlcyA9IEJ1ZmZlci5mcm9tKHR4QmFzZTY0LCAnYmFzZTY0Jyk7XG4gICAgY29uc3QgZGVjb2RlU2lnblR4ID0gYWxnb3Nkay5kZWNvZGVTaWduZWRUcmFuc2FjdGlvbih0eEJ5dGVzKTtcbiAgICBjb25zdCB3ZWxsRm9ybWVkRGVjb2RlZFNpZ25UeCA9IGRlY29kZVNpZ25UeC50eG4uZ2V0X29ial9mb3JfZW5jb2RpbmcoKTtcbiAgICBjb25zdCB0eEZvckVuY29kaW5nID0geyBtc2lnOiBkZWNvZGVTaWduVHgubXNpZywgdHhuOiB3ZWxsRm9ybWVkRGVjb2RlZFNpZ25UeCB9O1xuICAgIGNvbnN0IGVuX21zZyA9IGVuY29kaW5nLmVuY29kZSh0eEZvckVuY29kaW5nKTtcbiAgICBjb25zdCB0YWcgPSBCdWZmZXIuZnJvbShbODQsIDg4XSk7XG4gICAgY29uc3QgZ2ggPSBCdWZmZXIuZnJvbShjb25jYXRBcnJheXModGFnLCBlbl9tc2cpKTtcbiAgICBjb25zdCBoYXNoID0gQnVmZmVyLmZyb20oYWxnb05hY2wuZ2VuZXJpY0hhc2goZ2gpKTtcbiAgICByZXR1cm4gYmFzZTMyLmVuY29kZShoYXNoKS5zbGljZSgwLCBBTEdPUkFORF9UUkFOU0FDVElPTl9MRU5HVEgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB0cmFuc2FjdGlvbiBkYXRhIGlzIHRvIGVuYWJsZSBvciBkaXNhYmxlIGEgdG9rZW5cbiAgICogQHBhcmFtIGFtb3VudCB0aGUgYW1vdW50IGluIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBmcm9tIHRoZSBvcmlnaW5hdGVkIGFkZHJlc3NcbiAgICogQHBhcmFtIHRvIHRoZSB0YXJnZXQgYWRkcmVzc1xuICAgKiBAcGFyYW0gY2xvc2VSZW1haW5kZXJUbyAob3B0aW9uYWwpIGFkZHJlc3MgdG8gc2VuZCByZW1haW5pbmcgdW5pdHMgaW4gb3JpZ2luYXRlZCBhZGRyZXNzXG4gICAqIEByZXR1cm5zICdlbmFibGVUb2tlbicgb3IgJ2Rpc2FibGVUb2tlbidcbiAgICovXG4gIGdldFRva2VuVHhUeXBlKGFtb3VudDogc3RyaW5nLCBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcsIGNsb3NlUmVtYWluZGVyVG8/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCB0eXBlID0gJ3RyYW5zZmVyVG9rZW4nO1xuICAgIGlmIChhbW91bnQgPT09ICcwJyAmJiBmcm9tID09PSB0bykge1xuICAgICAgdHlwZSA9ICFjbG9zZVJlbWFpbmRlclRvID8gJ2VuYWJsZVRva2VuJyA6ICdkaXNhYmxlVG9rZW4nO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBpZiB0aGUga2V5IGlzIGEgdmFsaWQgYmFzZTY0IHN0cmluZ1xuICAgKiBAcGFyYW0ga2V5IHRoZSBrZXkgdG8gdmFsaWRhdGVcbiAgICovXG4gIHZhbGlkYXRlQmFzZTY0KGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFrZXkgfHwgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYXNlNjQgc3RyaW5nJyk7XG4gICAgfVxuICAgIGNvbnN0IGJhc2U2NFJlZ0V4cCA9XG4gICAgICAvXig/OlthLXpBLVowLTkrXFwvXXs0fSkqKD86fCg/OlthLXpBLVowLTkrXFwvXXszfT0pfCg/OlthLXpBLVowLTkrXFwvXXsyfT09KXwoPzpbYS16QS1aMC05K1xcL117MX09PT0pKSQvO1xuICAgIGlmICghYmFzZTY0UmVnRXhwLnRlc3Qoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhc2U2NCBzdHJpbmcnKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgdXRpbHMgPSBuZXcgVXRpbHMoKTtcblxuZXhwb3J0IGRlZmF1bHQgdXRpbHM7XG4iXX0=