"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Algo = void 0;
/**
 * @prettier
 */
const utxolib = __importStar(require("@bitgo/utxo-lib"));
const _ = __importStar(require("lodash"));
const seedValidator_1 = require("./seedValidator");
const statics_1 = require("@bitgo/statics");
const AlgoLib = __importStar(require("./lib"));
const sdk_core_1 = require("@bitgo/sdk-core");
const stellar_sdk_1 = __importDefault(require("stellar-sdk"));
const SUPPORTED_ADDRESS_VERSION = 1;
const MSIG_THRESHOLD = 2; // m in m-of-n
class Algo extends sdk_core_1.BaseCoin {
    constructor(bitgo) {
        super(bitgo);
        this.ENABLE_TOKEN = 'enabletoken';
        this.DISABLE_TOKEN = 'disabletoken';
    }
    static createInstance(bitgo) {
        return new Algo(bitgo);
    }
    getChain() {
        return 'algo';
    }
    getBaseChain() {
        return 'algo';
    }
    getFamily() {
        return 'algo';
    }
    getFullName() {
        return 'Algorand';
    }
    getBaseFactor() {
        return 1e6;
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
    /**
     * Algorand supports account consolidations. These are transfers from the receive addresses
     * to the main address.
     */
    allowsAccountConsolidations() {
        return true;
    }
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? new AlgoLib.KeyPair({ seed }) : new AlgoLib.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keyPair.getAddress(),
            prv: AlgoLib.algoUtils.encodeSeed(Buffer.from(keyPair.getSigningKey())),
        };
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        return AlgoLib.algoUtils.isValidAddress(pub);
    }
    /**
     * Return boolean indicating whether input is valid seed for the coin
     * In Algorand, when the private key is encoded as base32 string only the first 32 bytes are taken,
     * so the encoded value is actually the seed
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv) {
        return AlgoLib.algoUtils.isValidSeed(prv);
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address) {
        return AlgoLib.algoUtils.isValidAddress(address);
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     */
    async signMessage(key, message) {
        const algoKeypair = new AlgoLib.KeyPair({ prv: key.prv });
        if (Buffer.isBuffer(message)) {
            message = message.toString('base64');
        }
        return Buffer.from(algoKeypair.signMessage(message));
    }
    /**
     * Specifies what key we will need for signing` - Algorand needs the backup, bitgo pubs.
     */
    keyIdsForSigning() {
        return [sdk_core_1.KeyIndices.USER, sdk_core_1.KeyIndices.BACKUP, sdk_core_1.KeyIndices.BITGO];
    }
    getTokenNameById(tokenId) {
        const tokenNames = statics_1.coins.filter((coin) => coin.family === 'algo' && coin.isToken).map(({ name }) => name);
        return tokenNames.find((tokenName) => tokenName.split('-')[1] === `${tokenId}`) || 'AlgoToken unknown';
    }
    /**
     * Explain/parse transaction
     * @param params
     */
    async explainTransaction(params) {
        const txHex = params.txHex || (params.halfSigned && params.halfSigned.txHex);
        if (!txHex || !params.feeInfo) {
            throw new Error('missing explain tx parameters');
        }
        const factory = this.getBuilder();
        const txBuilder = factory.from(txHex);
        const tx = await txBuilder.build();
        const txJson = tx.toJson();
        if (tx.type === sdk_core_1.TransactionType.Send) {
            const outputs = [
                {
                    address: txJson.to,
                    amount: txJson.amount,
                    memo: txJson.note,
                },
            ];
            const operations = [];
            const isTokenTx = this.isTokenTx(txJson.type);
            if (isTokenTx) {
                const type = AlgoLib.algoUtils.getTokenTxType(txJson.amount, txJson.from, txJson.to, txJson.closeRemainderTo);
                operations.push({
                    type: type,
                    coin: this.getTokenNameById(txJson.tokenId),
                });
            }
            const displayOrder = [
                'id',
                'outputAmount',
                'changeAmount',
                'outputs',
                'changeOutputs',
                'fee',
                'memo',
                'type',
                'operations',
            ];
            const explanationResult = {
                displayOrder,
                id: txJson.id,
                outputAmount: txJson.amount.toString(),
                changeAmount: '0',
                outputs,
                changeOutputs: [],
                fee: txJson.fee,
                memo: txJson.note,
                type: tx.type.toString(),
                operations,
            };
            if (txJson.tokenId) {
                explanationResult.tokenId = txJson.tokenId;
            }
            return explanationResult;
        }
        if (tx.type === sdk_core_1.TransactionType.WalletInitialization) {
            const displayOrder = [
                'id',
                'fee',
                'memo',
                'type',
                'voteKey',
                'selectionKey',
                'voteFirst',
                'voteLast',
                'voteKeyDilution',
            ];
            return {
                displayOrder,
                id: txJson.id,
                outputAmount: '0',
                changeAmount: '0',
                outputs: [],
                changeOutputs: [],
                fee: txJson.fee,
                memo: txJson.note,
                type: tx.type,
                voteKey: txJson.voteKey,
                selectionKey: txJson.selectionKey,
                voteFirst: txJson.voteFirst,
                voteLast: txJson.voteLast,
                voteKeyDilution: txJson.voteKeyDilution,
            };
        }
    }
    /**
     * returns if a tx is a token tx
     * @param type {string} - tx type
     * @returns true if it's a token tx
     */
    isTokenTx(type) {
        return type === 'axfer';
    }
    /**
     * Check if a seed is a valid stellar seed
     *
     * @param {String} seed the seed to check
     * @returns {Boolean} true if the input is a Stellar seed
     */
    isStellarSeed(seed) {
        return seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM);
    }
    /**
     * Convert a stellar seed to an algo seed
     *
     * @param {String} seed the seed to convert
     * @returns {Boolean | null} seed in algo encoding
     */
    convertFromStellarSeed(seed) {
        // assume this is a trust custodial seed if its a valid ed25519 prv
        if (!this.isStellarSeed(seed) || seedValidator_1.SeedValidator.hasCompetingSeedFormats(seed)) {
            return null;
        }
        if (seedValidator_1.SeedValidator.isValidEd25519SeedForCoin(seed, statics_1.CoinFamily.XLM)) {
            return AlgoLib.algoUtils.convertFromStellarSeed(seed);
        }
        return null;
    }
    verifySignTransactionParams(params) {
        const prv = params.prv;
        const addressVersion = params.txPrebuild.addressVersion;
        let isHalfSigned = false;
        // it's possible this tx was already signed - take the halfSigned
        // txHex if it is
        let txHex = params.txPrebuild.txHex;
        if (params.txPrebuild.halfSigned) {
            isHalfSigned = true;
            txHex = params.txPrebuild.halfSigned.txHex;
        }
        if (_.isUndefined(txHex)) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isString(txHex)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txHex}`);
        }
        if (_.isUndefined(prv)) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        if (!_.has(params.txPrebuild, 'keys')) {
            throw new Error('missing public keys parameter to sign transaction');
        }
        if (!_.isNumber(addressVersion)) {
            throw new Error('missing addressVersion parameter to sign transaction');
        }
        const signers = params.txPrebuild.keys.map((key) => {
            // if we are receiving addresses do not try to convert them
            if (!AlgoLib.algoUtils.isValidAddress(key)) {
                return AlgoLib.algoUtils.publicKeyToAlgoAddress(AlgoLib.algoUtils.toUint8Array(key));
            }
            return key;
        });
        // TODO(https://bitgoinc.atlassian.net/browse/STLX-6067): fix the number of signers using
        // should be similar to other coins implementation
        // If we have a number with digits to eliminate them without taking any rounding criteria.
        const numberSigners = Math.trunc(signers.length / 2) + 1;
        return { txHex, addressVersion, signers, prv, isHalfSigned, numberSigners };
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<SignedTransaction>}
     */
    async signTransaction(params) {
        const { txHex, signers, prv, isHalfSigned, numberSigners } = this.verifySignTransactionParams(params);
        const factory = this.getBuilder();
        const txBuilder = factory.from(txHex);
        txBuilder.numberOfRequiredSigners(numberSigners);
        txBuilder.sign({ key: prv });
        txBuilder.setSigners(signers);
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid transaction');
        }
        const signedTxHex = Buffer.from(transaction.toBroadcastFormat()).toString('base64');
        if (numberSigners === 1) {
            return { txHex: signedTxHex };
        }
        else if (isHalfSigned) {
            return { txHex: signedTxHex };
        }
        else {
            return { halfSigned: { txHex: signedTxHex } };
        }
    }
    async parseTransaction(params) {
        return {};
    }
    /**
     * Check if address can be used to send funds.
     *
     * @param params.address address to validate
     * @param params.keychains public keys to generate the wallet
     */
    async isWalletAddress(params) {
        const { address, keychains, coinSpecific: { bitgoPubKey }, } = params;
        if (!this.isValidAddress(address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (!keychains) {
            throw new Error('missing required param keychains');
        }
        const effectiveKeychain = bitgoPubKey ? keychains.slice(0, -1).concat([{ pub: bitgoPubKey }]) : keychains;
        const pubKeys = effectiveKeychain.map((key) => this.stellarAddressToAlgoAddress(key.pub));
        if (!pubKeys.every((pubKey) => this.isValidPub(pubKey))) {
            throw new sdk_core_1.InvalidKey('invalid public key');
        }
        const rootAddress = AlgoLib.algoUtils.multisigAddress(SUPPORTED_ADDRESS_VERSION, MSIG_THRESHOLD, pubKeys);
        return rootAddress === address;
    }
    async verifyTransaction(params) {
        return true;
    }
    /** @inheritDoc */
    deriveKeyWithSeed({ key, seed }) {
        const derivationPathInput = utxolib.crypto.hash256(Buffer.from(seed, 'utf8')).toString('hex');
        const derivationPathParts = [
            999999,
            parseInt(derivationPathInput.slice(0, 7), 16),
            parseInt(derivationPathInput.slice(7, 14), 16),
        ];
        const derivationPath = 'm/' + derivationPathParts.map((part) => `${part}'`).join('/');
        const derivedKey = sdk_core_1.Ed25519KeyDeriver.derivePath(derivationPath, key).key;
        const keypair = new AlgoLib.KeyPair({ seed: derivedKey });
        return {
            key: keypair.getAddress(),
            derivationPath,
        };
    }
    decodeTx(txn) {
        return AlgoLib.algoUtils.decodeAlgoTxn(txn);
    }
    getAddressFromPublicKey(pubKey) {
        return AlgoLib.algoUtils.publicKeyToAlgoAddress(pubKey);
    }
    /**
     * Gets config for how token enablements work for this coin
     * @returns
     *    requiresTokenEnablement: True if tokens need to be enabled for this coin
     *    supportsMultipleTokenEnablements: True if multiple tokens can be enabled in one transaction
     */
    getTokenEnablementConfig() {
        return {
            requiresTokenEnablement: true,
            supportsMultipleTokenEnablements: false,
        };
    }
    /**
     * Stellar and Algorand both use keys on the ed25519 curve, but use different encodings.
     * As the HSM doesn't have explicit support to create Algorand addresses, we use the Stellar
     * keys and re-encode them to the Algorand encoding.
     *
     * This method should only be used when creating Algorand custodial wallets reusing Stellar keys.
     *
     * @param {string} addressOrPubKey a Stellar pubkey or Algorand address
     * @return {*}
     */
    stellarAddressToAlgoAddress(addressOrPubKey) {
        if (this.isValidAddress(addressOrPubKey)) {
            // we have an Algorand address
            return addressOrPubKey;
        }
        if (!stellar_sdk_1.default.StrKey.isValidEd25519PublicKey(addressOrPubKey)) {
            throw new sdk_core_1.UnexpectedAddressError('Neither an Algorand address nor a stellar pubkey.');
        }
        // we have a stellar key
        const stellarPub = stellar_sdk_1.default.StrKey.decodeEd25519PublicKey(addressOrPubKey);
        const algoAddress = AlgoLib.algoUtils.encodeAddress(stellarPub);
        if (!this.isValidAddress(algoAddress)) {
            throw new sdk_core_1.UnexpectedAddressError('Cannot convert Stellar address to an Algorand address via pubkey.');
        }
        return algoAddress;
    }
    getBuilder() {
        return new AlgoLib.TransactionBuilderFactory(statics_1.coins.get(this.getBaseChain()));
    }
}
exports.Algo = Algo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxnby5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hbGdvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7R0FFRztBQUNILHlEQUEyQztBQUMzQywwQ0FBNEI7QUFDNUIsbURBQWdEO0FBQ2hELDRDQUFtRDtBQUNuRCwrQ0FBaUM7QUFDakMsOENBb0J5QjtBQUN6Qiw4REFBa0M7QUFFbEMsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLENBQUM7QUFDcEMsTUFBTSxjQUFjLEdBQUcsQ0FBQyxDQUFDLENBQUMsY0FBYztBQTJGeEMsTUFBYSxJQUFLLFNBQVEsbUJBQVE7SUFJaEMsWUFBWSxLQUFnQjtRQUMxQixLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFKTixpQkFBWSxHQUF3QixhQUFhLENBQUM7UUFDbEQsa0JBQWEsR0FBd0IsY0FBYyxDQUFDO0lBSTdELENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCO1FBQ3BDLE9BQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsWUFBWTtRQUNWLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxTQUFTO1FBQ1AsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVELFdBQVc7UUFDVCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBRUQsYUFBYTtRQUNYLE9BQU8sR0FBRyxDQUFDO0lBQ2IsQ0FBQztJQUVEOzs7T0FHRztJQUNILHdCQUF3QjtRQUN0QixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7O09BR0c7SUFDSCwyQkFBMkI7UUFDekIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxlQUFlLENBQUMsSUFBYTtRQUMzQixNQUFNLE9BQU8sR0FBRyxJQUFJ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QUFFO1lBQ3JDLE1BQU0sSUFBSSxpQ0FBc0IsQ0FBQyxtRUFBbUUsQ0FBQyxDQUFDO1NBQ3ZHO1FBRUQsT0FBTyxXQUFXLENBQUM7SUFDckIsQ0FBQztJQUVPLFVBQVU7UUFDaEIsT0FBTyxJQUFJLE9BQU8sQ0FBQyx5QkFBeUIsQ0FBQyxlQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDL0UsQ0FBQztDQUNGO0FBdmNELG9CQXVjQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHByZXR0aWVyXG4gKi9cbmltcG9ydCAqIGFzIHV0eG9saWIgZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IFNlZWRWYWxpZGF0b3IgfSBmcm9tICcuL3NlZWRWYWxpZGF0b3InO1xuaW1wb3J0IHsgY29pbnMsIENvaW5GYW1pbHkgfSBmcm9tICdAYml0Z28vc3RhdGljcyc7XG5pbXBvcnQgKiBhcyBBbGdvTGliIGZyb20gJy4vbGliJztcbmltcG9ydCB7XG4gIEFkZHJlc3NDb2luU3BlY2lmaWMsXG4gIEJhc2VDb2luLFxuICBCaXRHb0Jhc2UsXG4gIEVkMjU1MTlLZXlEZXJpdmVyLFxuICBJbnZhbGlkQWRkcmVzc0Vycm9yLFxuICBJbnZhbGlkS2V5LFxuICBLZXlJbmRpY2VzLFxuICBLZXlQYWlyLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGFzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zLFxuICBUb2tlbk1hbmFnZW1lbnRUeXBlLFxuICBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uLFxuICBUcmFuc2FjdGlvblJlY2lwaWVudCxcbiAgVHJhbnNhY3Rpb25UeXBlLFxuICBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yLFxuICBWZXJpZnlBZGRyZXNzT3B0aW9ucyxcbiAgVmVyaWZ5VHJhbnNhY3Rpb25PcHRpb25zLFxufSBmcm9tICdAYml0Z28vc2RrLWNvcmUnO1xuaW1wb3J0IHN0ZWxsYXIgZnJvbSAnc3RlbGxhci1zZGsnO1xuXG5jb25zdCBTVVBQT1JURURfQUREUkVTU19WRVJTSU9OID0gMTtcbmNvbnN0IE1TSUdfVEhSRVNIT0xEID0gMjsgLy8gbSBpbiBtLW9mLW5cblxuZXhwb3J0IGludGVyZmFjZSBBbGdvQWRkcmVzc0NvaW5TcGVjaWZpY3MgZXh0ZW5kcyBBZGRyZXNzQ29pblNwZWNpZmljIHtcbiAgcm9vdEFkZHJlc3M6IHN0cmluZztcbiAgYml0Z29LZXk6IHN0cmluZztcbiAgYml0Z29QdWJLZXk/OiBzdHJpbmc7XG4gIGFkZHJlc3NWZXJzaW9uOiBudW1iZXI7XG4gIHRocmVzaG9sZDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZlcmlmeUFsZ29BZGRyZXNzT3B0aW9ucyBleHRlbmRzIFZlcmlmeUFkZHJlc3NPcHRpb25zIHtcbiAgY2hhaW46IG51bWJlcjtcbiAgaW5kZXg6IG51bWJlcjtcbiAgY29pbjogc3RyaW5nO1xuICB3YWxsZXQ6IHN0cmluZztcbiAgY29pblNwZWNpZmljOiBBbGdvQWRkcmVzc0NvaW5TcGVjaWZpY3M7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWxnb1RyYW5zYWN0aW9uRXhwbGFuYXRpb24gZXh0ZW5kcyBUcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHtcbiAgbWVtbz86IHN0cmluZztcbiAgdHlwZT86IHN0cmluZyB8IG51bWJlcjtcbiAgdm90ZUtleT86IHN0cmluZztcbiAgc2VsZWN0aW9uS2V5Pzogc3RyaW5nO1xuICB2b3RlRmlyc3Q/OiBudW1iZXI7XG4gIHZvdGVMYXN0PzogbnVtYmVyO1xuICB2b3RlS2V5RGlsdXRpb24/OiBudW1iZXI7XG4gIHRva2VuSWQ/OiBudW1iZXI7XG4gIG9wZXJhdGlvbnM/OiBUcmFuc2FjdGlvbk9wZXJhdGlvbltdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zYWN0aW9uT3BlcmF0aW9uIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjb2luOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBleHRlbmRzIEJhc2VTaWduVHJhbnNhY3Rpb25PcHRpb25zIHtcbiAgdHhQcmVidWlsZDogVHJhbnNhY3Rpb25QcmVidWlsZDtcbiAgcHJ2OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25QcmVidWlsZCB7XG4gIHR4SGV4OiBzdHJpbmc7XG4gIGhhbGZTaWduZWQ/OiB7XG4gICAgdHhIZXg6IHN0cmluZztcbiAgfTtcbiAgdHhJbmZvOiB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHRvOiBzdHJpbmc7XG4gICAgYW1vdW50OiBzdHJpbmc7XG4gICAgZmVlOiBudW1iZXI7XG4gICAgZmlyc3RSb3VuZDogbnVtYmVyO1xuICAgIGxhc3RSb3VuZDogbnVtYmVyO1xuICAgIGdlbmVzaXNJRDogc3RyaW5nO1xuICAgIGdlbmVzaXNIYXNoOiBzdHJpbmc7XG4gICAgbm90ZT86IHN0cmluZztcbiAgfTtcbiAga2V5czogc3RyaW5nW107XG4gIGFkZHJlc3NWZXJzaW9uOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVsbHlTaWduZWRUcmFuc2FjdGlvbiB7XG4gIHR4SGV4OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGFsZlNpZ25lZFRyYW5zYWN0aW9uIHtcbiAgaGFsZlNpZ25lZDoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25GZWUge1xuICBmZWU6IHN0cmluZztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4SGV4Pzogc3RyaW5nO1xuICBoYWxmU2lnbmVkPzoge1xuICAgIHR4SGV4OiBzdHJpbmc7XG4gIH07XG4gIHB1YmxpY0tleXM/OiBzdHJpbmdbXTtcbiAgZmVlSW5mbzogVHJhbnNhY3Rpb25GZWU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZpZWRUcmFuc2FjdGlvblBhcmFtZXRlcnMge1xuICB0eEhleDogc3RyaW5nO1xuICBhZGRyZXNzVmVyc2lvbjogbnVtYmVyO1xuICBzaWduZXJzOiBzdHJpbmdbXTtcbiAgcHJ2OiBzdHJpbmc7XG4gIGlzSGFsZlNpZ25lZDogYm9vbGVhbjtcbiAgbnVtYmVyU2lnbmVyczogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQWxnbyBleHRlbmRzIEJhc2VDb2luIHtcbiAgcmVhZG9ubHkgRU5BQkxFX1RPS0VOOiBUb2tlbk1hbmFnZW1lbnRUeXBlID0gJ2VuYWJsZXRva2VuJztcbiAgcmVhZG9ubHkgRElTQUJMRV9UT0tFTjogVG9rZW5NYW5hZ2VtZW50VHlwZSA9ICdkaXNhYmxldG9rZW4nO1xuXG4gIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UpIHtcbiAgICBzdXBlcihiaXRnbyk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSk6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IEFsZ28oYml0Z28pO1xuICB9XG5cbiAgZ2V0Q2hhaW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ2FsZ28nO1xuICB9XG5cbiAgZ2V0QmFzZUNoYWluKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdhbGdvJztcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnYWxnbyc7XG4gIH1cblxuICBnZXRGdWxsTmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnQWxnb3JhbmQnO1xuICB9XG5cbiAgZ2V0QmFzZUZhY3RvcigpOiBudW1iZXIgfCBzdHJpbmcge1xuICAgIHJldHVybiAxZTY7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyBmb3Igc2VuZGluZyB2YWx1ZSBvZiAwXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9rYXkgdG8gc2VuZCAwIHZhbHVlLCBmYWxzZSBvdGhlcndpc2VcbiAgICovXG4gIHZhbHVlbGVzc1RyYW5zZmVyQWxsb3dlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGdvcmFuZCBzdXBwb3J0cyBhY2NvdW50IGNvbnNvbGlkYXRpb25zLiBUaGVzZSBhcmUgdHJhbnNmZXJzIGZyb20gdGhlIHJlY2VpdmUgYWRkcmVzc2VzXG4gICAqIHRvIHRoZSBtYWluIGFkZHJlc3MuXG4gICAqL1xuICBhbGxvd3NBY2NvdW50Q29uc29saWRhdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZWQyNTUxOSBrZXkgcGFpclxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViLCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlZWQgPyBuZXcgQWxnb0xpYi5LZXlQYWlyKHsgc2VlZCB9KSA6IG5ldyBBbGdvTGliLktleVBhaXIoKTtcbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRLZXlzKCk7XG4gICAgaWYgKCFrZXlzLnBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBydiBpbiBrZXkgZ2VuZXJhdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBrZXlQYWlyLmdldEFkZHJlc3MoKSxcbiAgICAgIHBydjogQWxnb0xpYi5hbGdvVXRpbHMuZW5jb2RlU2VlZChCdWZmZXIuZnJvbShrZXlQYWlyLmdldFNpZ25pbmdLZXkoKSkpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEFsZ29MaWIuYWxnb1V0aWxzLmlzVmFsaWRBZGRyZXNzKHB1Yik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHNlZWQgZm9yIHRoZSBjb2luXG4gICAqIEluIEFsZ29yYW5kLCB3aGVuIHRoZSBwcml2YXRlIGtleSBpcyBlbmNvZGVkIGFzIGJhc2UzMiBzdHJpbmcgb25seSB0aGUgZmlyc3QgMzIgYnl0ZXMgYXJlIHRha2VuLFxuICAgKiBzbyB0aGUgZW5jb2RlZCB2YWx1ZSBpcyBhY3R1YWxseSB0aGUgc2VlZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJ2IHRoZSBwcnYgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHJ2KHBydjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIEFsZ29MaWIuYWxnb1V0aWxzLmlzVmFsaWRTZWVkKHBydik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gQWxnb0xpYi5hbGdvVXRpbHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBtZXNzYWdlIHdpdGggcHJpdmF0ZSBrZXlcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgKi9cbiAgYXN5bmMgc2lnbk1lc3NhZ2Uoa2V5OiBLZXlQYWlyLCBtZXNzYWdlOiBzdHJpbmcgfCBCdWZmZXIpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICAgIGNvbnN0IGFsZ29LZXlwYWlyID0gbmV3IEFsZ29MaWIuS2V5UGFpcih7IHBydjoga2V5LnBydiB9KTtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpKSB7XG4gICAgICBtZXNzYWdlID0gbWVzc2FnZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShhbGdvS2V5cGFpci5zaWduTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cblxuICAvKipcbiAgICogU3BlY2lmaWVzIHdoYXQga2V5IHdlIHdpbGwgbmVlZCBmb3Igc2lnbmluZ2AgLSBBbGdvcmFuZCBuZWVkcyB0aGUgYmFja3VwLCBiaXRnbyBwdWJzLlxuICAgKi9cbiAga2V5SWRzRm9yU2lnbmluZygpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIFtLZXlJbmRpY2VzLlVTRVIsIEtleUluZGljZXMuQkFDS1VQLCBLZXlJbmRpY2VzLkJJVEdPXTtcbiAgfVxuXG4gIGdldFRva2VuTmFtZUJ5SWQodG9rZW5JZDogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCB0b2tlbk5hbWVzID0gY29pbnMuZmlsdGVyKChjb2luKSA9PiBjb2luLmZhbWlseSA9PT0gJ2FsZ28nICYmIGNvaW4uaXNUb2tlbikubWFwKCh7IG5hbWUgfSkgPT4gbmFtZSEpO1xuICAgIHJldHVybiB0b2tlbk5hbWVzLmZpbmQoKHRva2VuTmFtZSkgPT4gdG9rZW5OYW1lLnNwbGl0KCctJylbMV0gPT09IGAke3Rva2VuSWR9YCkgfHwgJ0FsZ29Ub2tlbiB1bmtub3duJztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIGFzeW5jIGV4cGxhaW5UcmFuc2FjdGlvbihwYXJhbXM6IEV4cGxhaW5UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPEFsZ29UcmFuc2FjdGlvbkV4cGxhbmF0aW9uIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3QgdHhIZXggPSBwYXJhbXMudHhIZXggfHwgKHBhcmFtcy5oYWxmU2lnbmVkICYmIHBhcmFtcy5oYWxmU2lnbmVkLnR4SGV4KTtcbiAgICBpZiAoIXR4SGV4IHx8ICFwYXJhbXMuZmVlSW5mbykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGV4cGxhaW4gdHggcGFyYW1ldGVycycpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcblxuICAgIGNvbnN0IHR4QnVpbGRlciA9IGZhY3RvcnkuZnJvbSh0eEhleCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBjb25zdCB0eEpzb24gPSB0eC50b0pzb24oKTtcblxuICAgIGlmICh0eC50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU2VuZCkge1xuICAgICAgY29uc3Qgb3V0cHV0czogVHJhbnNhY3Rpb25SZWNpcGllbnRbXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGFkZHJlc3M6IHR4SnNvbi50byxcbiAgICAgICAgICBhbW91bnQ6IHR4SnNvbi5hbW91bnQsXG4gICAgICAgICAgbWVtbzogdHhKc29uLm5vdGUsXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uczogVHJhbnNhY3Rpb25PcGVyYXRpb25bXSA9IFtdO1xuXG4gICAgICBjb25zdCBpc1Rva2VuVHggPSB0aGlzLmlzVG9rZW5UeCh0eEpzb24udHlwZSk7XG4gICAgICBpZiAoaXNUb2tlblR4KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBBbGdvTGliLmFsZ29VdGlscy5nZXRUb2tlblR4VHlwZSh0eEpzb24uYW1vdW50LCB0eEpzb24uZnJvbSwgdHhKc29uLnRvLCB0eEpzb24uY2xvc2VSZW1haW5kZXJUbyk7XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBjb2luOiB0aGlzLmdldFRva2VuTmFtZUJ5SWQodHhKc29uLnRva2VuSWQpLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlzcGxheU9yZGVyID0gW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnb3V0cHV0QW1vdW50JyxcbiAgICAgICAgJ2NoYW5nZUFtb3VudCcsXG4gICAgICAgICdvdXRwdXRzJyxcbiAgICAgICAgJ2NoYW5nZU91dHB1dHMnLFxuICAgICAgICAnZmVlJyxcbiAgICAgICAgJ21lbW8nLFxuICAgICAgICAndHlwZScsXG4gICAgICAgICdvcGVyYXRpb25zJyxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IGV4cGxhbmF0aW9uUmVzdWx0OiBBbGdvVHJhbnNhY3Rpb25FeHBsYW5hdGlvbiA9IHtcbiAgICAgICAgZGlzcGxheU9yZGVyLFxuICAgICAgICBpZDogdHhKc29uLmlkLFxuICAgICAgICBvdXRwdXRBbW91bnQ6IHR4SnNvbi5hbW91bnQudG9TdHJpbmcoKSxcbiAgICAgICAgY2hhbmdlQW1vdW50OiAnMCcsXG4gICAgICAgIG91dHB1dHMsXG4gICAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgICBmZWU6IHR4SnNvbi5mZWUsXG4gICAgICAgIG1lbW86IHR4SnNvbi5ub3RlLFxuICAgICAgICB0eXBlOiB0eC50eXBlLnRvU3RyaW5nKCksXG4gICAgICAgIG9wZXJhdGlvbnMsXG4gICAgICB9O1xuXG4gICAgICBpZiAodHhKc29uLnRva2VuSWQpIHtcbiAgICAgICAgZXhwbGFuYXRpb25SZXN1bHQudG9rZW5JZCA9IHR4SnNvbi50b2tlbklkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwbGFuYXRpb25SZXN1bHQ7XG4gICAgfVxuXG4gICAgaWYgKHR4LnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5XYWxsZXRJbml0aWFsaXphdGlvbikge1xuICAgICAgY29uc3QgZGlzcGxheU9yZGVyID0gW1xuICAgICAgICAnaWQnLFxuICAgICAgICAnZmVlJyxcbiAgICAgICAgJ21lbW8nLFxuICAgICAgICAndHlwZScsXG4gICAgICAgICd2b3RlS2V5JyxcbiAgICAgICAgJ3NlbGVjdGlvbktleScsXG4gICAgICAgICd2b3RlRmlyc3QnLFxuICAgICAgICAndm90ZUxhc3QnLFxuICAgICAgICAndm90ZUtleURpbHV0aW9uJyxcbiAgICAgIF07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXlPcmRlcixcbiAgICAgICAgaWQ6IHR4SnNvbi5pZCxcbiAgICAgICAgb3V0cHV0QW1vdW50OiAnMCcsXG4gICAgICAgIGNoYW5nZUFtb3VudDogJzAnLFxuICAgICAgICBvdXRwdXRzOiBbXSxcbiAgICAgICAgY2hhbmdlT3V0cHV0czogW10sXG4gICAgICAgIGZlZTogdHhKc29uLmZlZSxcbiAgICAgICAgbWVtbzogdHhKc29uLm5vdGUsXG4gICAgICAgIHR5cGU6IHR4LnR5cGUsXG4gICAgICAgIHZvdGVLZXk6IHR4SnNvbi52b3RlS2V5LFxuICAgICAgICBzZWxlY3Rpb25LZXk6IHR4SnNvbi5zZWxlY3Rpb25LZXksXG4gICAgICAgIHZvdGVGaXJzdDogdHhKc29uLnZvdGVGaXJzdCxcbiAgICAgICAgdm90ZUxhc3Q6IHR4SnNvbi52b3RlTGFzdCxcbiAgICAgICAgdm90ZUtleURpbHV0aW9uOiB0eEpzb24udm90ZUtleURpbHV0aW9uLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBpZiBhIHR4IGlzIGEgdG9rZW4gdHhcbiAgICogQHBhcmFtIHR5cGUge3N0cmluZ30gLSB0eCB0eXBlXG4gICAqIEByZXR1cm5zIHRydWUgaWYgaXQncyBhIHRva2VuIHR4XG4gICAqL1xuICBpc1Rva2VuVHgodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdheGZlcic7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzZWVkIGlzIGEgdmFsaWQgc3RlbGxhciBzZWVkXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZWVkIHRoZSBzZWVkIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBpbnB1dCBpcyBhIFN0ZWxsYXIgc2VlZFxuICAgKi9cbiAgaXNTdGVsbGFyU2VlZChzZWVkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gU2VlZFZhbGlkYXRvci5pc1ZhbGlkRWQyNTUxOVNlZWRGb3JDb2luKHNlZWQsIENvaW5GYW1pbHkuWExNKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgc3RlbGxhciBzZWVkIHRvIGFuIGFsZ28gc2VlZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VlZCB0aGUgc2VlZCB0byBjb252ZXJ0XG4gICAqIEByZXR1cm5zIHtCb29sZWFuIHwgbnVsbH0gc2VlZCBpbiBhbGdvIGVuY29kaW5nXG4gICAqL1xuICBjb252ZXJ0RnJvbVN0ZWxsYXJTZWVkKHNlZWQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIC8vIGFzc3VtZSB0aGlzIGlzIGEgdHJ1c3QgY3VzdG9kaWFsIHNlZWQgaWYgaXRzIGEgdmFsaWQgZWQyNTUxOSBwcnZcbiAgICBpZiAoIXRoaXMuaXNTdGVsbGFyU2VlZChzZWVkKSB8fCBTZWVkVmFsaWRhdG9yLmhhc0NvbXBldGluZ1NlZWRGb3JtYXRzKHNlZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoU2VlZFZhbGlkYXRvci5pc1ZhbGlkRWQyNTUxOVNlZWRGb3JDb2luKHNlZWQsIENvaW5GYW1pbHkuWExNKSkge1xuICAgICAgcmV0dXJuIEFsZ29MaWIuYWxnb1V0aWxzLmNvbnZlcnRGcm9tU3RlbGxhclNlZWQoc2VlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2ZXJpZnlTaWduVHJhbnNhY3Rpb25QYXJhbXMocGFyYW1zOiBTaWduVHJhbnNhY3Rpb25PcHRpb25zKTogVmVyaWZpZWRUcmFuc2FjdGlvblBhcmFtZXRlcnMge1xuICAgIGNvbnN0IHBydiA9IHBhcmFtcy5wcnY7XG4gICAgY29uc3QgYWRkcmVzc1ZlcnNpb24gPSBwYXJhbXMudHhQcmVidWlsZC5hZGRyZXNzVmVyc2lvbjtcbiAgICBsZXQgaXNIYWxmU2lnbmVkID0gZmFsc2U7XG5cbiAgICAvLyBpdCdzIHBvc3NpYmxlIHRoaXMgdHggd2FzIGFscmVhZHkgc2lnbmVkIC0gdGFrZSB0aGUgaGFsZlNpZ25lZFxuICAgIC8vIHR4SGV4IGlmIGl0IGlzXG4gICAgbGV0IHR4SGV4ID0gcGFyYW1zLnR4UHJlYnVpbGQudHhIZXg7XG4gICAgaWYgKHBhcmFtcy50eFByZWJ1aWxkLmhhbGZTaWduZWQpIHtcbiAgICAgIGlzSGFsZlNpZ25lZCA9IHRydWU7XG4gICAgICB0eEhleCA9IHBhcmFtcy50eFByZWJ1aWxkLmhhbGZTaWduZWQudHhIZXg7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQodHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcodHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4SGV4fWApO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwcnYgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcocHJ2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcnYgbXVzdCBiZSBhIHN0cmluZywgZ290IHR5cGUgJHt0eXBlb2YgcHJ2fWApO1xuICAgIH1cblxuICAgIGlmICghXy5oYXMocGFyYW1zLnR4UHJlYnVpbGQsICdrZXlzJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBwdWJsaWMga2V5cyBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghXy5pc051bWJlcihhZGRyZXNzVmVyc2lvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBhZGRyZXNzVmVyc2lvbiBwYXJhbWV0ZXIgdG8gc2lnbiB0cmFuc2FjdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHNpZ25lcnMgPSBwYXJhbXMudHhQcmVidWlsZC5rZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgICAvLyBpZiB3ZSBhcmUgcmVjZWl2aW5nIGFkZHJlc3NlcyBkbyBub3QgdHJ5IHRvIGNvbnZlcnQgdGhlbVxuICAgICAgaWYgKCFBbGdvTGliLmFsZ29VdGlscy5pc1ZhbGlkQWRkcmVzcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBBbGdvTGliLmFsZ29VdGlscy5wdWJsaWNLZXlUb0FsZ29BZGRyZXNzKEFsZ29MaWIuYWxnb1V0aWxzLnRvVWludDhBcnJheShrZXkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfSk7XG4gICAgLy8gVE9ETyhodHRwczovL2JpdGdvaW5jLmF0bGFzc2lhbi5uZXQvYnJvd3NlL1NUTFgtNjA2Nyk6IGZpeCB0aGUgbnVtYmVyIG9mIHNpZ25lcnMgdXNpbmdcbiAgICAvLyBzaG91bGQgYmUgc2ltaWxhciB0byBvdGhlciBjb2lucyBpbXBsZW1lbnRhdGlvblxuICAgIC8vIElmIHdlIGhhdmUgYSBudW1iZXIgd2l0aCBkaWdpdHMgdG8gZWxpbWluYXRlIHRoZW0gd2l0aG91dCB0YWtpbmcgYW55IHJvdW5kaW5nIGNyaXRlcmlhLlxuICAgIGNvbnN0IG51bWJlclNpZ25lcnMgPSBNYXRoLnRydW5jKHNpZ25lcnMubGVuZ3RoIC8gMikgKyAxO1xuICAgIHJldHVybiB7IHR4SGV4LCBhZGRyZXNzVmVyc2lvbiwgc2lnbmVycywgcHJ2LCBpc0hhbGZTaWduZWQsIG51bWJlclNpZ25lcnMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NlbWJsZSBrZXljaGFpbiBhbmQgaGFsZi1zaWduIHByZWJ1aWx0IHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIHBhcmFtcy50eFByZWJ1aWxkIHtUcmFuc2FjdGlvblByZWJ1aWxkfSBwcmVidWlsZCBvYmplY3QgcmV0dXJuZWQgYnkgcGxhdGZvcm1cbiAgICogQHBhcmFtIHBhcmFtcy5wcnYge1N0cmluZ30gdXNlciBwcnZcbiAgICogQHJldHVybnMge1Byb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+fVxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyk6IFByb21pc2U8U2lnbmVkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCB7IHR4SGV4LCBzaWduZXJzLCBwcnYsIGlzSGFsZlNpZ25lZCwgbnVtYmVyU2lnbmVycyB9ID0gdGhpcy52ZXJpZnlTaWduVHJhbnNhY3Rpb25QYXJhbXMocGFyYW1zKTtcbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5nZXRCdWlsZGVyKCk7XG4gICAgY29uc3QgdHhCdWlsZGVyID0gZmFjdG9yeS5mcm9tKHR4SGV4KTtcbiAgICB0eEJ1aWxkZXIubnVtYmVyT2ZSZXF1aXJlZFNpZ25lcnMobnVtYmVyU2lnbmVycyk7XG4gICAgdHhCdWlsZGVyLnNpZ24oeyBrZXk6IHBydiB9KTtcbiAgICB0eEJ1aWxkZXIuc2V0U2lnbmVycyhzaWduZXJzKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFuc2FjdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZWRUeEhleCA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCkpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBpZiAobnVtYmVyU2lnbmVycyA9PT0gMSkge1xuICAgICAgcmV0dXJuIHsgdHhIZXg6IHNpZ25lZFR4SGV4IH07XG4gICAgfSBlbHNlIGlmIChpc0hhbGZTaWduZWQpIHtcbiAgICAgIHJldHVybiB7IHR4SGV4OiBzaWduZWRUeEhleCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBoYWxmU2lnbmVkOiB7IHR4SGV4OiBzaWduZWRUeEhleCB9IH07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcGFyc2VUcmFuc2FjdGlvbihwYXJhbXM6IFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zKTogUHJvbWlzZTxQYXJzZWRUcmFuc2FjdGlvbj4ge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhZGRyZXNzIGNhbiBiZSB1c2VkIHRvIHNlbmQgZnVuZHMuXG4gICAqXG4gICAqIEBwYXJhbSBwYXJhbXMuYWRkcmVzcyBhZGRyZXNzIHRvIHZhbGlkYXRlXG4gICAqIEBwYXJhbSBwYXJhbXMua2V5Y2hhaW5zIHB1YmxpYyBrZXlzIHRvIGdlbmVyYXRlIHRoZSB3YWxsZXRcbiAgICovXG4gIGFzeW5jIGlzV2FsbGV0QWRkcmVzcyhwYXJhbXM6IFZlcmlmeUFsZ29BZGRyZXNzT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBrZXljaGFpbnMsXG4gICAgICBjb2luU3BlY2lmaWM6IHsgYml0Z29QdWJLZXkgfSxcbiAgICB9ID0gcGFyYW1zO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFrZXljaGFpbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBwYXJhbSBrZXljaGFpbnMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBlZmZlY3RpdmVLZXljaGFpbiA9IGJpdGdvUHViS2V5ID8ga2V5Y2hhaW5zLnNsaWNlKDAsIC0xKS5jb25jYXQoW3sgcHViOiBiaXRnb1B1YktleSB9XSkgOiBrZXljaGFpbnM7XG4gICAgY29uc3QgcHViS2V5cyA9IGVmZmVjdGl2ZUtleWNoYWluLm1hcCgoa2V5KSA9PiB0aGlzLnN0ZWxsYXJBZGRyZXNzVG9BbGdvQWRkcmVzcyhrZXkucHViKSk7XG5cbiAgICBpZiAoIXB1YktleXMuZXZlcnkoKHB1YktleSkgPT4gdGhpcy5pc1ZhbGlkUHViKHB1YktleSkpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEtleSgnaW52YWxpZCBwdWJsaWMga2V5Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm9vdEFkZHJlc3MgPSBBbGdvTGliLmFsZ29VdGlscy5tdWx0aXNpZ0FkZHJlc3MoU1VQUE9SVEVEX0FERFJFU1NfVkVSU0lPTiwgTVNJR19USFJFU0hPTEQsIHB1YktleXMpO1xuXG4gICAgcmV0dXJuIHJvb3RBZGRyZXNzID09PSBhZGRyZXNzO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBkZXJpdmVLZXlXaXRoU2VlZCh7IGtleSwgc2VlZCB9OiB7IGtleTogc3RyaW5nOyBzZWVkOiBzdHJpbmcgfSk6IHsgZGVyaXZhdGlvblBhdGg6IHN0cmluZzsga2V5OiBzdHJpbmcgfSB7XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGhJbnB1dCA9IHV0eG9saWIuY3J5cHRvLmhhc2gyNTYoQnVmZmVyLmZyb20oc2VlZCwgJ3V0ZjgnKSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGNvbnN0IGRlcml2YXRpb25QYXRoUGFydHMgPSBbXG4gICAgICA5OTk5OTksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDAsIDcpLCAxNiksXG4gICAgICBwYXJzZUludChkZXJpdmF0aW9uUGF0aElucHV0LnNsaWNlKDcsIDE0KSwgMTYpLFxuICAgIF07XG4gICAgY29uc3QgZGVyaXZhdGlvblBhdGggPSAnbS8nICsgZGVyaXZhdGlvblBhdGhQYXJ0cy5tYXAoKHBhcnQpID0+IGAke3BhcnR9J2ApLmpvaW4oJy8nKTtcbiAgICBjb25zdCBkZXJpdmVkS2V5ID0gRWQyNTUxOUtleURlcml2ZXIuZGVyaXZlUGF0aChkZXJpdmF0aW9uUGF0aCwga2V5KS5rZXk7XG4gICAgY29uc3Qga2V5cGFpciA9IG5ldyBBbGdvTGliLktleVBhaXIoeyBzZWVkOiBkZXJpdmVkS2V5IH0pO1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGtleXBhaXIuZ2V0QWRkcmVzcygpLFxuICAgICAgZGVyaXZhdGlvblBhdGgsXG4gICAgfTtcbiAgfVxuXG4gIGRlY29kZVR4KHR4bjogQnVmZmVyKTogdW5rbm93biB7XG4gICAgcmV0dXJuIEFsZ29MaWIuYWxnb1V0aWxzLmRlY29kZUFsZ29UeG4odHhuKTtcbiAgfVxuXG4gIGdldEFkZHJlc3NGcm9tUHVibGljS2V5KHB1YktleTogVWludDhBcnJheSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEFsZ29MaWIuYWxnb1V0aWxzLnB1YmxpY0tleVRvQWxnb0FkZHJlc3MocHViS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNvbmZpZyBmb3IgaG93IHRva2VuIGVuYWJsZW1lbnRzIHdvcmsgZm9yIHRoaXMgY29pblxuICAgKiBAcmV0dXJuc1xuICAgKiAgICByZXF1aXJlc1Rva2VuRW5hYmxlbWVudDogVHJ1ZSBpZiB0b2tlbnMgbmVlZCB0byBiZSBlbmFibGVkIGZvciB0aGlzIGNvaW5cbiAgICogICAgc3VwcG9ydHNNdWx0aXBsZVRva2VuRW5hYmxlbWVudHM6IFRydWUgaWYgbXVsdGlwbGUgdG9rZW5zIGNhbiBiZSBlbmFibGVkIGluIG9uZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZ2V0VG9rZW5FbmFibGVtZW50Q29uZmlnKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlc1Rva2VuRW5hYmxlbWVudDogdHJ1ZSxcbiAgICAgIHN1cHBvcnRzTXVsdGlwbGVUb2tlbkVuYWJsZW1lbnRzOiBmYWxzZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0ZWxsYXIgYW5kIEFsZ29yYW5kIGJvdGggdXNlIGtleXMgb24gdGhlIGVkMjU1MTkgY3VydmUsIGJ1dCB1c2UgZGlmZmVyZW50IGVuY29kaW5ncy5cbiAgICogQXMgdGhlIEhTTSBkb2Vzbid0IGhhdmUgZXhwbGljaXQgc3VwcG9ydCB0byBjcmVhdGUgQWxnb3JhbmQgYWRkcmVzc2VzLCB3ZSB1c2UgdGhlIFN0ZWxsYXJcbiAgICoga2V5cyBhbmQgcmUtZW5jb2RlIHRoZW0gdG8gdGhlIEFsZ29yYW5kIGVuY29kaW5nLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgQWxnb3JhbmQgY3VzdG9kaWFsIHdhbGxldHMgcmV1c2luZyBTdGVsbGFyIGtleXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzT3JQdWJLZXkgYSBTdGVsbGFyIHB1YmtleSBvciBBbGdvcmFuZCBhZGRyZXNzXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuICBwcml2YXRlIHN0ZWxsYXJBZGRyZXNzVG9BbGdvQWRkcmVzcyhhZGRyZXNzT3JQdWJLZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzc09yUHViS2V5KSkge1xuICAgICAgLy8gd2UgaGF2ZSBhbiBBbGdvcmFuZCBhZGRyZXNzXG4gICAgICByZXR1cm4gYWRkcmVzc09yUHViS2V5O1xuICAgIH1cblxuICAgIGlmICghc3RlbGxhci5TdHJLZXkuaXNWYWxpZEVkMjU1MTlQdWJsaWNLZXkoYWRkcmVzc09yUHViS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRBZGRyZXNzRXJyb3IoJ05laXRoZXIgYW4gQWxnb3JhbmQgYWRkcmVzcyBub3IgYSBzdGVsbGFyIHB1YmtleS4nKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBoYXZlIGEgc3RlbGxhciBrZXlcbiAgICBjb25zdCBzdGVsbGFyUHViID0gc3RlbGxhci5TdHJLZXkuZGVjb2RlRWQyNTUxOVB1YmxpY0tleShhZGRyZXNzT3JQdWJLZXkpO1xuICAgIGNvbnN0IGFsZ29BZGRyZXNzID0gQWxnb0xpYi5hbGdvVXRpbHMuZW5jb2RlQWRkcmVzcyhzdGVsbGFyUHViKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkQWRkcmVzcyhhbGdvQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yKCdDYW5ub3QgY29udmVydCBTdGVsbGFyIGFkZHJlc3MgdG8gYW4gQWxnb3JhbmQgYWRkcmVzcyB2aWEgcHVia2V5LicpO1xuICAgIH1cblxuICAgIHJldHVybiBhbGdvQWRkcmVzcztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0QnVpbGRlcigpOiBBbGdvTGliLlRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICAgIHJldHVybiBuZXcgQWxnb0xpYi5UcmFuc2FjdGlvbkJ1aWxkZXJGYWN0b3J5KGNvaW5zLmdldCh0aGlzLmdldEJhc2VDaGFpbigpKSk7XG4gIH1cbn1cbiJdfQ==