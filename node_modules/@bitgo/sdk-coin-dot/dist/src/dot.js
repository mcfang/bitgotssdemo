"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dot = exports.DEFAULT_SCAN_FACTOR = void 0;
const _ = __importStar(require("lodash"));
const sdk_core_1 = require("@bitgo/sdk-core");
const statics_1 = require("@bitgo/statics");
const lib_1 = require("./lib");
const api_1 = require("@polkadot/api");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
exports.DEFAULT_SCAN_FACTOR = 20; // default number of receive addresses to scan for funds
const dotUtils = lib_1.Utils.default;
class Dot extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        this.MAX_VALIDITY_DURATION = 2400;
        this.SWEEP_TXN_DURATION = 64;
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new Dot(bitgo, staticsCoin);
    }
    getChain() {
        return 'dot';
    }
    getBaseChain() {
        return 'dot';
    }
    getFamily() {
        return 'dot';
    }
    getFullName() {
        return 'Polkadot';
    }
    getBaseFactor() {
        return Math.pow(10, this._staticsCoin.decimalPlaces);
    }
    /**
     * Flag for sending value of 0
     * @returns {boolean} True if okay to send 0 value, false otherwise
     */
    valuelessTransferAllowed() {
        return true;
    }
    /** @inheritDoc */
    supportsTss() {
        return true;
    }
    getMPCAlgorithm() {
        return 'eddsa';
    }
    allowsAccountConsolidations() {
        return true;
    }
    /**
     * Generate ed25519 key pair
     *
     * @param seed
     * @returns {Object} object with generated pub, prv
     */
    generateKeyPair(seed) {
        const keyPair = seed ? dotUtils.keyPairFromSeed(new Uint8Array(seed)) : new lib_1.KeyPair();
        const keys = keyPair.getKeys();
        if (!keys.prv) {
            throw new Error('Missing prv in key generation.');
        }
        return {
            pub: keys.pub,
            prv: keys.prv,
        };
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin.
     *
     * @param {String} pub the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPub(pub) {
        return dotUtils.isValidPublicKey(pub);
    }
    /**
     * Return boolean indicating whether the supplied private key is a valid dot private key
     *
     * @param {String} prv the prv to be checked
     * @returns {Boolean} is it valid?
     */
    isValidPrv(prv) {
        return dotUtils.isValidPrivateKey(prv);
    }
    /**
     * Return boolean indicating whether input is valid public key for the coin
     *
     * @param {String} address the pub to be checked
     * @returns {Boolean} is it valid?
     */
    isValidAddress(address) {
        return dotUtils.isValidAddress(address);
    }
    /**
     * Sign message with private key
     *
     * @param key
     * @param message
     * @return {Buffer} A signature over the given message using the given key
     */
    async signMessage(key, message) {
        const msg = Buffer.isBuffer(message) ? message.toString('utf8') : message;
        // reconstitute keys and sign
        return Buffer.from(new lib_1.KeyPair({ prv: key.prv }).signMessage(msg));
    }
    /**
     * Explain/parse transaction
     * @param unsignedTransaction
     */
    async explainTransaction(unsignedTransaction) {
        var _a, _b;
        let outputAmount = 0;
        unsignedTransaction.parsedTx.outputs.forEach((o) => {
            outputAmount += parseInt(o.valueString, 10);
        });
        const explanationResult = {
            displayOrder: [
                'outputAmount',
                'changeAmount',
                'outputs',
                'changeOutputs',
                'fee',
                'type',
                'sequenceId',
                'id',
                'blockNumber',
            ],
            sequenceId: unsignedTransaction.parsedTx.sequenceId,
            fee: (_a = unsignedTransaction.feeInfo) === null || _a === void 0 ? void 0 : _a.feeString,
            id: unsignedTransaction.parsedTx.id,
            type: unsignedTransaction.parsedTx.type,
            outputs: unsignedTransaction.parsedTx.outputs,
            blockNumber: (_b = unsignedTransaction.coinSpecific) === null || _b === void 0 ? void 0 : _b.blockNumber,
            outputAmount: outputAmount,
            changeOutputs: [],
            changeAmount: '0',
        };
        return explanationResult;
    }
    verifySignTransactionParams(params) {
        const prv = params.prv;
        const txHex = params.txPrebuild.txHex;
        if (!txHex) {
            throw new Error('missing txPrebuild parameter');
        }
        if (!_.isString(txHex)) {
            throw new Error(`txPrebuild must be an object, got type ${typeof txHex}`);
        }
        if (!prv) {
            throw new Error('missing prv parameter to sign transaction');
        }
        if (!_.isString(prv)) {
            throw new Error(`prv must be a string, got type ${typeof prv}`);
        }
        if (!_.has(params, 'pubs')) {
            throw new Error('missing public key parameter to sign transaction');
        }
        return { txHex, prv };
    }
    /**
     * Assemble keychain and half-sign prebuilt transaction
     *
     * @param params
     * @param params.txPrebuild {TransactionPrebuild} prebuild object returned by platform
     * @param params.prv {String} user prv
     * @returns {Promise<SignedTransaction>}
     */
    async signTransaction(params) {
        const { txHex, prv } = this.verifySignTransactionParams(params);
        const factory = this.getBuilder();
        const txBuilder = factory.from(txHex);
        const keyPair = new lib_1.KeyPair({ prv: prv });
        const { referenceBlock, blockNumber, transactionVersion, sender } = params.txPrebuild.transaction;
        txBuilder
            .validity({ firstValid: blockNumber, maxDuration: this.MAX_VALIDITY_DURATION })
            .referenceBlock(referenceBlock)
            .version(transactionVersion)
            .sender({ address: sender })
            .sign({ key: keyPair.getKeys().prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new Error('Invalid transaction');
        }
        const signedTxHex = transaction.toBroadcastFormat();
        return { txHex: signedTxHex };
    }
    async getInitializedNodeAPI() {
        if (!Dot.nodeApiInitialized) {
            const wsProvider = new api_1.WsProvider(sdk_core_1.Environments[this.bitgo.getEnv()].dotNodeUrls);
            Dot.API = await api_1.ApiPromise.create({ provider: wsProvider });
            Dot.nodeApiInitialized = true;
        }
        return Dot.API;
    }
    async getAccountInfo(walletAddr) {
        const api = await this.getInitializedNodeAPI();
        const { nonce, data: balance } = await api.query.system.account(walletAddr);
        return { nonce: nonce.toNumber(), freeBalance: balance.free.toNumber() };
    }
    async getHeaderInfo() {
        const api = await this.getInitializedNodeAPI();
        const { number, hash } = await api.rpc.chain.getHeader();
        return { headerNumber: number.toNumber(), headerHash: hash.toString() };
    }
    /**
     *
     * Estimate the fee of the transaction
     *
     * @param {string} destAddr destination wallet address
     * @param {string} srcAddr source wallet address
     * @param {string} amount amount to transfer
     * @returns {number} the estimated fee the transaction will cost
     *
     * @see https://polkadot.js.org/docs/api/cookbook/tx#how-do-i-estimate-the-transaction-fees
     */
    async getFee(destAddr, srcAddr, amount) {
        const api = await this.getInitializedNodeAPI();
        const info = await api.tx.balances.transfer(destAddr, amount).paymentInfo(srcAddr);
        return info.partialFee.toNumber();
    }
    async getMaterial() {
        const api = await this.getInitializedNodeAPI();
        return {
            genesisHash: api.genesisHash.toString(),
            chainName: api.runtimeChain.toString(),
            specName: api.runtimeVersion.specName.toString(),
            specVersion: api.runtimeVersion.specVersion.toNumber(),
            txVersion: api.runtimeVersion.transactionVersion.toNumber(),
            metadata: api.runtimeMetadata.toHex(),
        };
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {MPCRecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {MPCTx} the serialized transaction hex string and index
     * of the address being swept
     */
    async recover(params) {
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        const index = params.index || 0;
        const currPath = params.seed ? sdk_lib_mpc_1.getDerivationPath(params.seed) + `/${index}` : `m/${index}`;
        const accountId = MPC.deriveUnhardened(bitgoKey, currPath).slice(0, 64);
        const senderAddr = this.getAddressFromPublicKey(accountId);
        const { nonce, freeBalance } = await this.getAccountInfo(senderAddr);
        const destAddr = params.recoveryDestination;
        const amount = freeBalance;
        const partialFee = await this.getFee(destAddr, senderAddr, amount);
        // Polkadot has a concept of existential desposit (ed), it is the minimum amount required by an address to have
        // to keep the account active
        const existentialDeposit = this.getChain() === 'tdot' ? 10000000000 : 1000000000000;
        const value = new bignumber_js_1.default(freeBalance).minus(new bignumber_js_1.default(existentialDeposit)).minus(new bignumber_js_1.default(partialFee));
        if (value.toNumber() <= 0) {
            throw new Error('Did not find address with funds to recover');
        }
        // first build the unsigned txn
        const { headerNumber, headerHash } = await this.getHeaderInfo();
        const material = await this.getMaterial();
        const validityWindow = { firstValid: headerNumber, maxDuration: this.MAX_VALIDITY_DURATION };
        const txnBuilder = this.getBuilder().getTransferBuilder().material(material);
        txnBuilder
            .sweep()
            .to({ address: params.recoveryDestination })
            .sender({ address: senderAddr })
            .validity(validityWindow)
            .referenceBlock(headerHash)
            .sequenceId({ name: 'Nonce', keyword: 'nonce', value: nonce })
            .fee({ amount: 0, type: 'tip' });
        const unsignedTransaction = (await txnBuilder.build());
        let serializedTx = unsignedTransaction.toBroadcastFormat();
        if (!isUnsignedSweep) {
            if (!params.userKey) {
                throw new Error('missing userKey');
            }
            if (!params.backupKey) {
                throw new Error('missing backupKey');
            }
            if (!params.walletPassphrase) {
                throw new Error('missing wallet passphrase');
            }
            // Clean up whitespace from entered values
            const userKey = params.userKey.replace(/\s/g, '');
            const backupKey = params.backupKey.replace(/\s/g, '');
            // Decrypt private keys from KeyCard values
            let userPrv;
            try {
                userPrv = this.bitgo.decrypt({
                    input: userKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting user keychain: ${e.message}`);
            }
            /** TODO BG-52419 Implement Codec for parsing */
            const userSigningMaterial = JSON.parse(userPrv);
            let backupPrv;
            try {
                backupPrv = this.bitgo.decrypt({
                    input: backupKey,
                    password: params.walletPassphrase,
                });
            }
            catch (e) {
                throw new Error(`Error decrypting backup keychain: ${e.message}`);
            }
            const backupSigningMaterial = JSON.parse(backupPrv);
            // add signature
            const signatureHex = await sdk_core_1.EDDSAMethods.getTSSSignature(userSigningMaterial, backupSigningMaterial, currPath, unsignedTransaction);
            const dotKeyPair = new lib_1.KeyPair({ pub: accountId });
            txnBuilder.addSignature({ pub: dotKeyPair.getKeys().pub }, signatureHex);
            const signedTransaction = await txnBuilder.build();
            serializedTx = signedTransaction.toBroadcastFormat();
        }
        else {
            // Polkadot has a concept of existential desposit (ed), it is the minimum amount required by an address to have
            // to keep the account active
            const existentialDeposit = this.getChain() === 'tdot' ? 10000000000 : 1000000000000;
            const value = new bignumber_js_1.default(freeBalance).minus(new bignumber_js_1.default(existentialDeposit));
            const walletCoin = this.getChain();
            const inputs = [
                {
                    address: unsignedTransaction.inputs[0].address,
                    valueString: value.toString(),
                    value: value.toNumber(),
                },
            ];
            const outputs = [
                {
                    address: unsignedTransaction.outputs[0].address,
                    valueString: value.toString(),
                    coinName: walletCoin,
                },
            ];
            const spendAmount = value.toString();
            const parsedTx = { inputs: inputs, outputs: outputs, spendAmount: spendAmount, type: '' };
            const feeInfo = { fee: 0, feeString: '0' };
            const transaction = {
                serializedTx: serializedTx,
                scanIndex: index,
                coin: walletCoin,
                signableHex: unsignedTransaction.signablePayload.toString('hex'),
                derivationPath: currPath,
                parsedTx: parsedTx,
                feeInfo: feeInfo,
                coinSpecific: { ...validityWindow, commonKeychain: bitgoKey },
            };
            const unsignedTx = { unsignedTx: transaction, signatureShares: [] };
            const transactions = [unsignedTx];
            const txRequest = {
                transactions: transactions,
                walletCoin: walletCoin,
            };
            const txRequests = { txRequests: [txRequest] };
            return txRequests;
        }
        const transaction = { serializedTx: serializedTx, scanIndex: index };
        return transaction;
    }
    /**
     * Builds native DOT recoveries of receive addresses in batch without BitGo.
     * Funds will be recovered to base address first. You need to initiate another sweep txn after that.
     *
     * @param {MPCConsolidationRecoveryOptions} params - options for consolidation recovery.
     * @param {string} [params.startingScanIndex] - receive address index to start scanning from. default to 1 (inclusive).
     * @param {string} [params.endingScanIndex] - receive address index to end scanning at. default to startingScanIndex + 20 (exclusive).
     */
    async recoverConsolidations(params) {
        const isUnsignedSweep = !params.userKey && !params.backupKey && !params.walletPassphrase;
        const startIdx = params.startingScanIndex || 1;
        const endIdx = params.endingScanIndex || startIdx + exports.DEFAULT_SCAN_FACTOR;
        if (startIdx < 1 || endIdx <= startIdx || endIdx - startIdx > 10 * exports.DEFAULT_SCAN_FACTOR) {
            throw new Error(`Invalid starting or ending index to scan for addresses. startingScanIndex: ${startIdx}, endingScanIndex: ${endIdx}.`);
        }
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
        const baseIndex = 0;
        const basePath = params.seed ? sdk_lib_mpc_1.getDerivationPath(params.seed) + `/${baseIndex}` : `m/${baseIndex}`;
        const accountId = MPC.deriveUnhardened(bitgoKey, basePath).slice(0, 64);
        const baseAddress = this.getAddressFromPublicKey(accountId);
        const consolidationTransactions = [];
        let lastScanIndex = startIdx;
        for (let i = startIdx; i < endIdx; i++) {
            const recoverParams = {
                userKey: params.userKey,
                backupKey: params.backupKey,
                bitgoKey: params.bitgoKey,
                walletPassphrase: params.walletPassphrase,
                recoveryDestination: baseAddress,
                seed: params.seed,
                index: i,
            };
            let recoveryTransaction;
            try {
                recoveryTransaction = await this.recover(recoverParams);
            }
            catch (e) {
                if (e.message === 'Did not find address with funds to recover') {
                    lastScanIndex = i;
                    continue;
                }
                throw e;
            }
            if (isUnsignedSweep) {
                consolidationTransactions.push(recoveryTransaction.txRequests[0]);
            }
            else {
                consolidationTransactions.push(recoveryTransaction);
            }
            lastScanIndex = i;
        }
        if (consolidationTransactions.length == 0) {
            throw new Error('Did not find an address with funds to recover');
        }
        if (isUnsignedSweep) {
            // lastScanIndex will be used to inform user the last address index scanned for available funds (so they can
            // appropriately adjust the scan range on the next iteration of consolidation recoveries). In the case of unsigned
            // sweep consolidations, this lastScanIndex will be provided in the coinSpecific of the last txn made.
            const lastTransactionCoinSpecific = {
                firstValid: consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific
                    .firstValid,
                maxDuration: consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific
                    .maxDuration,
                commonKeychain: consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific
                    .commonKeychain,
                lastScanIndex: lastScanIndex,
            };
            consolidationTransactions[consolidationTransactions.length - 1].transactions[0].unsignedTx.coinSpecific =
                lastTransactionCoinSpecific;
            const consolidationSweepTransactions = { txRequests: consolidationTransactions };
            return consolidationSweepTransactions;
        }
        return { transactions: consolidationTransactions, lastScanIndex };
    }
    /**
     * Creates funds sweep recovery transaction(s) without BitGo
     *
     * @param {MPCSweepRecoveryOptions} params parameters needed to combine the signatures
     * and transactions to create broadcastable transactions
     *
     * @returns {MPCTx[]} array of the serialized transaction hex strings and indices
     * of the addresses being swept
     */
    async createBroadcastableSweepTransaction(params) {
        var _a, _b, _c, _d, _e;
        const req = params.signatureShares;
        const broadcastableTransactions = [];
        let lastScanIndex = 0;
        for (let i = 0; i < req.length; i++) {
            const MPC = await sdk_core_1.EDDSAMethods.getInitializedMpcInstance();
            const transaction = req[i].txRequest.transactions[0].unsignedTx;
            if (!req[i].ovc || !req[i].ovc[0].eddsaSignature) {
                throw new Error('Missing signature(s)');
            }
            const signature = req[i].ovc[0].eddsaSignature;
            if (!transaction.signableHex) {
                throw new Error('Missing signable hex');
            }
            const messageBuffer = Buffer.from(transaction.signableHex, 'hex');
            const result = MPC.verify(messageBuffer, signature);
            if (!result) {
                throw new Error('Invalid signature');
            }
            const signatureHex = Buffer.concat([Buffer.from(signature.R, 'hex'), Buffer.from(signature.sigma, 'hex')]);
            if (!transaction.coinSpecific ||
                !((_a = transaction.coinSpecific) === null || _a === void 0 ? void 0 : _a.firstValid) ||
                !((_b = transaction.coinSpecific) === null || _b === void 0 ? void 0 : _b.maxDuration)) {
                throw new Error('missing validity window');
            }
            const validityWindow = {
                firstValid: (_c = transaction.coinSpecific) === null || _c === void 0 ? void 0 : _c.firstValid,
                maxDuration: (_d = transaction.coinSpecific) === null || _d === void 0 ? void 0 : _d.maxDuration,
            };
            const material = await this.getMaterial();
            if (!((_e = transaction.coinSpecific) === null || _e === void 0 ? void 0 : _e.commonKeychain)) {
                throw new Error('Missing common keychain');
            }
            const commonKeychain = transaction.coinSpecific.commonKeychain;
            if (!transaction.derivationPath) {
                throw new Error('Missing derivation path');
            }
            const derivationPath = transaction.derivationPath;
            const accountId = MPC.deriveUnhardened(commonKeychain, derivationPath).slice(0, 64);
            const senderAddr = this.getAddressFromPublicKey(accountId);
            const txnBuilder = this.getBuilder()
                .material(material)
                .from(transaction.serializedTx)
                .sender({ address: senderAddr })
                .validity(validityWindow);
            const dotKeyPair = new lib_1.KeyPair({ pub: accountId });
            txnBuilder.addSignature({ pub: dotKeyPair.getKeys().pub }, signatureHex);
            const signedTransaction = await txnBuilder.build();
            const serializedTx = signedTransaction.toBroadcastFormat();
            broadcastableTransactions.push({
                serializedTx: serializedTx,
                scanIndex: transaction.scanIndex,
            });
            if (i === req.length - 1 && transaction.coinSpecific.lastScanIndex) {
                lastScanIndex = transaction.coinSpecific.lastScanIndex;
            }
        }
        return { transactions: broadcastableTransactions, lastScanIndex };
    }
    async parseTransaction(params) {
        return {};
    }
    async isWalletAddress(params) {
        throw new sdk_core_1.MethodNotImplementedError();
    }
    async verifyTransaction(params) {
        return true;
    }
    getAddressFromPublicKey(Pubkey) {
        return new lib_1.KeyPair({ pub: Pubkey }).getAddress(lib_1.Utils.default.getAddressFormat(this.getChain()));
    }
    getBuilder() {
        return new lib_1.TransactionBuilderFactory(statics_1.coins.get(this.getChain()));
    }
}
exports.Dot = Dot;
Dot.initialized = false;
Dot.nodeApiInitialized = false;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG90LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RvdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsMENBQTRCO0FBQzVCLDhDQTJCeUI7QUFDekIsNENBQTBGO0FBQzFGLCtCQUF3RztBQUN4Ryx1Q0FBdUQ7QUFFdkQsZ0VBQXFDO0FBQ3JDLG9EQUF1RDtBQUUxQyxRQUFBLG1CQUFtQixHQUFHLEVBQUUsQ0FBQyxDQUFDLHdEQUF3RDtBQXlCL0YsTUFBTSxRQUFRLEdBQUcsV0FBSyxDQUFDLE9BQU8sQ0FBQztBQUUvQixNQUFhLEdBQUksU0FBUSxtQkFBUTtJQUsvQixZQUFZLEtBQWdCLEVBQUUsV0FBdUM7UUFDbkUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBSk4sMEJBQXFCLEdBQUcsSUFBSSxDQUFDO1FBQzdCLHVCQUFrQixHQUFHLEVBQUUsQ0FBQztRQUsvQixJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7SUFPRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCLEVBQUUsV0FBdUM7UUFDN0UsT0FBTyxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDckMsQ0FBQztJQUVELFFBQVE7UUFDTixPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCxZQUFZO1FBQ1YsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQsU0FBUztRQUNQLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELFdBQVc7UUFDVCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBRUQsYUFBYTtRQUNYLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxh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Z0JBQ25FLGFBQWEsR0FBRyxXQUFXLENBQUMsWUFBYSxDQUFDLGFBQXVCLENBQUM7YUFDbkU7U0FDRjtRQUNELE9BQU8sRUFBRSxZQUFZLEVBQUUseUJBQXlCLEVBQUUsYUFBYSxFQUFFLENBQUM7SUFDcEUsQ0FBQztJQUVELEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUErQjtRQUNwRCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxLQUFLLENBQUMsZUFBZSxDQUFDLE1BQTRCO1FBQ2hELE1BQU0sSUFBSSxvQ0FBeUIsRUFBRSxDQUFDO0lBQ3hDLENBQUM7SUFFRCxLQUFLLENBQUMsaUJBQWlCLENBQUMsTUFBZ0M7UUFDdEQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsdUJBQXVCLENBQUMsTUFBYztRQUNwQyxPQUFPLElBQUksYUFBVSxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLFdBQUssQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBbUIsQ0FBQyxDQUFDLENBQUM7SUFDdEgsQ0FBQztJQUVPLFVBQVU7UUFDaEIsT0FBTyxJQUFJLCtCQUF5QixDQUFDLGVBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNuRSxDQUFDOztBQXZsQkgsa0JBd2xCQztBQXprQmtCLGVBQVcsR0FBRyxLQUFLLENBQUM7QUFFcEIsc0JBQWtCLEdBQUcsS0FBSyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgQmFzZUNvaW4sXG4gIEJpdEdvQmFzZSxcbiAgRG90QXNzZXRUeXBlcyxcbiAgRWRkc2EsXG4gIEVudmlyb25tZW50cyxcbiAgRXhwbGFuYXRpb25SZXN1bHQsXG4gIEtleVBhaXIsXG4gIE1ldGhvZE5vdEltcGxlbWVudGVkRXJyb3IsXG4gIE1QQ0FsZ29yaXRobSxcbiAgUGFyc2VkVHJhbnNhY3Rpb24sXG4gIFBhcnNlVHJhbnNhY3Rpb25PcHRpb25zLFxuICBTaWduZWRUcmFuc2FjdGlvbixcbiAgU2lnblRyYW5zYWN0aW9uT3B0aW9ucyBhcyBCYXNlU2lnblRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgVW5zaWduZWRUcmFuc2FjdGlvbixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbiAgRUREU0FNZXRob2RzLFxuICBFRERTQU1ldGhvZFR5cGVzLFxuICBNUENUeCxcbiAgTVBDUmVjb3ZlcnlPcHRpb25zLFxuICBNUENDb25zb2xpZGF0aW9uUmVjb3ZlcnlPcHRpb25zLFxuICBNUENTd2VlcFR4cyxcbiAgUmVjb3ZlcnlUeFJlcXVlc3QsXG4gIE1QQ1Vuc2lnbmVkVHgsXG4gIE1QQ1N3ZWVwUmVjb3ZlcnlPcHRpb25zLFxuICBNUENUeHMsXG59IGZyb20gJ0BiaXRnby9zZGstY29yZSc7XG5pbXBvcnQgeyBCYXNlQ29pbiBhcyBTdGF0aWNzQmFzZUNvaW4sIGNvaW5zLCBQb2xrYWRvdFNwZWNOYW1lVHlwZSB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IEludGVyZmFjZSwgS2V5UGFpciBhcyBEb3RLZXlQYWlyLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeSwgVXRpbHMgfSBmcm9tICcuL2xpYic7XG5pbXBvcnQgeyBBcGlQcm9taXNlLCBXc1Byb3ZpZGVyIH0gZnJvbSAnQHBvbGthZG90L2FwaSc7XG5pbXBvcnQgeyBNYXRlcmlhbCB9IGZyb20gJy4vbGliL2lmYWNlJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGdldERlcml2YXRpb25QYXRoIH0gZnJvbSAnQGJpdGdvL3Nkay1saWItbXBjJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0NBTl9GQUNUT1IgPSAyMDsgLy8gZGVmYXVsdCBudW1iZXIgb2YgcmVjZWl2ZSBhZGRyZXNzZXMgdG8gc2NhbiBmb3IgZnVuZHNcblxuZXhwb3J0IGludGVyZmFjZSBTaWduVHJhbnNhY3Rpb25PcHRpb25zIGV4dGVuZHMgQmFzZVNpZ25UcmFuc2FjdGlvbk9wdGlvbnMge1xuICB0eFByZWJ1aWxkOiBUcmFuc2FjdGlvblByZWJ1aWxkO1xuICBwcnY6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2FjdGlvblByZWJ1aWxkIHtcbiAgdHhIZXg6IHN0cmluZztcbiAgdHJhbnNhY3Rpb246IEludGVyZmFjZS5UeERhdGE7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXhwbGFpblRyYW5zYWN0aW9uT3B0aW9ucyB7XG4gIHR4UHJlYnVpbGQ6IFRyYW5zYWN0aW9uUHJlYnVpbGQ7XG4gIHB1YmxpY0tleTogc3RyaW5nO1xuICBmZWVJbmZvOiB7XG4gICAgZmVlOiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmVyaWZpZWRUcmFuc2FjdGlvblBhcmFtZXRlcnMge1xuICB0eEhleDogc3RyaW5nO1xuICBwcnY6IHN0cmluZztcbn1cblxuY29uc3QgZG90VXRpbHMgPSBVdGlscy5kZWZhdWx0O1xuXG5leHBvcnQgY2xhc3MgRG90IGV4dGVuZHMgQmFzZUNvaW4ge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3N0YXRpY3NDb2luOiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+O1xuICByZWFkb25seSBNQVhfVkFMSURJVFlfRFVSQVRJT04gPSAyNDAwO1xuICByZWFkb25seSBTV0VFUF9UWE5fRFVSQVRJT04gPSA2NDtcblxuICBjb25zdHJ1Y3RvcihiaXRnbzogQml0R29CYXNlLCBzdGF0aWNzQ29pbj86IFJlYWRvbmx5PFN0YXRpY3NCYXNlQ29pbj4pIHtcbiAgICBzdXBlcihiaXRnbyk7XG5cbiAgICBpZiAoIXN0YXRpY3NDb2luKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcmVxdWlyZWQgY29uc3RydWN0b3IgcGFyYW1ldGVyIHN0YXRpY3NDb2luJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGljc0NvaW4gPSBzdGF0aWNzQ29pbjtcbiAgfVxuXG4gIHByb3RlY3RlZCBzdGF0aWMgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJvdGVjdGVkIHN0YXRpYyBNUEM6IEVkZHNhO1xuICBwcm90ZWN0ZWQgc3RhdGljIG5vZGVBcGlJbml0aWFsaXplZCA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgc3RhdGljIEFQSTogQXBpUHJvbWlzZTtcblxuICBzdGF0aWMgY3JlYXRlSW5zdGFuY2UoYml0Z286IEJpdEdvQmFzZSwgc3RhdGljc0NvaW4/OiBSZWFkb25seTxTdGF0aWNzQmFzZUNvaW4+KTogQmFzZUNvaW4ge1xuICAgIHJldHVybiBuZXcgRG90KGJpdGdvLCBzdGF0aWNzQ29pbik7XG4gIH1cblxuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZG90JztcbiAgfVxuXG4gIGdldEJhc2VDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZG90JztcbiAgfVxuXG4gIGdldEZhbWlseSgpOiBzdHJpbmcge1xuICAgIHJldHVybiAnZG90JztcbiAgfVxuXG4gIGdldEZ1bGxOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdQb2xrYWRvdCc7XG4gIH1cblxuICBnZXRCYXNlRmFjdG9yKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGF0aWNzQ29pbi5kZWNpbWFsUGxhY2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGZvciBzZW5kaW5nIHZhbHVlIG9mIDBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb2theSB0byBzZW5kIDAgdmFsdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgdmFsdWVsZXNzVHJhbnNmZXJBbGxvd2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIHN1cHBvcnRzVHNzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZ2V0TVBDQWxnb3JpdGhtKCk6IE1QQ0FsZ29yaXRobSB7XG4gICAgcmV0dXJuICdlZGRzYSc7XG4gIH1cblxuICBhbGxvd3NBY2NvdW50Q29uc29saWRhdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgZWQyNTUxOSBrZXkgcGFpclxuICAgKlxuICAgKiBAcGFyYW0gc2VlZFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgd2l0aCBnZW5lcmF0ZWQgcHViLCBwcnZcbiAgICovXG4gIGdlbmVyYXRlS2V5UGFpcihzZWVkPzogQnVmZmVyKTogS2V5UGFpciB7XG4gICAgY29uc3Qga2V5UGFpciA9IHNlZWQgPyBkb3RVdGlscy5rZXlQYWlyRnJvbVNlZWQobmV3IFVpbnQ4QXJyYXkoc2VlZCkpIDogbmV3IERvdEtleVBhaXIoKTtcbiAgICBjb25zdCBrZXlzID0ga2V5UGFpci5nZXRLZXlzKCk7XG4gICAgaWYgKCFrZXlzLnBydikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBydiBpbiBrZXkgZ2VuZXJhdGlvbi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1Yjoga2V5cy5wdWIsXG4gICAgICBwcnY6IGtleXMucHJ2LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGlucHV0IGlzIHZhbGlkIHB1YmxpYyBrZXkgZm9yIHRoZSBjb2luLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHViIHRoZSBwdWIgdG8gYmUgY2hlY2tlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXMgaXQgdmFsaWQ/XG4gICAqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRvdFV0aWxzLmlzVmFsaWRQdWJsaWNLZXkocHViKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHN1cHBsaWVkIHByaXZhdGUga2V5IGlzIGEgdmFsaWQgZG90IHByaXZhdGUga2V5XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcnYgdGhlIHBydiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRQcnYocHJ2OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZG90VXRpbHMuaXNWYWxpZFByaXZhdGVLZXkocHJ2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgaW5wdXQgaXMgdmFsaWQgcHVibGljIGtleSBmb3IgdGhlIGNvaW5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIHB1YiB0byBiZSBjaGVja2VkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBpcyBpdCB2YWxpZD9cbiAgICovXG4gIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3M6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkb3RVdGlscy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIG1lc3NhZ2Ugd2l0aCBwcml2YXRlIGtleVxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBtZXNzYWdlXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gQSBzaWduYXR1cmUgb3ZlciB0aGUgZ2l2ZW4gbWVzc2FnZSB1c2luZyB0aGUgZ2l2ZW4ga2V5XG4gICAqL1xuICBhc3luYyBzaWduTWVzc2FnZShrZXk6IEtleVBhaXIsIG1lc3NhZ2U6IHN0cmluZyB8IEJ1ZmZlcik6IFByb21pc2U8QnVmZmVyPiB7XG4gICAgY29uc3QgbXNnID0gQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2UpID8gbWVzc2FnZS50b1N0cmluZygndXRmOCcpIDogbWVzc2FnZTtcbiAgICAvLyByZWNvbnN0aXR1dGUga2V5cyBhbmQgc2lnblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShuZXcgRG90S2V5UGFpcih7IHBydjoga2V5LnBydiB9KS5zaWduTWVzc2FnZShtc2cpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBsYWluL3BhcnNlIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB1bnNpZ25lZFRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBleHBsYWluVHJhbnNhY3Rpb24odW5zaWduZWRUcmFuc2FjdGlvbjogVW5zaWduZWRUcmFuc2FjdGlvbik6IFByb21pc2U8RXhwbGFuYXRpb25SZXN1bHQ+IHtcbiAgICBsZXQgb3V0cHV0QW1vdW50ID0gMDtcbiAgICB1bnNpZ25lZFRyYW5zYWN0aW9uLnBhcnNlZFR4Lm91dHB1dHMuZm9yRWFjaCgobykgPT4ge1xuICAgICAgb3V0cHV0QW1vdW50ICs9IHBhcnNlSW50KG8udmFsdWVTdHJpbmcsIDEwKTtcbiAgICB9KTtcbiAgICBjb25zdCBleHBsYW5hdGlvblJlc3VsdDogRXhwbGFuYXRpb25SZXN1bHQgPSB7XG4gICAgICBkaXNwbGF5T3JkZXI6IFtcbiAgICAgICAgJ291dHB1dEFtb3VudCcsXG4gICAgICAgICdjaGFuZ2VBbW91bnQnLFxuICAgICAgICAnb3V0cHV0cycsXG4gICAgICAgICdjaGFuZ2VPdXRwdXRzJyxcbiAgICAgICAgJ2ZlZScsXG4gICAgICAgICd0eXBlJyxcbiAgICAgICAgJ3NlcXVlbmNlSWQnLFxuICAgICAgICAnaWQnLFxuICAgICAgICAnYmxvY2tOdW1iZXInLFxuICAgICAgXSxcbiAgICAgIHNlcXVlbmNlSWQ6IHVuc2lnbmVkVHJhbnNhY3Rpb24ucGFyc2VkVHguc2VxdWVuY2VJZCxcbiAgICAgIGZlZTogdW5zaWduZWRUcmFuc2FjdGlvbi5mZWVJbmZvPy5mZWVTdHJpbmcsXG4gICAgICBpZDogdW5zaWduZWRUcmFuc2FjdGlvbi5wYXJzZWRUeC5pZCxcbiAgICAgIHR5cGU6IHVuc2lnbmVkVHJhbnNhY3Rpb24ucGFyc2VkVHgudHlwZSxcbiAgICAgIG91dHB1dHM6IHVuc2lnbmVkVHJhbnNhY3Rpb24ucGFyc2VkVHgub3V0cHV0cyxcbiAgICAgIGJsb2NrTnVtYmVyOiB1bnNpZ25lZFRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYz8uYmxvY2tOdW1iZXIsXG4gICAgICBvdXRwdXRBbW91bnQ6IG91dHB1dEFtb3VudCxcbiAgICAgIGNoYW5nZU91dHB1dHM6IFtdLFxuICAgICAgY2hhbmdlQW1vdW50OiAnMCcsXG4gICAgfTtcblxuICAgIHJldHVybiBleHBsYW5hdGlvblJlc3VsdDtcbiAgfVxuXG4gIHZlcmlmeVNpZ25UcmFuc2FjdGlvblBhcmFtcyhwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBWZXJpZmllZFRyYW5zYWN0aW9uUGFyYW1ldGVycyB7XG4gICAgY29uc3QgcHJ2ID0gcGFyYW1zLnBydjtcblxuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zLnR4UHJlYnVpbGQudHhIZXg7XG5cbiAgICBpZiAoIXR4SGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdHhQcmVidWlsZCBwYXJhbWV0ZXInKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaXNTdHJpbmcodHhIZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHR4UHJlYnVpbGQgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCB0eXBlICR7dHlwZW9mIHR4SGV4fWApO1xuICAgIH1cblxuICAgIGlmICghcHJ2KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgcHJ2IHBhcmFtZXRlciB0byBzaWduIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmlzU3RyaW5nKHBydikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcHJ2IG11c3QgYmUgYSBzdHJpbmcsIGdvdCB0eXBlICR7dHlwZW9mIHBydn1gKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaGFzKHBhcmFtcywgJ3B1YnMnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHB1YmxpYyBrZXkgcGFyYW1ldGVyIHRvIHNpZ24gdHJhbnNhY3Rpb24nKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eEhleCwgcHJ2IH07XG4gIH1cblxuICAvKipcbiAgICogQXNzZW1ibGUga2V5Y2hhaW4gYW5kIGhhbGYtc2lnbiBwcmVidWlsdCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMudHhQcmVidWlsZCB7VHJhbnNhY3Rpb25QcmVidWlsZH0gcHJlYnVpbGQgb2JqZWN0IHJldHVybmVkIGJ5IHBsYXRmb3JtXG4gICAqIEBwYXJhbSBwYXJhbXMucHJ2IHtTdHJpbmd9IHVzZXIgcHJ2XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPn1cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihwYXJhbXM6IFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFNpZ25lZFRyYW5zYWN0aW9uPiB7XG4gICAgY29uc3QgeyB0eEhleCwgcHJ2IH0gPSB0aGlzLnZlcmlmeVNpZ25UcmFuc2FjdGlvblBhcmFtcyhwYXJhbXMpO1xuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmdldEJ1aWxkZXIoKTtcbiAgICBjb25zdCB0eEJ1aWxkZXIgPSBmYWN0b3J5LmZyb20odHhIZXgpO1xuICAgIGNvbnN0IGtleVBhaXIgPSBuZXcgRG90S2V5UGFpcih7IHBydjogcHJ2IH0pO1xuICAgIGNvbnN0IHsgcmVmZXJlbmNlQmxvY2ssIGJsb2NrTnVtYmVyLCB0cmFuc2FjdGlvblZlcnNpb24sIHNlbmRlciB9ID0gcGFyYW1zLnR4UHJlYnVpbGQudHJhbnNhY3Rpb247XG5cbiAgICB0eEJ1aWxkZXJcbiAgICAgIC52YWxpZGl0eSh7IGZpcnN0VmFsaWQ6IGJsb2NrTnVtYmVyLCBtYXhEdXJhdGlvbjogdGhpcy5NQVhfVkFMSURJVFlfRFVSQVRJT04gfSlcbiAgICAgIC5yZWZlcmVuY2VCbG9jayhyZWZlcmVuY2VCbG9jaylcbiAgICAgIC52ZXJzaW9uKHRyYW5zYWN0aW9uVmVyc2lvbilcbiAgICAgIC5zZW5kZXIoeyBhZGRyZXNzOiBzZW5kZXIgfSlcbiAgICAgIC5zaWduKHsga2V5OiBrZXlQYWlyLmdldEtleXMoKS5wcnYgfSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBhd2FpdCB0eEJ1aWxkZXIuYnVpbGQoKTtcbiAgICBpZiAoIXRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVkVHhIZXggPSB0cmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuICAgIHJldHVybiB7IHR4SGV4OiBzaWduZWRUeEhleCB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEluaXRpYWxpemVkTm9kZUFQSSgpOiBQcm9taXNlPEFwaVByb21pc2U+IHtcbiAgICBpZiAoIURvdC5ub2RlQXBpSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGNvbnN0IHdzUHJvdmlkZXIgPSBuZXcgV3NQcm92aWRlcihFbnZpcm9ubWVudHNbdGhpcy5iaXRnby5nZXRFbnYoKV0uZG90Tm9kZVVybHMpO1xuICAgICAgRG90LkFQSSA9IGF3YWl0IEFwaVByb21pc2UuY3JlYXRlKHsgcHJvdmlkZXI6IHdzUHJvdmlkZXIgfSk7XG4gICAgICBEb3Qubm9kZUFwaUluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIERvdC5BUEk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QWNjb3VudEluZm8od2FsbGV0QWRkcjogc3RyaW5nKTogUHJvbWlzZTx7IG5vbmNlOiBudW1iZXI7IGZyZWVCYWxhbmNlOiBudW1iZXIgfT4ge1xuICAgIGNvbnN0IGFwaSA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbGl6ZWROb2RlQVBJKCk7XG4gICAgY29uc3QgeyBub25jZSwgZGF0YTogYmFsYW5jZSB9ID0gYXdhaXQgYXBpLnF1ZXJ5LnN5c3RlbS5hY2NvdW50KHdhbGxldEFkZHIpO1xuICAgIHJldHVybiB7IG5vbmNlOiBub25jZS50b051bWJlcigpLCBmcmVlQmFsYW5jZTogYmFsYW5jZS5mcmVlLnRvTnVtYmVyKCkgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBnZXRIZWFkZXJJbmZvKCk6IFByb21pc2U8eyBoZWFkZXJOdW1iZXI6IG51bWJlcjsgaGVhZGVySGFzaDogc3RyaW5nIH0+IHtcbiAgICBjb25zdCBhcGkgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxpemVkTm9kZUFQSSgpO1xuICAgIGNvbnN0IHsgbnVtYmVyLCBoYXNoIH0gPSBhd2FpdCBhcGkucnBjLmNoYWluLmdldEhlYWRlcigpO1xuICAgIHJldHVybiB7IGhlYWRlck51bWJlcjogbnVtYmVyLnRvTnVtYmVyKCksIGhlYWRlckhhc2g6IGhhc2gudG9TdHJpbmcoKSB9O1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEVzdGltYXRlIHRoZSBmZWUgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0QWRkciBkZXN0aW5hdGlvbiB3YWxsZXQgYWRkcmVzc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjQWRkciBzb3VyY2Ugd2FsbGV0IGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCBhbW91bnQgdG8gdHJhbnNmZXJcbiAgICogQHJldHVybnMge251bWJlcn0gdGhlIGVzdGltYXRlZCBmZWUgdGhlIHRyYW5zYWN0aW9uIHdpbGwgY29zdFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vcG9sa2Fkb3QuanMub3JnL2RvY3MvYXBpL2Nvb2tib29rL3R4I2hvdy1kby1pLWVzdGltYXRlLXRoZS10cmFuc2FjdGlvbi1mZWVzXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0RmVlKGRlc3RBZGRyOiBzdHJpbmcsIHNyY0FkZHI6IHN0cmluZywgYW1vdW50OiBudW1iZXIpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIGNvbnN0IGFwaSA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbGl6ZWROb2RlQVBJKCk7XG4gICAgY29uc3QgaW5mbyA9IGF3YWl0IGFwaS50eC5iYWxhbmNlcy50cmFuc2ZlcihkZXN0QWRkciwgYW1vdW50KS5wYXltZW50SW5mbyhzcmNBZGRyKTtcbiAgICByZXR1cm4gaW5mby5wYXJ0aWFsRmVlLnRvTnVtYmVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0TWF0ZXJpYWwoKTogUHJvbWlzZTxNYXRlcmlhbD4ge1xuICAgIGNvbnN0IGFwaSA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbGl6ZWROb2RlQVBJKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVzaXNIYXNoOiBhcGkuZ2VuZXNpc0hhc2gudG9TdHJpbmcoKSxcbiAgICAgIGNoYWluTmFtZTogYXBpLnJ1bnRpbWVDaGFpbi50b1N0cmluZygpLFxuICAgICAgc3BlY05hbWU6IGFwaS5ydW50aW1lVmVyc2lvbi5zcGVjTmFtZS50b1N0cmluZygpIGFzIFBvbGthZG90U3BlY05hbWVUeXBlLFxuICAgICAgc3BlY1ZlcnNpb246IGFwaS5ydW50aW1lVmVyc2lvbi5zcGVjVmVyc2lvbi50b051bWJlcigpLFxuICAgICAgdHhWZXJzaW9uOiBhcGkucnVudGltZVZlcnNpb24udHJhbnNhY3Rpb25WZXJzaW9uLnRvTnVtYmVyKCksXG4gICAgICBtZXRhZGF0YTogYXBpLnJ1bnRpbWVNZXRhZGF0YS50b0hleCgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGEgZnVuZHMgcmVjb3ZlcnkgdHJhbnNhY3Rpb24gd2l0aG91dCBCaXRHb1xuICAgKiBAcGFyYW0ge01QQ1JlY292ZXJ5T3B0aW9uc30gcGFyYW1zIHBhcmFtZXRlcnMgbmVlZGVkIHRvIGNvbnN0cnVjdCBhbmRcbiAgICogKG1heWJlKSBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7TVBDVHh9IHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGhleCBzdHJpbmcgYW5kIGluZGV4XG4gICAqIG9mIHRoZSBhZGRyZXNzIGJlaW5nIHN3ZXB0XG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogTVBDUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxNUENUeCB8IE1QQ1N3ZWVwVHhzPiB7XG4gICAgaWYgKCFwYXJhbXMuYml0Z29LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiaXRnb0tleScpO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIHx8ICF0aGlzLmlzVmFsaWRBZGRyZXNzKHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJlY292ZXJ5RGVzdGluYXRpb24nKTtcbiAgICB9XG5cbiAgICBjb25zdCBiaXRnb0tleSA9IHBhcmFtcy5iaXRnb0tleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGNvbnN0IGlzVW5zaWduZWRTd2VlcCA9ICFwYXJhbXMudXNlcktleSAmJiAhcGFyYW1zLmJhY2t1cEtleSAmJiAhcGFyYW1zLndhbGxldFBhc3NwaHJhc2U7XG5cbiAgICBjb25zdCBNUEMgPSBhd2FpdCBFRERTQU1ldGhvZHMuZ2V0SW5pdGlhbGl6ZWRNcGNJbnN0YW5jZSgpO1xuXG4gICAgY29uc3QgaW5kZXggPSBwYXJhbXMuaW5kZXggfHwgMDtcbiAgICBjb25zdCBjdXJyUGF0aCA9IHBhcmFtcy5zZWVkID8gZ2V0RGVyaXZhdGlvblBhdGgocGFyYW1zLnNlZWQpICsgYC8ke2luZGV4fWAgOiBgbS8ke2luZGV4fWA7XG4gICAgY29uc3QgYWNjb3VudElkID0gTVBDLmRlcml2ZVVuaGFyZGVuZWQoYml0Z29LZXksIGN1cnJQYXRoKS5zbGljZSgwLCA2NCk7XG4gICAgY29uc3Qgc2VuZGVyQWRkciA9IHRoaXMuZ2V0QWRkcmVzc0Zyb21QdWJsaWNLZXkoYWNjb3VudElkKTtcblxuICAgIGNvbnN0IHsgbm9uY2UsIGZyZWVCYWxhbmNlIH0gPSBhd2FpdCB0aGlzLmdldEFjY291bnRJbmZvKHNlbmRlckFkZHIpO1xuICAgIGNvbnN0IGRlc3RBZGRyID0gcGFyYW1zLnJlY292ZXJ5RGVzdGluYXRpb247XG4gICAgY29uc3QgYW1vdW50ID0gZnJlZUJhbGFuY2U7XG4gICAgY29uc3QgcGFydGlhbEZlZSA9IGF3YWl0IHRoaXMuZ2V0RmVlKGRlc3RBZGRyLCBzZW5kZXJBZGRyLCBhbW91bnQpO1xuICAgIC8vIFBvbGthZG90IGhhcyBhIGNvbmNlcHQgb2YgZXhpc3RlbnRpYWwgZGVzcG9zaXQgKGVkKSwgaXQgaXMgdGhlIG1pbmltdW0gYW1vdW50IHJlcXVpcmVkIGJ5IGFuIGFkZHJlc3MgdG8gaGF2ZVxuICAgIC8vIHRvIGtlZXAgdGhlIGFjY291bnQgYWN0aXZlXG4gICAgY29uc3QgZXhpc3RlbnRpYWxEZXBvc2l0ID0gdGhpcy5nZXRDaGFpbigpID09PSAndGRvdCcgPyAxMDAwMDAwMDAwMCA6IDEwMDAwMDAwMDAwMDA7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgQmlnTnVtYmVyKGZyZWVCYWxhbmNlKS5taW51cyhuZXcgQmlnTnVtYmVyKGV4aXN0ZW50aWFsRGVwb3NpdCkpLm1pbnVzKG5ldyBCaWdOdW1iZXIocGFydGlhbEZlZSkpO1xuICAgIGlmICh2YWx1ZS50b051bWJlcigpIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGFkZHJlc3Mgd2l0aCBmdW5kcyB0byByZWNvdmVyJyk7XG4gICAgfVxuXG4gICAgLy8gZmlyc3QgYnVpbGQgdGhlIHVuc2lnbmVkIHR4blxuICAgIGNvbnN0IHsgaGVhZGVyTnVtYmVyLCBoZWFkZXJIYXNoIH0gPSBhd2FpdCB0aGlzLmdldEhlYWRlckluZm8oKTtcbiAgICBjb25zdCBtYXRlcmlhbCA9IGF3YWl0IHRoaXMuZ2V0TWF0ZXJpYWwoKTtcbiAgICBjb25zdCB2YWxpZGl0eVdpbmRvdyA9IHsgZmlyc3RWYWxpZDogaGVhZGVyTnVtYmVyLCBtYXhEdXJhdGlvbjogdGhpcy5NQVhfVkFMSURJVFlfRFVSQVRJT04gfTtcblxuICAgIGNvbnN0IHR4bkJ1aWxkZXIgPSB0aGlzLmdldEJ1aWxkZXIoKS5nZXRUcmFuc2ZlckJ1aWxkZXIoKS5tYXRlcmlhbChtYXRlcmlhbCk7XG4gICAgdHhuQnVpbGRlclxuICAgICAgLnN3ZWVwKClcbiAgICAgIC50byh7IGFkZHJlc3M6IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uIH0pXG4gICAgICAuc2VuZGVyKHsgYWRkcmVzczogc2VuZGVyQWRkciB9KVxuICAgICAgLnZhbGlkaXR5KHZhbGlkaXR5V2luZG93KVxuICAgICAgLnJlZmVyZW5jZUJsb2NrKGhlYWRlckhhc2gpXG4gICAgICAuc2VxdWVuY2VJZCh7IG5hbWU6ICdOb25jZScsIGtleXdvcmQ6ICdub25jZScsIHZhbHVlOiBub25jZSB9KVxuICAgICAgLmZlZSh7IGFtb3VudDogMCwgdHlwZTogJ3RpcCcgfSk7XG4gICAgY29uc3QgdW5zaWduZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0eG5CdWlsZGVyLmJ1aWxkKCkpIGFzIFRyYW5zYWN0aW9uO1xuXG4gICAgbGV0IHNlcmlhbGl6ZWRUeCA9IHVuc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcbiAgICBpZiAoIWlzVW5zaWduZWRTd2VlcCkge1xuICAgICAgaWYgKCFwYXJhbXMudXNlcktleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgdXNlcktleScpO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXJhbXMuYmFja3VwS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICAgIH1cbiAgICAgIGlmICghcGFyYW1zLndhbGxldFBhc3NwaHJhc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHdhbGxldCBwYXNzcGhyYXNlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFuIHVwIHdoaXRlc3BhY2UgZnJvbSBlbnRlcmVkIHZhbHVlc1xuICAgICAgY29uc3QgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICBjb25zdCBiYWNrdXBLZXkgPSBwYXJhbXMuYmFja3VwS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG5cbiAgICAgIC8vIERlY3J5cHQgcHJpdmF0ZSBrZXlzIGZyb20gS2V5Q2FyZCB2YWx1ZXNcbiAgICAgIGxldCB1c2VyUHJ2O1xuICAgICAgdHJ5IHtcbiAgICAgICAgdXNlclBydiA9IHRoaXMuYml0Z28uZGVjcnlwdCh7XG4gICAgICAgICAgaW5wdXQ6IHVzZXJLZXksXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNyeXB0aW5nIHVzZXIga2V5Y2hhaW46ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgLyoqIFRPRE8gQkctNTI0MTkgSW1wbGVtZW50IENvZGVjIGZvciBwYXJzaW5nICovXG4gICAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZSh1c2VyUHJ2KSBhcyBFRERTQU1ldGhvZFR5cGVzLlVzZXJTaWduaW5nTWF0ZXJpYWw7XG5cbiAgICAgIGxldCBiYWNrdXBQcnY7XG4gICAgICB0cnkge1xuICAgICAgICBiYWNrdXBQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICAgIGlucHV0OiBiYWNrdXBLZXksXG4gICAgICAgICAgcGFzc3dvcmQ6IHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNyeXB0aW5nIGJhY2t1cCBrZXljaGFpbjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBiYWNrdXBTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKGJhY2t1cFBydikgYXMgRUREU0FNZXRob2RUeXBlcy5CYWNrdXBTaWduaW5nTWF0ZXJpYWw7XG5cbiAgICAgIC8vIGFkZCBzaWduYXR1cmVcbiAgICAgIGNvbnN0IHNpZ25hdHVyZUhleCA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRUU1NTaWduYXR1cmUoXG4gICAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwsXG4gICAgICAgIGJhY2t1cFNpZ25pbmdNYXRlcmlhbCxcbiAgICAgICAgY3VyclBhdGgsXG4gICAgICAgIHVuc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgICk7XG4gICAgICBjb25zdCBkb3RLZXlQYWlyID0gbmV3IERvdEtleVBhaXIoeyBwdWI6IGFjY291bnRJZCB9KTtcbiAgICAgIHR4bkJ1aWxkZXIuYWRkU2lnbmF0dXJlKHsgcHViOiBkb3RLZXlQYWlyLmdldEtleXMoKS5wdWIgfSwgc2lnbmF0dXJlSGV4KTtcbiAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9uID0gYXdhaXQgdHhuQnVpbGRlci5idWlsZCgpO1xuICAgICAgc2VyaWFsaXplZFR4ID0gc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUG9sa2Fkb3QgaGFzIGEgY29uY2VwdCBvZiBleGlzdGVudGlhbCBkZXNwb3NpdCAoZWQpLCBpdCBpcyB0aGUgbWluaW11bSBhbW91bnQgcmVxdWlyZWQgYnkgYW4gYWRkcmVzcyB0byBoYXZlXG4gICAgICAvLyB0byBrZWVwIHRoZSBhY2NvdW50IGFjdGl2ZVxuICAgICAgY29uc3QgZXhpc3RlbnRpYWxEZXBvc2l0ID0gdGhpcy5nZXRDaGFpbigpID09PSAndGRvdCcgPyAxMDAwMDAwMDAwMCA6IDEwMDAwMDAwMDAwMDA7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5ldyBCaWdOdW1iZXIoZnJlZUJhbGFuY2UpLm1pbnVzKG5ldyBCaWdOdW1iZXIoZXhpc3RlbnRpYWxEZXBvc2l0KSk7XG4gICAgICBjb25zdCB3YWxsZXRDb2luID0gdGhpcy5nZXRDaGFpbigpO1xuICAgICAgY29uc3QgaW5wdXRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgYWRkcmVzczogdW5zaWduZWRUcmFuc2FjdGlvbi5pbnB1dHNbMF0uYWRkcmVzcyxcbiAgICAgICAgICB2YWx1ZVN0cmluZzogdmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUudG9OdW1iZXIoKSxcbiAgICAgICAgfSxcbiAgICAgIF07XG4gICAgICBjb25zdCBvdXRwdXRzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgYWRkcmVzczogdW5zaWduZWRUcmFuc2FjdGlvbi5vdXRwdXRzWzBdLmFkZHJlc3MsXG4gICAgICAgICAgdmFsdWVTdHJpbmc6IHZhbHVlLnRvU3RyaW5nKCksXG4gICAgICAgICAgY29pbk5hbWU6IHdhbGxldENvaW4sXG4gICAgICAgIH0sXG4gICAgICBdO1xuICAgICAgY29uc3Qgc3BlbmRBbW91bnQgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgY29uc3QgcGFyc2VkVHggPSB7IGlucHV0czogaW5wdXRzLCBvdXRwdXRzOiBvdXRwdXRzLCBzcGVuZEFtb3VudDogc3BlbmRBbW91bnQsIHR5cGU6ICcnIH07XG4gICAgICBjb25zdCBmZWVJbmZvID0geyBmZWU6IDAsIGZlZVN0cmluZzogJzAnIH07XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbjogTVBDVHggPSB7XG4gICAgICAgIHNlcmlhbGl6ZWRUeDogc2VyaWFsaXplZFR4LFxuICAgICAgICBzY2FuSW5kZXg6IGluZGV4LFxuICAgICAgICBjb2luOiB3YWxsZXRDb2luLFxuICAgICAgICBzaWduYWJsZUhleDogdW5zaWduZWRUcmFuc2FjdGlvbi5zaWduYWJsZVBheWxvYWQudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgICBkZXJpdmF0aW9uUGF0aDogY3VyclBhdGgsXG4gICAgICAgIHBhcnNlZFR4OiBwYXJzZWRUeCxcbiAgICAgICAgZmVlSW5mbzogZmVlSW5mbyxcbiAgICAgICAgY29pblNwZWNpZmljOiB7IC4uLnZhbGlkaXR5V2luZG93LCBjb21tb25LZXljaGFpbjogYml0Z29LZXkgfSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHVuc2lnbmVkVHg6IE1QQ1Vuc2lnbmVkVHggPSB7IHVuc2lnbmVkVHg6IHRyYW5zYWN0aW9uLCBzaWduYXR1cmVTaGFyZXM6IFtdIH07XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbnM6IE1QQ1Vuc2lnbmVkVHhbXSA9IFt1bnNpZ25lZFR4XTtcbiAgICAgIGNvbnN0IHR4UmVxdWVzdDogUmVjb3ZlcnlUeFJlcXVlc3QgPSB7XG4gICAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLFxuICAgICAgICB3YWxsZXRDb2luOiB3YWxsZXRDb2luLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHR4UmVxdWVzdHM6IE1QQ1N3ZWVwVHhzID0geyB0eFJlcXVlc3RzOiBbdHhSZXF1ZXN0XSB9O1xuICAgICAgcmV0dXJuIHR4UmVxdWVzdHM7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uOiBNUENUeCA9IHsgc2VyaWFsaXplZFR4OiBzZXJpYWxpemVkVHgsIHNjYW5JbmRleDogaW5kZXggfTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIG5hdGl2ZSBET1QgcmVjb3ZlcmllcyBvZiByZWNlaXZlIGFkZHJlc3NlcyBpbiBiYXRjaCB3aXRob3V0IEJpdEdvLlxuICAgKiBGdW5kcyB3aWxsIGJlIHJlY292ZXJlZCB0byBiYXNlIGFkZHJlc3MgZmlyc3QuIFlvdSBuZWVkIHRvIGluaXRpYXRlIGFub3RoZXIgc3dlZXAgdHhuIGFmdGVyIHRoYXQuXG4gICAqXG4gICAqIEBwYXJhbSB7TVBDQ29uc29saWRhdGlvblJlY292ZXJ5T3B0aW9uc30gcGFyYW1zIC0gb3B0aW9ucyBmb3IgY29uc29saWRhdGlvbiByZWNvdmVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuc3RhcnRpbmdTY2FuSW5kZXhdIC0gcmVjZWl2ZSBhZGRyZXNzIGluZGV4IHRvIHN0YXJ0IHNjYW5uaW5nIGZyb20uIGRlZmF1bHQgdG8gMSAoaW5jbHVzaXZlKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuZW5kaW5nU2NhbkluZGV4XSAtIHJlY2VpdmUgYWRkcmVzcyBpbmRleCB0byBlbmQgc2Nhbm5pbmcgYXQuIGRlZmF1bHQgdG8gc3RhcnRpbmdTY2FuSW5kZXggKyAyMCAoZXhjbHVzaXZlKS5cbiAgICovXG4gIGFzeW5jIHJlY292ZXJDb25zb2xpZGF0aW9ucyhwYXJhbXM6IE1QQ0NvbnNvbGlkYXRpb25SZWNvdmVyeU9wdGlvbnMpOiBQcm9taXNlPE1QQ1R4cyB8IE1QQ1N3ZWVwVHhzPiB7XG4gICAgY29uc3QgaXNVbnNpZ25lZFN3ZWVwID0gIXBhcmFtcy51c2VyS2V5ICYmICFwYXJhbXMuYmFja3VwS2V5ICYmICFwYXJhbXMud2FsbGV0UGFzc3BocmFzZTtcbiAgICBjb25zdCBzdGFydElkeCA9IHBhcmFtcy5zdGFydGluZ1NjYW5JbmRleCB8fCAxO1xuICAgIGNvbnN0IGVuZElkeCA9IHBhcmFtcy5lbmRpbmdTY2FuSW5kZXggfHwgc3RhcnRJZHggKyBERUZBVUxUX1NDQU5fRkFDVE9SO1xuXG4gICAgaWYgKHN0YXJ0SWR4IDwgMSB8fCBlbmRJZHggPD0gc3RhcnRJZHggfHwgZW5kSWR4IC0gc3RhcnRJZHggPiAxMCAqIERFRkFVTFRfU0NBTl9GQUNUT1IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgc3RhcnRpbmcgb3IgZW5kaW5nIGluZGV4IHRvIHNjYW4gZm9yIGFkZHJlc3Nlcy4gc3RhcnRpbmdTY2FuSW5kZXg6ICR7c3RhcnRJZHh9LCBlbmRpbmdTY2FuSW5kZXg6ICR7ZW5kSWR4fS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGJpdGdvS2V5ID0gcGFyYW1zLmJpdGdvS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgTVBDID0gYXdhaXQgRUREU0FNZXRob2RzLmdldEluaXRpYWxpemVkTXBjSW5zdGFuY2UoKTtcbiAgICBjb25zdCBiYXNlSW5kZXggPSAwO1xuICAgIGNvbnN0IGJhc2VQYXRoID0gcGFyYW1zLnNlZWQgPyBnZXREZXJpdmF0aW9uUGF0aChwYXJhbXMuc2VlZCkgKyBgLyR7YmFzZUluZGV4fWAgOiBgbS8ke2Jhc2VJbmRleH1gO1xuICAgIGNvbnN0IGFjY291bnRJZCA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGJpdGdvS2V5LCBiYXNlUGF0aCkuc2xpY2UoMCwgNjQpO1xuICAgIGNvbnN0IGJhc2VBZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzRnJvbVB1YmxpY0tleShhY2NvdW50SWQpO1xuXG4gICAgY29uc3QgY29uc29saWRhdGlvblRyYW5zYWN0aW9uczogYW55W10gPSBbXTtcbiAgICBsZXQgbGFzdFNjYW5JbmRleCA9IHN0YXJ0SWR4O1xuICAgIGZvciAobGV0IGkgPSBzdGFydElkeDsgaSA8IGVuZElkeDsgaSsrKSB7XG4gICAgICBjb25zdCByZWNvdmVyUGFyYW1zID0ge1xuICAgICAgICB1c2VyS2V5OiBwYXJhbXMudXNlcktleSxcbiAgICAgICAgYmFja3VwS2V5OiBwYXJhbXMuYmFja3VwS2V5LFxuICAgICAgICBiaXRnb0tleTogcGFyYW1zLmJpdGdvS2V5LFxuICAgICAgICB3YWxsZXRQYXNzcGhyYXNlOiBwYXJhbXMud2FsbGV0UGFzc3BocmFzZSxcbiAgICAgICAgcmVjb3ZlcnlEZXN0aW5hdGlvbjogYmFzZUFkZHJlc3MsXG4gICAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgIH07XG5cbiAgICAgIGxldCByZWNvdmVyeVRyYW5zYWN0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVjb3ZlcnlUcmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMucmVjb3ZlcihyZWNvdmVyUGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gJ0RpZCBub3QgZmluZCBhZGRyZXNzIHdpdGggZnVuZHMgdG8gcmVjb3ZlcicpIHtcbiAgICAgICAgICBsYXN0U2NhbkluZGV4ID0gaTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAgIGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnMucHVzaCgocmVjb3ZlcnlUcmFuc2FjdGlvbiBhcyBNUENTd2VlcFR4cykudHhSZXF1ZXN0c1swXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLnB1c2gocmVjb3ZlcnlUcmFuc2FjdGlvbik7XG4gICAgICB9XG4gICAgICBsYXN0U2NhbkluZGV4ID0gaTtcbiAgICB9XG5cbiAgICBpZiAoY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGZpbmQgYW4gYWRkcmVzcyB3aXRoIGZ1bmRzIHRvIHJlY292ZXInKTtcbiAgICB9XG5cbiAgICBpZiAoaXNVbnNpZ25lZFN3ZWVwKSB7XG4gICAgICAvLyBsYXN0U2NhbkluZGV4IHdpbGwgYmUgdXNlZCB0byBpbmZvcm0gdXNlciB0aGUgbGFzdCBhZGRyZXNzIGluZGV4IHNjYW5uZWQgZm9yIGF2YWlsYWJsZSBmdW5kcyAoc28gdGhleSBjYW5cbiAgICAgIC8vIGFwcHJvcHJpYXRlbHkgYWRqdXN0IHRoZSBzY2FuIHJhbmdlIG9uIHRoZSBuZXh0IGl0ZXJhdGlvbiBvZiBjb25zb2xpZGF0aW9uIHJlY292ZXJpZXMpLiBJbiB0aGUgY2FzZSBvZiB1bnNpZ25lZFxuICAgICAgLy8gc3dlZXAgY29uc29saWRhdGlvbnMsIHRoaXMgbGFzdFNjYW5JbmRleCB3aWxsIGJlIHByb3ZpZGVkIGluIHRoZSBjb2luU3BlY2lmaWMgb2YgdGhlIGxhc3QgdHhuIG1hZGUuXG4gICAgICBjb25zdCBsYXN0VHJhbnNhY3Rpb25Db2luU3BlY2lmaWMgPSB7XG4gICAgICAgIGZpcnN0VmFsaWQ6XG4gICAgICAgICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9uc1tjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLnRyYW5zYWN0aW9uc1swXS51bnNpZ25lZFR4LmNvaW5TcGVjaWZpY1xuICAgICAgICAgICAgLmZpcnN0VmFsaWQsXG4gICAgICAgIG1heER1cmF0aW9uOlxuICAgICAgICAgIGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnNbY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5sZW5ndGggLSAxXS50cmFuc2FjdGlvbnNbMF0udW5zaWduZWRUeC5jb2luU3BlY2lmaWNcbiAgICAgICAgICAgIC5tYXhEdXJhdGlvbixcbiAgICAgICAgY29tbW9uS2V5Y2hhaW46XG4gICAgICAgICAgY29uc29saWRhdGlvblRyYW5zYWN0aW9uc1tjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLnRyYW5zYWN0aW9uc1swXS51bnNpZ25lZFR4LmNvaW5TcGVjaWZpY1xuICAgICAgICAgICAgLmNvbW1vbktleWNoYWluLFxuICAgICAgICBsYXN0U2NhbkluZGV4OiBsYXN0U2NhbkluZGV4LFxuICAgICAgfTtcbiAgICAgIGNvbnNvbGlkYXRpb25UcmFuc2FjdGlvbnNbY29uc29saWRhdGlvblRyYW5zYWN0aW9ucy5sZW5ndGggLSAxXS50cmFuc2FjdGlvbnNbMF0udW5zaWduZWRUeC5jb2luU3BlY2lmaWMgPVxuICAgICAgICBsYXN0VHJhbnNhY3Rpb25Db2luU3BlY2lmaWM7XG4gICAgICBjb25zdCBjb25zb2xpZGF0aW9uU3dlZXBUcmFuc2FjdGlvbnM6IE1QQ1N3ZWVwVHhzID0geyB0eFJlcXVlc3RzOiBjb25zb2xpZGF0aW9uVHJhbnNhY3Rpb25zIH07XG4gICAgICByZXR1cm4gY29uc29saWRhdGlvblN3ZWVwVHJhbnNhY3Rpb25zO1xuICAgIH1cblxuICAgIHJldHVybiB7IHRyYW5zYWN0aW9uczogY29uc29saWRhdGlvblRyYW5zYWN0aW9ucywgbGFzdFNjYW5JbmRleCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZnVuZHMgc3dlZXAgcmVjb3ZlcnkgdHJhbnNhY3Rpb24ocykgd2l0aG91dCBCaXRHb1xuICAgKlxuICAgKiBAcGFyYW0ge01QQ1N3ZWVwUmVjb3ZlcnlPcHRpb25zfSBwYXJhbXMgcGFyYW1ldGVycyBuZWVkZWQgdG8gY29tYmluZSB0aGUgc2lnbmF0dXJlc1xuICAgKiBhbmQgdHJhbnNhY3Rpb25zIHRvIGNyZWF0ZSBicm9hZGNhc3RhYmxlIHRyYW5zYWN0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7TVBDVHhbXX0gYXJyYXkgb2YgdGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gaGV4IHN0cmluZ3MgYW5kIGluZGljZXNcbiAgICogb2YgdGhlIGFkZHJlc3NlcyBiZWluZyBzd2VwdFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQnJvYWRjYXN0YWJsZVN3ZWVwVHJhbnNhY3Rpb24ocGFyYW1zOiBNUENTd2VlcFJlY292ZXJ5T3B0aW9ucyk6IFByb21pc2U8TVBDVHhzPiB7XG4gICAgY29uc3QgcmVxID0gcGFyYW1zLnNpZ25hdHVyZVNoYXJlcztcbiAgICBjb25zdCBicm9hZGNhc3RhYmxlVHJhbnNhY3Rpb25zOiBNUENUeFtdID0gW107XG4gICAgbGV0IGxhc3RTY2FuSW5kZXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IE1QQyA9IGF3YWl0IEVERFNBTWV0aG9kcy5nZXRJbml0aWFsaXplZE1wY0luc3RhbmNlKCk7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHJlcVtpXS50eFJlcXVlc3QudHJhbnNhY3Rpb25zWzBdLnVuc2lnbmVkVHg7XG4gICAgICBpZiAoIXJlcVtpXS5vdmMgfHwgIXJlcVtpXS5vdmNbMF0uZWRkc2FTaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hdHVyZShzKScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcmVxW2ldLm92Y1swXS5lZGRzYVNpZ25hdHVyZTtcbiAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmFibGVIZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hYmxlIGhleCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHRyYW5zYWN0aW9uLnNpZ25hYmxlSGV4ISwgJ2hleCcpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gTVBDLnZlcmlmeShtZXNzYWdlQnVmZmVyLCBzaWduYXR1cmUpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlSGV4ID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oc2lnbmF0dXJlLlIsICdoZXgnKSwgQnVmZmVyLmZyb20oc2lnbmF0dXJlLnNpZ21hLCAnaGV4JyldKTtcbiAgICAgIGlmIChcbiAgICAgICAgIXRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYyB8fFxuICAgICAgICAhdHJhbnNhY3Rpb24uY29pblNwZWNpZmljPy5maXJzdFZhbGlkIHx8XG4gICAgICAgICF0cmFuc2FjdGlvbi5jb2luU3BlY2lmaWM/Lm1heER1cmF0aW9uXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHZhbGlkaXR5IHdpbmRvdycpO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRpdHlXaW5kb3cgPSB7XG4gICAgICAgIGZpcnN0VmFsaWQ6IHRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYz8uZmlyc3RWYWxpZCxcbiAgICAgICAgbWF4RHVyYXRpb246IHRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYz8ubWF4RHVyYXRpb24sXG4gICAgICB9O1xuICAgICAgY29uc3QgbWF0ZXJpYWwgPSBhd2FpdCB0aGlzLmdldE1hdGVyaWFsKCk7XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYz8uY29tbW9uS2V5Y2hhaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGNvbW1vbiBrZXljaGFpbicpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tbW9uS2V5Y2hhaW4gPSB0cmFuc2FjdGlvbi5jb2luU3BlY2lmaWMhLmNvbW1vbktleWNoYWluISBhcyBzdHJpbmc7XG4gICAgICBpZiAoIXRyYW5zYWN0aW9uLmRlcml2YXRpb25QYXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkZXJpdmF0aW9uIHBhdGgnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlcml2YXRpb25QYXRoID0gdHJhbnNhY3Rpb24uZGVyaXZhdGlvblBhdGggYXMgc3RyaW5nO1xuICAgICAgY29uc3QgYWNjb3VudElkID0gTVBDLmRlcml2ZVVuaGFyZGVuZWQoY29tbW9uS2V5Y2hhaW4sIGRlcml2YXRpb25QYXRoKS5zbGljZSgwLCA2NCk7XG4gICAgICBjb25zdCBzZW5kZXJBZGRyID0gdGhpcy5nZXRBZGRyZXNzRnJvbVB1YmxpY0tleShhY2NvdW50SWQpO1xuICAgICAgY29uc3QgdHhuQnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlcigpXG4gICAgICAgIC5tYXRlcmlhbChtYXRlcmlhbClcbiAgICAgICAgLmZyb20odHJhbnNhY3Rpb24uc2VyaWFsaXplZFR4IGFzIHN0cmluZylcbiAgICAgICAgLnNlbmRlcih7IGFkZHJlc3M6IHNlbmRlckFkZHIgfSlcbiAgICAgICAgLnZhbGlkaXR5KHZhbGlkaXR5V2luZG93KTtcbiAgICAgIGNvbnN0IGRvdEtleVBhaXIgPSBuZXcgRG90S2V5UGFpcih7IHB1YjogYWNjb3VudElkIH0pO1xuICAgICAgdHhuQnVpbGRlci5hZGRTaWduYXR1cmUoeyBwdWI6IGRvdEtleVBhaXIuZ2V0S2V5cygpLnB1YiB9LCBzaWduYXR1cmVIZXgpO1xuICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0eG5CdWlsZGVyLmJ1aWxkKCk7XG4gICAgICBjb25zdCBzZXJpYWxpemVkVHggPSBzaWduZWRUcmFuc2FjdGlvbi50b0Jyb2FkY2FzdEZvcm1hdCgpO1xuXG4gICAgICBicm9hZGNhc3RhYmxlVHJhbnNhY3Rpb25zLnB1c2goe1xuICAgICAgICBzZXJpYWxpemVkVHg6IHNlcmlhbGl6ZWRUeCxcbiAgICAgICAgc2NhbkluZGV4OiB0cmFuc2FjdGlvbi5zY2FuSW5kZXgsXG4gICAgICB9KTtcblxuICAgICAgaWYgKGkgPT09IHJlcS5sZW5ndGggLSAxICYmIHRyYW5zYWN0aW9uLmNvaW5TcGVjaWZpYyEubGFzdFNjYW5JbmRleCkge1xuICAgICAgICBsYXN0U2NhbkluZGV4ID0gdHJhbnNhY3Rpb24uY29pblNwZWNpZmljIS5sYXN0U2NhbkluZGV4IGFzIG51bWJlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdHJhbnNhY3Rpb25zOiBicm9hZGNhc3RhYmxlVHJhbnNhY3Rpb25zLCBsYXN0U2NhbkluZGV4IH07XG4gIH1cblxuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPFBhcnNlZFRyYW5zYWN0aW9uPiB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgYXN5bmMgaXNXYWxsZXRBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0aHJvdyBuZXcgTWV0aG9kTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9XG5cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGdldEFkZHJlc3NGcm9tUHVibGljS2V5KFB1YmtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbmV3IERvdEtleVBhaXIoeyBwdWI6IFB1YmtleSB9KS5nZXRBZGRyZXNzKFV0aWxzLmRlZmF1bHQuZ2V0QWRkcmVzc0Zvcm1hdCh0aGlzLmdldENoYWluKCkgYXMgRG90QXNzZXRUeXBlcykpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRCdWlsZGVyKCk6IFRyYW5zYWN0aW9uQnVpbGRlckZhY3Rvcnkge1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25CdWlsZGVyRmFjdG9yeShjb2lucy5nZXQodGhpcy5nZXRDaGFpbigpKSk7XG4gIH1cbn1cbiJdfQ==