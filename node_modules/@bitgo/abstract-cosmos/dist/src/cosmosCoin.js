"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmosCoin = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const sdk_lib_mpc_1 = require("@bitgo/sdk-lib-mpc");
const utxo_lib_1 = require("@bitgo/utxo-lib");
const bignumber_js_1 = require("bignumber.js");
const buffer_1 = require("buffer");
const crypto_1 = require("crypto");
const _ = require("lodash");
const querystring = require("querystring");
const request = require("superagent");
const url = require("url");
const constants_1 = require("./lib/constants");
const utils_1 = require("./lib/utils");
class CosmosCoin extends sdk_core_1.BaseCoin {
    constructor(bitgo, staticsCoin) {
        super(bitgo);
        if (!staticsCoin) {
            throw new Error('missing required constructor parameter staticsCoin');
        }
        this._staticsCoin = staticsCoin;
    }
    static createInstance(bitgo, staticsCoin) {
        return new CosmosCoin(bitgo, staticsCoin);
    }
    /**
     * Creates an instance of TransactionBuilderFactory for the coin specific sdk
     */
    getBuilder() {
        throw new Error('Method not implemented.');
    }
    /** @inheritDoc **/
    getBaseFactor() {
        throw new Error('Method not implemented');
    }
    /** @inheritDoc **/
    getChain() {
        return this._staticsCoin.name;
    }
    /** @inheritDoc **/
    getFamily() {
        return this._staticsCoin.family;
    }
    /** @inheritDoc **/
    getFullName() {
        return this._staticsCoin.fullName;
    }
    /** @inheritDoc */
    supportsTss() {
        return true;
    }
    /** @inheritDoc **/
    getMPCAlgorithm() {
        return 'ecdsa';
    }
    /** @inheritDoc **/
    isValidPub(pub) {
        return utils_1.default.isValidPublicKey(pub);
    }
    /** @inheritDoc **/
    isValidPrv(prv) {
        return utils_1.default.isValidPrivateKey(prv);
    }
    isValidAddress(address) {
        throw new Error('Method not implemented.');
    }
    /**
     * Builds a funds recovery transaction without BitGo
     * @param {RecoveryOptions} params parameters needed to construct and
     * (maybe) sign the transaction
     *
     * @returns {CosmosLikeCoinRecoveryOutput} the serialized transaction hex string and index
     * of the address being swept
     */
    async recover(params) {
        // Step 1: Check if params contains the required parameters
        if (!params.bitgoKey) {
            throw new Error('missing bitgoKey');
        }
        if (!params.recoveryDestination || !this.isValidAddress(params.recoveryDestination)) {
            throw new Error('invalid recoveryDestination');
        }
        if (!params.userKey) {
            throw new Error('missing userKey');
        }
        if (!params.backupKey) {
            throw new Error('missing backupKey');
        }
        if (!params.walletPassphrase) {
            throw new Error('missing wallet passphrase');
        }
        // Step 2: Fetch the bitgo key from params
        const bitgoKey = params.bitgoKey.replace(/\s/g, '');
        // Step 3: Instantiate the ECDSA signer and fetch the address details
        const MPC = new sdk_core_1.Ecdsa();
        const chainId = await this.getChainId();
        const publicKey = MPC.deriveUnhardened(bitgoKey, constants_1.ROOT_PATH).slice(0, 66);
        const senderAddress = this.getAddressFromPublicKey(publicKey);
        // Step 4: Fetch account details such as accountNo, balance and check for sufficient funds once gasAmount has been deducted
        const [accountNumber, sequenceNo] = await this.getAccountDetails(senderAddress);
        const balance = new bignumber_js_1.BigNumber(await this.getAccountBalance(senderAddress));
        const gasBudget = {
            amount: [{ denom: this.getDenomination(), amount: this.getGasAmountDetails().gasAmount }],
            gasLimit: this.getGasAmountDetails().gasLimit,
        };
        const gasAmount = new bignumber_js_1.BigNumber(gasBudget.amount[0].amount);
        const actualBalance = balance.minus(gasAmount);
        if (actualBalance.isLessThanOrEqualTo(0)) {
            throw new Error('Did not have enough funds to recover');
        }
        // Step 5: Once sufficient funds are present, construct the recover tx messsage
        const amount = [
            {
                denom: this.getDenomination(),
                amount: actualBalance.toFixed(),
            },
        ];
        const sendMessage = [
            {
                fromAddress: senderAddress,
                toAddress: params.recoveryDestination,
                amount: amount,
            },
        ];
        // Step 6: Build the unsigned tx using the constructed message
        const txnBuilder = this.getBuilder().getTransferBuilder();
        txnBuilder
            .messages(sendMessage)
            .gasBudget(gasBudget)
            .publicKey(publicKey)
            .sequence(Number(sequenceNo))
            .accountNumber(Number(accountNumber))
            .chainId(chainId);
        const unsignedTransaction = (await txnBuilder.build());
        let serializedTx = unsignedTransaction.toBroadcastFormat();
        const signableHex = unsignedTransaction.signablePayload.toString('hex');
        const userKey = params.userKey.replace(/\s/g, '');
        const backupKey = params.backupKey.replace(/\s/g, '');
        const [userKeyCombined, backupKeyCombined] = (() => {
            const [userKeyCombined, backupKeyCombined] = this.getKeyCombinedFromTssKeyShares(userKey, backupKey, params.walletPassphrase);
            return [userKeyCombined, backupKeyCombined];
        })();
        if (!userKeyCombined || !backupKeyCombined) {
            throw new Error('Missing combined key shares for user or backup');
        }
        // Step 7: Sign the tx
        const signature = await this.signRecoveryTSS(userKeyCombined, backupKeyCombined, signableHex);
        const signableBuffer = buffer_1.Buffer.from(signableHex, 'hex');
        MPC.verify(signableBuffer, signature, this.getHashFunction());
        const cosmosKeyPair = this.getKeyPair(publicKey);
        txnBuilder.addSignature({ pub: cosmosKeyPair.getKeys().pub }, buffer_1.Buffer.from(signature.r + signature.s, 'hex'));
        const signedTransaction = await txnBuilder.build();
        serializedTx = signedTransaction.toBroadcastFormat();
        return { serializedTx: serializedTx };
    }
    getKeyCombinedFromTssKeyShares(userPublicOrPrivateKeyShare, backupPrivateOrPublicKeyShare, walletPassphrase) {
        let backupPrv;
        let userPrv;
        try {
            backupPrv = this.bitgo.decrypt({
                input: backupPrivateOrPublicKeyShare,
                password: walletPassphrase,
            });
            userPrv = this.bitgo.decrypt({
                input: userPublicOrPrivateKeyShare,
                password: walletPassphrase,
            });
        }
        catch (e) {
            throw new Error(`Error decrypting backup keychain: ${e.message}`);
        }
        const userSigningMaterial = JSON.parse(userPrv);
        const backupSigningMaterial = JSON.parse(backupPrv);
        if (!userSigningMaterial.backupNShare) {
            throw new Error('Invalid user key - missing backupNShare');
        }
        if (!backupSigningMaterial.userNShare) {
            throw new Error('Invalid backup key - missing userNShare');
        }
        const MPC = new sdk_core_1.Ecdsa();
        const userKeyCombined = MPC.keyCombine(userSigningMaterial.pShare, [
            userSigningMaterial.bitgoNShare,
            userSigningMaterial.backupNShare,
        ]);
        const userSigningKeyDerived = MPC.keyDerive(userSigningMaterial.pShare, [userSigningMaterial.bitgoNShare, userSigningMaterial.backupNShare], 'm/0');
        const userKeyDerivedCombined = {
            xShare: userSigningKeyDerived.xShare,
            yShares: userKeyCombined.yShares,
        };
        const backupKeyCombined = MPC.keyCombine(backupSigningMaterial.pShare, [
            userSigningKeyDerived.nShares[2],
            backupSigningMaterial.bitgoNShare,
        ]);
        if (userKeyDerivedCombined.xShare.y !== backupKeyCombined.xShare.y ||
            userKeyDerivedCombined.xShare.chaincode !== backupKeyCombined.xShare.chaincode) {
            throw new Error('Common keychains do not match');
        }
        return [userKeyDerivedCombined, backupKeyCombined];
    }
    async signRecoveryTSS(userKeyCombined, backupKeyCombined, txHex, { rangeProofChallenge, } = {}) {
        const MPC = new sdk_core_1.Ecdsa();
        const signerOneIndex = userKeyCombined.xShare.i;
        const signerTwoIndex = backupKeyCombined.xShare.i;
        // Since this is a user <> backup signing, we will reuse the same range proof challenge
        rangeProofChallenge =
            rangeProofChallenge !== null && rangeProofChallenge !== void 0 ? rangeProofChallenge : sdk_lib_mpc_1.EcdsaTypes.serializeNtildeWithProofs(await sdk_lib_mpc_1.EcdsaRangeProof.generateNtilde());
        const userToBackupPaillierChallenge = await sdk_lib_mpc_1.EcdsaPaillierProof.generateP(sdk_core_1.hexToBigInt(userKeyCombined.yShares[signerTwoIndex].n));
        const backupToUserPaillierChallenge = await sdk_lib_mpc_1.EcdsaPaillierProof.generateP(sdk_core_1.hexToBigInt(backupKeyCombined.yShares[signerOneIndex].n));
        const userXShare = MPC.appendChallenge(userKeyCombined.xShare, rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: userToBackupPaillierChallenge }));
        const userYShare = MPC.appendChallenge(userKeyCombined.yShares[signerTwoIndex], rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: backupToUserPaillierChallenge }));
        const backupXShare = MPC.appendChallenge(backupKeyCombined.xShare, rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: backupToUserPaillierChallenge }));
        const backupYShare = MPC.appendChallenge(backupKeyCombined.yShares[signerOneIndex], rangeProofChallenge, sdk_lib_mpc_1.EcdsaTypes.serializePaillierChallenge({ p: userToBackupPaillierChallenge }));
        const signShares = await MPC.signShare(userXShare, userYShare);
        const signConvertS21 = await MPC.signConvertStep1({
            xShare: backupXShare,
            yShare: backupYShare,
            kShare: signShares.kShare,
        });
        const signConvertS12 = await MPC.signConvertStep2({
            aShare: signConvertS21.aShare,
            wShare: signShares.wShare,
        });
        const signConvertS21_2 = await MPC.signConvertStep3({
            muShare: signConvertS12.muShare,
            bShare: signConvertS21.bShare,
        });
        const [signCombineOne, signCombineTwo] = [
            MPC.signCombine({
                gShare: signConvertS12.gShare,
                signIndex: {
                    i: signConvertS12.muShare.i,
                    j: signConvertS12.muShare.j,
                },
            }),
            MPC.signCombine({
                gShare: signConvertS21_2.gShare,
                signIndex: {
                    i: signConvertS21_2.signIndex.i,
                    j: signConvertS21_2.signIndex.j,
                },
            }),
        ];
        const MESSAGE = buffer_1.Buffer.from(txHex, 'hex');
        const [signA, signB] = [
            MPC.sign(MESSAGE, signCombineOne.oShare, signCombineTwo.dShare, this.getHashFunction()),
            MPC.sign(MESSAGE, signCombineTwo.oShare, signCombineOne.dShare, this.getHashFunction()),
        ];
        return MPC.constructSignature([signA, signB]);
    }
    /** @inheritDoc **/
    async verifyTransaction(params) {
        var _a;
        let totalAmount = new bignumber_js_1.BigNumber(0);
        const { txPrebuild, txParams } = params;
        const rawTx = txPrebuild.txHex;
        if (!rawTx) {
            throw new Error('missing required tx prebuild property txHex');
        }
        const transaction = await this.getBuilder().from(rawTx).build();
        const explainedTx = transaction.explainTransaction();
        if (txParams.recipients && txParams.recipients.length > 0) {
            const filteredRecipients = (_a = txParams.recipients) === null || _a === void 0 ? void 0 : _a.map((recipient) => _.pick(recipient, ['address', 'amount']));
            const filteredOutputs = explainedTx.outputs.map((output) => _.pick(output, ['address', 'amount']));
            if (!_.isEqual(filteredOutputs, filteredRecipients)) {
                throw new Error('Tx outputs does not match with expected txParams recipients');
            }
            // WithdrawDelegatorRewards and ContractCall transaction don't have amount
            if (transaction.type !== sdk_core_1.TransactionType.StakingWithdraw && transaction.type !== sdk_core_1.TransactionType.ContractCall) {
                for (const recipients of txParams.recipients) {
                    totalAmount = totalAmount.plus(recipients.amount);
                }
                if (!totalAmount.isEqualTo(explainedTx.outputAmount)) {
                    throw new Error('Tx total amount does not match with expected total amount field');
                }
            }
        }
        return true;
    }
    /** @inheritDoc **/
    async explainTransaction(options) {
        if (!options.txHex) {
            throw new Error('missing required txHex parameter');
        }
        try {
            const transactionBuilder = this.getBuilder().from(options.txHex);
            const transaction = await transactionBuilder.build();
            return transaction.explainTransaction();
        }
        catch (e) {
            throw new Error('Invalid transaction: ' + e.message);
        }
    }
    /**
     * Sign a transaction with a single private key
     * @param params parameters in the form of { txPrebuild: {txHex}, prv }
     * @returns signed transaction in the form of { txHex }
     */
    async signTransaction(params) {
        var _a;
        const txHex = (_a = params === null || params === void 0 ? void 0 : params.txPrebuild) === null || _a === void 0 ? void 0 : _a.txHex;
        const privateKey = params === null || params === void 0 ? void 0 : params.prv;
        if (!txHex) {
            throw new sdk_core_1.SigningError('missing required txPrebuild parameter: params.txPrebuild.txHex');
        }
        if (!privateKey) {
            throw new sdk_core_1.SigningError('missing required prv parameter: params.prv');
        }
        const txBuilder = this.getBuilder().from(params.txPrebuild.txHex);
        txBuilder.sign({ key: params.prv });
        const transaction = await txBuilder.build();
        if (!transaction) {
            throw new sdk_core_1.SigningError('Failed to build signed transaction');
        }
        const serializedTx = transaction.toBroadcastFormat();
        return {
            txHex: serializedTx,
        };
    }
    /** @inheritDoc **/
    async parseTransaction(params) {
        const transactionExplanation = await this.explainTransaction({ txHex: params.txHex });
        if (!transactionExplanation) {
            throw new Error('Invalid transaction');
        }
        if (transactionExplanation.outputs.length <= 0) {
            return {
                inputs: [],
                outputs: [],
            };
        }
        const senderAddress = transactionExplanation.outputs[0].address;
        const feeAmount = new bignumber_js_1.BigNumber(transactionExplanation.fee.fee === '' ? '0' : transactionExplanation.fee.fee);
        const inputs = [
            {
                address: senderAddress,
                amount: new bignumber_js_1.BigNumber(transactionExplanation.outputAmount).plus(feeAmount).toFixed(),
            },
        ];
        const outputs = transactionExplanation.outputs.map((output) => {
            return {
                address: output.address,
                amount: new bignumber_js_1.BigNumber(output.amount).toFixed(),
            };
        });
        return {
            inputs,
            outputs,
        };
    }
    /**
     * Get the public node url from the Environments constant we have defined
     */
    getPublicNodeUrl() {
        throw new Error('Method not implemented.');
    }
    /**
     * Get account number from public node
     */
    async getAccountFromNode(senderAddress) {
        const nodeUrl = this.getPublicNodeUrl();
        const getAccountPath = '/cosmos/auth/v1beta1/accounts/';
        const fullEndpoint = nodeUrl + getAccountPath + senderAddress;
        try {
            return await request.get(fullEndpoint).send();
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${getAccountPath + senderAddress} from node: ${nodeUrl}`);
    }
    /**
     * Get balance from public node
     */
    async getBalanceFromNode(senderAddress) {
        const nodeUrl = this.getPublicNodeUrl();
        const getBalancePath = '/cosmos/bank/v1beta1/balances/';
        const fullEndpoint = nodeUrl + getBalancePath + senderAddress;
        try {
            return await request.get(fullEndpoint).send();
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${getBalancePath + senderAddress} from node: ${nodeUrl}`);
    }
    /**
     * Get chain id from public node
     */
    async getChainIdFromNode() {
        const nodeUrl = this.getPublicNodeUrl();
        const getLatestBlockPath = '/cosmos/base/tendermint/v1beta1/blocks/latest';
        const fullEndpoint = nodeUrl + getLatestBlockPath;
        try {
            return await request.get(fullEndpoint).send();
        }
        catch (e) {
            console.debug(e);
        }
        throw new Error(`Unable to call endpoint ${getLatestBlockPath} from node: ${nodeUrl}`);
    }
    /**
     * Helper to fetch account balance
     */
    async getAccountBalance(senderAddress) {
        const response = await this.getBalanceFromNode(senderAddress);
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        const balance = response.body.balances.find((item) => item.denom === this.getDenomination());
        return balance.amount;
    }
    /**
     * Helper to fetch chainId
     */
    async getChainId() {
        const response = await this.getChainIdFromNode();
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return response.body.block.header.chain_id;
    }
    /**
     * Helper to fetch account number
     */
    async getAccountDetails(senderAddress) {
        const response = await this.getAccountFromNode(senderAddress);
        if (response.status !== 200) {
            throw new Error('Account not found');
        }
        return [response.body.account.account_number, response.body.account.sequence];
    }
    /** @inheritDoc **/
    generateKeyPair(seed) {
        if (!seed) {
            // An extended private key has both a normal 256 bit private key and a 256
            // bit chain code, both of which must be random. 512 bits is therefore the
            // maximum entropy and gives us maximum security against cracking.
            seed = crypto_1.randomBytes(512 / 8);
        }
        const extendedKey = utxo_lib_1.bip32.fromSeed(seed);
        return {
            pub: extendedKey.neutered().toBase58(),
            prv: extendedKey.toBase58(),
        };
    }
    /**
     * Retrieves the address from a public key.
     * @param {string} pubKey - The public key.
     * @returns {string} The corresponding address.
     */
    getAddressFromPublicKey(pubKey) {
        throw new Error('Method not implemented');
    }
    /** @inheritDoc **/
    async isWalletAddress(params) {
        const addressDetails = this.getAddressDetails(params.address);
        if (!this.isValidAddress(addressDetails.address)) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${addressDetails.address}`);
        }
        const rootAddress = params.coinSpecific.rootAddress;
        if (addressDetails.address !== rootAddress) {
            throw new sdk_core_1.UnexpectedAddressError(`address validation failure: ${addressDetails.address} vs ${rootAddress}`);
        }
        return true;
    }
    /** @inheritDoc **/
    getHashFunction() {
        return utils_1.default.getHashFunction();
    }
    /**
     * Process address into address and memo id
     *
     * @param address the address
     * @returns object containing address and memo id
     */
    getAddressDetails(address) {
        const destinationDetails = url.parse(address);
        const destinationAddress = destinationDetails.pathname || '';
        // address doesn't have a memo id
        if (destinationDetails.pathname === address) {
            return {
                address: address,
                memoId: undefined,
            };
        }
        if (!destinationDetails.query) {
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        const queryDetails = querystring.parse(destinationDetails.query);
        if (!queryDetails.memoId) {
            // if there are more properties, the query details need to contain the memo id property
            throw new sdk_core_1.InvalidAddressError(`invalid address: ${address}`);
        }
        if (Array.isArray(queryDetails.memoId)) {
            throw new sdk_core_1.InvalidAddressError(`memoId may only be given at most once, but found ${queryDetails.memoId.length} instances in address ${address}`);
        }
        if (Array.isArray(queryDetails.memoId) && queryDetails.memoId.length !== 1) {
            // valid addresses can only contain one memo id
            throw new sdk_core_1.InvalidAddressError(`invalid address '${address}', must contain exactly one memoId`);
        }
        const [memoId] = _.castArray(queryDetails.memoId) || undefined;
        if (!this.isValidMemoId(memoId)) {
            throw new sdk_core_1.InvalidMemoIdError(`invalid address: '${address}', memoId is not valid`);
        }
        return {
            address: destinationAddress,
            memoId,
        };
    }
    /**
     * Return boolean indicating whether a memo id is valid
     *
     * @param memoId memo id
     * @returns true if memo id is valid
     */
    isValidMemoId(memoId) {
        let memoIdNumber;
        try {
            memoIdNumber = new bignumber_js_1.BigNumber(memoId);
        }
        catch (e) {
            return false;
        }
        return memoIdNumber.gte(0);
    }
    /**
     * Helper method to return the respective coin's base unit
     */
    getDenomination() {
        throw new Error('Method not implemented');
    }
    /**
     * Helper method to fetch gas amount details for respective coin
     */
    getGasAmountDetails() {
        throw new Error('Method not implemented');
    }
    /**
     * Helper method to get key pair for individual coin
     * @param publicKey
     */
    getKeyPair(publicKey) {
        throw new Error('Method not implemented');
    }
}
exports.CosmosCoin = CosmosCoin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29zbW9zQ29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb3Ntb3NDb2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDhDQXNCeUI7QUFDekIsb0RBQXFGO0FBRXJGLDhDQUF3QztBQUV4QywrQ0FBeUM7QUFDekMsbUNBQWdDO0FBQ2hDLG1DQUEyQztBQUMzQyw0QkFBNEI7QUFDNUIsMkNBQTJDO0FBQzNDLHNDQUFzQztBQUN0QywyQkFBMkI7QUFVM0IsK0NBQTRDO0FBQzVDLHVDQUFnQztBQWlCaEMsTUFBYSxVQUFXLFNBQVEsbUJBQVE7SUFFdEMsWUFBc0IsS0FBZ0IsRUFBRSxXQUF1QztRQUM3RSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFYixJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2hCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztTQUN2RTtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDO0lBQ2xDLENBQUM7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLEtBQWdCLEVBQUUsV0FBdUM7UUFDN0UsT0FBTyxJQUFJLFVBQVUsQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVTtRQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRUQsbUJBQW1CO0lBQ25CLGFBQWE7UUFDWCxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDNUMsQ0FBQztJQUVELG1CQUFtQjtJQUNuQixRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQztJQUNoQyxDQUFDO0lBRUQsbUJBQW1CO0lBQ25CLFNBQVM7UUFDUCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ2xDLENBQUM7SUFFRCxtQkFBbUI7SUFDbkIs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Ozs7OztPQUtHO0lBQ0gsYUFBYSxDQUFDLE1BQWM7UUFDMUIsSUFBSSxZQUFZLENBQUM7UUFDakIsSUFBSTtZQUNGLFlBQVksR0FBRyxJQUFJLHdCQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDdEM7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7UUFDRCxPQUFPLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZUFBZTtRQUNiLE1BQU0sSUFBSSxLQUFLLENBQUMsd0JBQXdCLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxtQkFBbUI7UUFDakIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVLENBQUMsU0FBaUI7UUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0lBQzVDLENBQUM7Q0FDRjtBQTVvQkQsZ0NBNG9CQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJhc2VDb2luLFxuICBCYXNlVHJhbnNhY3Rpb24sXG4gIEJpdEdvQmFzZSxcbiAgRUNEU0EsXG4gIEVjZHNhLFxuICBFQ0RTQU1ldGhvZFR5cGVzLFxuICBFeHBsYW5hdGlvblJlc3VsdCxcbiAgaGV4VG9CaWdJbnQsXG4gIEludmFsaWRBZGRyZXNzRXJyb3IsXG4gIEludmFsaWRNZW1vSWRFcnJvcixcbiAgS2V5UGFpcixcbiAgTVBDQWxnb3JpdGhtLFxuICBQYXJzZWRUcmFuc2FjdGlvbixcbiAgUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFNpZ25lZFRyYW5zYWN0aW9uLFxuICBTaWduaW5nRXJyb3IsXG4gIFNpZ25UcmFuc2FjdGlvbk9wdGlvbnMsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbiAgVW5leHBlY3RlZEFkZHJlc3NFcnJvcixcbiAgVmVyaWZ5QWRkcmVzc09wdGlvbnMsXG4gIFZlcmlmeVRyYW5zYWN0aW9uT3B0aW9ucyxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IEVjZHNhUGFpbGxpZXJQcm9vZiwgRWNkc2FSYW5nZVByb29mLCBFY2RzYVR5cGVzIH0gZnJvbSAnQGJpdGdvL3Nkay1saWItbXBjJztcbmltcG9ydCB7IEJhc2VDb2luIGFzIFN0YXRpY3NCYXNlQ29pbiwgQ29pbkZhbWlseSB9IGZyb20gJ0BiaXRnby9zdGF0aWNzJztcbmltcG9ydCB7IGJpcDMyIH0gZnJvbSAnQGJpdGdvL3V0eG8tbGliJztcbmltcG9ydCB7IENvaW4gfSBmcm9tICdAY29zbWpzL3N0YXJnYXRlJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHsgSGFzaCwgcmFuZG9tQnl0ZXMgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAncXVlcnlzdHJpbmcnO1xuaW1wb3J0ICogYXMgcmVxdWVzdCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCAqIGFzIHVybCBmcm9tICd1cmwnO1xuaW1wb3J0IHtcbiAgQ29zbW9zS2V5UGFpcixcbiAgQ29zbW9zTGlrZUNvaW5SZWNvdmVyeU91dHB1dCxcbiAgQ29zbW9zVHJhbnNhY3Rpb24sXG4gIEZlZURhdGEsXG4gIEdhc0Ftb3VudERldGFpbHMsXG4gIFJlY292ZXJ5T3B0aW9ucyxcbiAgU2VuZE1lc3NhZ2UsXG59IGZyb20gJy4vbGliJztcbmltcG9ydCB7IFJPT1RfUEFUSCB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi9saWIvdXRpbHMnO1xuXG4vKipcbiAqIENvc21vcyBhY2NvdW50cyBzdXBwb3J0IG1lbW8gSWQgYmFzZWQgYWRkcmVzc2VzXG4gKi9cbmludGVyZmFjZSBBZGRyZXNzRGV0YWlscyB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgbWVtb0lkPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENvc21vcyBhY2NvdW50cyBzdXBwb3J0IG1lbW8gSWQgYmFzZWQgYWRkcmVzc2VzXG4gKi9cbmludGVyZmFjZSBDb3Ntb3NDb2luU3BlY2lmaWMge1xuICByb290QWRkcmVzczogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQ29zbW9zQ29pbiBleHRlbmRzIEJhc2VDb2luIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zdGF0aWNzQ29pbjogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPjtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPikge1xuICAgIHN1cGVyKGJpdGdvKTtcblxuICAgIGlmICghc3RhdGljc0NvaW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyByZXF1aXJlZCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXIgc3RhdGljc0NvaW4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdGF0aWNzQ29pbiA9IHN0YXRpY3NDb2luO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKGJpdGdvOiBCaXRHb0Jhc2UsIHN0YXRpY3NDb2luPzogUmVhZG9ubHk8U3RhdGljc0Jhc2VDb2luPik6IEJhc2VDb2luIHtcbiAgICByZXR1cm4gbmV3IENvc21vc0NvaW4oYml0Z28sIHN0YXRpY3NDb2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFRyYW5zYWN0aW9uQnVpbGRlckZhY3RvcnkgZm9yIHRoZSBjb2luIHNwZWNpZmljIHNka1xuICAgKi9cbiAgZ2V0QnVpbGRlcigpOiBhbnkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgZ2V0QmFzZUZhY3RvcigpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBnZXRDaGFpbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9zdGF0aWNzQ29pbi5uYW1lO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBnZXRGYW1pbHkoKTogQ29pbkZhbWlseSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRpY3NDb2luLmZhbWlseTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgZ2V0RnVsbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGljc0NvaW4uZnVsbE5hbWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgc3VwcG9ydHNUc3MoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKiovXG4gIGdldE1QQ0FsZ29yaXRobSgpOiBNUENBbGdvcml0aG0ge1xuICAgIHJldHVybiAnZWNkc2EnO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBpc1ZhbGlkUHViKHB1Yjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHV0aWxzLmlzVmFsaWRQdWJsaWNLZXkocHViKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgaXNWYWxpZFBydihwcnY6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB1dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShwcnYpO1xuICB9XG5cbiAgaXNWYWxpZEFkZHJlc3MoYWRkcmVzczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGZ1bmRzIHJlY292ZXJ5IHRyYW5zYWN0aW9uIHdpdGhvdXQgQml0R29cbiAgICogQHBhcmFtIHtSZWNvdmVyeU9wdGlvbnN9IHBhcmFtcyBwYXJhbWV0ZXJzIG5lZWRlZCB0byBjb25zdHJ1Y3QgYW5kXG4gICAqIChtYXliZSkgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge0Nvc21vc0xpa2VDb2luUmVjb3ZlcnlPdXRwdXR9IHRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIGhleCBzdHJpbmcgYW5kIGluZGV4XG4gICAqIG9mIHRoZSBhZGRyZXNzIGJlaW5nIHN3ZXB0XG4gICAqL1xuICBhc3luYyByZWNvdmVyKHBhcmFtczogUmVjb3ZlcnlPcHRpb25zKTogUHJvbWlzZTxDb3Ntb3NMaWtlQ29pblJlY292ZXJ5T3V0cHV0PiB7XG4gICAgLy8gU3RlcCAxOiBDaGVjayBpZiBwYXJhbXMgY29udGFpbnMgdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnNcbiAgICBpZiAoIXBhcmFtcy5iaXRnb0tleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGJpdGdvS2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbiB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhwYXJhbXMucmVjb3ZlcnlEZXN0aW5hdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZWNvdmVyeURlc3RpbmF0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMudXNlcktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHVzZXJLZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5iYWNrdXBLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWlzc2luZyBiYWNrdXBLZXknKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy53YWxsZXRQYXNzcGhyYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21pc3Npbmcgd2FsbGV0IHBhc3NwaHJhc2UnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDI6IEZldGNoIHRoZSBiaXRnbyBrZXkgZnJvbSBwYXJhbXNcbiAgICBjb25zdCBiaXRnb0tleSA9IHBhcmFtcy5iaXRnb0tleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuXG4gICAgLy8gU3RlcCAzOiBJbnN0YW50aWF0ZSB0aGUgRUNEU0Egc2lnbmVyIGFuZCBmZXRjaCB0aGUgYWRkcmVzcyBkZXRhaWxzXG4gICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGF3YWl0IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IE1QQy5kZXJpdmVVbmhhcmRlbmVkKGJpdGdvS2V5LCBST09UX1BBVEgpLnNsaWNlKDAsIDY2KTtcbiAgICBjb25zdCBzZW5kZXJBZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzRnJvbVB1YmxpY0tleShwdWJsaWNLZXkpO1xuXG4gICAgLy8gU3RlcCA0OiBGZXRjaCBhY2NvdW50IGRldGFpbHMgc3VjaCBhcyBhY2NvdW50Tm8sIGJhbGFuY2UgYW5kIGNoZWNrIGZvciBzdWZmaWNpZW50IGZ1bmRzIG9uY2UgZ2FzQW1vdW50IGhhcyBiZWVuIGRlZHVjdGVkXG4gICAgY29uc3QgW2FjY291bnROdW1iZXIsIHNlcXVlbmNlTm9dID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50RGV0YWlscyhzZW5kZXJBZGRyZXNzKTtcbiAgICBjb25zdCBiYWxhbmNlID0gbmV3IEJpZ051bWJlcihhd2FpdCB0aGlzLmdldEFjY291bnRCYWxhbmNlKHNlbmRlckFkZHJlc3MpKTtcbiAgICBjb25zdCBnYXNCdWRnZXQ6IEZlZURhdGEgPSB7XG4gICAgICBhbW91bnQ6IFt7IGRlbm9tOiB0aGlzLmdldERlbm9taW5hdGlvbigpLCBhbW91bnQ6IHRoaXMuZ2V0R2FzQW1vdW50RGV0YWlscygpLmdhc0Ftb3VudCB9XSxcbiAgICAgIGdhc0xpbWl0OiB0aGlzLmdldEdhc0Ftb3VudERldGFpbHMoKS5nYXNMaW1pdCxcbiAgICB9O1xuICAgIGNvbnN0IGdhc0Ftb3VudCA9IG5ldyBCaWdOdW1iZXIoZ2FzQnVkZ2V0LmFtb3VudFswXS5hbW91bnQpO1xuICAgIGNvbnN0IGFjdHVhbEJhbGFuY2UgPSBiYWxhbmNlLm1pbnVzKGdhc0Ftb3VudCk7XG5cbiAgICBpZiAoYWN0dWFsQmFsYW5jZS5pc0xlc3NUaGFuT3JFcXVhbFRvKDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgaGF2ZSBlbm91Z2ggZnVuZHMgdG8gcmVjb3ZlcicpO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgNTogT25jZSBzdWZmaWNpZW50IGZ1bmRzIGFyZSBwcmVzZW50LCBjb25zdHJ1Y3QgdGhlIHJlY292ZXIgdHggbWVzc3NhZ2VcbiAgICBjb25zdCBhbW91bnQ6IENvaW5bXSA9IFtcbiAgICAgIHtcbiAgICAgICAgZGVub206IHRoaXMuZ2V0RGVub21pbmF0aW9uKCksXG4gICAgICAgIGFtb3VudDogYWN0dWFsQmFsYW5jZS50b0ZpeGVkKCksXG4gICAgICB9LFxuICAgIF07XG4gICAgY29uc3Qgc2VuZE1lc3NhZ2U6IFNlbmRNZXNzYWdlW10gPSBbXG4gICAgICB7XG4gICAgICAgIGZyb21BZGRyZXNzOiBzZW5kZXJBZGRyZXNzLFxuICAgICAgICB0b0FkZHJlc3M6IHBhcmFtcy5yZWNvdmVyeURlc3RpbmF0aW9uLFxuICAgICAgICBhbW91bnQ6IGFtb3VudCxcbiAgICAgIH0sXG4gICAgXTtcblxuICAgIC8vIFN0ZXAgNjogQnVpbGQgdGhlIHVuc2lnbmVkIHR4IHVzaW5nIHRoZSBjb25zdHJ1Y3RlZCBtZXNzYWdlXG4gICAgY29uc3QgdHhuQnVpbGRlciA9IHRoaXMuZ2V0QnVpbGRlcigpLmdldFRyYW5zZmVyQnVpbGRlcigpO1xuICAgIHR4bkJ1aWxkZXJcbiAgICAgIC5tZXNzYWdlcyhzZW5kTWVzc2FnZSlcbiAgICAgIC5nYXNCdWRnZXQoZ2FzQnVkZ2V0KVxuICAgICAgLnB1YmxpY0tleShwdWJsaWNLZXkpXG4gICAgICAuc2VxdWVuY2UoTnVtYmVyKHNlcXVlbmNlTm8pKVxuICAgICAgLmFjY291bnROdW1iZXIoTnVtYmVyKGFjY291bnROdW1iZXIpKVxuICAgICAgLmNoYWluSWQoY2hhaW5JZCk7XG4gICAgY29uc3QgdW5zaWduZWRUcmFuc2FjdGlvbiA9IChhd2FpdCB0eG5CdWlsZGVyLmJ1aWxkKCkpIGFzIENvc21vc1RyYW5zYWN0aW9uO1xuICAgIGxldCBzZXJpYWxpemVkVHggPSB1bnNpZ25lZFRyYW5zYWN0aW9uLnRvQnJvYWRjYXN0Rm9ybWF0KCk7XG4gICAgY29uc3Qgc2lnbmFibGVIZXggPSB1bnNpZ25lZFRyYW5zYWN0aW9uLnNpZ25hYmxlUGF5bG9hZC50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgdXNlcktleSA9IHBhcmFtcy51c2VyS2V5LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgY29uc3QgYmFja3VwS2V5ID0gcGFyYW1zLmJhY2t1cEtleS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgIGNvbnN0IFt1c2VyS2V5Q29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXSA9ICgoKTogW1xuICAgICAgRUNEU0FNZXRob2RUeXBlcy5LZXlDb21iaW5lZCB8IHVuZGVmaW5lZCxcbiAgICAgIEVDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWQgfCB1bmRlZmluZWRcbiAgICBdID0+IHtcbiAgICAgIGNvbnN0IFt1c2VyS2V5Q29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXSA9IHRoaXMuZ2V0S2V5Q29tYmluZWRGcm9tVHNzS2V5U2hhcmVzKFxuICAgICAgICB1c2VyS2V5LFxuICAgICAgICBiYWNrdXBLZXksXG4gICAgICAgIHBhcmFtcy53YWxsZXRQYXNzcGhyYXNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIFt1c2VyS2V5Q29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXTtcbiAgICB9KSgpO1xuXG4gICAgaWYgKCF1c2VyS2V5Q29tYmluZWQgfHwgIWJhY2t1cEtleUNvbWJpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY29tYmluZWQga2V5IHNoYXJlcyBmb3IgdXNlciBvciBiYWNrdXAnKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDc6IFNpZ24gdGhlIHR4XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgdGhpcy5zaWduUmVjb3ZlcnlUU1ModXNlcktleUNvbWJpbmVkLCBiYWNrdXBLZXlDb21iaW5lZCwgc2lnbmFibGVIZXgpO1xuICAgIGNvbnN0IHNpZ25hYmxlQnVmZmVyID0gQnVmZmVyLmZyb20oc2lnbmFibGVIZXgsICdoZXgnKTtcbiAgICBNUEMudmVyaWZ5KHNpZ25hYmxlQnVmZmVyLCBzaWduYXR1cmUsIHRoaXMuZ2V0SGFzaEZ1bmN0aW9uKCkpO1xuICAgIGNvbnN0IGNvc21vc0tleVBhaXIgPSB0aGlzLmdldEtleVBhaXIocHVibGljS2V5KTtcbiAgICB0eG5CdWlsZGVyLmFkZFNpZ25hdHVyZSh7IHB1YjogY29zbW9zS2V5UGFpci5nZXRLZXlzKCkucHViIH0sIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZS5yICsgc2lnbmF0dXJlLnMsICdoZXgnKSk7XG4gICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBhd2FpdCB0eG5CdWlsZGVyLmJ1aWxkKCk7XG4gICAgc2VyaWFsaXplZFR4ID0gc2lnbmVkVHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcblxuICAgIHJldHVybiB7IHNlcmlhbGl6ZWRUeDogc2VyaWFsaXplZFR4IH07XG4gIH1cblxuICBwcml2YXRlIGdldEtleUNvbWJpbmVkRnJvbVRzc0tleVNoYXJlcyhcbiAgICB1c2VyUHVibGljT3JQcml2YXRlS2V5U2hhcmU6IHN0cmluZyxcbiAgICBiYWNrdXBQcml2YXRlT3JQdWJsaWNLZXlTaGFyZTogc3RyaW5nLFxuICAgIHdhbGxldFBhc3NwaHJhc2U/OiBzdHJpbmdcbiAgKTogW0VDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWQsIEVDRFNBTWV0aG9kVHlwZXMuS2V5Q29tYmluZWRdIHtcbiAgICBsZXQgYmFja3VwUHJ2O1xuICAgIGxldCB1c2VyUHJ2O1xuICAgIHRyeSB7XG4gICAgICBiYWNrdXBQcnYgPSB0aGlzLmJpdGdvLmRlY3J5cHQoe1xuICAgICAgICBpbnB1dDogYmFja3VwUHJpdmF0ZU9yUHVibGljS2V5U2hhcmUsXG4gICAgICAgIHBhc3N3b3JkOiB3YWxsZXRQYXNzcGhyYXNlLFxuICAgICAgfSk7XG4gICAgICB1c2VyUHJ2ID0gdGhpcy5iaXRnby5kZWNyeXB0KHtcbiAgICAgICAgaW5wdXQ6IHVzZXJQdWJsaWNPclByaXZhdGVLZXlTaGFyZSxcbiAgICAgICAgcGFzc3dvcmQ6IHdhbGxldFBhc3NwaHJhc2UsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY3J5cHRpbmcgYmFja3VwIGtleWNoYWluOiAke2UubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyU2lnbmluZ01hdGVyaWFsID0gSlNPTi5wYXJzZSh1c2VyUHJ2KSBhcyBFQ0RTQU1ldGhvZFR5cGVzLlNpZ25pbmdNYXRlcmlhbDtcbiAgICBjb25zdCBiYWNrdXBTaWduaW5nTWF0ZXJpYWwgPSBKU09OLnBhcnNlKGJhY2t1cFBydikgYXMgRUNEU0FNZXRob2RUeXBlcy5TaWduaW5nTWF0ZXJpYWw7XG5cbiAgICBpZiAoIXVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdXNlciBrZXkgLSBtaXNzaW5nIGJhY2t1cE5TaGFyZScpO1xuICAgIH1cblxuICAgIGlmICghYmFja3VwU2lnbmluZ01hdGVyaWFsLnVzZXJOU2hhcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiYWNrdXAga2V5IC0gbWlzc2luZyB1c2VyTlNoYXJlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG5cbiAgICBjb25zdCB1c2VyS2V5Q29tYmluZWQgPSBNUEMua2V5Q29tYmluZSh1c2VyU2lnbmluZ01hdGVyaWFsLnBTaGFyZSwgW1xuICAgICAgdXNlclNpZ25pbmdNYXRlcmlhbC5iaXRnb05TaGFyZSxcbiAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlLFxuICAgIF0pO1xuXG4gICAgY29uc3QgdXNlclNpZ25pbmdLZXlEZXJpdmVkID0gTVBDLmtleURlcml2ZShcbiAgICAgIHVzZXJTaWduaW5nTWF0ZXJpYWwucFNoYXJlLFxuICAgICAgW3VzZXJTaWduaW5nTWF0ZXJpYWwuYml0Z29OU2hhcmUsIHVzZXJTaWduaW5nTWF0ZXJpYWwuYmFja3VwTlNoYXJlXSxcbiAgICAgICdtLzAnXG4gICAgKTtcblxuICAgIGNvbnN0IHVzZXJLZXlEZXJpdmVkQ29tYmluZWQgPSB7XG4gICAgICB4U2hhcmU6IHVzZXJTaWduaW5nS2V5RGVyaXZlZC54U2hhcmUsXG4gICAgICB5U2hhcmVzOiB1c2VyS2V5Q29tYmluZWQueVNoYXJlcyxcbiAgICB9O1xuXG4gICAgY29uc3QgYmFja3VwS2V5Q29tYmluZWQgPSBNUEMua2V5Q29tYmluZShiYWNrdXBTaWduaW5nTWF0ZXJpYWwucFNoYXJlLCBbXG4gICAgICB1c2VyU2lnbmluZ0tleURlcml2ZWQublNoYXJlc1syXSxcbiAgICAgIGJhY2t1cFNpZ25pbmdNYXRlcmlhbC5iaXRnb05TaGFyZSxcbiAgICBdKTtcblxuICAgIGlmIChcbiAgICAgIHVzZXJLZXlEZXJpdmVkQ29tYmluZWQueFNoYXJlLnkgIT09IGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZS55IHx8XG4gICAgICB1c2VyS2V5RGVyaXZlZENvbWJpbmVkLnhTaGFyZS5jaGFpbmNvZGUgIT09IGJhY2t1cEtleUNvbWJpbmVkLnhTaGFyZS5jaGFpbmNvZGVcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29tbW9uIGtleWNoYWlucyBkbyBub3QgbWF0Y2gnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3VzZXJLZXlEZXJpdmVkQ29tYmluZWQsIGJhY2t1cEtleUNvbWJpbmVkXTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2lnblJlY292ZXJ5VFNTKFxuICAgIHVzZXJLZXlDb21iaW5lZDogRUNEU0EuS2V5Q29tYmluZWQsXG4gICAgYmFja3VwS2V5Q29tYmluZWQ6IEVDRFNBLktleUNvbWJpbmVkLFxuICAgIHR4SGV4OiBzdHJpbmcsXG4gICAge1xuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSxcbiAgICB9OiB7XG4gICAgICByYW5nZVByb29mQ2hhbGxlbmdlPzogRWNkc2FUeXBlcy5TZXJpYWxpemVkTnRpbGRlO1xuICAgIH0gPSB7fVxuICApOiBQcm9taXNlPEVDRFNBTWV0aG9kVHlwZXMuU2lnbmF0dXJlPiB7XG4gICAgY29uc3QgTVBDID0gbmV3IEVjZHNhKCk7XG4gICAgY29uc3Qgc2lnbmVyT25lSW5kZXggPSB1c2VyS2V5Q29tYmluZWQueFNoYXJlLmk7XG4gICAgY29uc3Qgc2lnbmVyVHdvSW5kZXggPSBiYWNrdXBLZXlDb21iaW5lZC54U2hhcmUuaTtcblxuICAgIC8vIFNpbmNlIHRoaXMgaXMgYSB1c2VyIDw+IGJhY2t1cCBzaWduaW5nLCB3ZSB3aWxsIHJldXNlIHRoZSBzYW1lIHJhbmdlIHByb29mIGNoYWxsZW5nZVxuICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2UgPVxuICAgICAgcmFuZ2VQcm9vZkNoYWxsZW5nZSA/PyBFY2RzYVR5cGVzLnNlcmlhbGl6ZU50aWxkZVdpdGhQcm9vZnMoYXdhaXQgRWNkc2FSYW5nZVByb29mLmdlbmVyYXRlTnRpbGRlKCkpO1xuXG4gICAgY29uc3QgdXNlclRvQmFja3VwUGFpbGxpZXJDaGFsbGVuZ2UgPSBhd2FpdCBFY2RzYVBhaWxsaWVyUHJvb2YuZ2VuZXJhdGVQKFxuICAgICAgaGV4VG9CaWdJbnQodXNlcktleUNvbWJpbmVkLnlTaGFyZXNbc2lnbmVyVHdvSW5kZXhdLm4pXG4gICAgKTtcbiAgICBjb25zdCBiYWNrdXBUb1VzZXJQYWlsbGllckNoYWxsZW5nZSA9IGF3YWl0IEVjZHNhUGFpbGxpZXJQcm9vZi5nZW5lcmF0ZVAoXG4gICAgICBoZXhUb0JpZ0ludChiYWNrdXBLZXlDb21iaW5lZC55U2hhcmVzW3NpZ25lck9uZUluZGV4XS5uKVxuICAgICk7XG5cbiAgICBjb25zdCB1c2VyWFNoYXJlID0gTVBDLmFwcGVuZENoYWxsZW5nZShcbiAgICAgIHVzZXJLZXlDb21iaW5lZC54U2hhcmUsXG4gICAgICByYW5nZVByb29mQ2hhbGxlbmdlLFxuICAgICAgRWNkc2FUeXBlcy5zZXJpYWxpemVQYWlsbGllckNoYWxsZW5nZSh7IHA6IHVzZXJUb0JhY2t1cFBhaWxsaWVyQ2hhbGxlbmdlIH0pXG4gICAgKTtcbiAgICBjb25zdCB1c2VyWVNoYXJlID0gTVBDLmFwcGVuZENoYWxsZW5nZShcbiAgICAgIHVzZXJLZXlDb21iaW5lZC55U2hhcmVzW3NpZ25lclR3b0luZGV4XSxcbiAgICAgIHJhbmdlUHJvb2ZDaGFsbGVuZ2UsXG4gICAgICBFY2RzYVR5cGVzLnNlcmlhbGl6ZVBhaWxsaWVyQ2hhbGxlbmdlKHsgcDogYmFja3VwVG9Vc2VyUGFpbGxpZXJDaGFsbGVuZ2UgfSlcbiAgICApO1xuICAgIGNvbnN0IGJhY2t1cFhTaGFyZSA9IE1QQy5hcHBlbmRDaGFsbGVuZ2UoXG4gICAgICBiYWNrdXBLZXlDb21iaW5lZC54U2hhcmUsXG4gICAgICByYW5nZVByb29mQ2hhbGxlbmdlLFxuICAgICAgRWNkc2FUeXBlcy5zZXJpYWxpemVQYWlsbGllckNoYWxsZW5nZSh7IHA6IGJhY2t1cFRvVXNlclBhaWxsaWVyQ2hhbGxlbmdlIH0pXG4gICAgKTtcbiAgICBjb25zdCBiYWNrdXBZU2hhcmUgPSBNUEMuYXBwZW5kQ2hhbGxlbmdlKFxuICAgICAgYmFja3VwS2V5Q29tYmluZWQueVNoYXJlc1tzaWduZXJPbmVJbmRleF0sXG4gICAgICByYW5nZVByb29mQ2hhbGxlbmdlLFxuICAgICAgRWNkc2FUeXBlcy5zZXJpYWxpemVQYWlsbGllckNoYWxsZW5nZSh7IHA6IHVzZXJUb0JhY2t1cFBhaWxsaWVyQ2hhbGxlbmdlIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IHNpZ25TaGFyZXM6IEVDRFNBLlNpZ25TaGFyZVJUID0gYXdhaXQgTVBDLnNpZ25TaGFyZSh1c2VyWFNoYXJlLCB1c2VyWVNoYXJlKTtcblxuICAgIGNvbnN0IHNpZ25Db252ZXJ0UzIxID0gYXdhaXQgTVBDLnNpZ25Db252ZXJ0U3RlcDEoe1xuICAgICAgeFNoYXJlOiBiYWNrdXBYU2hhcmUsXG4gICAgICB5U2hhcmU6IGJhY2t1cFlTaGFyZSwgLy8gWVNoYXJlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG90aGVyIHBhcnRpY2lwYW50IHNpZ25lck9uZVxuICAgICAga1NoYXJlOiBzaWduU2hhcmVzLmtTaGFyZSxcbiAgICB9KTtcbiAgICBjb25zdCBzaWduQ29udmVydFMxMiA9IGF3YWl0IE1QQy5zaWduQ29udmVydFN0ZXAyKHtcbiAgICAgIGFTaGFyZTogc2lnbkNvbnZlcnRTMjEuYVNoYXJlLFxuICAgICAgd1NoYXJlOiBzaWduU2hhcmVzLndTaGFyZSxcbiAgICB9KTtcbiAgICBjb25zdCBzaWduQ29udmVydFMyMV8yID0gYXdhaXQgTVBDLnNpZ25Db252ZXJ0U3RlcDMoe1xuICAgICAgbXVTaGFyZTogc2lnbkNvbnZlcnRTMTIubXVTaGFyZSxcbiAgICAgIGJTaGFyZTogc2lnbkNvbnZlcnRTMjEuYlNoYXJlLFxuICAgIH0pO1xuXG4gICAgY29uc3QgW3NpZ25Db21iaW5lT25lLCBzaWduQ29tYmluZVR3b10gPSBbXG4gICAgICBNUEMuc2lnbkNvbWJpbmUoe1xuICAgICAgICBnU2hhcmU6IHNpZ25Db252ZXJ0UzEyLmdTaGFyZSxcbiAgICAgICAgc2lnbkluZGV4OiB7XG4gICAgICAgICAgaTogc2lnbkNvbnZlcnRTMTIubXVTaGFyZS5pLFxuICAgICAgICAgIGo6IHNpZ25Db252ZXJ0UzEyLm11U2hhcmUuaixcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgICAgTVBDLnNpZ25Db21iaW5lKHtcbiAgICAgICAgZ1NoYXJlOiBzaWduQ29udmVydFMyMV8yLmdTaGFyZSxcbiAgICAgICAgc2lnbkluZGV4OiB7XG4gICAgICAgICAgaTogc2lnbkNvbnZlcnRTMjFfMi5zaWduSW5kZXguaSxcbiAgICAgICAgICBqOiBzaWduQ29udmVydFMyMV8yLnNpZ25JbmRleC5qLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgXTtcblxuICAgIGNvbnN0IE1FU1NBR0UgPSBCdWZmZXIuZnJvbSh0eEhleCwgJ2hleCcpO1xuXG4gICAgY29uc3QgW3NpZ25BLCBzaWduQl0gPSBbXG4gICAgICBNUEMuc2lnbihNRVNTQUdFLCBzaWduQ29tYmluZU9uZS5vU2hhcmUsIHNpZ25Db21iaW5lVHdvLmRTaGFyZSwgdGhpcy5nZXRIYXNoRnVuY3Rpb24oKSksXG4gICAgICBNUEMuc2lnbihNRVNTQUdFLCBzaWduQ29tYmluZVR3by5vU2hhcmUsIHNpZ25Db21iaW5lT25lLmRTaGFyZSwgdGhpcy5nZXRIYXNoRnVuY3Rpb24oKSksXG4gICAgXTtcblxuICAgIHJldHVybiBNUEMuY29uc3RydWN0U2lnbmF0dXJlKFtzaWduQSwgc2lnbkJdKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgYXN5bmMgdmVyaWZ5VHJhbnNhY3Rpb24ocGFyYW1zOiBWZXJpZnlUcmFuc2FjdGlvbk9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsZXQgdG90YWxBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApO1xuICAgIGNvbnN0IHsgdHhQcmVidWlsZCwgdHhQYXJhbXMgfSA9IHBhcmFtcztcbiAgICBjb25zdCByYXdUeCA9IHR4UHJlYnVpbGQudHhIZXg7XG4gICAgaWYgKCFyYXdUeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4IHByZWJ1aWxkIHByb3BlcnR5IHR4SGV4Jyk7XG4gICAgfVxuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5nZXRCdWlsZGVyKCkuZnJvbShyYXdUeCkuYnVpbGQoKTtcbiAgICBjb25zdCBleHBsYWluZWRUeCA9IHRyYW5zYWN0aW9uLmV4cGxhaW5UcmFuc2FjdGlvbigpO1xuXG4gICAgaWYgKHR4UGFyYW1zLnJlY2lwaWVudHMgJiYgdHhQYXJhbXMucmVjaXBpZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmaWx0ZXJlZFJlY2lwaWVudHMgPSB0eFBhcmFtcy5yZWNpcGllbnRzPy5tYXAoKHJlY2lwaWVudCkgPT4gXy5waWNrKHJlY2lwaWVudCwgWydhZGRyZXNzJywgJ2Ftb3VudCddKSk7XG4gICAgICBjb25zdCBmaWx0ZXJlZE91dHB1dHMgPSBleHBsYWluZWRUeC5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiBfLnBpY2sob3V0cHV0LCBbJ2FkZHJlc3MnLCAnYW1vdW50J10pKTtcblxuICAgICAgaWYgKCFfLmlzRXF1YWwoZmlsdGVyZWRPdXRwdXRzLCBmaWx0ZXJlZFJlY2lwaWVudHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHggb3V0cHV0cyBkb2VzIG5vdCBtYXRjaCB3aXRoIGV4cGVjdGVkIHR4UGFyYW1zIHJlY2lwaWVudHMnKTtcbiAgICAgIH1cbiAgICAgIC8vIFdpdGhkcmF3RGVsZWdhdG9yUmV3YXJkcyBhbmQgQ29udHJhY3RDYWxsIHRyYW5zYWN0aW9uIGRvbid0IGhhdmUgYW1vdW50XG4gICAgICBpZiAodHJhbnNhY3Rpb24udHlwZSAhPT0gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdyAmJiB0cmFuc2FjdGlvbi50eXBlICE9PSBUcmFuc2FjdGlvblR5cGUuQ29udHJhY3RDYWxsKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVjaXBpZW50cyBvZiB0eFBhcmFtcy5yZWNpcGllbnRzKSB7XG4gICAgICAgICAgdG90YWxBbW91bnQgPSB0b3RhbEFtb3VudC5wbHVzKHJlY2lwaWVudHMuYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvdGFsQW1vdW50LmlzRXF1YWxUbyhleHBsYWluZWRUeC5vdXRwdXRBbW91bnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeCB0b3RhbCBhbW91bnQgZG9lcyBub3QgbWF0Y2ggd2l0aCBleHBlY3RlZCB0b3RhbCBhbW91bnQgZmllbGQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgYXN5bmMgZXhwbGFpblRyYW5zYWN0aW9uKG9wdGlvbnM6IHsgdHhIZXg6IHN0cmluZyB9KTogUHJvbWlzZTxFeHBsYW5hdGlvblJlc3VsdD4ge1xuICAgIGlmICghb3B0aW9ucy50eEhleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHR4SGV4IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb25CdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZnJvbShvcHRpb25zLnR4SGV4KTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gYXdhaXQgdHJhbnNhY3Rpb25CdWlsZGVyLmJ1aWxkKCk7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24uZXhwbGFpblRyYW5zYWN0aW9uKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uOiAnICsgZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggYSBzaW5nbGUgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIHBhcmFtcyBwYXJhbWV0ZXJzIGluIHRoZSBmb3JtIG9mIHsgdHhQcmVidWlsZDoge3R4SGV4fSwgcHJ2IH1cbiAgICogQHJldHVybnMgc2lnbmVkIHRyYW5zYWN0aW9uIGluIHRoZSBmb3JtIG9mIHsgdHhIZXggfVxuICAgKi9cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKFxuICAgIHBhcmFtczogU2lnblRyYW5zYWN0aW9uT3B0aW9ucyAmIHsgdHhQcmVidWlsZDogeyB0eEhleDogc3RyaW5nIH07IHBydjogc3RyaW5nIH1cbiAgKTogUHJvbWlzZTxTaWduZWRUcmFuc2FjdGlvbj4ge1xuICAgIGNvbnN0IHR4SGV4ID0gcGFyYW1zPy50eFByZWJ1aWxkPy50eEhleDtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gcGFyYW1zPy5wcnY7XG4gICAgaWYgKCF0eEhleCkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25pbmdFcnJvcignbWlzc2luZyByZXF1aXJlZCB0eFByZWJ1aWxkIHBhcmFtZXRlcjogcGFyYW1zLnR4UHJlYnVpbGQudHhIZXgnKTtcbiAgICB9XG4gICAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgU2lnbmluZ0Vycm9yKCdtaXNzaW5nIHJlcXVpcmVkIHBydiBwYXJhbWV0ZXI6IHBhcmFtcy5wcnYnKTtcbiAgICB9XG4gICAgY29uc3QgdHhCdWlsZGVyID0gdGhpcy5nZXRCdWlsZGVyKCkuZnJvbShwYXJhbXMudHhQcmVidWlsZC50eEhleCk7XG4gICAgdHhCdWlsZGVyLnNpZ24oeyBrZXk6IHBhcmFtcy5wcnYgfSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb246IEJhc2VUcmFuc2FjdGlvbiA9IGF3YWl0IHR4QnVpbGRlci5idWlsZCgpO1xuICAgIGlmICghdHJhbnNhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBTaWduaW5nRXJyb3IoJ0ZhaWxlZCB0byBidWlsZCBzaWduZWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZFR4ID0gdHJhbnNhY3Rpb24udG9Ccm9hZGNhc3RGb3JtYXQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHhIZXg6IHNlcmlhbGl6ZWRUeCxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBhc3luYyBwYXJzZVRyYW5zYWN0aW9uKHBhcmFtczogUGFyc2VUcmFuc2FjdGlvbk9wdGlvbnMgJiB7IHR4SGV4OiBzdHJpbmcgfSk6IFByb21pc2U8UGFyc2VkVHJhbnNhY3Rpb24+IHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkV4cGxhbmF0aW9uID0gYXdhaXQgdGhpcy5leHBsYWluVHJhbnNhY3Rpb24oeyB0eEhleDogcGFyYW1zLnR4SGV4IH0pO1xuICAgIGlmICghdHJhbnNhY3Rpb25FeHBsYW5hdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zYWN0aW9uRXhwbGFuYXRpb24ub3V0cHV0cy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXRzOiBbXSxcbiAgICAgICAgb3V0cHV0czogW10sXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzZW5kZXJBZGRyZXNzID0gdHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5vdXRwdXRzWzBdLmFkZHJlc3M7XG4gICAgY29uc3QgZmVlQW1vdW50ID0gbmV3IEJpZ051bWJlcih0cmFuc2FjdGlvbkV4cGxhbmF0aW9uLmZlZS5mZWUgPT09ICcnID8gJzAnIDogdHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5mZWUuZmVlKTtcbiAgICBjb25zdCBpbnB1dHMgPSBbXG4gICAgICB7XG4gICAgICAgIGFkZHJlc3M6IHNlbmRlckFkZHJlc3MsXG4gICAgICAgIGFtb3VudDogbmV3IEJpZ051bWJlcih0cmFuc2FjdGlvbkV4cGxhbmF0aW9uLm91dHB1dEFtb3VudCkucGx1cyhmZWVBbW91bnQpLnRvRml4ZWQoKSxcbiAgICAgIH0sXG4gICAgXTtcbiAgICBjb25zdCBvdXRwdXRzID0gdHJhbnNhY3Rpb25FeHBsYW5hdGlvbi5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBvdXRwdXQuYWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBuZXcgQmlnTnVtYmVyKG91dHB1dC5hbW91bnQpLnRvRml4ZWQoKSxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlucHV0cyxcbiAgICAgIG91dHB1dHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpYyBub2RlIHVybCBmcm9tIHRoZSBFbnZpcm9ubWVudHMgY29uc3RhbnQgd2UgaGF2ZSBkZWZpbmVkXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0UHVibGljTm9kZVVybCgpOiBzdHJpbmcge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWNjb3VudCBudW1iZXIgZnJvbSBwdWJsaWMgbm9kZVxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEFjY291bnRGcm9tTm9kZShzZW5kZXJBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHJlcXVlc3QuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBub2RlVXJsID0gdGhpcy5nZXRQdWJsaWNOb2RlVXJsKCk7XG4gICAgY29uc3QgZ2V0QWNjb3VudFBhdGggPSAnL2Nvc21vcy9hdXRoL3YxYmV0YTEvYWNjb3VudHMvJztcbiAgICBjb25zdCBmdWxsRW5kcG9pbnQgPSBub2RlVXJsICsgZ2V0QWNjb3VudFBhdGggKyBzZW5kZXJBZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5nZXQoZnVsbEVuZHBvaW50KS5zZW5kKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY2FsbCBlbmRwb2ludCAke2dldEFjY291bnRQYXRoICsgc2VuZGVyQWRkcmVzc30gZnJvbSBub2RlOiAke25vZGVVcmx9YCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGJhbGFuY2UgZnJvbSBwdWJsaWMgbm9kZVxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIGdldEJhbGFuY2VGcm9tTm9kZShzZW5kZXJBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPHJlcXVlc3QuUmVzcG9uc2U+IHtcbiAgICBjb25zdCBub2RlVXJsID0gdGhpcy5nZXRQdWJsaWNOb2RlVXJsKCk7XG4gICAgY29uc3QgZ2V0QmFsYW5jZVBhdGggPSAnL2Nvc21vcy9iYW5rL3YxYmV0YTEvYmFsYW5jZXMvJztcbiAgICBjb25zdCBmdWxsRW5kcG9pbnQgPSBub2RlVXJsICsgZ2V0QmFsYW5jZVBhdGggKyBzZW5kZXJBZGRyZXNzO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5nZXQoZnVsbEVuZHBvaW50KS5zZW5kKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY2FsbCBlbmRwb2ludCAke2dldEJhbGFuY2VQYXRoICsgc2VuZGVyQWRkcmVzc30gZnJvbSBub2RlOiAke25vZGVVcmx9YCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNoYWluIGlkIGZyb20gcHVibGljIG5vZGVcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXRDaGFpbklkRnJvbU5vZGUoKTogUHJvbWlzZTxyZXF1ZXN0LlJlc3BvbnNlPiB7XG4gICAgY29uc3Qgbm9kZVVybCA9IHRoaXMuZ2V0UHVibGljTm9kZVVybCgpO1xuICAgIGNvbnN0IGdldExhdGVzdEJsb2NrUGF0aCA9ICcvY29zbW9zL2Jhc2UvdGVuZGVybWludC92MWJldGExL2Jsb2Nrcy9sYXRlc3QnO1xuICAgIGNvbnN0IGZ1bGxFbmRwb2ludCA9IG5vZGVVcmwgKyBnZXRMYXRlc3RCbG9ja1BhdGg7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LmdldChmdWxsRW5kcG9pbnQpLnNlbmQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKGUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjYWxsIGVuZHBvaW50ICR7Z2V0TGF0ZXN0QmxvY2tQYXRofSBmcm9tIG5vZGU6ICR7bm9kZVVybH1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZmV0Y2ggYWNjb3VudCBiYWxhbmNlXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QWNjb3VudEJhbGFuY2Uoc2VuZGVyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZUZyb21Ob2RlKHNlbmRlckFkZHJlc3MpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBiYWxhbmNlID0gcmVzcG9uc2UuYm9keS5iYWxhbmNlcy5maW5kKChpdGVtKSA9PiBpdGVtLmRlbm9tID09PSB0aGlzLmdldERlbm9taW5hdGlvbigpKTtcbiAgICByZXR1cm4gYmFsYW5jZS5hbW91bnQ7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGZldGNoIGNoYWluSWRcbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBnZXRDaGFpbklkKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldENoYWluSWRGcm9tTm9kZSgpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuYm9keS5ibG9jay5oZWFkZXIuY2hhaW5faWQ7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIHRvIGZldGNoIGFjY291bnQgbnVtYmVyXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgZ2V0QWNjb3VudERldGFpbHMoc2VuZGVyQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50RnJvbU5vZGUoc2VuZGVyQWRkcmVzcyk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBbcmVzcG9uc2UuYm9keS5hY2NvdW50LmFjY291bnRfbnVtYmVyLCByZXNwb25zZS5ib2R5LmFjY291bnQuc2VxdWVuY2VdO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0RG9jICoqL1xuICBnZW5lcmF0ZUtleVBhaXIoc2VlZD86IEJ1ZmZlcik6IEtleVBhaXIge1xuICAgIGlmICghc2VlZCkge1xuICAgICAgLy8gQW4gZXh0ZW5kZWQgcHJpdmF0ZSBrZXkgaGFzIGJvdGggYSBub3JtYWwgMjU2IGJpdCBwcml2YXRlIGtleSBhbmQgYSAyNTZcbiAgICAgIC8vIGJpdCBjaGFpbiBjb2RlLCBib3RoIG9mIHdoaWNoIG11c3QgYmUgcmFuZG9tLiA1MTIgYml0cyBpcyB0aGVyZWZvcmUgdGhlXG4gICAgICAvLyBtYXhpbXVtIGVudHJvcHkgYW5kIGdpdmVzIHVzIG1heGltdW0gc2VjdXJpdHkgYWdhaW5zdCBjcmFja2luZy5cbiAgICAgIHNlZWQgPSByYW5kb21CeXRlcyg1MTIgLyA4KTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5kZWRLZXkgPSBiaXAzMi5mcm9tU2VlZChzZWVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgcHViOiBleHRlbmRlZEtleS5uZXV0ZXJlZCgpLnRvQmFzZTU4KCksXG4gICAgICBwcnY6IGV4dGVuZGVkS2V5LnRvQmFzZTU4KCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGFkZHJlc3MgZnJvbSBhIHB1YmxpYyBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJLZXkgLSBUaGUgcHVibGljIGtleS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvcnJlc3BvbmRpbmcgYWRkcmVzcy5cbiAgICovXG4gIGdldEFkZHJlc3NGcm9tUHVibGljS2V5KHB1YktleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgYXN5bmMgaXNXYWxsZXRBZGRyZXNzKHBhcmFtczogVmVyaWZ5QWRkcmVzc09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBhZGRyZXNzRGV0YWlscyA9IHRoaXMuZ2V0QWRkcmVzc0RldGFpbHMocGFyYW1zLmFkZHJlc3MpO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3NEZXRhaWxzLmFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3NEZXRhaWxzLmFkZHJlc3N9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJvb3RBZGRyZXNzID0gKHBhcmFtcy5jb2luU3BlY2lmaWMgYXMgQ29zbW9zQ29pblNwZWNpZmljKS5yb290QWRkcmVzcztcbiAgICBpZiAoYWRkcmVzc0RldGFpbHMuYWRkcmVzcyAhPT0gcm9vdEFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQWRkcmVzc0Vycm9yKGBhZGRyZXNzIHZhbGlkYXRpb24gZmFpbHVyZTogJHthZGRyZXNzRGV0YWlscy5hZGRyZXNzfSB2cyAke3Jvb3RBZGRyZXNzfWApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqKi9cbiAgZ2V0SGFzaEZ1bmN0aW9uKCk6IEhhc2gge1xuICAgIHJldHVybiB1dGlscy5nZXRIYXNoRnVuY3Rpb24oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGFkZHJlc3MgaW50byBhZGRyZXNzIGFuZCBtZW1vIGlkXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGFkZHJlc3MgYW5kIG1lbW8gaWRcbiAgICovXG4gIGdldEFkZHJlc3NEZXRhaWxzKGFkZHJlc3M6IHN0cmluZyk6IEFkZHJlc3NEZXRhaWxzIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkRldGFpbHMgPSB1cmwucGFyc2UoYWRkcmVzcyk7XG4gICAgY29uc3QgZGVzdGluYXRpb25BZGRyZXNzID0gZGVzdGluYXRpb25EZXRhaWxzLnBhdGhuYW1lIHx8ICcnO1xuXG4gICAgLy8gYWRkcmVzcyBkb2Vzbid0IGhhdmUgYSBtZW1vIGlkXG4gICAgaWYgKGRlc3RpbmF0aW9uRGV0YWlscy5wYXRobmFtZSA9PT0gYWRkcmVzcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgbWVtb0lkOiB1bmRlZmluZWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcnlEZXRhaWxzID0gcXVlcnlzdHJpbmcucGFyc2UoZGVzdGluYXRpb25EZXRhaWxzLnF1ZXJ5KTtcbiAgICBpZiAoIXF1ZXJ5RGV0YWlscy5tZW1vSWQpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBtb3JlIHByb3BlcnRpZXMsIHRoZSBxdWVyeSBkZXRhaWxzIG5lZWQgdG8gY29udGFpbiB0aGUgbWVtbyBpZCBwcm9wZXJ0eVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IoYGludmFsaWQgYWRkcmVzczogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5RGV0YWlscy5tZW1vSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihcbiAgICAgICAgYG1lbW9JZCBtYXkgb25seSBiZSBnaXZlbiBhdCBtb3N0IG9uY2UsIGJ1dCBmb3VuZCAke3F1ZXJ5RGV0YWlscy5tZW1vSWQubGVuZ3RofSBpbnN0YW5jZXMgaW4gYWRkcmVzcyAke2FkZHJlc3N9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSAmJiBxdWVyeURldGFpbHMubWVtb0lkLmxlbmd0aCAhPT0gMSkge1xuICAgICAgLy8gdmFsaWQgYWRkcmVzc2VzIGNhbiBvbmx5IGNvbnRhaW4gb25lIG1lbW8gaWRcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGBpbnZhbGlkIGFkZHJlc3MgJyR7YWRkcmVzc30nLCBtdXN0IGNvbnRhaW4gZXhhY3RseSBvbmUgbWVtb0lkYCk7XG4gICAgfVxuXG4gICAgY29uc3QgW21lbW9JZF0gPSBfLmNhc3RBcnJheShxdWVyeURldGFpbHMubWVtb0lkKSB8fCB1bmRlZmluZWQ7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRNZW1vSWQobWVtb0lkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRNZW1vSWRFcnJvcihgaW52YWxpZCBhZGRyZXNzOiAnJHthZGRyZXNzfScsIG1lbW9JZCBpcyBub3QgdmFsaWRgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogZGVzdGluYXRpb25BZGRyZXNzLFxuICAgICAgbWVtb0lkLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGEgbWVtbyBpZCBpcyB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0gbWVtb0lkIG1lbW8gaWRcbiAgICogQHJldHVybnMgdHJ1ZSBpZiBtZW1vIGlkIGlzIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkTWVtb0lkKG1lbW9JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgbGV0IG1lbW9JZE51bWJlcjtcbiAgICB0cnkge1xuICAgICAgbWVtb0lkTnVtYmVyID0gbmV3IEJpZ051bWJlcihtZW1vSWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW9JZE51bWJlci5ndGUoMCk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byByZXR1cm4gdGhlIHJlc3BlY3RpdmUgY29pbidzIGJhc2UgdW5pdFxuICAgKi9cbiAgZ2V0RGVub21pbmF0aW9uKCk6IHN0cmluZyB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogSGVscGVyIG1ldGhvZCB0byBmZXRjaCBnYXMgYW1vdW50IGRldGFpbHMgZm9yIHJlc3BlY3RpdmUgY29pblxuICAgKi9cbiAgZ2V0R2FzQW1vdW50RGV0YWlscygpOiBHYXNBbW91bnREZXRhaWxzIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGdldCBrZXkgcGFpciBmb3IgaW5kaXZpZHVhbCBjb2luXG4gICAqIEBwYXJhbSBwdWJsaWNLZXlcbiAgICovXG4gIGdldEtleVBhaXIocHVibGljS2V5OiBzdHJpbmcpOiBDb3Ntb3NLZXlQYWlyIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuIl19