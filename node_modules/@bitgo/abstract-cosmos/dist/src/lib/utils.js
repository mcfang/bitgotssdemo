"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CosmosUtils = void 0;
const sdk_core_1 = require("@bitgo/sdk-core");
const amino_1 = require("@cosmjs/amino");
const encoding_1 = require("@cosmjs/encoding");
const proto_signing_1 = require("@cosmjs/proto-signing");
const stargate_1 = require("@cosmjs/stargate");
const bignumber_js_1 = require("bignumber.js");
const tx_1 = require("cosmjs-types/cosmos/tx/v1beta1/tx");
const tx_2 = require("cosmjs-types/cosmwasm/wasm/v1/tx");
const crypto_1 = require("crypto");
const constants = require("./constants");
const keyPair_1 = require("./keyPair");
class CosmosUtils {
    constructor() {
        this.registry = new proto_signing_1.Registry([...stargate_1.defaultRegistryTypes]);
        this.registry.register(constants.executeContractMsgTypeUrl, tx_2.MsgExecuteContract);
    }
    /** @inheritdoc */
    isValidBlockId(hash) {
        return this.validateBlake2b(hash);
    }
    /** @inheritdoc */
    isValidPrivateKey(key) {
        try {
            new keyPair_1.CosmosKeyPair({ prv: key });
            return true;
        }
        catch {
            return false;
        }
    }
    /** @inheritdoc */
    isValidPublicKey(key) {
        try {
            new keyPair_1.CosmosKeyPair({ pub: key });
            return true;
        }
        catch {
            return false;
        }
    }
    /** @inheritdoc */
    isValidSignature(signature) {
        throw new sdk_core_1.NotImplementedError('isValidSignature not implemented');
    }
    /** @inheritdoc */
    isValidTransactionId(txId) {
        return this.validateBlake2b(txId);
    }
    /**
     * Checks if transaction hash is in valid black2b format
     */
    validateBlake2b(hash) {
        if ((hash === null || hash === void 0 ? void 0 : hash.length) !== 64) {
            return false;
        }
        return hash.match(/^[a-zA-Z0-9]+$/) !== null;
    }
    /**
     * Validates whether amounts are in range
     *
     * @param {number[]} amounts - the amounts to validate
     * @returns {boolean} - the validation result
     */
    isValidAmounts(amounts) {
        for (const amount of amounts) {
            if (!this.isValidAmount(amount)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Validates whether amount is in range
     * @param {number} amount
     * @returns {boolean} the validation result
     */
    isValidAmount(amount) {
        const bigNumberAmount = new bignumber_js_1.default(amount);
        if (!bigNumberAmount.isInteger() || bigNumberAmount.isLessThanOrEqualTo(0)) {
            return false;
        }
        return true;
    }
    /**
     * Decodes raw tx data into messages, signing info, and fee data
     * @param {string} txHex - raw base64 tx
     * @returns {DecodedTxRaw} Decoded transaction
     */
    getDecodedTxFromRawBase64(txRaw) {
        try {
            return proto_signing_1.decodeTxRaw(encoding_1.fromBase64(txRaw));
        }
        catch (e) {
            throw new sdk_core_1.ParseTransactionError('Error decoding TxRaw base64 encoded string: ' + e.message);
        }
    }
    /**
     * Returns the array of messages in the body of the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {EncodeObject[]} messages along with type url
     */
    getEncodedMessagesFromDecodedTx(decodedTx) {
        return decodedTx.body.messages;
    }
    /**
     * Checks the txn sequence is valid or not
     * @param {number} sequence
     */
    validateSequence(sequence) {
        if (sequence < 0) {
            throw new sdk_core_1.InvalidTransactionError('Invalid sequence: less than zero');
        }
    }
    /**
     * Pulls the sequence number from a DecodedTxRaw AuthInfo property
     * @param {DecodedTxRaw} decodedTx
     * @returns {number} sequence
     */
    getSequenceFromDecodedTx(decodedTx) {
        return Number(decodedTx.authInfo.signerInfos[0].sequence);
    }
    /**
     * Pulls the typeUrl from the encoded message of a DecodedTxRaw
     * @param {DecodedTxRaw} decodedTx
     * @returns {string} cosmos proto type url
     */
    getTypeUrlFromDecodedTx(decodedTx) {
        const encodedMessage = this.getEncodedMessagesFromDecodedTx(decodedTx)[0];
        return encodedMessage.typeUrl;
    }
    /**
     * Returns the fee data from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {FeeData} fee data
     */
    getGasBudgetFromDecodedTx(decodedTx) {
        var _a, _b;
        return {
            amount: (_a = decodedTx.authInfo.fee) === null || _a === void 0 ? void 0 : _a.amount,
            gasLimit: Number((_b = decodedTx.authInfo.fee) === null || _b === void 0 ? void 0 : _b.gasLimit),
        };
    }
    /**
     * Returns the publicKey from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {string | undefined} publicKey in hex format if it exists, undefined otherwise
     */
    getPublicKeyFromDecodedTx(decodedTx) {
        var _a, _b, _c, _d;
        const publicKeyUInt8Array = (_b = (_a = decodedTx.authInfo.signerInfos) === null || _a === void 0 ? void 0 : _a[0].publicKey) === null || _b === void 0 ? void 0 : _b.value;
        if (publicKeyUInt8Array) {
            return encoding_1.toHex(encoding_1.fromBase64((_d = proto_signing_1.decodePubkey((_c = decodedTx.authInfo.signerInfos) === null || _c === void 0 ? void 0 : _c[0].publicKey)) === null || _d === void 0 ? void 0 : _d.value));
        }
        return undefined;
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Send transaction message data
     */
    getSendMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    fromAddress: value.fromAddress,
                    toAddress: value.toAddress,
                    amount: value.amount,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Delegate of undelegate transaction message data
     */
    getDelegateOrUndelegateMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    delegatorAddress: value.delegatorAddress,
                    validatorAddress: value.validatorAddress,
                    amount: value.amount,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} WithdrawDelegatorRewards transaction message data
     */
    getWithdrawRewardsMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    delegatorAddress: value.delegatorAddress,
                    validatorAddress: value.validatorAddress,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Delegate of undelegate transaction message data
     */
    getWithdrawDelegatorRewardsMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    delegatorAddress: value.delegatorAddress,
                    validatorAddress: value.validatorAddress,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Returns the array of MessageData[] from the decoded transaction
     * @param {DecodedTxRaw} decodedTx
     * @returns {MessageData[]} Execute contract transaction message data
     */
    getExecuteContractMessageDataFromDecodedTx(decodedTx) {
        return decodedTx.body.messages.map((message) => {
            const value = this.registry.decode(message);
            return {
                value: {
                    sender: value.sender,
                    contract: value.contract,
                    msg: value.msg,
                    funds: value.funds,
                },
                typeUrl: message.typeUrl,
            };
        });
    }
    /**
     * Determines bitgo transaction type based on cosmos proto type url
     * @param {string} typeUrl
     * @returns {TransactionType | undefined} TransactionType if url is supported else undefined
     */
    getTransactionTypeFromTypeUrl(typeUrl) {
        switch (typeUrl) {
            case constants.sendMsgTypeUrl:
                return sdk_core_1.TransactionType.Send;
            case constants.delegateMsgTypeUrl:
                return sdk_core_1.TransactionType.StakingActivate;
            case constants.undelegateMsgTypeUrl:
                return sdk_core_1.TransactionType.StakingDeactivate;
            case constants.withdrawDelegatorRewardMsgTypeUrl:
                return sdk_core_1.TransactionType.StakingWithdraw;
            case constants.executeContractMsgTypeUrl:
                return sdk_core_1.TransactionType.ContractCall;
            default:
                return undefined;
        }
    }
    /**
     * Takes a hex encoded pubkey, converts it to the Amino JSON representation (type/value wrapper)
     * and returns it as protobuf `Any`
     * @param {string} pubkey hex encoded compressed secp256k1 public key
     * @returns {Any} pubkey encoded as protobuf `Any`
     */
    getEncodedPubkey(pubkey) {
        return proto_signing_1.encodePubkey(amino_1.encodeSecp256k1Pubkey(encoding_1.fromHex(pubkey)));
    }
    /**
     * Creates a txRaw from an cosmos like transaction @see CosmosLikeTransaction
     * @Precondition cosmosLikeTransaction.publicKey must be defined
     * @param {CosmosLikeTransaction} cosmosLikeTransaction
     * @returns {TxRaw} Unsigned raw transaction
     */
    createTxRawFromCosmosLikeTransaction(cosmosLikeTransaction) {
        if (!cosmosLikeTransaction.publicKey) {
            throw new Error('publicKey is required to create a txRaw');
        }
        const encodedPublicKey = this.getEncodedPubkey(cosmosLikeTransaction.publicKey);
        const messages = cosmosLikeTransaction.sendMessages;
        let txBodyValue;
        if (cosmosLikeTransaction.memo) {
            txBodyValue = {
                memo: cosmosLikeTransaction.memo,
                messages: messages,
            };
        }
        else {
            txBodyValue = {
                messages: messages,
            };
        }
        const txBodyBytes = this.registry.encodeTxBody(txBodyValue);
        const sequence = cosmosLikeTransaction.sequence;
        const authInfoBytes = proto_signing_1.makeAuthInfoBytes([{ pubkey: encodedPublicKey, sequence }], cosmosLikeTransaction.gasBudget.amount, cosmosLikeTransaction.gasBudget.gasLimit, undefined, undefined, undefined);
        return tx_1.TxRaw.fromPartial({
            bodyBytes: txBodyBytes,
            authInfoBytes: authInfoBytes,
        });
    }
    /**
     * Encodes a signature into a txRaw
     * @param {string} publicKeyHex publicKey in hex encoded string format
     * @param {string} signatureHex signature in hex encoded string format
     * @param {TxRaw} unsignedTx raw transaction
     * @returns {TxRaw} Signed raw transaction
     */
    createSignedTxRaw(publicKeyHex, signatureHex, unsignedTx) {
        const stdSignature = amino_1.encodeSecp256k1Signature(encoding_1.fromHex(publicKeyHex), encoding_1.fromHex(signatureHex));
        return tx_1.TxRaw.fromPartial({
            bodyBytes: unsignedTx.bodyBytes,
            authInfoBytes: unsignedTx.authInfoBytes,
            signatures: [encoding_1.fromBase64(stdSignature.signature)],
        });
    }
    /**
     * Decodes a raw transaction into a DecodedTxRaw and checks if it has non empty signatures
     * @param {string} rawTransaction
     * @returns {boolean} true if transaction is signed else false
     */
    isSignedRawTx(rawTransaction) {
        const decodedTx = this.getDecodedTxFromRawBase64(rawTransaction);
        if (decodedTx.signatures.length > 0) {
            return true;
        }
        return false;
    }
    /**
     * Returns whether or not the string is a valid protocol public key
     * @param {string | undefined} publicKey - the  public key to be validated
     */
    validatePublicKey(publicKey) {
        if (publicKey !== undefined) {
            try {
                new keyPair_1.CosmosKeyPair({ pub: publicKey });
            }
            catch {
                throw new sdk_core_1.InvalidTransactionError(`Invalid Public Key`);
            }
        }
    }
    /**
     * Creates a sign doc from an cosmos like transaction @see CosmosLikeTransaction
     * @Precondition cosmosLikeTransaction.accountNumber and cosmosLikeTransaction.chainId must be defined
     * @param {CosmosLikeTransaction} cosmosLikeTransaction
     * @returns {SignDoc} sign doc
     */
    createSignDoc(cosmosLikeTransaction, accountNumber, chainId) {
        if (!accountNumber) {
            throw new Error('accountNumber is required to create a sign doc');
        }
        if (!chainId) {
            throw new Error('chainId is required to create a sign doc');
        }
        if (!cosmosLikeTransaction) {
            throw new Error('cosmosLikeTransaction is required to create a sign doc');
        }
        const txRaw = this.createTxRawFromCosmosLikeTransaction(cosmosLikeTransaction);
        return proto_signing_1.makeSignDoc(txRaw.bodyBytes, txRaw.authInfoBytes, chainId, accountNumber);
    }
    /**
     * Returns whether or not the string is a valid hex
     * @param hexString - hex string format
     * @returns {boolean} true if string is hex else false
     */
    isValidHexString(hexString) {
        return /^[0-9A-Fa-f]*$/.test(hexString);
    }
    /**
     * Validates the WithdrawDelegatorRewardsMessage
     * @param {WithdrawDelegatorRewardsMessage} withdrawRewardsMessage - The WithdrawDelegatorRewardsMessage to validate.
     * @throws {InvalidTransactionError} Throws an error if the validatorAddress or delegatorAddress is invalid or missing.
     */
    validateWithdrawRewardsMessage(withdrawRewardsMessage) {
        if (!withdrawRewardsMessage.validatorAddress ||
            !this.isValidValidatorAddress(withdrawRewardsMessage.validatorAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid WithdrawDelegatorRewardsMessage validatorAddress: ` + withdrawRewardsMessage.validatorAddress);
        }
        if (!withdrawRewardsMessage.delegatorAddress || !this.isValidAddress(withdrawRewardsMessage.delegatorAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid WithdrawDelegatorRewardsMessage delegatorAddress: ` + withdrawRewardsMessage.delegatorAddress);
        }
    }
    /**
     * Helper method to check if the specified properties in an object are missing or null.
     * @param {Object} obj - The object to check.
     * @param {string[]} keys - An array of property keys to check.
     * @throws {Error} Throws an error if any of the specified properties are missing or null.
     */
    isObjPropertyNull(obj, keys) {
        for (const key of keys) {
            if (obj[key] == null) {
                throw new Error(`Missing or null value for property ${key}`);
            }
        }
    }
    /**
     * Validates the DelegateOrUndelegeteMessage
     * @param {DelegateOrUndelegeteMessage} delegateMessage - The DelegateOrUndelegeteMessage to validate.
     * @throws {InvalidTransactionError} Throws an error if the validatorAddress, delegatorAddress, or amount is invalid or missing.
     */
    validateDelegateOrUndelegateMessage(delegateMessage) {
        this.isObjPropertyNull(delegateMessage, ['validatorAddress', 'delegatorAddress']);
        if (!this.isValidValidatorAddress(delegateMessage.validatorAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid DelegateOrUndelegeteMessage validatorAddress: ` + delegateMessage.validatorAddress);
        }
        if (!this.isValidAddress(delegateMessage.delegatorAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid DelegateOrUndelegeteMessage delegatorAddress: ` + delegateMessage.delegatorAddress);
        }
        this.validateAmount(delegateMessage.amount);
    }
    /**
     * Validates the MessageData
     * @param {MessageData} messageData - The MessageData to validate.
     * @throws {InvalidTransactionError} Throws an error if the messageData is invalid or missing required fields.
     */
    validateMessageData(messageData) {
        if (messageData == null) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid MessageData: undefined`);
        }
        if (messageData.typeUrl == null || this.getTransactionTypeFromTypeUrl(messageData.typeUrl) == null) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid MessageData typeurl: ` + messageData.typeUrl);
        }
        const type = this.getTransactionTypeFromTypeUrl(messageData.typeUrl);
        switch (type) {
            case sdk_core_1.TransactionType.Send: {
                const value = messageData.value;
                this.validateSendMessage(value);
                break;
            }
            case sdk_core_1.TransactionType.StakingActivate:
            case sdk_core_1.TransactionType.StakingDeactivate: {
                const value = messageData.value;
                this.validateDelegateOrUndelegateMessage(value);
                break;
            }
            case sdk_core_1.TransactionType.StakingWithdraw: {
                const value = messageData.value;
                this.validateWithdrawRewardsMessage(value);
                break;
            }
            case sdk_core_1.TransactionType.ContractCall: {
                const value = messageData.value;
                this.validateExecuteContractMessage(value, sdk_core_1.TransactionType.ContractCall);
                break;
            }
            default:
                throw new sdk_core_1.InvalidTransactionError(`Invalid MessageData TypeUrl is not supported: ` + messageData.typeUrl);
        }
    }
    /**
     * Validates the Cosmos-like transaction.
     * @param {CosmosLikeTransaction} tx - The transaction to validate.
     * @throws {InvalidTransactionError} Throws an error if the transaction is invalid or missing required fields.
     */
    validateTransaction(tx) {
        this.validateSequence(tx.sequence);
        this.validateGasBudget(tx.gasBudget);
        this.validatePublicKey(tx.publicKey);
        if (tx.sendMessages === undefined || tx.sendMessages.length === 0) {
            throw new sdk_core_1.InvalidTransactionError('Invalid transaction: messages is required');
        }
        else {
            tx.sendMessages.forEach((message) => this.validateMessageData(message));
        }
    }
    /**
     * Creates a Cosmos-like transaction.
     * @param {number} sequence - The sender address sequence number for the transaction.
     * @param {MessageData[]} messages - The array of message data for the transaction.
     * @param {FeeData} gasBudget - The fee data for the transaction.
     * @param {string} [publicKey] - The public key associated with the sender.
     * @param {string} [memo] - The memo for the transaction.
     * @returns {CosmosLikeTransaction} Returns the created Cosmos-like transaction.
     * @throws {InvalidTransactionError} Throws an error if the created transaction is invalid.
     */
    createTransaction(sequence, messages, gasBudget, publicKey, memo) {
        const cosmosLikeTxn = {
            sequence: sequence,
            sendMessages: messages,
            gasBudget: gasBudget,
            publicKey: publicKey,
            memo: memo,
        };
        this.validateTransaction(cosmosLikeTxn);
        return cosmosLikeTxn;
    }
    /**
     * Creates a Cosmos-like transaction with a hash.
     * @param {number} sequence - The sender address sequence number for the transaction.
     * @param {MessageData[]} messages - The array of message data for the transaction.
     * @param {FeeData} gasBudget - The fee data for the transaction.
     * @param {string} [publicKey] - The public key associated with the transaction.
     * @param {Buffer} [signature] - The signature for the transaction.
     * @param {string} [memo] - The memo for the transaction.
     * @returns {CosmosLikeTransaction} Returns the created Cosmos-like transaction with the hash and signature if provided.
     */
    createTransactionWithHash(sequence, messages, gasBudget, publicKey, signature, memo) {
        const cosmosLikeTxn = this.createTransaction(sequence, messages, gasBudget, publicKey, memo);
        let hash = constants.UNAVAILABLE_TEXT;
        if (signature !== undefined) {
            const unsignedTx = this.createTxRawFromCosmosLikeTransaction(cosmosLikeTxn);
            const signedTx = tx_1.TxRaw.fromPartial({
                bodyBytes: unsignedTx.bodyBytes,
                authInfoBytes: unsignedTx.authInfoBytes,
                signatures: [signature],
            });
            hash = crypto_1.createHash('sha256')
                .update(tx_1.TxRaw.encode(signedTx).finish())
                .digest()
                .toString('hex')
                .toLocaleUpperCase('en-US');
            return { ...cosmosLikeTxn, hash: hash, signature: signature };
        }
        return { ...cosmosLikeTxn, hash: hash };
    }
    /**
     * Deserializes base64 enocded raw transaction string into @see CosmosLikeTransaction
     * @param {string} rawTx base64 enocded raw transaction string
     * @returns {CosmosLikeTransaction} Deserialized cosmosLikeTransaction
     */
    deserializeTransaction(rawTx) {
        var _a, _b;
        const decodedTx = this.getDecodedTxFromRawBase64(rawTx);
        const typeUrl = this.getTypeUrlFromDecodedTx(decodedTx);
        const type = this.getTransactionTypeFromTypeUrl(typeUrl);
        let sendMessageData;
        if (type === sdk_core_1.TransactionType.Send) {
            sendMessageData = this.getSendMessageDataFromDecodedTx(decodedTx);
        }
        else if (type === sdk_core_1.TransactionType.StakingActivate || type === sdk_core_1.TransactionType.StakingDeactivate) {
            sendMessageData = this.getDelegateOrUndelegateMessageDataFromDecodedTx(decodedTx);
        }
        else if (type === sdk_core_1.TransactionType.StakingWithdraw) {
            sendMessageData = this.getWithdrawRewardsMessageDataFromDecodedTx(decodedTx);
        }
        else if (type === sdk_core_1.TransactionType.ContractCall) {
            sendMessageData = this.getExecuteContractMessageDataFromDecodedTx(decodedTx);
        }
        else {
            throw new Error('Transaction type not supported: ' + typeUrl);
        }
        const sequence = this.getSequenceFromDecodedTx(decodedTx);
        const gasBudget = this.getGasBudgetFromDecodedTx(decodedTx);
        const publicKey = this.getPublicKeyFromDecodedTx(decodedTx);
        const signature = ((_a = decodedTx.signatures) === null || _a === void 0 ? void 0 : _a[0]) !== undefined ? Buffer.from(decodedTx.signatures[0]) : undefined;
        return this.createTransactionWithHash(sequence, sendMessageData, gasBudget, publicKey, signature, (_b = decodedTx.body) === null || _b === void 0 ? void 0 : _b.memo);
    }
    /**
     * Validates an array of coin amounts.
     * @param {Coin[]} amountArray - The array of coin amounts to validate.
     * @param {TransactionType} transactionType - optional field for transaction type
     */
    validateAmountData(amountArray, transactionType) {
        amountArray.forEach((coinAmount) => {
            this.validateAmount(coinAmount, transactionType);
        });
    }
    /**
     * Validates the gas limit and gas amount for a transaction.
     * @param {FeeData} gasBudget - The gas budget to validate.
     * @throws {InvalidTransactionError} Throws an error if the gas budget is invalid.
     */
    validateGasBudget(gasBudget) {
        if (gasBudget.gasLimit <= 0) {
            throw new sdk_core_1.InvalidTransactionError('Invalid gas limit ' + gasBudget.gasLimit);
        }
        this.validateAmountData(gasBudget.amount);
    }
    /**
     * Validates a send message for a transaction.
     * @param {SendMessage} sendMessage - The send message to validate.
     * @throws {InvalidTransactionError} Throws an error if the send message is invalid.
     */
    validateSendMessage(sendMessage) {
        if (!sendMessage.toAddress || !this.isValidAddress(sendMessage.toAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid SendMessage toAddress: ` + sendMessage.toAddress);
        }
        if (!sendMessage.fromAddress || !this.isValidAddress(sendMessage.fromAddress)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid SendMessage fromAddress: ` + sendMessage.fromAddress);
        }
        this.validateAmountData(sendMessage.amount);
    }
    /**
     * Validates a coin amount.
     * @param {Coin} amount - The coin amount to validate.
     * @param {TransactionType} transactionType - optional field for transaction type
     * @throws {InvalidTransactionError} Throws an error if the coin amount is invalid.
     */
    validateAmount(amount, transactionType) {
        throw new sdk_core_1.NotImplementedError('validateAmount not implemented');
    }
    /**
     * Validates if the address matches with regex @see accountAddressRegex
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidValidatorAddress(address) {
        throw new sdk_core_1.NotImplementedError('isValidValidatorAddress not implemented');
    }
    /**
     * Validates if the address matches with regex @see accountAddressRegex
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidAddress(address) {
        throw new sdk_core_1.NotImplementedError('isValidAddress not implemented');
    }
    /**
     * Validates if the address matches with regex @see contractAddressRegex
     * @param {string} address
     * @returns {boolean} - the validation result
     */
    isValidContractAddress(address) {
        throw new sdk_core_1.NotImplementedError('isValidContractAddress not implemented');
    }
    /**
     * Validates a execute contract message
     * @param {ExecuteContractMessage} message - The execute contract message to validate
     * @param {TransactionType} transactionType - optional field for transaction type
     * @throws {InvalidTransactionError} Throws an error if the message is invalid
     */
    validateExecuteContractMessage(message, transactionType) {
        if (!message.contract || !this.isValidContractAddress(message.contract)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid ExecuteContractMessage contract address: ` + message.contract);
        }
        if (!message.sender || !this.isValidAddress(message.sender)) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid ExecuteContractMessage sender address: ` + message.sender);
        }
        if (!message.msg) {
            throw new sdk_core_1.InvalidTransactionError(`Invalid ExecuteContractMessage msg: ` + message.msg);
        }
        if (message.funds) {
            this.validateAmountData(message.funds, transactionType);
        }
    }
    /**
     * Get coin specific hash function
     * @returns {Hash} The hash function
     */
    getHashFunction() {
        return crypto_1.createHash('sha256');
    }
}
exports.CosmosUtils = CosmosUtils;
const utils = new CosmosUtils();
exports.default = utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDhDQU15QjtBQUN6Qix5Q0FBZ0Y7QUFDaEYsK0NBQThEO0FBQzlELHlEQVMrQjtBQUMvQiwrQ0FBOEQ7QUFDOUQsK0NBQXFDO0FBQ3JDLDBEQUFtRTtBQUVuRSx5REFBc0U7QUFFdEUsbUNBQTBDO0FBQzFDLHlDQUF5QztBQVV6Qyx1Q0FBcUQ7QUFFckQsTUFBYSxXQUFXO0lBR3RCO1FBQ0UsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLHdCQUFRLENBQUMsQ0FBQyxHQUFHLCtCQUFvQixDQUFDLENBQUMsQ0FBQztRQUN4RCxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMseUJBQXlCLEVBQUUsdUJBQWtCLENBQUMsQ0FBQztJQUNsRixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLGNBQWMsQ0FBQyxJQUFZO1FBQ3pCLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLGlCQUFpQixDQUFDLEdBQVc7UUFDM0IsSUFBSTtZQUNGLElBQUksdUJBQU8sQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFBQyxNQUFNO1lBQ04sT0FBTyxLQUFLLENBQUM7U0FDZDtJQUNILENBQUM7SUFFRCxrQkFBa0I7SUFDbEIsZ0JBQWdCLENBQUMsR0FBVztRQUMxQixJQUFJO1lBQ0YsSUFBSSx1QkFBTyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7WUFDMUIsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUFDLE1BQU07WUFDTixPQUFPLEtBQUssQ0FBQztTQUNkO0lBQ0gsQ0FBQztJQUVELGtCQUFrQjtJQUNsQixnQkFBZ0IsQ0FB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QyxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQ3ZFLE1BQU0sSUFBSSxrQ0FBdUIsQ0FBQyxtREFBbUQsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDM0c7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzNELE1BQU0sSUFBSSxrQ0FBdUIsQ0FBQyxpREFBaUQsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDdkc7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRTtZQUNoQixNQUFNLElBQUksa0NBQXVCLENBQUMsc0NBQXNDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3pGO1FBQ0QsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO1lBQ2pCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1NBQ3pEO0lBQ0gsQ0FBQztJQUVEOzs7T0FHRztJQUNILGVBQWU7UUFDYixPQUFPLG1CQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDOUIsQ0FBQztDQUNGO0FBL3NCRCxrQ0Erc0JDO0FBRUQsTUFBTSxLQUFLLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQztBQUVoQyxrQkFBZSxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCYXNlVXRpbHMsXG4gIEludmFsaWRUcmFuc2FjdGlvbkVycm9yLFxuICBOb3RJbXBsZW1lbnRlZEVycm9yLFxuICBQYXJzZVRyYW5zYWN0aW9uRXJyb3IsXG4gIFRyYW5zYWN0aW9uVHlwZSxcbn0gZnJvbSAnQGJpdGdvL3Nkay1jb3JlJztcbmltcG9ydCB7IGVuY29kZVNlY3AyNTZrMVB1YmtleSwgZW5jb2RlU2VjcDI1NmsxU2lnbmF0dXJlIH0gZnJvbSAnQGNvc21qcy9hbWlubyc7XG5pbXBvcnQgeyBmcm9tQmFzZTY0LCBmcm9tSGV4LCB0b0hleCB9IGZyb20gJ0Bjb3NtanMvZW5jb2RpbmcnO1xuaW1wb3J0IHtcbiAgRGVjb2RlZFR4UmF3LFxuICBFbmNvZGVPYmplY3QsXG4gIFJlZ2lzdHJ5LFxuICBkZWNvZGVQdWJrZXksXG4gIGRlY29kZVR4UmF3LFxuICBlbmNvZGVQdWJrZXksXG4gIG1ha2VBdXRoSW5mb0J5dGVzLFxuICBtYWtlU2lnbkRvYyxcbn0gZnJvbSAnQGNvc21qcy9wcm90by1zaWduaW5nJztcbmltcG9ydCB7IENvaW4sIGRlZmF1bHRSZWdpc3RyeVR5cGVzIH0gZnJvbSAnQGNvc21qcy9zdGFyZ2F0ZSc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBTaWduRG9jLCBUeFJhdyB9IGZyb20gJ2Nvc21qcy10eXBlcy9jb3Ntb3MvdHgvdjFiZXRhMS90eCc7XG5pbXBvcnQgeyBBbnkgfSBmcm9tICdjb3NtanMtdHlwZXMvZ29vZ2xlL3Byb3RvYnVmL2FueSc7XG5pbXBvcnQgeyBNc2dFeGVjdXRlQ29udHJhY3QgfSBmcm9tICdjb3NtanMtdHlwZXMvY29zbXdhc20vd2FzbS92MS90eCc7XG5cbmltcG9ydCB7IEhhc2gsIGNyZWF0ZUhhc2ggfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIENvc21vc0xpa2VUcmFuc2FjdGlvbixcbiAgRGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlLFxuICBFeGVjdXRlQ29udHJhY3RNZXNzYWdlLFxuICBGZWVEYXRhLFxuICBNZXNzYWdlRGF0YSxcbiAgU2VuZE1lc3NhZ2UsXG4gIFdpdGhkcmF3RGVsZWdhdG9yUmV3YXJkc01lc3NhZ2UsXG59IGZyb20gJy4vaWZhY2UnO1xuaW1wb3J0IHsgQ29zbW9zS2V5UGFpciBhcyBLZXlQYWlyIH0gZnJvbSAnLi9rZXlQYWlyJztcblxuZXhwb3J0IGNsYXNzIENvc21vc1V0aWxzIGltcGxlbWVudHMgQmFzZVV0aWxzIHtcbiAgcHJpdmF0ZSByZWdpc3RyeTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KFsuLi5kZWZhdWx0UmVnaXN0cnlUeXBlc10pO1xuICAgIHRoaXMucmVnaXN0cnkucmVnaXN0ZXIoY29uc3RhbnRzLmV4ZWN1dGVDb250cmFjdE1zZ1R5cGVVcmwsIE1zZ0V4ZWN1dGVDb250cmFjdCk7XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZEJsb2NrSWQoaGFzaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGVCbGFrZTJiKGhhc2gpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRQcml2YXRlS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBLZXlQYWlyKHsgcHJ2OiBrZXkgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKiogQGluaGVyaXRkb2MgKi9cbiAgaXNWYWxpZFB1YmxpY0tleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgS2V5UGFpcih7IHB1Yjoga2V5IH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIGlzVmFsaWRTaWduYXR1cmUoc2lnbmF0dXJlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignaXNWYWxpZFNpZ25hdHVyZSBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBpc1ZhbGlkVHJhbnNhY3Rpb25JZCh0eElkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUJsYWtlMmIodHhJZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRyYW5zYWN0aW9uIGhhc2ggaXMgaW4gdmFsaWQgYmxhY2syYiBmb3JtYXRcbiAgICovXG4gIHZhbGlkYXRlQmxha2UyYihoYXNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoaGFzaD8ubGVuZ3RoICE9PSA2NCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaC5tYXRjaCgvXlthLXpBLVowLTldKyQvKSAhPT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgd2hldGhlciBhbW91bnRzIGFyZSBpbiByYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcltdfSBhbW91bnRzIC0gdGhlIGFtb3VudHMgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICBpc1ZhbGlkQW1vdW50cyhhbW91bnRzOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xuICAgIGZvciAoY29uc3QgYW1vdW50IG9mIGFtb3VudHMpIHtcbiAgICAgIGlmICghdGhpcy5pc1ZhbGlkQW1vdW50KGFtb3VudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgd2hldGhlciBhbW91bnQgaXMgaW4gcmFuZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICBpc1ZhbGlkQW1vdW50KGFtb3VudDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYmlnTnVtYmVyQW1vdW50ID0gbmV3IEJpZ051bWJlcihhbW91bnQpO1xuICAgIGlmICghYmlnTnVtYmVyQW1vdW50LmlzSW50ZWdlcigpIHx8IGJpZ051bWJlckFtb3VudC5pc0xlc3NUaGFuT3JFcXVhbFRvKDApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZXMgcmF3IHR4IGRhdGEgaW50byBtZXNzYWdlcywgc2lnbmluZyBpbmZvLCBhbmQgZmVlIGRhdGFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR4SGV4IC0gcmF3IGJhc2U2NCB0eFxuICAgKiBAcmV0dXJucyB7RGVjb2RlZFR4UmF3fSBEZWNvZGVkIHRyYW5zYWN0aW9uXG4gICAqL1xuICBnZXREZWNvZGVkVHhGcm9tUmF3QmFzZTY0KHR4UmF3OiBzdHJpbmcpOiBEZWNvZGVkVHhSYXcge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZGVjb2RlVHhSYXcoZnJvbUJhc2U2NCh0eFJhdykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZVRyYW5zYWN0aW9uRXJyb3IoJ0Vycm9yIGRlY29kaW5nIFR4UmF3IGJhc2U2NCBlbmNvZGVkIHN0cmluZzogJyArIGUubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IG9mIG1lc3NhZ2VzIGluIHRoZSBib2R5IG9mIHRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RGVjb2RlZFR4UmF3fSBkZWNvZGVkVHhcbiAgICogQHJldHVybnMge0VuY29kZU9iamVjdFtdfSBtZXNzYWdlcyBhbG9uZyB3aXRoIHR5cGUgdXJsXG4gICAqL1xuICBwcml2YXRlIGdldEVuY29kZWRNZXNzYWdlc0Zyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBFbmNvZGVPYmplY3RbXSB7XG4gICAgcmV0dXJuIGRlY29kZWRUeC5ib2R5Lm1lc3NhZ2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgdHhuIHNlcXVlbmNlIGlzIHZhbGlkIG9yIG5vdFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2VxdWVuY2VcbiAgICovXG4gIHZhbGlkYXRlU2VxdWVuY2Uoc2VxdWVuY2U6IG51bWJlcikge1xuICAgIGlmIChzZXF1ZW5jZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcignSW52YWxpZCBzZXF1ZW5jZTogbGVzcyB0aGFuIHplcm8nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHVsbHMgdGhlIHNlcXVlbmNlIG51bWJlciBmcm9tIGEgRGVjb2RlZFR4UmF3IEF1dGhJbmZvIHByb3BlcnR5XG4gICAqIEBwYXJhbSB7RGVjb2RlZFR4UmF3fSBkZWNvZGVkVHhcbiAgICogQHJldHVybnMge251bWJlcn0gc2VxdWVuY2VcbiAgICovXG4gIGdldFNlcXVlbmNlRnJvbURlY29kZWRUeChkZWNvZGVkVHg6IERlY29kZWRUeFJhdyk6IG51bWJlciB7XG4gICAgcmV0dXJuIE51bWJlcihkZWNvZGVkVHguYXV0aEluZm8uc2lnbmVySW5mb3NbMF0uc2VxdWVuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1bGxzIHRoZSB0eXBlVXJsIGZyb20gdGhlIGVuY29kZWQgbWVzc2FnZSBvZiBhIERlY29kZWRUeFJhd1xuICAgKiBAcGFyYW0ge0RlY29kZWRUeFJhd30gZGVjb2RlZFR4XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGNvc21vcyBwcm90byB0eXBlIHVybFxuICAgKi9cbiAgZ2V0VHlwZVVybEZyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlID0gdGhpcy5nZXRFbmNvZGVkTWVzc2FnZXNGcm9tRGVjb2RlZFR4KGRlY29kZWRUeClbMF07XG4gICAgcmV0dXJuIGVuY29kZWRNZXNzYWdlLnR5cGVVcmw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmVlIGRhdGEgZnJvbSB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0RlY29kZWRUeFJhd30gZGVjb2RlZFR4XG4gICAqIEByZXR1cm5zIHtGZWVEYXRhfSBmZWUgZGF0YVxuICAgKi9cbiAgZ2V0R2FzQnVkZ2V0RnJvbURlY29kZWRUeChkZWNvZGVkVHg6IERlY29kZWRUeFJhdyk6IEZlZURhdGEge1xuICAgIHJldHVybiB7XG4gICAgICBhbW91bnQ6IGRlY29kZWRUeC5hdXRoSW5mby5mZWU/LmFtb3VudCBhcyBDb2luW10sXG4gICAgICBnYXNMaW1pdDogTnVtYmVyKGRlY29kZWRUeC5hdXRoSW5mby5mZWU/Lmdhc0xpbWl0KSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHB1YmxpY0tleSBmcm9tIHRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RGVjb2RlZFR4UmF3fSBkZWNvZGVkVHhcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gcHVibGljS2V5IGluIGhleCBmb3JtYXQgaWYgaXQgZXhpc3RzLCB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAqL1xuICBnZXRQdWJsaWNLZXlGcm9tRGVjb2RlZFR4KGRlY29kZWRUeDogRGVjb2RlZFR4UmF3KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBwdWJsaWNLZXlVSW50OEFycmF5ID0gZGVjb2RlZFR4LmF1dGhJbmZvLnNpZ25lckluZm9zPy5bMF0ucHVibGljS2V5Py52YWx1ZTtcbiAgICBpZiAocHVibGljS2V5VUludDhBcnJheSkge1xuICAgICAgcmV0dXJuIHRvSGV4KGZyb21CYXNlNjQoZGVjb2RlUHVia2V5KGRlY29kZWRUeC5hdXRoSW5mby5zaWduZXJJbmZvcz8uWzBdLnB1YmxpY0tleSk/LnZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgTWVzc2FnZURhdGFbXSBmcm9tIHRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RGVjb2RlZFR4UmF3fSBkZWNvZGVkVHhcbiAgICogQHJldHVybnMge01lc3NhZ2VEYXRhW119IFNlbmQgdHJhbnNhY3Rpb24gbWVzc2FnZSBkYXRhXG4gICAqL1xuICBwcm90ZWN0ZWQgZ2V0U2VuZE1lc3NhZ2VEYXRhRnJvbURlY29kZWRUeChkZWNvZGVkVHg6IERlY29kZWRUeFJhdyk6IE1lc3NhZ2VEYXRhW10ge1xuICAgIHJldHVybiBkZWNvZGVkVHguYm9keS5tZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWdpc3RyeS5kZWNvZGUobWVzc2FnZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGZyb21BZGRyZXNzOiB2YWx1ZS5mcm9tQWRkcmVzcyxcbiAgICAgICAgICB0b0FkZHJlc3M6IHZhbHVlLnRvQWRkcmVzcyxcbiAgICAgICAgICBhbW91bnQ6IHZhbHVlLmFtb3VudCxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZVVybDogbWVzc2FnZS50eXBlVXJsLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBNZXNzYWdlRGF0YVtdIGZyb20gdGhlIGRlY29kZWQgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtEZWNvZGVkVHhSYXd9IGRlY29kZWRUeFxuICAgKiBAcmV0dXJucyB7TWVzc2FnZURhdGFbXX0gRGVsZWdhdGUgb2YgdW5kZWxlZ2F0ZSB0cmFuc2FjdGlvbiBtZXNzYWdlIGRhdGFcbiAgICovXG4gIGdldERlbGVnYXRlT3JVbmRlbGVnYXRlTWVzc2FnZURhdGFGcm9tRGVjb2RlZFR4KGRlY29kZWRUeDogRGVjb2RlZFR4UmF3KTogTWVzc2FnZURhdGFbXSB7XG4gICAgcmV0dXJuIGRlY29kZWRUeC5ib2R5Lm1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlZ2lzdHJ5LmRlY29kZShtZXNzYWdlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZGVsZWdhdG9yQWRkcmVzczogdmFsdWUuZGVsZWdhdG9yQWRkcmVzcyxcbiAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiB2YWx1ZS52YWxpZGF0b3JBZGRyZXNzLFxuICAgICAgICAgIGFtb3VudDogdmFsdWUuYW1vdW50LFxuICAgICAgICB9LFxuICAgICAgICB0eXBlVXJsOiBtZXNzYWdlLnR5cGVVcmwsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFycmF5IG9mIE1lc3NhZ2VEYXRhW10gZnJvbSB0aGUgZGVjb2RlZCB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0RlY29kZWRUeFJhd30gZGVjb2RlZFR4XG4gICAqIEByZXR1cm5zIHtNZXNzYWdlRGF0YVtdfSBXaXRoZHJhd0RlbGVnYXRvclJld2FyZHMgdHJhbnNhY3Rpb24gbWVzc2FnZSBkYXRhXG4gICAqL1xuICBnZXRXaXRoZHJhd1Jld2FyZHNNZXNzYWdlRGF0YUZyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBNZXNzYWdlRGF0YVtdIHtcbiAgICByZXR1cm4gZGVjb2RlZFR4LmJvZHkubWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVnaXN0cnkuZGVjb2RlKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiB2YWx1ZS5kZWxlZ2F0b3JBZGRyZXNzLFxuICAgICAgICAgIHZhbGlkYXRvckFkZHJlc3M6IHZhbHVlLnZhbGlkYXRvckFkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVVcmw6IG1lc3NhZ2UudHlwZVVybCxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgTWVzc2FnZURhdGFbXSBmcm9tIHRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RGVjb2RlZFR4UmF3fSBkZWNvZGVkVHhcbiAgICogQHJldHVybnMge01lc3NhZ2VEYXRhW119IERlbGVnYXRlIG9mIHVuZGVsZWdhdGUgdHJhbnNhY3Rpb24gbWVzc2FnZSBkYXRhXG4gICAqL1xuICBnZXRXaXRoZHJhd0RlbGVnYXRvclJld2FyZHNNZXNzYWdlRGF0YUZyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBNZXNzYWdlRGF0YVtdIHtcbiAgICByZXR1cm4gZGVjb2RlZFR4LmJvZHkubWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVnaXN0cnkuZGVjb2RlKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiB2YWx1ZS5kZWxlZ2F0b3JBZGRyZXNzLFxuICAgICAgICAgIHZhbGlkYXRvckFkZHJlc3M6IHZhbHVlLnZhbGlkYXRvckFkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVVcmw6IG1lc3NhZ2UudHlwZVVybCxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgTWVzc2FnZURhdGFbXSBmcm9tIHRoZSBkZWNvZGVkIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7RGVjb2RlZFR4UmF3fSBkZWNvZGVkVHhcbiAgICogQHJldHVybnMge01lc3NhZ2VEYXRhW119IEV4ZWN1dGUgY29udHJhY3QgdHJhbnNhY3Rpb24gbWVzc2FnZSBkYXRhXG4gICAqL1xuICBnZXRFeGVjdXRlQ29udHJhY3RNZXNzYWdlRGF0YUZyb21EZWNvZGVkVHgoZGVjb2RlZFR4OiBEZWNvZGVkVHhSYXcpOiBNZXNzYWdlRGF0YVtdIHtcbiAgICByZXR1cm4gZGVjb2RlZFR4LmJvZHkubWVzc2FnZXMubWFwKChtZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVnaXN0cnkuZGVjb2RlKG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBzZW5kZXI6IHZhbHVlLnNlbmRlcixcbiAgICAgICAgICBjb250cmFjdDogdmFsdWUuY29udHJhY3QsXG4gICAgICAgICAgbXNnOiB2YWx1ZS5tc2csXG4gICAgICAgICAgZnVuZHM6IHZhbHVlLmZ1bmRzLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlVXJsOiBtZXNzYWdlLnR5cGVVcmwsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgYml0Z28gdHJhbnNhY3Rpb24gdHlwZSBiYXNlZCBvbiBjb3Ntb3MgcHJvdG8gdHlwZSB1cmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVVcmxcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9uVHlwZSB8IHVuZGVmaW5lZH0gVHJhbnNhY3Rpb25UeXBlIGlmIHVybCBpcyBzdXBwb3J0ZWQgZWxzZSB1bmRlZmluZWRcbiAgICovXG4gIGdldFRyYW5zYWN0aW9uVHlwZUZyb21UeXBlVXJsKHR5cGVVcmw6IHN0cmluZyk6IFRyYW5zYWN0aW9uVHlwZSB8IHVuZGVmaW5lZCB7XG4gICAgc3dpdGNoICh0eXBlVXJsKSB7XG4gICAgICBjYXNlIGNvbnN0YW50cy5zZW5kTXNnVHlwZVVybDpcbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uVHlwZS5TZW5kO1xuICAgICAgY2FzZSBjb25zdGFudHMuZGVsZWdhdGVNc2dUeXBlVXJsOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBY3RpdmF0ZTtcbiAgICAgIGNhc2UgY29uc3RhbnRzLnVuZGVsZWdhdGVNc2dUeXBlVXJsOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdEZWFjdGl2YXRlO1xuICAgICAgY2FzZSBjb25zdGFudHMud2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRNc2dUeXBlVXJsOlxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdXaXRoZHJhdztcbiAgICAgIGNhc2UgY29uc3RhbnRzLmV4ZWN1dGVDb250cmFjdE1zZ1R5cGVVcmw6XG4gICAgICAgIHJldHVybiBUcmFuc2FjdGlvblR5cGUuQ29udHJhY3RDYWxsO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSBoZXggZW5jb2RlZCBwdWJrZXksIGNvbnZlcnRzIGl0IHRvIHRoZSBBbWlubyBKU09OIHJlcHJlc2VudGF0aW9uICh0eXBlL3ZhbHVlIHdyYXBwZXIpXG4gICAqIGFuZCByZXR1cm5zIGl0IGFzIHByb3RvYnVmIGBBbnlgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJrZXkgaGV4IGVuY29kZWQgY29tcHJlc3NlZCBzZWNwMjU2azEgcHVibGljIGtleVxuICAgKiBAcmV0dXJucyB7QW55fSBwdWJrZXkgZW5jb2RlZCBhcyBwcm90b2J1ZiBgQW55YFxuICAgKi9cbiAgZ2V0RW5jb2RlZFB1YmtleShwdWJrZXk6IHN0cmluZyk6IEFueSB7XG4gICAgcmV0dXJuIGVuY29kZVB1YmtleShlbmNvZGVTZWNwMjU2azFQdWJrZXkoZnJvbUhleChwdWJrZXkpKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHR4UmF3IGZyb20gYW4gY29zbW9zIGxpa2UgdHJhbnNhY3Rpb24gQHNlZSBDb3Ntb3NMaWtlVHJhbnNhY3Rpb25cbiAgICogQFByZWNvbmRpdGlvbiBjb3Ntb3NMaWtlVHJhbnNhY3Rpb24ucHVibGljS2V5IG11c3QgYmUgZGVmaW5lZFxuICAgKiBAcGFyYW0ge0Nvc21vc0xpa2VUcmFuc2FjdGlvbn0gY29zbW9zTGlrZVRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtUeFJhd30gVW5zaWduZWQgcmF3IHRyYW5zYWN0aW9uXG4gICAqL1xuICBjcmVhdGVUeFJhd0Zyb21Db3Ntb3NMaWtlVHJhbnNhY3Rpb24oY29zbW9zTGlrZVRyYW5zYWN0aW9uOiBDb3Ntb3NMaWtlVHJhbnNhY3Rpb24pOiBUeFJhdyB7XG4gICAgaWYgKCFjb3Ntb3NMaWtlVHJhbnNhY3Rpb24ucHVibGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1YmxpY0tleSBpcyByZXF1aXJlZCB0byBjcmVhdGUgYSB0eFJhdycpO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGVkUHVibGljS2V5OiBBbnkgPSB0aGlzLmdldEVuY29kZWRQdWJrZXkoY29zbW9zTGlrZVRyYW5zYWN0aW9uLnB1YmxpY0tleSk7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBjb3Ntb3NMaWtlVHJhbnNhY3Rpb24uc2VuZE1lc3NhZ2VzIGFzIHVua25vd24gYXMgQW55W107XG4gICAgbGV0IHR4Qm9keVZhbHVlO1xuICAgIGlmIChjb3Ntb3NMaWtlVHJhbnNhY3Rpb24ubWVtbykge1xuICAgICAgdHhCb2R5VmFsdWUgPSB7XG4gICAgICAgIG1lbW86IGNvc21vc0xpa2VUcmFuc2FjdGlvbi5tZW1vLFxuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXMsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0eEJvZHlWYWx1ZSA9IHtcbiAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCB0eEJvZHlCeXRlcyA9IHRoaXMucmVnaXN0cnkuZW5jb2RlVHhCb2R5KHR4Qm9keVZhbHVlKTtcbiAgICBjb25zdCBzZXF1ZW5jZSA9IGNvc21vc0xpa2VUcmFuc2FjdGlvbi5zZXF1ZW5jZTtcbiAgICBjb25zdCBhdXRoSW5mb0J5dGVzID0gbWFrZUF1dGhJbmZvQnl0ZXMoXG4gICAgICBbeyBwdWJrZXk6IGVuY29kZWRQdWJsaWNLZXksIHNlcXVlbmNlIH1dLFxuICAgICAgY29zbW9zTGlrZVRyYW5zYWN0aW9uLmdhc0J1ZGdldC5hbW91bnQsXG4gICAgICBjb3Ntb3NMaWtlVHJhbnNhY3Rpb24uZ2FzQnVkZ2V0Lmdhc0xpbWl0LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgdW5kZWZpbmVkXG4gICAgKTtcbiAgICByZXR1cm4gVHhSYXcuZnJvbVBhcnRpYWwoe1xuICAgICAgYm9keUJ5dGVzOiB0eEJvZHlCeXRlcyxcbiAgICAgIGF1dGhJbmZvQnl0ZXM6IGF1dGhJbmZvQnl0ZXMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRW5jb2RlcyBhIHNpZ25hdHVyZSBpbnRvIGEgdHhSYXdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY0tleUhleCBwdWJsaWNLZXkgaW4gaGV4IGVuY29kZWQgc3RyaW5nIGZvcm1hdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlSGV4IHNpZ25hdHVyZSBpbiBoZXggZW5jb2RlZCBzdHJpbmcgZm9ybWF0XG4gICAqIEBwYXJhbSB7VHhSYXd9IHVuc2lnbmVkVHggcmF3IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtUeFJhd30gU2lnbmVkIHJhdyB0cmFuc2FjdGlvblxuICAgKi9cbiAgY3JlYXRlU2lnbmVkVHhSYXcoXG4gICAgcHVibGljS2V5SGV4OiBzdHJpbmcsXG4gICAgc2lnbmF0dXJlSGV4OiBzdHJpbmcsXG4gICAgdW5zaWduZWRUeDogeyBib2R5Qnl0ZXM6IFVpbnQ4QXJyYXk7IGF1dGhJbmZvQnl0ZXM6IFVpbnQ4QXJyYXkgfVxuICApOiBUeFJhdyB7XG4gICAgY29uc3Qgc3RkU2lnbmF0dXJlID0gZW5jb2RlU2VjcDI1NmsxU2lnbmF0dXJlKGZyb21IZXgocHVibGljS2V5SGV4KSwgZnJvbUhleChzaWduYXR1cmVIZXgpKTtcbiAgICByZXR1cm4gVHhSYXcuZnJvbVBhcnRpYWwoe1xuICAgICAgYm9keUJ5dGVzOiB1bnNpZ25lZFR4LmJvZHlCeXRlcyxcbiAgICAgIGF1dGhJbmZvQnl0ZXM6IHVuc2lnbmVkVHguYXV0aEluZm9CeXRlcyxcbiAgICAgIHNpZ25hdHVyZXM6IFtmcm9tQmFzZTY0KHN0ZFNpZ25hdHVyZS5zaWduYXR1cmUpXSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGVzIGEgcmF3IHRyYW5zYWN0aW9uIGludG8gYSBEZWNvZGVkVHhSYXcgYW5kIGNoZWNrcyBpZiBpdCBoYXMgbm9uIGVtcHR5IHNpZ25hdHVyZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJhd1RyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRyYW5zYWN0aW9uIGlzIHNpZ25lZCBlbHNlIGZhbHNlXG4gICAqL1xuICBpc1NpZ25lZFJhd1R4KHJhd1RyYW5zYWN0aW9uOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBkZWNvZGVkVHggPSB0aGlzLmdldERlY29kZWRUeEZyb21SYXdCYXNlNjQocmF3VHJhbnNhY3Rpb24pO1xuICAgIGlmIChkZWNvZGVkVHguc2lnbmF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHN0cmluZyBpcyBhIHZhbGlkIHByb3RvY29sIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHB1YmxpY0tleSAtIHRoZSAgcHVibGljIGtleSB0byBiZSB2YWxpZGF0ZWRcbiAgICovXG4gIHZhbGlkYXRlUHVibGljS2V5KHB1YmxpY0tleTogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHB1YmxpY0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgS2V5UGFpcih7IHB1YjogcHVibGljS2V5IH0pO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBQdWJsaWMgS2V5YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaWduIGRvYyBmcm9tIGFuIGNvc21vcyBsaWtlIHRyYW5zYWN0aW9uIEBzZWUgQ29zbW9zTGlrZVRyYW5zYWN0aW9uXG4gICAqIEBQcmVjb25kaXRpb24gY29zbW9zTGlrZVRyYW5zYWN0aW9uLmFjY291bnROdW1iZXIgYW5kIGNvc21vc0xpa2VUcmFuc2FjdGlvbi5jaGFpbklkIG11c3QgYmUgZGVmaW5lZFxuICAgKiBAcGFyYW0ge0Nvc21vc0xpa2VUcmFuc2FjdGlvbn0gY29zbW9zTGlrZVRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm5zIHtTaWduRG9jfSBzaWduIGRvY1xuICAgKi9cbiAgY3JlYXRlU2lnbkRvYyhcbiAgICBjb3Ntb3NMaWtlVHJhbnNhY3Rpb246IENvc21vc0xpa2VUcmFuc2FjdGlvbixcbiAgICBhY2NvdW50TnVtYmVyOiBudW1iZXIgfCB1bmRlZmluZWQsXG4gICAgY2hhaW5JZDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICk6IFNpZ25Eb2Mge1xuICAgIGlmICghYWNjb3VudE51bWJlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhY2NvdW50TnVtYmVyIGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBhIHNpZ24gZG9jJyk7XG4gICAgfVxuICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGFpbklkIGlzIHJlcXVpcmVkIHRvIGNyZWF0ZSBhIHNpZ24gZG9jJyk7XG4gICAgfVxuICAgIGlmICghY29zbW9zTGlrZVRyYW5zYWN0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nvc21vc0xpa2VUcmFuc2FjdGlvbiBpcyByZXF1aXJlZCB0byBjcmVhdGUgYSBzaWduIGRvYycpO1xuICAgIH1cbiAgICBjb25zdCB0eFJhdyA9IHRoaXMuY3JlYXRlVHhSYXdGcm9tQ29zbW9zTGlrZVRyYW5zYWN0aW9uKGNvc21vc0xpa2VUcmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIG1ha2VTaWduRG9jKHR4UmF3LmJvZHlCeXRlcywgdHhSYXcuYXV0aEluZm9CeXRlcywgY2hhaW5JZCwgYWNjb3VudE51bWJlcik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgaGV4XG4gICAqIEBwYXJhbSBoZXhTdHJpbmcgLSBoZXggc3RyaW5nIGZvcm1hdFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzdHJpbmcgaXMgaGV4IGVsc2UgZmFsc2VcbiAgICovXG4gIGlzVmFsaWRIZXhTdHJpbmcoaGV4U3RyaW5nOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gL15bMC05QS1GYS1mXSokLy50ZXN0KGhleFN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBXaXRoZHJhd0RlbGVnYXRvclJld2FyZHNNZXNzYWdlXG4gICAqIEBwYXJhbSB7V2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRzTWVzc2FnZX0gd2l0aGRyYXdSZXdhcmRzTWVzc2FnZSAtIFRoZSBXaXRoZHJhd0RlbGVnYXRvclJld2FyZHNNZXNzYWdlIHRvIHZhbGlkYXRlLlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2YWxpZGF0b3JBZGRyZXNzIG9yIGRlbGVnYXRvckFkZHJlc3MgaXMgaW52YWxpZCBvciBtaXNzaW5nLlxuICAgKi9cbiAgdmFsaWRhdGVXaXRoZHJhd1Jld2FyZHNNZXNzYWdlKHdpdGhkcmF3UmV3YXJkc01lc3NhZ2U6IFdpdGhkcmF3RGVsZWdhdG9yUmV3YXJkc01lc3NhZ2UpIHtcbiAgICBpZiAoXG4gICAgICAhd2l0aGRyYXdSZXdhcmRzTWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzIHx8XG4gICAgICAhdGhpcy5pc1ZhbGlkVmFsaWRhdG9yQWRkcmVzcyh3aXRoZHJhd1Jld2FyZHNNZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIFdpdGhkcmF3RGVsZWdhdG9yUmV3YXJkc01lc3NhZ2UgdmFsaWRhdG9yQWRkcmVzczogYCArIHdpdGhkcmF3UmV3YXJkc01lc3NhZ2UudmFsaWRhdG9yQWRkcmVzc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCF3aXRoZHJhd1Jld2FyZHNNZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgfHwgIXRoaXMuaXNWYWxpZEFkZHJlc3Mod2l0aGRyYXdSZXdhcmRzTWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKFxuICAgICAgICBgSW52YWxpZCBXaXRoZHJhd0RlbGVnYXRvclJld2FyZHNNZXNzYWdlIGRlbGVnYXRvckFkZHJlc3M6IGAgKyB3aXRoZHJhd1Jld2FyZHNNZXNzYWdlLmRlbGVnYXRvckFkZHJlc3NcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gY2hlY2sgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzIGluIGFuIG9iamVjdCBhcmUgbWlzc2luZyBvciBudWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gVGhlIG9iamVjdCB0byBjaGVjay5cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5cyAtIEFuIGFycmF5IG9mIHByb3BlcnR5IGtleXMgdG8gY2hlY2suXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcyBhcmUgbWlzc2luZyBvciBudWxsLlxuICAgKi9cbiAgaXNPYmpQcm9wZXJ0eU51bGwob2JqOiB7IFtrZXk6IHN0cmluZ106IGFueSB9LCBrZXlzOiBBcnJheTxzdHJpbmc+KSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIG9yIG51bGwgdmFsdWUgZm9yIHByb3BlcnR5ICR7a2V5fWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIERlbGVnYXRlT3JVbmRlbGVnZXRlTWVzc2FnZVxuICAgKiBAcGFyYW0ge0RlbGVnYXRlT3JVbmRlbGVnZXRlTWVzc2FnZX0gZGVsZWdhdGVNZXNzYWdlIC0gVGhlIERlbGVnYXRlT3JVbmRlbGVnZXRlTWVzc2FnZSB0byB2YWxpZGF0ZS5cbiAgICogQHRocm93cyB7SW52YWxpZFRyYW5zYWN0aW9uRXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgdmFsaWRhdG9yQWRkcmVzcywgZGVsZWdhdG9yQWRkcmVzcywgb3IgYW1vdW50IGlzIGludmFsaWQgb3IgbWlzc2luZy5cbiAgICovXG4gIHZhbGlkYXRlRGVsZWdhdGVPclVuZGVsZWdhdGVNZXNzYWdlKGRlbGVnYXRlTWVzc2FnZTogRGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlKSB7XG4gICAgdGhpcy5pc09ialByb3BlcnR5TnVsbChkZWxlZ2F0ZU1lc3NhZ2UsIFsndmFsaWRhdG9yQWRkcmVzcycsICdkZWxlZ2F0b3JBZGRyZXNzJ10pO1xuXG4gICAgaWYgKCF0aGlzLmlzVmFsaWRWYWxpZGF0b3JBZGRyZXNzKGRlbGVnYXRlTWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKFxuICAgICAgICBgSW52YWxpZCBEZWxlZ2F0ZU9yVW5kZWxlZ2V0ZU1lc3NhZ2UgdmFsaWRhdG9yQWRkcmVzczogYCArIGRlbGVnYXRlTWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNWYWxpZEFkZHJlc3MoZGVsZWdhdGVNZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIERlbGVnYXRlT3JVbmRlbGVnZXRlTWVzc2FnZSBkZWxlZ2F0b3JBZGRyZXNzOiBgICsgZGVsZWdhdGVNZXNzYWdlLmRlbGVnYXRvckFkZHJlc3NcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMudmFsaWRhdGVBbW91bnQoZGVsZWdhdGVNZXNzYWdlLmFtb3VudCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBNZXNzYWdlRGF0YVxuICAgKiBAcGFyYW0ge01lc3NhZ2VEYXRhfSBtZXNzYWdlRGF0YSAtIFRoZSBNZXNzYWdlRGF0YSB0byB2YWxpZGF0ZS5cbiAgICogQHRocm93cyB7SW52YWxpZFRyYW5zYWN0aW9uRXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgbWVzc2FnZURhdGEgaXMgaW52YWxpZCBvciBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkcy5cbiAgICovXG4gIHZhbGlkYXRlTWVzc2FnZURhdGEobWVzc2FnZURhdGE6IE1lc3NhZ2VEYXRhKTogdm9pZCB7XG4gICAgaWYgKG1lc3NhZ2VEYXRhID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBNZXNzYWdlRGF0YTogdW5kZWZpbmVkYCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlRGF0YS50eXBlVXJsID09IG51bGwgfHwgdGhpcy5nZXRUcmFuc2FjdGlvblR5cGVGcm9tVHlwZVVybChtZXNzYWdlRGF0YS50eXBlVXJsKSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgTWVzc2FnZURhdGEgdHlwZXVybDogYCArIG1lc3NhZ2VEYXRhLnR5cGVVcmwpO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFRyYW5zYWN0aW9uVHlwZUZyb21UeXBlVXJsKG1lc3NhZ2VEYXRhLnR5cGVVcmwpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuU2VuZDoge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG1lc3NhZ2VEYXRhLnZhbHVlIGFzIFNlbmRNZXNzYWdlO1xuICAgICAgICB0aGlzLnZhbGlkYXRlU2VuZE1lc3NhZ2UodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBY3RpdmF0ZTpcbiAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdEZWFjdGl2YXRlOiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWVzc2FnZURhdGEudmFsdWUgYXMgRGVsZWdhdGVPclVuZGVsZWdldGVNZXNzYWdlO1xuICAgICAgICB0aGlzLnZhbGlkYXRlRGVsZWdhdGVPclVuZGVsZWdhdGVNZXNzYWdlKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nV2l0aGRyYXc6IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBtZXNzYWdlRGF0YS52YWx1ZSBhcyBXaXRoZHJhd0RlbGVnYXRvclJld2FyZHNNZXNzYWdlO1xuICAgICAgICB0aGlzLnZhbGlkYXRlV2l0aGRyYXdSZXdhcmRzTWVzc2FnZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQ29udHJhY3RDYWxsOiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWVzc2FnZURhdGEudmFsdWUgYXMgRXhlY3V0ZUNvbnRyYWN0TWVzc2FnZTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV4ZWN1dGVDb250cmFjdE1lc3NhZ2UodmFsdWUsIFRyYW5zYWN0aW9uVHlwZS5Db250cmFjdENhbGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBNZXNzYWdlRGF0YSBUeXBlVXJsIGlzIG5vdCBzdXBwb3J0ZWQ6IGAgKyBtZXNzYWdlRGF0YS50eXBlVXJsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBDb3Ntb3MtbGlrZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtDb3Ntb3NMaWtlVHJhbnNhY3Rpb259IHR4IC0gVGhlIHRyYW5zYWN0aW9uIHRvIHZhbGlkYXRlLlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBpbnZhbGlkIG9yIG1pc3NpbmcgcmVxdWlyZWQgZmllbGRzLlxuICAgKi9cbiAgdmFsaWRhdGVUcmFuc2FjdGlvbih0eDogQ29zbW9zTGlrZVRyYW5zYWN0aW9uKTogdm9pZCB7XG4gICAgdGhpcy52YWxpZGF0ZVNlcXVlbmNlKHR4LnNlcXVlbmNlKTtcbiAgICB0aGlzLnZhbGlkYXRlR2FzQnVkZ2V0KHR4Lmdhc0J1ZGdldCk7XG4gICAgdGhpcy52YWxpZGF0ZVB1YmxpY0tleSh0eC5wdWJsaWNLZXkpO1xuICAgIGlmICh0eC5zZW5kTWVzc2FnZXMgPT09IHVuZGVmaW5lZCB8fCB0eC5zZW5kTWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoJ0ludmFsaWQgdHJhbnNhY3Rpb246IG1lc3NhZ2VzIGlzIHJlcXVpcmVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR4LnNlbmRNZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB0aGlzLnZhbGlkYXRlTWVzc2FnZURhdGEobWVzc2FnZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQ29zbW9zLWxpa2UgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZXF1ZW5jZSAtIFRoZSBzZW5kZXIgYWRkcmVzcyBzZXF1ZW5jZSBudW1iZXIgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtNZXNzYWdlRGF0YVtdfSBtZXNzYWdlcyAtIFRoZSBhcnJheSBvZiBtZXNzYWdlIGRhdGEgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtGZWVEYXRhfSBnYXNCdWRnZXQgLSBUaGUgZmVlIGRhdGEgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwdWJsaWNLZXldIC0gVGhlIHB1YmxpYyBrZXkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZW5kZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWVtb10gLSBUaGUgbWVtbyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcmV0dXJucyB7Q29zbW9zTGlrZVRyYW5zYWN0aW9ufSBSZXR1cm5zIHRoZSBjcmVhdGVkIENvc21vcy1saWtlIHRyYW5zYWN0aW9uLlxuICAgKiBAdGhyb3dzIHtJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjcmVhdGVkIHRyYW5zYWN0aW9uIGlzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVUcmFuc2FjdGlvbihcbiAgICBzZXF1ZW5jZTogbnVtYmVyLFxuICAgIG1lc3NhZ2VzOiBNZXNzYWdlRGF0YVtdLFxuICAgIGdhc0J1ZGdldDogRmVlRGF0YSxcbiAgICBwdWJsaWNLZXk/OiBzdHJpbmcsXG4gICAgbWVtbz86IHN0cmluZ1xuICApOiBDb3Ntb3NMaWtlVHJhbnNhY3Rpb24ge1xuICAgIGNvbnN0IGNvc21vc0xpa2VUeG4gPSB7XG4gICAgICBzZXF1ZW5jZTogc2VxdWVuY2UsXG4gICAgICBzZW5kTWVzc2FnZXM6IG1lc3NhZ2VzLFxuICAgICAgZ2FzQnVkZ2V0OiBnYXNCdWRnZXQsXG4gICAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSxcbiAgICAgIG1lbW86IG1lbW8sXG4gICAgfTtcbiAgICB0aGlzLnZhbGlkYXRlVHJhbnNhY3Rpb24oY29zbW9zTGlrZVR4bik7XG4gICAgcmV0dXJuIGNvc21vc0xpa2VUeG47XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIENvc21vcy1saWtlIHRyYW5zYWN0aW9uIHdpdGggYSBoYXNoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2VxdWVuY2UgLSBUaGUgc2VuZGVyIGFkZHJlc3Mgc2VxdWVuY2UgbnVtYmVyIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7TWVzc2FnZURhdGFbXX0gbWVzc2FnZXMgLSBUaGUgYXJyYXkgb2YgbWVzc2FnZSBkYXRhIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7RmVlRGF0YX0gZ2FzQnVkZ2V0IC0gVGhlIGZlZSBkYXRhIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcHVibGljS2V5XSAtIFRoZSBwdWJsaWMga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbc2lnbmF0dXJlXSAtIFRoZSBzaWduYXR1cmUgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFttZW1vXSAtIFRoZSBtZW1vIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gICAqIEByZXR1cm5zIHtDb3Ntb3NMaWtlVHJhbnNhY3Rpb259IFJldHVybnMgdGhlIGNyZWF0ZWQgQ29zbW9zLWxpa2UgdHJhbnNhY3Rpb24gd2l0aCB0aGUgaGFzaCBhbmQgc2lnbmF0dXJlIGlmIHByb3ZpZGVkLlxuICAgKi9cbiAgY3JlYXRlVHJhbnNhY3Rpb25XaXRoSGFzaChcbiAgICBzZXF1ZW5jZTogbnVtYmVyLFxuICAgIG1lc3NhZ2VzOiBNZXNzYWdlRGF0YVtdLFxuICAgIGdhc0J1ZGdldDogRmVlRGF0YSxcbiAgICBwdWJsaWNLZXk/OiBzdHJpbmcsXG4gICAgc2lnbmF0dXJlPzogQnVmZmVyLFxuICAgIG1lbW8/OiBzdHJpbmdcbiAgKTogQ29zbW9zTGlrZVRyYW5zYWN0aW9uIHtcbiAgICBjb25zdCBjb3Ntb3NMaWtlVHhuID0gdGhpcy5jcmVhdGVUcmFuc2FjdGlvbihzZXF1ZW5jZSwgbWVzc2FnZXMsIGdhc0J1ZGdldCwgcHVibGljS2V5LCBtZW1vKTtcbiAgICBsZXQgaGFzaCA9IGNvbnN0YW50cy5VTkFWQUlMQUJMRV9URVhUO1xuICAgIGlmIChzaWduYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdW5zaWduZWRUeCA9IHRoaXMuY3JlYXRlVHhSYXdGcm9tQ29zbW9zTGlrZVRyYW5zYWN0aW9uKGNvc21vc0xpa2VUeG4pO1xuICAgICAgY29uc3Qgc2lnbmVkVHggPSBUeFJhdy5mcm9tUGFydGlhbCh7XG4gICAgICAgIGJvZHlCeXRlczogdW5zaWduZWRUeC5ib2R5Qnl0ZXMsXG4gICAgICAgIGF1dGhJbmZvQnl0ZXM6IHVuc2lnbmVkVHguYXV0aEluZm9CeXRlcyxcbiAgICAgICAgc2lnbmF0dXJlczogW3NpZ25hdHVyZV0sXG4gICAgICB9KTtcbiAgICAgIGhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKFR4UmF3LmVuY29kZShzaWduZWRUeCkuZmluaXNoKCkpXG4gICAgICAgIC5kaWdlc3QoKVxuICAgICAgICAudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIC50b0xvY2FsZVVwcGVyQ2FzZSgnZW4tVVMnKTtcbiAgICAgIHJldHVybiB7IC4uLmNvc21vc0xpa2VUeG4sIGhhc2g6IGhhc2gsIHNpZ25hdHVyZTogc2lnbmF0dXJlIH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmNvc21vc0xpa2VUeG4sIGhhc2g6IGhhc2ggfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZXMgYmFzZTY0IGVub2NkZWQgcmF3IHRyYW5zYWN0aW9uIHN0cmluZyBpbnRvIEBzZWUgQ29zbW9zTGlrZVRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByYXdUeCBiYXNlNjQgZW5vY2RlZCByYXcgdHJhbnNhY3Rpb24gc3RyaW5nXG4gICAqIEByZXR1cm5zIHtDb3Ntb3NMaWtlVHJhbnNhY3Rpb259IERlc2VyaWFsaXplZCBjb3Ntb3NMaWtlVHJhbnNhY3Rpb25cbiAgICovXG4gIGRlc2VyaWFsaXplVHJhbnNhY3Rpb24ocmF3VHg6IHN0cmluZyk6IENvc21vc0xpa2VUcmFuc2FjdGlvbiB7XG4gICAgY29uc3QgZGVjb2RlZFR4ID0gdGhpcy5nZXREZWNvZGVkVHhGcm9tUmF3QmFzZTY0KHJhd1R4KTtcbiAgICBjb25zdCB0eXBlVXJsID0gdGhpcy5nZXRUeXBlVXJsRnJvbURlY29kZWRUeChkZWNvZGVkVHgpO1xuICAgIGNvbnN0IHR5cGU6IFRyYW5zYWN0aW9uVHlwZSB8IHVuZGVmaW5lZCA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25UeXBlRnJvbVR5cGVVcmwodHlwZVVybCk7XG4gICAgbGV0IHNlbmRNZXNzYWdlRGF0YTogTWVzc2FnZURhdGFbXTtcbiAgICBpZiAodHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlNlbmQpIHtcbiAgICAgIHNlbmRNZXNzYWdlRGF0YSA9IHRoaXMuZ2V0U2VuZE1lc3NhZ2VEYXRhRnJvbURlY29kZWRUeChkZWNvZGVkVHgpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlN0YWtpbmdBY3RpdmF0ZSB8fCB0eXBlID09PSBUcmFuc2FjdGlvblR5cGUuU3Rha2luZ0RlYWN0aXZhdGUpIHtcbiAgICAgIHNlbmRNZXNzYWdlRGF0YSA9IHRoaXMuZ2V0RGVsZWdhdGVPclVuZGVsZWdhdGVNZXNzYWdlRGF0YUZyb21EZWNvZGVkVHgoZGVjb2RlZFR4KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5TdGFraW5nV2l0aGRyYXcpIHtcbiAgICAgIHNlbmRNZXNzYWdlRGF0YSA9IHRoaXMuZ2V0V2l0aGRyYXdSZXdhcmRzTWVzc2FnZURhdGFGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQ29udHJhY3RDYWxsKSB7XG4gICAgICBzZW5kTWVzc2FnZURhdGEgPSB0aGlzLmdldEV4ZWN1dGVDb250cmFjdE1lc3NhZ2VEYXRhRnJvbURlY29kZWRUeChkZWNvZGVkVHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIHR5cGUgbm90IHN1cHBvcnRlZDogJyArIHR5cGVVcmwpO1xuICAgIH1cbiAgICBjb25zdCBzZXF1ZW5jZSA9IHRoaXMuZ2V0U2VxdWVuY2VGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgY29uc3QgZ2FzQnVkZ2V0ID0gdGhpcy5nZXRHYXNCdWRnZXRGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gdGhpcy5nZXRQdWJsaWNLZXlGcm9tRGVjb2RlZFR4KGRlY29kZWRUeCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gZGVjb2RlZFR4LnNpZ25hdHVyZXM/LlswXSAhPT0gdW5kZWZpbmVkID8gQnVmZmVyLmZyb20oZGVjb2RlZFR4LnNpZ25hdHVyZXNbMF0pIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRyYW5zYWN0aW9uV2l0aEhhc2goXG4gICAgICBzZXF1ZW5jZSxcbiAgICAgIHNlbmRNZXNzYWdlRGF0YSxcbiAgICAgIGdhc0J1ZGdldCxcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGRlY29kZWRUeC5ib2R5Py5tZW1vXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW4gYXJyYXkgb2YgY29pbiBhbW91bnRzLlxuICAgKiBAcGFyYW0ge0NvaW5bXX0gYW1vdW50QXJyYXkgLSBUaGUgYXJyYXkgb2YgY29pbiBhbW91bnRzIHRvIHZhbGlkYXRlLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uVHlwZX0gdHJhbnNhY3Rpb25UeXBlIC0gb3B0aW9uYWwgZmllbGQgZm9yIHRyYW5zYWN0aW9uIHR5cGVcbiAgICovXG4gIHZhbGlkYXRlQW1vdW50RGF0YShhbW91bnRBcnJheTogQ29pbltdLCB0cmFuc2FjdGlvblR5cGU/OiBUcmFuc2FjdGlvblR5cGUpOiB2b2lkIHtcbiAgICBhbW91bnRBcnJheS5mb3JFYWNoKChjb2luQW1vdW50KSA9PiB7XG4gICAgICB0aGlzLnZhbGlkYXRlQW1vdW50KGNvaW5BbW91bnQsIHRyYW5zYWN0aW9uVHlwZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBnYXMgbGltaXQgYW5kIGdhcyBhbW91bnQgZm9yIGEgdHJhbnNhY3Rpb24uXG4gICAqIEBwYXJhbSB7RmVlRGF0YX0gZ2FzQnVkZ2V0IC0gVGhlIGdhcyBidWRnZXQgdG8gdmFsaWRhdGUuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRUcmFuc2FjdGlvbkVycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGdhcyBidWRnZXQgaXMgaW52YWxpZC5cbiAgICovXG4gIHZhbGlkYXRlR2FzQnVkZ2V0KGdhc0J1ZGdldDogRmVlRGF0YSk6IHZvaWQge1xuICAgIGlmIChnYXNCdWRnZXQuZ2FzTGltaXQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUcmFuc2FjdGlvbkVycm9yKCdJbnZhbGlkIGdhcyBsaW1pdCAnICsgZ2FzQnVkZ2V0Lmdhc0xpbWl0KTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZUFtb3VudERhdGEoZ2FzQnVkZ2V0LmFtb3VudCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGEgc2VuZCBtZXNzYWdlIGZvciBhIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge1NlbmRNZXNzYWdlfSBzZW5kTWVzc2FnZSAtIFRoZSBzZW5kIG1lc3NhZ2UgdG8gdmFsaWRhdGUuXG4gICAqIEB0aHJvd3Mge0ludmFsaWRUcmFuc2FjdGlvbkVycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHNlbmQgbWVzc2FnZSBpcyBpbnZhbGlkLlxuICAgKi9cbiAgdmFsaWRhdGVTZW5kTWVzc2FnZShzZW5kTWVzc2FnZTogU2VuZE1lc3NhZ2UpIHtcbiAgICBpZiAoIXNlbmRNZXNzYWdlLnRvQWRkcmVzcyB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhzZW5kTWVzc2FnZS50b0FkZHJlc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgU2VuZE1lc3NhZ2UgdG9BZGRyZXNzOiBgICsgc2VuZE1lc3NhZ2UudG9BZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKCFzZW5kTWVzc2FnZS5mcm9tQWRkcmVzcyB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhzZW5kTWVzc2FnZS5mcm9tQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBTZW5kTWVzc2FnZSBmcm9tQWRkcmVzczogYCArIHNlbmRNZXNzYWdlLmZyb21BZGRyZXNzKTtcbiAgICB9XG4gICAgdGhpcy52YWxpZGF0ZUFtb3VudERhdGEoc2VuZE1lc3NhZ2UuYW1vdW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYSBjb2luIGFtb3VudC5cbiAgICogQHBhcmFtIHtDb2lufSBhbW91bnQgLSBUaGUgY29pbiBhbW91bnQgdG8gdmFsaWRhdGUuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb25UeXBlfSB0cmFuc2FjdGlvblR5cGUgLSBvcHRpb25hbCBmaWVsZCBmb3IgdHJhbnNhY3Rpb24gdHlwZVxuICAgKiBAdGhyb3dzIHtJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcn0gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjb2luIGFtb3VudCBpcyBpbnZhbGlkLlxuICAgKi9cbiAgdmFsaWRhdGVBbW91bnQoYW1vdW50OiBDb2luLCB0cmFuc2FjdGlvblR5cGU/OiBUcmFuc2FjdGlvblR5cGUpOiB2b2lkIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigndmFsaWRhdGVBbW91bnQgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGlmIHRoZSBhZGRyZXNzIG1hdGNoZXMgd2l0aCByZWdleCBAc2VlIGFjY291bnRBZGRyZXNzUmVnZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICBpc1ZhbGlkVmFsaWRhdG9yQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignaXNWYWxpZFZhbGlkYXRvckFkZHJlc3Mgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGlmIHRoZSBhZGRyZXNzIG1hdGNoZXMgd2l0aCByZWdleCBAc2VlIGFjY291bnRBZGRyZXNzUmVnZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gdGhlIHZhbGlkYXRpb24gcmVzdWx0XG4gICAqL1xuICBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignaXNWYWxpZEFkZHJlc3Mgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGlmIHRoZSBhZGRyZXNzIG1hdGNoZXMgd2l0aCByZWdleCBAc2VlIGNvbnRyYWN0QWRkcmVzc1JlZ2V4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIHRoZSB2YWxpZGF0aW9uIHJlc3VsdFxuICAgKi9cbiAgaXNWYWxpZENvbnRyYWN0QWRkcmVzcyhhZGRyZXNzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignaXNWYWxpZENvbnRyYWN0QWRkcmVzcyBub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYSBleGVjdXRlIGNvbnRyYWN0IG1lc3NhZ2VcbiAgICogQHBhcmFtIHtFeGVjdXRlQ29udHJhY3RNZXNzYWdlfSBtZXNzYWdlIC0gVGhlIGV4ZWN1dGUgY29udHJhY3QgbWVzc2FnZSB0byB2YWxpZGF0ZVxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9uVHlwZX0gdHJhbnNhY3Rpb25UeXBlIC0gb3B0aW9uYWwgZmllbGQgZm9yIHRyYW5zYWN0aW9uIHR5cGVcbiAgICogQHRocm93cyB7SW52YWxpZFRyYW5zYWN0aW9uRXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgbWVzc2FnZSBpcyBpbnZhbGlkXG4gICAqL1xuICB2YWxpZGF0ZUV4ZWN1dGVDb250cmFjdE1lc3NhZ2UobWVzc2FnZTogRXhlY3V0ZUNvbnRyYWN0TWVzc2FnZSwgdHJhbnNhY3Rpb25UeXBlPzogVHJhbnNhY3Rpb25UeXBlKSB7XG4gICAgaWYgKCFtZXNzYWdlLmNvbnRyYWN0IHx8ICF0aGlzLmlzVmFsaWRDb250cmFjdEFkZHJlc3MobWVzc2FnZS5jb250cmFjdCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBFeGVjdXRlQ29udHJhY3RNZXNzYWdlIGNvbnRyYWN0IGFkZHJlc3M6IGAgKyBtZXNzYWdlLmNvbnRyYWN0KTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlLnNlbmRlciB8fCAhdGhpcy5pc1ZhbGlkQWRkcmVzcyhtZXNzYWdlLnNlbmRlcikpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkVHJhbnNhY3Rpb25FcnJvcihgSW52YWxpZCBFeGVjdXRlQ29udHJhY3RNZXNzYWdlIHNlbmRlciBhZGRyZXNzOiBgICsgbWVzc2FnZS5zZW5kZXIpO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2UubXNnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFRyYW5zYWN0aW9uRXJyb3IoYEludmFsaWQgRXhlY3V0ZUNvbnRyYWN0TWVzc2FnZSBtc2c6IGAgKyBtZXNzYWdlLm1zZyk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmZ1bmRzKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlQW1vdW50RGF0YShtZXNzYWdlLmZ1bmRzLCB0cmFuc2FjdGlvblR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY29pbiBzcGVjaWZpYyBoYXNoIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtIYXNofSBUaGUgaGFzaCBmdW5jdGlvblxuICAgKi9cbiAgZ2V0SGFzaEZ1bmN0aW9uKCk6IEhhc2gge1xuICAgIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKTtcbiAgfVxufVxuXG5jb25zdCB1dGlscyA9IG5ldyBDb3Ntb3NVdGlscygpO1xuXG5leHBvcnQgZGVmYXVsdCB1dGlscztcbiJdfQ==